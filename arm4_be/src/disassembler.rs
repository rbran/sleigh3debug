pub type AddrType = u32;
#[derive(Clone, Copy, Debug)]
pub enum Register {
    r0,
    r1,
    r2,
    r3,
    r4,
    r5,
    r6,
    r7,
    r8,
    r9,
    r10,
    r11,
    r12,
    sp,
    lr,
    pc,
    NG,
    ZR,
    CY,
    OV,
    tmpNG,
    tmpZR,
    tmpCY,
    tmpOV,
    shift_carry,
    TB,
    Q,
    GE1,
    GE2,
    GE3,
    GE4,
    cpsr,
    spsr,
    mult_addr,
    r14_svc,
    r13_svc,
    spsr_svc,
    mult_dat8,
    mult_dat16,
    fpsr,
    ISAModeSwitch,
    fp0,
    fp1,
    fp2,
    fp3,
    fp4,
    fp5,
    fp6,
    fp7,
    cr0,
    cr1,
    cr2,
    cr3,
    cr4,
    cr5,
    cr6,
    cr7,
    cr8,
    cr9,
    cr10,
    cr11,
    cr12,
    cr13,
    cr14,
    cr15,
    contextreg,
}
impl Register {
    fn as_str(&self) -> &'static str {
        match self {
            Self::r0 => "r0",
            Self::r1 => "r1",
            Self::r2 => "r2",
            Self::r3 => "r3",
            Self::r4 => "r4",
            Self::r5 => "r5",
            Self::r6 => "r6",
            Self::r7 => "r7",
            Self::r8 => "r8",
            Self::r9 => "r9",
            Self::r10 => "r10",
            Self::r11 => "r11",
            Self::r12 => "r12",
            Self::sp => "sp",
            Self::lr => "lr",
            Self::pc => "pc",
            Self::NG => "NG",
            Self::ZR => "ZR",
            Self::CY => "CY",
            Self::OV => "OV",
            Self::tmpNG => "tmpNG",
            Self::tmpZR => "tmpZR",
            Self::tmpCY => "tmpCY",
            Self::tmpOV => "tmpOV",
            Self::shift_carry => "shift_carry",
            Self::TB => "TB",
            Self::Q => "Q",
            Self::GE1 => "GE1",
            Self::GE2 => "GE2",
            Self::GE3 => "GE3",
            Self::GE4 => "GE4",
            Self::cpsr => "cpsr",
            Self::spsr => "spsr",
            Self::mult_addr => "mult_addr",
            Self::r14_svc => "r14_svc",
            Self::r13_svc => "r13_svc",
            Self::spsr_svc => "spsr_svc",
            Self::mult_dat8 => "mult_dat8",
            Self::mult_dat16 => "mult_dat16",
            Self::fpsr => "fpsr",
            Self::ISAModeSwitch => "ISAModeSwitch",
            Self::fp0 => "fp0",
            Self::fp1 => "fp1",
            Self::fp2 => "fp2",
            Self::fp3 => "fp3",
            Self::fp4 => "fp4",
            Self::fp5 => "fp5",
            Self::fp6 => "fp6",
            Self::fp7 => "fp7",
            Self::cr0 => "cr0",
            Self::cr1 => "cr1",
            Self::cr2 => "cr2",
            Self::cr3 => "cr3",
            Self::cr4 => "cr4",
            Self::cr5 => "cr5",
            Self::cr6 => "cr6",
            Self::cr7 => "cr7",
            Self::cr8 => "cr8",
            Self::cr9 => "cr9",
            Self::cr10 => "cr10",
            Self::cr11 => "cr11",
            Self::cr12 => "cr12",
            Self::cr13 => "cr13",
            Self::cr14 => "cr14",
            Self::cr15 => "cr15",
            Self::contextreg => "contextreg",
        }
    }
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::sp,
        14 => Register::lr,
        15 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r1,
        2 => Register::r3,
        4 => Register::r5,
        6 => Register::r7,
        8 => Register::r9,
        10 => Register::r11,
        12 => Register::sp,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        8 => Register::cr8,
        9 => Register::cr9,
        10 => Register::cr10,
        11 => Register::cr11,
        12 => Register::cr12,
        13 => Register::cr13,
        14 => Register::cr14,
        15 => Register::cr15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::sp,
        14 => Register::lr,
        15 => Register::pc,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("p0"),
        1 => <DisplayElement>::Literal("p1"),
        2 => <DisplayElement>::Literal("p2"),
        3 => <DisplayElement>::Literal("p3"),
        4 => <DisplayElement>::Literal("p4"),
        5 => <DisplayElement>::Literal("p5"),
        6 => <DisplayElement>::Literal("p6"),
        7 => <DisplayElement>::Literal("p7"),
        8 => <DisplayElement>::Literal("p8"),
        9 => <DisplayElement>::Literal("p9"),
        10 => <DisplayElement>::Literal("p10"),
        11 => <DisplayElement>::Literal("p11"),
        12 => <DisplayElement>::Literal("p12"),
        13 => <DisplayElement>::Literal("p13"),
        14 => <DisplayElement>::Literal("p14"),
        15 => <DisplayElement>::Literal("p15"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("opt0"),
        1 => <DisplayElement>::Literal("opt1"),
        2 => <DisplayElement>::Literal("opt2"),
        3 => <DisplayElement>::Literal("opt3"),
        4 => <DisplayElement>::Literal("opt4"),
        5 => <DisplayElement>::Literal("opt5"),
        6 => <DisplayElement>::Literal("opt6"),
        7 => <DisplayElement>::Literal("opt7"),
        8 => <DisplayElement>::Literal("opt8"),
        9 => <DisplayElement>::Literal("opt9"),
        10 => <DisplayElement>::Literal("opt10"),
        11 => <DisplayElement>::Literal("opt11"),
        12 => <DisplayElement>::Literal("opt12"),
        13 => <DisplayElement>::Literal("opt13"),
        14 => <DisplayElement>::Literal("opt14"),
        15 => <DisplayElement>::Literal("SY"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("opt0"),
        1 => <DisplayElement>::Literal("opt1"),
        2 => <DisplayElement>::Literal("OSHST"),
        3 => <DisplayElement>::Literal("OSH"),
        4 => <DisplayElement>::Literal("opt4"),
        5 => <DisplayElement>::Literal("opt5"),
        6 => <DisplayElement>::Literal("NSHST"),
        7 => <DisplayElement>::Literal("NSH"),
        8 => <DisplayElement>::Literal("opt8"),
        9 => <DisplayElement>::Literal("opt9"),
        10 => <DisplayElement>::Literal("ISHST"),
        11 => <DisplayElement>::Literal("ISH"),
        12 => <DisplayElement>::Literal("opt12"),
        13 => <DisplayElement>::Literal("opt13"),
        14 => <DisplayElement>::Literal("ST"),
        15 => <DisplayElement>::Literal("SY"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, bool, u64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(true, false, value) => {
                write!(f, "0x{:x}", value)
            }
            Self::Number(true, true, value) => {
                write!(f, "-0x{:x}", value)
            }
            Self::Number(false, false, value) => value.fmt(f),
            Self::Number(false, true, value) => {
                write!(f, "-{:x}", value)
            }
        }
    }
}
#[doc = "Create token_fields: Dm_3 Sm0_3 Sm1_3 c0002 thv_Dm_3 thv_Sm0_3 thv_Sm1_3"]
fn token_29(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 7) as u8)
}
#[doc = "Create token_fields: c2027 thv_c2027"]
fn token_44(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 255) as u8)
}
#[doc = "Create token_fields: c0000 thv_bit00 thv_c0000"]
fn token_114(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 1) as u8)
}
#[doc = "Create token_fields: c2131 thv_c2131"]
fn token_41(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 2047) as u16)
}
#[doc = "Create token_fields: c0315"]
fn token_98(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 8191) as u16)
}
#[doc = "Create token_fields: c1621 thv_c1621"]
fn token_59(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 63) as u8)
}
#[doc = "Create token_fields: c0009"]
fn token_109(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 1023) as u16)
}
#[doc = "Create token_fields: cond c2831 thv_c2831"]
fn token_2(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 28) & 15) as u8)
}
#[doc = "Create token_fields: c1717 thv_c1717"]
fn token_56(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 1) as u8)
}
#[doc = "Create token_fields: c2024 thv_c2024"]
fn token_45(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 31) as u8)
}
#[doc = "Create token_fields: c1315"]
fn token_66(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 7) as u8)
}
#[doc = "Create token_fields: op c2124 thv_c2124"]
fn token_7(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 15) as u8)
}
#[doc = "Create token_fields: c1821 thv_c1821"]
fn token_50(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 15) as u8)
}
#[doc = "Create token_fields: opcode1"]
fn token_17(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 15) as u8)
}
#[doc = "Create token_fields: c1631 thv_c1631"]
fn token_57(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 65535) as u16)
}
#[doc = "Create token_fields: c2527 thv_c2527"]
fn token_36(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 7) as u8)
}
#[doc = "Create token_fields: c2627 thv_c2627"]
fn token_34(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 26) & 3) as u8)
}
#[doc = "Create token_fields: c2324 thv_c2324"]
fn token_40(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 3) as u8)
}
#[doc = "Create token_fields: thv_c0015"]
fn token_118(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 65535) as u16)
}
#[doc = "Create token_fields: c0815"]
fn token_78(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 255) as u8)
}
#[doc = "Create token_fields: c0431 thv_c0431"]
fn token_89(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 268435455) as u32)
}
#[doc = "Create token_fields: c0014"]
fn token_105(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 32767) as u16)
}
#[doc = "Create token_fields: c0013"]
fn token_106(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 16383) as u16)
}
#[doc = "Create token_fields: offset_12 c0011 thv_c0011"]
fn token_24(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 4095) as u16)
}
#[doc = "Create token_fields: c0101 thv_c0101"]
fn token_103(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 1) as u8)
}
#[doc = "Create token_fields: pref c0031 thv_c0031"]
fn token_1(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 4294967295) as u32)
}
#[doc = "Create token_fields: P24 H24 L24 c2424 thv_c2424"]
fn token_4(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 24) & 1) as u8)
}
#[doc = "Create token_fields: c2021 thv_c2021"]
fn token_47(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 3) as u8)
}
#[doc = "Create token_fields: c1718 thv_c1718"]
fn token_55(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 3) as u8)
}
#[doc = "Create token_fields: c1627 thv_c1627"]
fn token_58(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 4095) as u16)
}
#[doc = "Create token_fields: I25 c2525 thv_c2525"]
fn token_3(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 1) as u8)
}
#[doc = "Create token_fields: c1921 thv_c1921"]
fn token_48(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 19) & 7) as u8)
}
#[doc = "Create token_fields: c0515"]
fn token_87(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 2047) as u16)
}
#[doc = "Create token_fields: c0027 thv_c0027"]
fn token_104(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 268435455) as u32)
}
#[doc = "Create token_fields: thv_c2931"]
fn token_115(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 29) & 7) as u8)
}
#[doc = "Create token_fields: c0202 thv_c0202"]
fn token_101(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 1) as u8)
}
#[doc = "Create token_fields: c1617 thv_c1617"]
fn token_61(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 3) as u8)
}
#[doc = "Create token_fields: c2331 thv_c2331"]
fn token_38(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 511) as u16)
}
#[doc = "Create token_fields: lsb sftimm c0711 thv_c0711"]
fn token_20(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 31) as u8)
}
#[doc = "Create token_fields: c0409 thv_c0409"]
fn token_93(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 63) as u8)
}
#[doc = "Create token_fields: bit29 thv_bit29"]
fn token_32(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 29) & 1) as u8)
}
#[doc = "Create token_fields: srsMode c0004 thv_c0004"]
fn token_26(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 31) as u8)
}
#[doc = "Create token_fields: bit31 thv_bit31"]
fn token_30(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 31) & 1) as u8)
}
#[doc = "Create token_fields: c0607 thv_c0607"]
fn token_86(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 3) as u8)
}
#[doc = "Create token_fields: immed24 addr24"]
fn token_23(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 16777215) as u32)
}
#[doc = "Create token_fields: bit30 thv_bit30"]
fn token_31(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 30) & 1) as u8)
}
#[doc = "Create token_fields: c1719 thv_c1719"]
fn token_54(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 7) as u8)
}
#[doc = "Create token_fields: c2327 thv_c2327"]
fn token_39(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 31) as u8)
}
#[doc = "Create token_fields: c0715"]
fn token_81(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 511) as u16)
}
#[doc = "Create token_fields: thv_c0104"]
fn token_117(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 15) as u8)
}
#[doc = "Create token_fields: smRm Rs rotate immedH cpn RmHi cmode c0811 thv_cmode thv_Rt2 thv_c0811"]
fn token_14(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 15) as u8)
}
#[doc = "Create token_fields: c1111 thv_c1111"]
fn token_70(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 1) as u8)
}
#[doc = "Create token_fields: U23 c2323 thv_bit23 thv_c2323"]
fn token_5(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 1) as u8)
}
#[doc = "Create token_fields: c1010 thv_c1010"]
fn token_73(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 1) as u8)
}
#[doc = "Create token_fields: c0010 thv_c0010"]
fn token_108(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 2047) as u16)
}
#[doc = "Create token_fields: Rn satimm4 mask CRn RdHi smRd Qn0 Qn1 Dn0 Dn1 Sn0 Sn1 c1619 thv_Qn0 thv_Qn1 thv_Dn0 thv_Dn1 thv_Sn0 thv_Sn1 thv_Rn thv_c1619"]
fn token_10(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 15) as u8)
}
#[doc = "Create token_fields: c0915"]
fn token_75(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 127) as u8)
}
#[doc = "Create token_fields: c0005"]
fn token_112(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 63) as u8)
}
#[doc = "Create token_fields: c0215 thv_c0215"]
fn token_100(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 16383) as u16)
}
#[doc = "Create token_fields: c0001 thv_c0001"]
fn token_113(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 3) as u8)
}
#[doc = "Create token_fields: c1818 thv_c1818"]
fn token_52(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 1) as u8)
}
#[doc = "Create token_fields: c0408"]
fn token_94(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 31) as u8)
}
#[doc = "Create token_fields: c1819 thv_c1819"]
fn token_51(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 3) as u8)
}
#[doc = "Create token_fields: c0006 thv_c0006"]
fn token_111(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 127) as u8)
}
#[doc = "Create token_fields: W21 c2121 thv_bit21 thv_c2121"]
fn token_8(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 1) as u8)
}
#[doc = "Create token_fields: c1415 thv_c1415"]
fn token_64(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 14) & 3) as u8)
}
#[doc = "Create token_fields: Rd Rd2 CRd RdLo smRa Qd0 Qd1 Dd0 Dd_1 Dd_2 Dd_3 Dd_4 Dd_5 Dd_6 Dd_7 Dd_8 Dd_9 Dd_10 Dd_11 Dd_12 Dd_13 Dd_14 Dd_15 Dd_16 Dd1 Sd0 Sd1 c1215 thv_Qd0 thv_Qd1 thv_Dd0 thv_Dd_1 thv_Dd_2 thv_Dd_3 thv_Dd_4 thv_Dd_5 thv_Dd_6 thv_Dd_7 thv_Dd_8 thv_Dd_9 thv_Dd_10 thv_Dd_11 thv_Dd_12 thv_Dd_13 thv_Dd_14 thv_Dd_15 thv_Dd_16 thv_Dd1 thv_Sd0 thv_Sd1 thv_Rd thv_Rt thv_c1215"]
fn token_13(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 15) as u8)
}
#[doc = "Create token_fields: N7 L7 c0707 thv_N7 thv_L7 thv_bit07 thv_c0707"]
fn token_28(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 1) as u8)
}
#[doc = "Create token_fields: c0415"]
fn token_91(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 4095) as u16)
}
#[doc = "Create token_fields: c0404 thv_c0404"]
fn token_97(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 1) as u8)
}
#[doc = "Create token_fields: c0303 thv_c0303"]
fn token_99(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 1) as u8)
}
#[doc = "Create token_fields: sh y Q6 c0606 thv_Q6 thv_bit06 thv_c0606"]
fn token_21(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 1) as u8)
}
#[doc = "Create token_fields: c1313 thv_c1313"]
fn token_67(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 1) as u8)
}
#[doc = "Create token_fields: c1212 thv_c1212"]
fn token_68(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 1) as u8)
}
#[doc = "Create token_fields: c0611 thv_c0611"]
fn token_85(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 63) as u8)
}
#[doc = "Create token_fields: c0709 thv_c0709"]
fn token_82(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 7) as u8)
}
#[doc = "Create token_fields: B22 N22 S22 D22 c2222 thv_D22 thv_c2222"]
fn token_6(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 22) & 1) as u8)
}
#[doc = "Create token_fields: x r M5 c0505 thv_M5 thv_c0505"]
fn token_27(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 1) as u8)
}
#[doc = "Create token_fields: c0916"]
fn token_74(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 255) as u8)
}
#[doc = "Create token_fields: c1115"]
fn token_69(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 31) as u8)
}
#[doc = "Create token_fields: c2531 thv_c2531"]
fn token_35(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 127) as u8)
}
#[doc = "Create token_fields: thv_c2031"]
fn token_116(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 4095) as u16)
}
#[doc = "Create token_fields: c1011 thv_c1011"]
fn token_72(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 3) as u8)
}
#[doc = "Create token_fields: c0411 thv_c0411"]
fn token_92(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 255) as u8)
}
#[doc = "Create token_fields: RnLo CRm smRn immedL immed4 dbOption ibOption Rm Rm2 Qm0 Qm1 Dm0 Dm1 Dm_4 Sm0 Sm0next Sm1 Sm1next c0003 thv_Qm0 thv_Qm1 thv_Dm0 thv_Dm1 thv_Dm_4 thv_Sm0 thv_Sm0next thv_Sm1 thv_Sm1next thv_Rm thv_c0003 thv_option"]
fn token_11(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 15) as u8)
}
#[doc = "Create token_fields: c0615"]
fn token_84(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 1023) as u16)
}
#[doc = "Create token_fields: opc1 c2123 thv_c2123"]
fn token_16(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 7) as u8)
}
#[doc = "Create token_fields: c2022 thv_c2022"]
fn token_46(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 7) as u8)
}
#[doc = "Create token_fields: c1515 thv_c1515"]
fn token_63(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 15) & 1) as u8)
}
#[doc = "Create token_fields: c0406 thv_c0406"]
fn token_95(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 7) as u8)
}
#[doc = "Create token_fields: c0809 thv_c0809"]
fn token_79(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 3) as u8)
}
#[doc = "Create token_fields: opcode3 c0407 thv_c0407"]
fn token_19(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 15) as u8)
}
#[doc = "Create token_fields: immed c0007 thv_immed thv_c0007"]
fn token_25(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: c0427 thv_c0427"]
fn token_90(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 16777215) as u32)
}
#[doc = "Create token_fields: c0508 thv_c0508"]
fn token_88(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 15) as u8)
}
#[doc = "Create token_fields: c0115"]
fn token_102(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 32767) as u16)
}
#[doc = "Create token_fields: c2127 thv_c2127"]
fn token_42(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 127) as u8)
}
#[doc = "Create token_fields: c1721 thv_c1721"]
fn token_53(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 31) as u8)
}
#[doc = "Create token_fields: c0808 thv_c0808"]
fn token_80(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 1) as u8)
}
#[doc = "Create token_fields: immed12"]
fn token_15(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 4095) as u16)
}
#[doc = "Create token_fields: shft c0506 thv_c0506"]
fn token_22(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 3) as u8)
}
#[doc = "Create token_fields: c2122 thv_c2122"]
fn token_43(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 3) as u8)
}
#[doc = "Create token_fields: c0911 thv_c0911"]
fn token_76(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 7) as u8)
}
#[doc = "Create token_fields: S20 L20 c2020 thv_bit20 thv_c2020"]
fn token_9(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 1) as u8)
}
#[doc = "Create token_fields: bit28 thv_bit28 thv_c2828"]
fn token_33(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 28) & 1) as u8)
}
#[doc = "Create token_fields: c0405 thv_c0405"]
fn token_96(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 3) as u8)
}
#[doc = "Create token_fields: c1616 thv_c1616"]
fn token_62(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 1) as u8)
}
#[doc = "Create token_fields: c1414 thv_c1414"]
fn token_65(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 14) & 1) as u8)
}
#[doc = "Create token_fields: msb satimm5 c1620 thv_c1620"]
fn token_12(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 31) as u8)
}
#[doc = "Create token_fields: c1618 thv_c1618"]
fn token_60(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 7) as u8)
}
#[doc = "Create token_fields: c0012"]
fn token_107(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 8191) as u16)
}
#[doc = "Create token_fields: c0708 thv_c0708"]
fn token_83(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 3) as u8)
}
#[doc = "Create token_fields: c0008 thv_c0008"]
fn token_110(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 511) as u16)
}
#[doc = "Create token_fields: c0909 thv_c0909"]
fn token_77(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 1) as u8)
}
#[doc = "Create token_fields: c1919 thv_c1919"]
fn token_49(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 19) & 1) as u8)
}
#[doc = "Create token_fields: c1015"]
fn token_71(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 63) as u8)
}
#[doc = "Create token_fields: opc2 opcode2 c0507 thv_c0507"]
fn token_18(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 7) as u8)
}
#[doc = "Create token_fields: c2427 thv_c2427"]
fn token_37(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 24) & 15) as u8)
}
#[derive(Clone, Copy, Default)]
pub struct ContextMemory(pub u32);
impl ContextMemory {
    pub fn read_LRset(&self) -> u8 {
        (((self.0.reverse_bits() >> 31) & 1) as u8)
    }
    pub fn write_LRset(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 31)) | ((value as u32 & 1) << 31)).reverse_bits();
    }
    pub fn read_REToverride(&self) -> u8 {
        (((self.0.reverse_bits() >> 30) & 1) as u8)
    }
    pub fn write_REToverride(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 30)) | ((value as u32 & 1) << 30)).reverse_bits();
    }
    pub fn read_CALLoverride(&self) -> u8 {
        (((self.0.reverse_bits() >> 29) & 1) as u8)
    }
    pub fn write_CALLoverride(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 29)) | ((value as u32 & 1) << 29)).reverse_bits();
    }
    pub fn read_counter(&self) -> u8 {
        (((self.0.reverse_bits() >> 24) & 31) as u8)
    }
    pub fn write_counter(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 24)) | ((value as u32 & 31) << 24)).reverse_bits();
    }
    pub fn read_regNum(&self) -> u8 {
        (((self.0.reverse_bits() >> 19) & 31) as u8)
    }
    pub fn write_regNum(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 19)) | ((value as u32 & 31) << 19)).reverse_bits();
    }
    pub fn read_counter2(&self) -> u8 {
        (((self.0.reverse_bits() >> 16) & 7) as u8)
    }
    pub fn write_counter2(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 16)) | ((value as u32 & 7) << 16)).reverse_bits();
    }
    pub fn read_reg2Num(&self) -> u8 {
        (((self.0.reverse_bits() >> 11) & 31) as u8)
    }
    pub fn write_reg2Num(&mut self, value: u8) {
        self.0 =
            ((self.0.reverse_bits() & !(31 << 11)) | ((value as u32 & 31) << 11)).reverse_bits();
    }
    pub fn read_regInc(&self) -> u8 {
        (((self.0.reverse_bits() >> 9) & 3) as u8)
    }
    pub fn write_regInc(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(3 << 9)) | ((value as u32 & 3) << 9)).reverse_bits();
    }
    pub fn read_ARMcond(&self) -> u8 {
        (((self.0.reverse_bits() >> 8) & 1) as u8)
    }
    pub fn write_ARMcond(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 8)) | ((value as u32 & 1) << 8)).reverse_bits();
    }
    pub fn read_ARMcondCk(&self) -> u8 {
        (((self.0.reverse_bits() >> 7) & 1) as u8)
    }
    pub fn write_ARMcondCk(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 7)) | ((value as u32 & 1) << 7)).reverse_bits();
    }
}
#[derive(Clone)]
pub struct GlobalSet {
    default: ContextMemory,
    branches: std::collections::HashMap<AddrType, ContextMemory>,
}
impl GlobalSet {
    pub fn new(default: ContextMemory) -> Self {
        Self {
            default,
            branches: std::collections::HashMap::new(),
        }
    }
    pub fn set(&mut self, address: Option<AddrType>, set: impl FnOnce(&mut ContextMemory)) {
        let Some (address) = address else { return } ;
        let entry = self
            .branches
            .entry(address)
            .or_insert_with(|| self.default.clone());
        set(entry);
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3494:1, end:3494:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar0 {}
impl mov_instructionVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_LRset(
                u8::try_from(i128::try_from(context.read_LRset()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("mov"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_LRset(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3563:1, end:3563:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar1 {
    rm: Tablerm,
}
impl mov_instructionVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_LRset(
                u8::try_from(i128::try_from(context.read_LRset()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("mov"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_LRset(u8::try_from(1i128 & 1).unwrap());
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2276:1, end:2276:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar2 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3569:1, end:3569:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar3 {
    COND: TableCOND,
}
impl mov_instructionVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2006:1, end:2006:2))"]
#[derive(Clone, Debug)]
struct adr_instructionVar4 {
    ArmPCRelImmed12: TableArmPCRelImmed12,
    COND: TableCOND,
}
impl adr_instructionVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ArmPCRelImmed12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c74 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_45(tokens_param) == 8 {
                    return Some(((), (), 4));
                }
                if token_45(tokens_param) == 4 {
                    return Some(((), (), 4));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c74(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ArmPCRelImmed12 = if let Some((len, table)) =
            TableArmPCRelImmed12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ArmPCRelImmed12,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4160:1, end:4160:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar5 {
    cpsrmask: Tablecpsrmask,
    COND: TableCOND,
    rm: Tablerm,
}
impl msr_instructionVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cpsrmask
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpsrmask = if let Some((len, table)) =
            Tablecpsrmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cpsrmask, COND, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4182:1, end:4182:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar6 {
    rm: Tablerm,
    spsrmask: Tablespsrmask,
    COND: TableCOND,
}
impl msr_instructionVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.spsrmask
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let spsrmask = if let Some((len, table)) =
            Tablespsrmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, spsrmask, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4152:1, end:4152:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar7 {
    shift1: Tableshift1,
    cpsrmask: Tablecpsrmask,
    COND: TableCOND,
}
impl msr_instructionVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cpsrmask
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpsrmask = if let Some((len, table)) =
            Tablecpsrmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift1,
                cpsrmask,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4174:1, end:4174:2))"]
#[derive(Clone, Debug)]
struct msr_instructionVar8 {
    COND: TableCOND,
    spsrmask: Tablespsrmask,
    shift1: Tableshift1,
}
impl msr_instructionVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("msr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.spsrmask
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let spsrmask = if let Some((len, table)) =
            Tablespsrmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                spsrmask,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2492:1, end:2492:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar9 {
    COND: TableCOND,
    shift1: Tableshift1,
    rn: Tablern,
}
impl cmn_instructionVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, shift1, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2503:1, end:2503:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar10 {
    rn: Tablern,
    shift2: Tableshift2,
    COND: TableCOND,
}
impl cmn_instructionVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, shift2, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2514:1, end:2514:2))"]
#[derive(Clone, Debug)]
struct cmn_instructionVar11 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl cmn_instructionVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2525:1, end:2525:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar12 {
    rn: Tablern,
    shift1: Tableshift1,
    COND: TableCOND,
}
impl cmp_instructionVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, shift1, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2536:1, end:2536:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar13 {
    rn: Tablern,
    shift2: Tableshift2,
    COND: TableCOND,
}
impl cmp_instructionVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, shift2, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2547:1, end:2547:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar14 {
    shift3: Tableshift3,
    COND: TableCOND,
    rn: Tablern,
}
impl cmp_instructionVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { shift3, COND, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3537:1, end:3537:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar15 {
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    shift2: Tableshift2,
}
impl mov_instructionVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5624:1, end:5624:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar16 {
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    shift1: Tableshift1,
    rn: Tablern,
}
impl sub_instructionVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                shift1,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3512:1, end:3512:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar17 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl mov_instructionVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3525:1, end:3525:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar18 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl mov_instructionVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3550:1, end:3550:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar19 {
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    shift3: Tableshift3,
}
impl mov_instructionVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4189:1, end:4189:2))"]
#[derive(Clone, Debug)]
struct mul_instructionVar20 {
    SBIT_ZN: TableSBIT_ZN,
    rn: Tablern,
    rs: Tablers,
    COND: TableCOND,
    rm: Tablerm,
}
impl mul_instructionVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_ZN,
                rn,
                rs,
                COND,
                rm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4229:1, end:4229:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar21 {
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
    shift1: Tableshift1,
}
impl mvn_instructionVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                shift1,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4240:1, end:4240:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar22 {
    SBIT_ZN: TableSBIT_ZN,
    shift2: Tableshift2,
    COND: TableCOND,
}
impl mvn_instructionVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_ZN,
                shift2,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4251:1, end:4251:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar23 {
    SBIT_ZN: TableSBIT_ZN,
    shift3: Tableshift3,
    COND: TableCOND,
}
impl mvn_instructionVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_ZN,
                shift3,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5758:1, end:5758:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar24 {
    COND: TableCOND,
    shift1: Tableshift1,
    rn: Tablern,
}
impl teq_instructionVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, shift1, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5769:1, end:5769:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar25 {
    COND: TableCOND,
    shift2: Tableshift2,
    rn: Tablern,
}
impl teq_instructionVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, shift2, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5780:1, end:5780:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar26 {
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl teq_instructionVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, rn, shift3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5791:1, end:5791:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar27 {
    shift1: Tableshift1,
    rn: Tablern,
    COND: TableCOND,
}
impl teq_instructionVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("p"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { shift1, rn, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5802:1, end:5802:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar28 {
    shift2: Tableshift2,
    COND: TableCOND,
    rn: Tablern,
}
impl teq_instructionVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("p"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { shift2, COND, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5813:1, end:5813:2))"]
#[derive(Clone, Debug)]
struct teq_instructionVar29 {
    rn: Tablern,
    shift3: Tableshift3,
    COND: TableCOND,
}
impl teq_instructionVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("teq"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("p"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, shift3, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5825:1, end:5825:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar30 {
    shift1: Tableshift1,
    COND: TableCOND,
    rn: Tablern,
}
impl tst_instructionVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tst"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { shift1, COND, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5836:1, end:5836:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar31 {
    COND: TableCOND,
    shift2: Tableshift2,
    rn: Tablern,
}
impl tst_instructionVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tst"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, shift2, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5847:1, end:5847:2))"]
#[derive(Clone, Debug)]
struct tst_instructionVar32 {
    shift3: Tableshift3,
    COND: TableCOND,
    rn: Tablern,
}
impl tst_instructionVar32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tst"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { shift3, COND, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1945:1, end:1945:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar33 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
    rn: Tablern,
    COND: TableCOND,
}
impl adc_instructionVar33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift1,
                rn,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1958:1, end:1958:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar34 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl adc_instructionVar34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1971:1, end:1971:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar35 {
    COND: TableCOND,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl adc_instructionVar35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                SBIT_CZNO,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2936:1, end:2936:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar36 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2945:1, end:2945:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar37 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2954:1, end:2954:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar38 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2963:1, end:2963:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar39 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2972:1, end:2972:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar40 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2981:1, end:2981:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar41 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2990:1, end:2990:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar42 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2999:1, end:2999:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar43 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3008:1, end:3008:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar44 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3017:1, end:3017:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar45 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3026:1, end:3026:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar46 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3035:1, end:3035:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar47 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3044:1, end:3044:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar48 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3053:1, end:3053:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar49 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3062:1, end:3062:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar50 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3071:1, end:3071:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar51 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3080:1, end:3080:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar52 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3089:1, end:3089:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar53 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3098:1, end:3098:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar54 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3107:1, end:3107:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar55 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3116:1, end:3116:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar56 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3125:1, end:3125:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar57 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3134:1, end:3134:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar58 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3143:1, end:3143:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar59 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3152:1, end:3152:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar60 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3161:1, end:3161:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar61 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3170:1, end:3170:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar62 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3179:1, end:3179:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar63 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3188:1, end:3188:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar64 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3197:1, end:3197:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar65 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar65 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3206:1, end:3206:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar66 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar66 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3215:1, end:3215:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar67 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar67 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3224:1, end:3224:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar68 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar68 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3233:1, end:3233:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar69 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar69 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3242:1, end:3242:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar70 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar70 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3251:1, end:3251:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar71 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar71 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3260:1, end:3260:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar72 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar72 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3269:1, end:3269:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar73 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar73 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3278:1, end:3278:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar74 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar74 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3287:1, end:3287:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar75 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar75 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3296:1, end:3296:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar76 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar76 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3607:1, end:3607:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar77 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar77 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3617:1, end:3617:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar78 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar78 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3627:1, end:3627:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar79 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar79 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3637:1, end:3637:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar80 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar80 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3647:1, end:3647:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar81 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar81 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3657:1, end:3657:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar82 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar82 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3667:1, end:3667:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar83 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar83 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3677:1, end:3677:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar84 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar84 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3687:1, end:3687:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar85 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar85 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3697:1, end:3697:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar86 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar86 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3707:1, end:3707:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar87 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar87 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3717:1, end:3717:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar88 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar88 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3727:1, end:3727:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar89 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar89 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3737:1, end:3737:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar90 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar90 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3747:1, end:3747:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar91 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar91 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3757:1, end:3757:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar92 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar92 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3767:1, end:3767:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar93 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar93 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3777:1, end:3777:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar94 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar94 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3787:1, end:3787:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar95 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar95 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3797:1, end:3797:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar96 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar96 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3807:1, end:3807:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar97 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar97 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3817:1, end:3817:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar98 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar98 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3827:1, end:3827:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar99 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar99 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3837:1, end:3837:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar100 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar100 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3847:1, end:3847:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar101 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar101 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3857:1, end:3857:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar102 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar102 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3867:1, end:3867:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar103 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar103 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3877:1, end:3877:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar104 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar104 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3887:1, end:3887:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar105 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar105 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3897:1, end:3897:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar106 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar106 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3907:1, end:3907:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar107 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar107 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3917:1, end:3917:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar108 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar108 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3927:1, end:3927:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar109 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar109 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3937:1, end:3937:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar110 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar110 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3947:1, end:3947:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar111 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar111 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3957:1, end:3957:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar112 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar112 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3967:1, end:3967:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar113 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar113 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3977:1, end:3977:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar114 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar114 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3987:1, end:3987:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar115 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar115 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3997:1, end:3997:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar116 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar116 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4007:1, end:4007:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar117 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar117 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4139:1, end:4139:2))"]
#[derive(Clone, Debug)]
struct mrs_instructionVar118 {
    Rd: u8,
    COND: TableCOND,
}
impl mrs_instructionVar118 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrs"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::cpsr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4146:1, end:4146:2))"]
#[derive(Clone, Debug)]
struct mrs_instructionVar119 {
    Rd: u8,
    COND: TableCOND,
}
impl mrs_instructionVar119 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrs"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::spsr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3305:1, end:3305:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar120 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar120 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3315:1, end:3315:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar121 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar121 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3325:1, end:3325:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar122 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar122 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3335:1, end:3335:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar123 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar123 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3345:1, end:3345:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar124 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mcr_instructionVar124 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3355:1, end:3355:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar125 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar125 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3365:1, end:3365:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar126 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar126 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3375:1, end:3375:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar127 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar127 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4017:1, end:4017:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar128 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar128 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4028:1, end:4028:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar129 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar129 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4039:1, end:4039:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar130 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar130 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4050:1, end:4050:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar131 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar131 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4061:1, end:4061:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar132 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4072:1, end:4072:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar133 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar133 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4083:1, end:4083:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar134 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar134 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4094:1, end:4094:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar135 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mrc_instructionVar135 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3385:1, end:3385:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar136 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar136 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRm = token_11(tokens_current);
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4105:1, end:4105:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar137 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar137 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRm = token_11(tokens_current);
        let Rd = token_13(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2000:1, end:2000:2))"]
#[derive(Clone, Debug)]
struct adr_instructionVar138 {
    Rd: u8,
    COND: TableCOND,
    ArmPCRelImmed12: TableArmPCRelImmed12,
}
impl adr_instructionVar138 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ArmPCRelImmed12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c73 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_45(tokens_param) == 8 {
                    return Some(((), (), 4));
                }
                if token_45(tokens_param) == 4 {
                    return Some(((), (), 4));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c73(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let ArmPCRelImmed12 = if let Some((len, table)) =
            TableArmPCRelImmed12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                ArmPCRelImmed12,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2048:1, end:2048:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar139 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
    COND: TableCOND,
    rn: Tablern,
}
impl add_instructionVar139 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift1,
                COND,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2061:1, end:2061:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar140 {
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
}
impl add_instructionVar140 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2074:1, end:2074:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar141 {
    shift3: Tableshift3,
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl add_instructionVar141 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                rn,
                COND,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2120:1, end:2120:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar142 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
    COND: TableCOND,
    rn: Tablern,
}
impl and_instructionVar142 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift1,
                COND,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2133:1, end:2133:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar143 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
    COND: TableCOND,
    rn: Tablern,
}
impl and_instructionVar143 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift2,
                COND,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2146:1, end:2146:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar144 {
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl and_instructionVar144 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2229:1, end:2229:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar145 {
    rn: Tablern,
    shift1: Tableshift1,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl bic_instructionVar145 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                shift1,
                SBIT_CZNO,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2242:1, end:2242:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar146 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl bic_instructionVar146 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                shift2,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2255:1, end:2255:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar147 {
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
    shift3: Tableshift3,
}
impl bic_instructionVar147 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2644:1, end:2644:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar148 {
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift1: Tableshift1,
    COND: TableCOND,
}
impl eor_instructionVar148 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                rn,
                shift1,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2657:1, end:2657:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar149 {
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    COND: TableCOND,
    shift2: Tableshift2,
}
impl eor_instructionVar149 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                rn,
                COND,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2670:1, end:2670:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar150 {
    COND: TableCOND,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl eor_instructionVar150 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                SBIT_CZNO,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5687:1, end:5687:2))"]
#[derive(Clone, Debug)]
struct swp_instructionVar151 {
    Rd: u8,
    Rm: u8,
    Rn: u8,
    COND: TableCOND,
}
impl swp_instructionVar151 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swp"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn = token_10(tokens_current);
        let Rd = token_13(tokens_current);
        let Rm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd, Rm, Rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5695:1, end:5695:2))"]
#[derive(Clone, Debug)]
struct swpb_instructionVar152 {
    Rd: u8,
    Rm: u8,
    Rn: u8,
    COND: TableCOND,
}
impl swpb_instructionVar152 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swpb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn = token_10(tokens_current);
        let Rd = token_13(tokens_current);
        let Rm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Rd, Rm, Rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3457:1, end:3457:2))"]
#[derive(Clone, Debug)]
struct mla_instructionVar153 {
    Rn: u8,
    Rm: u8,
    Rs: u8,
    Rd: u8,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
}
impl mla_instructionVar153 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mla"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rm),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rs),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rs = token_14(tokens_current);
        let Rd = token_13(tokens_current);
        let Rm = token_11(tokens_current);
        let Rn = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                Rn,
                Rm,
                Rs,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3474:1, end:3474:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar154 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl mov_instructionVar154 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3484:1, end:3484:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar155 {
    Rd: u8,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl mov_instructionVar155 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3502:1, end:3502:2))"]
#[derive(Clone, Debug)]
struct mov_instructionVar156 {
    Rd: u8,
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl mov_instructionVar156 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mov"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4199:1, end:4199:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar157 {
    Rd: u8,
    shift1: Tableshift1,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl mvn_instructionVar157 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift1,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4209:1, end:4209:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar158 {
    Rd: u8,
    COND: TableCOND,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl mvn_instructionVar158 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift2,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4219:1, end:4219:2))"]
#[derive(Clone, Debug)]
struct mvn_instructionVar159 {
    Rd: u8,
    COND: TableCOND,
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl mvn_instructionVar159 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mvn"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift3,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4302:1, end:4302:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar160 {
    COND: TableCOND,
    shift1: Tableshift1,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
}
impl orr_instructionVar160 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift1,
                SBIT_CZNO,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4315:1, end:4315:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar161 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
    rn: Tablern,
    COND: TableCOND,
}
impl orr_instructionVar161 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift2,
                rn,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4328:1, end:4328:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar162 {
    COND: TableCOND,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl orr_instructionVar162 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                SBIT_CZNO,
                shift3,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4644:1, end:4644:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar163 {
    COND: TableCOND,
    shift1: Tableshift1,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
}
impl rsb_instructionVar163 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift1,
                SBIT_CZNO,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4657:1, end:4657:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar164 {
    COND: TableCOND,
    rn: Tablern,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl rsb_instructionVar164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                shift2,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4670:1, end:4670:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar165 {
    COND: TableCOND,
    shift3: Tableshift3,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl rsb_instructionVar165 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift3,
                rn,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4716:1, end:4716:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar166 {
    rn: Tablern,
    COND: TableCOND,
    shift1: Tableshift1,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl rsc_instructionVar166 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                shift1,
                SBIT_CZNO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4729:1, end:4729:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar167 {
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    COND: TableCOND,
}
impl rsc_instructionVar167 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                SBIT_CZNO,
                rn,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4742:1, end:4742:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar168 {
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    shift3: Tableshift3,
    rn: Tablern,
}
impl rsc_instructionVar168 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                shift3,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4848:1, end:4848:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar169 {
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    shift1: Tableshift1,
    rn: Tablern,
}
impl sbc_instructionVar169 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                shift1,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4861:1, end:4861:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar170 {
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl sbc_instructionVar170 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4874:1, end:4874:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar171 {
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    COND: TableCOND,
}
impl sbc_instructionVar171 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                SBIT_CZNO,
                rn,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5073:1, end:5073:2))"]
#[derive(Clone, Debug)]
struct smlal_instructionVar172 {
    RdLo: u8,
    RdHi: u8,
    smRn: u8,
    smRm: u8,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
}
impl smlal_instructionVar172 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smlal"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.RdLo),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.RdHi),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let smRm = token_14(tokens_current);
        let smRn = token_11(tokens_current);
        let RdLo = token_13(tokens_current);
        let RdHi = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                RdLo,
                RdHi,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5294:1, end:5294:2))"]
#[derive(Clone, Debug)]
struct smull_instructionVar173 {
    RdLo: u8,
    RdHi: u8,
    smRn: u8,
    smRm: u8,
    COND: TableCOND,
    SBIT_ZN: TableSBIT_ZN,
}
impl smull_instructionVar173 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("smull"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.RdLo),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.RdHi),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.smRm),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RdLo = token_13(tokens_current);
        let RdHi = token_10(tokens_current);
        let smRn = token_11(tokens_current);
        let smRm = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_ZN,
                RdLo,
                RdHi,
                smRn,
                smRm,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5609:1, end:5609:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar174 {
    shift1: Tableshift1,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
}
impl sub_instructionVar174 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift1,
                COND,
                SBIT_CZNO,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5638:1, end:5638:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar175 {
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
    rn: Tablern,
    COND: TableCOND,
}
impl sub_instructionVar175 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                shift2,
                rn,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5653:1, end:5653:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar176 {
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    shift3: Tableshift3,
    rn: Tablern,
}
impl sub_instructionVar176 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                shift3,
                rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:6080:1, end:6080:2))"]
#[derive(Clone, Debug)]
struct umlal_instructionVar177 {
    Rd: u8,
    Rn: u8,
    COND: TableCOND,
    rs: Tablers,
    rm: Tablerm,
    SBIT_ZN: TableSBIT_ZN,
}
impl umlal_instructionVar177 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("umlal"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn = token_10(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rs,
                rm,
                SBIT_ZN,
                Rd,
                Rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:6095:1, end:6095:2))"]
#[derive(Clone, Debug)]
struct umull_instructionVar178 {
    Rd: u8,
    Rn: u8,
    COND: TableCOND,
    rm: Tablerm,
    SBIT_ZN: TableSBIT_ZN,
    rs: Tablers,
}
impl umull_instructionVar178 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("umull"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_ZN
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_ZN = if let Some((len, table)) =
            TableSBIT_ZN::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rn = token_10(tokens_current);
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rm,
                SBIT_ZN,
                rs,
                Rd,
                Rn,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1912:1, end:1912:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar179 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl adc_instructionVar179 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1923:1, end:1923:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar180 {
    Rd: u8,
    COND: TableCOND,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl adc_instructionVar180 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                SBIT_CZNO,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1934:1, end:1934:2))"]
#[derive(Clone, Debug)]
struct adc_instructionVar181 {
    Rd: u8,
    rn: Tablern,
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl adc_instructionVar181 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                shift3,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2015:1, end:2015:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar182 {
    Rd: u8,
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl add_instructionVar182 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2026:1, end:2026:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar183 {
    Rd: u8,
    rn: Tablern,
    shift2: Tableshift2,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl add_instructionVar183 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                shift2,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2037:1, end:2037:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar184 {
    Rd: u8,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
    COND: TableCOND,
}
impl add_instructionVar184 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                SBIT_CZNO,
                shift3,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2087:1, end:2087:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar185 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl and_instructionVar185 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2098:1, end:2098:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar186 {
    Rd: u8,
    shift2: Tableshift2,
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl and_instructionVar186 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                rn,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2109:1, end:2109:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar187 {
    Rd: u8,
    shift3: Tableshift3,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
}
impl and_instructionVar187 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                COND,
                SBIT_CZNO,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2269:1, end:2269:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar188 {
    Addr24: TableAddr24,
}
impl bl_instructionVar188 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2161:1, end:2161:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar189 {
    Addr24: TableAddr24,
}
impl b_instructionVar189 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2284:1, end:2284:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar190 {
    Addr24: TableAddr24,
}
impl bl_instructionVar190 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2290:1, end:2290:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar191 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar191 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2298:1, end:2298:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar192 {
    COND: TableCOND,
    Addr24: TableAddr24,
}
impl bl_instructionVar192 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3395:1, end:3395:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar193 {
    COND: TableCOND,
    mcrOperands: TablemcrOperands,
}
impl mcr_instructionVar193 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        let CRm = token_11(tokens_current);
        let opc1 = token_16(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, mcrOperands }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4116:1, end:4116:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar194 {
    mcrOperands: TablemcrOperands,
    COND: TableCOND,
}
impl mrc_instructionVar194 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.mcrOperands
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mcrOperands = if let Some((len, table)) =
            TablemcrOperands::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRm = token_11(tokens_current);
        let opc2 = token_18(tokens_current);
        let Rd = token_13(tokens_current);
        let opc1 = token_16(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mcrOperands, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:3407:1, end:3407:2))"]
#[derive(Clone, Debug)]
struct mcr_instructionVar195 {
    cpn: u8,
    opc1: u8,
    Rd: u8,
    CRn: u8,
    CRm: u8,
    opc2: u8,
    COND: TableCOND,
}
impl mcr_instructionVar195 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc1 as u64),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRn = token_10(tokens_current);
        let CRm = token_11(tokens_current);
        let Rd = token_13(tokens_current);
        let cpn = token_14(tokens_current);
        let opc2 = token_18(tokens_current);
        let opc1 = token_16(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpn,
                opc1,
                Rd,
                CRn,
                CRm,
                opc2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4129:1, end:4129:2))"]
#[derive(Clone, Debug)]
struct mrc_instructionVar196 {
    cpn: u8,
    opc1: u8,
    Rd: u8,
    CRn: u8,
    CRm: u8,
    opc2: u8,
    COND: TableCOND,
}
impl mrc_instructionVar196 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mrc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc1 as u64),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let opc1 = token_16(tokens_current);
        let CRm = token_11(tokens_current);
        let Rd = token_13(tokens_current);
        let cpn = token_14(tokens_current);
        let CRn = token_10(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpn,
                opc1,
                Rd,
                CRn,
                CRm,
                opc2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2464:1, end:2464:2))"]
#[derive(Clone, Debug)]
struct cdp_instructionVar197 {
    cpn: u8,
    opcode1: u8,
    CRd: u8,
    CRn: u8,
    CRm: u8,
    opcode2: u8,
    COND: TableCOND,
}
impl cdp_instructionVar197 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cdp"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 12usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opcode1 as u64),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opcode2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRd = token_13(tokens_current);
        let opcode2 = token_18(tokens_current);
        let opcode1 = token_17(tokens_current);
        let CRn = token_10(tokens_current);
        let CRm = token_11(tokens_current);
        let cpn = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                cpn,
                opcode1,
                CRd,
                CRn,
                CRm,
                opcode2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2771:1, end:2771:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar198 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar198 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_LRset(
                u8::try_from(i128::try_from(context.read_LRset()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ldr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_LRset(u8::try_from(0i128 & 1).unwrap());
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c124 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c124 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c124(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c124(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2759:1, end:2759:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar199 {
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl ldr_instructionVar199 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_LRset(
                u8::try_from(i128::try_from(context.read_LRset()).unwrap() & 1).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("ldr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_LRset(u8::try_from(0i128 & 1).unwrap());
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c116 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c116 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c116(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c116(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrmode2, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2793:1, end:2793:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar200 {
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar200 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c114 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c114 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c114(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c114(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, addrmode2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2784:1, end:2784:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar201 {
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl ldr_instructionVar201 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::pc),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrmode2, COND }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2809:1, end:2809:2))"]
#[derive(Clone, Debug)]
struct ldrbt_instructionVar202 {
    Rd: u8,
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl ldrbt_instructionVar202 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrbt"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c107(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c107(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2913:1, end:2913:2))"]
#[derive(Clone, Debug)]
struct ldrt_instructionVar203 {
    Rd: u8,
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl ldrt_instructionVar203 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrt"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5469:1, end:5469:2))"]
#[derive(Clone, Debug)]
struct strbt_instructionVar204 {
    Rd: u8,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl strbt_instructionVar204 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strbt"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c107 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c107(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c107(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5569:1, end:5569:2))"]
#[derive(Clone, Debug)]
struct strt_instructionVar205 {
    Rd: u8,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl strt_instructionVar205 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strt"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c106 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c106(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c106(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5668:1, end:5668:2))"]
#[derive(Clone, Debug)]
struct swi_instructionVar206 {
    immed24: u32,
    COND: TableCOND,
}
impl swi_instructionVar206 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swi"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.immed24 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed24 = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { COND, immed24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2166:1, end:2166:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar207 {
    cc: Tablecc,
    Addr24: TableAddr24,
}
impl b_instructionVar207 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Addr24
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Addr24 = if let Some((len, table)) =
            TableAddr24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc, Addr24 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2196:1, end:2196:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar208 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl bic_instructionVar208 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2207:1, end:2207:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar209 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl bic_instructionVar209 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2218:1, end:2218:2))"]
#[derive(Clone, Debug)]
struct bic_instructionVar210 {
    Rd: u8,
    shift3: Tableshift3,
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl bic_instructionVar210 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bic"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                rn,
                COND,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2611:1, end:2611:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar211 {
    Rd: u8,
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl eor_instructionVar211 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2622:1, end:2622:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar212 {
    Rd: u8,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
}
impl eor_instructionVar212 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift2,
                SBIT_CZNO,
                COND,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2633:1, end:2633:2))"]
#[derive(Clone, Debug)]
struct eor_instructionVar213 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl eor_instructionVar213 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2710:1, end:2710:2))"]
#[derive(Clone, Debug)]
struct ldc_instructionVar214 {
    cpn: u8,
    CRd: u8,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl ldc_instructionVar214 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let cpn = token_14(tokens_current);
        let CRd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2718:1, end:2718:2))"]
#[derive(Clone, Debug)]
struct ldcl_instructionVar215 {
    cpn: u8,
    CRd: u8,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl ldcl_instructionVar215 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldcl"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRd = token_13(tokens_current);
        let cpn = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2726:1, end:2726:2))"]
#[derive(Clone, Debug)]
struct ldm_instructionVar216 {
    COND: TableCOND,
    mdir: Tablemdir,
    reglist: Tablereglist,
}
impl ldm_instructionVar216 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldm"));
        self.mdir
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) =
            Tablereglist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                mdir,
                reglist,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2732:1, end:2732:2))"]
#[derive(Clone, Debug)]
struct ldm_instructionVar217 {
    reglist: Tablereglist,
    mdir: Tablemdir,
    COND: TableCOND,
}
impl ldm_instructionVar217 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldm"));
        self.mdir
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) =
            Tablereglist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                reglist,
                mdir,
                COND,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2751:1, end:2751:2))"]
#[derive(Clone, Debug)]
struct ldr_instructionVar218 {
    Rd: u8,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl ldr_instructionVar218 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2802:1, end:2802:2))"]
#[derive(Clone, Debug)]
struct ldrb_instructionVar219 {
    Rd: u8,
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl ldrb_instructionVar219 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2861:1, end:2861:2))"]
#[derive(Clone, Debug)]
struct ldrh_instructionVar220 {
    Rd: u8,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl ldrh_instructionVar220 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrh"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) =
            Tableaddrmode3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2878:1, end:2878:2))"]
#[derive(Clone, Debug)]
struct ldrsb_instructionVar221 {
    Rd: u8,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl ldrsb_instructionVar221 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) =
            Tableaddrmode3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:2895:1, end:2895:2))"]
#[derive(Clone, Debug)]
struct ldrsh_instructionVar222 {
    Rd: u8,
    addrmode3: Tableaddrmode3,
    COND: TableCOND,
}
impl ldrsh_instructionVar222 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldrsh"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) =
            Tableaddrmode3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode3,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4269:1, end:4269:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar223 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
    shift1: Tableshift1,
}
impl orr_instructionVar223 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                rn,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4280:1, end:4280:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar224 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
    COND: TableCOND,
}
impl orr_instructionVar224 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                rn,
                shift2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4291:1, end:4291:2))"]
#[derive(Clone, Debug)]
struct orr_instructionVar225 {
    Rd: u8,
    shift3: Tableshift3,
    COND: TableCOND,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl orr_instructionVar225 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orr"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                COND,
                rn,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4611:1, end:4611:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar226 {
    Rd: u8,
    COND: TableCOND,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
}
impl rsb_instructionVar226 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                rn,
                SBIT_CZNO,
                shift1,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4622:1, end:4622:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar227 {
    Rd: u8,
    COND: TableCOND,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
}
impl rsb_instructionVar227 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                shift2,
                SBIT_CZNO,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4633:1, end:4633:2))"]
#[derive(Clone, Debug)]
struct rsb_instructionVar228 {
    Rd: u8,
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift3: Tableshift3,
}
impl rsb_instructionVar228 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4683:1, end:4683:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar229 {
    Rd: u8,
    shift1: Tableshift1,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
}
impl rsc_instructionVar229 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift1,
                SBIT_CZNO,
                COND,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4694:1, end:4694:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar230 {
    Rd: u8,
    rn: Tablern,
    COND: TableCOND,
    shift2: Tableshift2,
    SBIT_CZNO: TableSBIT_CZNO,
}
impl rsc_instructionVar230 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                shift2,
                SBIT_CZNO,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4705:1, end:4705:2))"]
#[derive(Clone, Debug)]
struct rsc_instructionVar231 {
    Rd: u8,
    shift3: Tableshift3,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    rn: Tablern,
}
impl rsc_instructionVar231 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rsc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                SBIT_CZNO,
                COND,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4815:1, end:4815:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar232 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift1: Tableshift1,
    rn: Tablern,
}
impl sbc_instructionVar232 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                shift1,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4826:1, end:4826:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar233 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift2: Tableshift2,
}
impl sbc_instructionVar233 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:4837:1, end:4837:2))"]
#[derive(Clone, Debug)]
struct sbc_instructionVar234 {
    Rd: u8,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    rn: Tablern,
    shift3: Tableshift3,
}
impl sbc_instructionVar234 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbc"));
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                SBIT_CZNO,
                rn,
                shift3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5423:1, end:5423:2))"]
#[derive(Clone, Debug)]
struct stc_instructionVar235 {
    cpn: u8,
    CRd: u8,
    addrmode5: Tableaddrmode5,
    COND: TableCOND,
}
impl stc_instructionVar235 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stc"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRd = token_13(tokens_current);
        let cpn = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode5,
                COND,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5431:1, end:5431:2))"]
#[derive(Clone, Debug)]
struct stcl_instructionVar236 {
    cpn: u8,
    CRd: u8,
    COND: TableCOND,
    addrmode5: Tableaddrmode5,
}
impl stcl_instructionVar236 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stcl"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.cpn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode5 = if let Some((len, table)) =
            Tableaddrmode5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRd = token_13(tokens_current);
        let cpn = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode5,
                cpn,
                CRd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5454:1, end:5454:2))"]
#[derive(Clone, Debug)]
struct str_instructionVar237 {
    Rd: u8,
    COND: TableCOND,
    addrmode2: Tableaddrmode2,
}
impl str_instructionVar237 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("str"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5461:1, end:5461:2))"]
#[derive(Clone, Debug)]
struct strb_instructionVar238 {
    Rd: u8,
    addrmode2: Tableaddrmode2,
    COND: TableCOND,
}
impl strb_instructionVar238 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strb"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_3(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                let mut sub_pattern_c90 = |tokens: &[u8], context_param: &mut ContextMemory| {
                    let mut pattern_len = 0;
                    let mut context_instance = context_param.clone();
                    let mut tokens = tokens;
                    let mut block_0_len = 4;
                    if token_3(tokens) != 1 {
                        return None;
                    }
                    if token_97(tokens) != 0 {
                        return None;
                    }
                    pattern_len += block_0_len;
                    tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                    *context_param = context_instance;
                    Some(((), (), pattern_len))
                };
                let mut context_current = context_param.clone();
                if let Some(((), (), sub_pattern_len)) =
                    sub_pattern_c90(tokens_param, &mut context_current)
                {
                    *context_param = context_current;
                    return Some(((), (), sub_pattern_len));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c90(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let addrmode2 = if let Some((len, table)) =
            Tableaddrmode2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addrmode2,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5477:1, end:5477:2))"]
#[derive(Clone, Debug)]
struct strh_instructionVar239 {
    Rd: u8,
    COND: TableCOND,
    addrmode3: Tableaddrmode3,
}
impl strh_instructionVar239 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("strh"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addrmode3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addrmode3 = if let Some((len, table)) =
            Tableaddrmode3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                COND,
                addrmode3,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5439:1, end:5439:2))"]
#[derive(Clone, Debug)]
struct stm_instructionVar240 {
    reglist: Tablereglist,
    COND: TableCOND,
    mdir: Tablemdir,
}
impl stm_instructionVar240 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stm"));
        self.mdir
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.reglist
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mdir = if let Some((len, table)) =
            Tablemdir::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let reglist = if let Some((len, table)) =
            Tablereglist::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                reglist,
                COND,
                mdir,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5576:1, end:5576:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar241 {
    Rd: u8,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
    shift1: Tableshift1,
    rn: Tablern,
}
impl sub_instructionVar241 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift1 = if let Some((len, table)) =
            Tableshift1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SBIT_CZNO,
                COND,
                shift1,
                rn,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5587:1, end:5587:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar242 {
    Rd: u8,
    rn: Tablern,
    COND: TableCOND,
    SBIT_CZNO: TableSBIT_CZNO,
    shift2: Tableshift2,
}
impl sub_instructionVar242 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift2 = if let Some((len, table)) =
            Tableshift2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rn,
                COND,
                SBIT_CZNO,
                shift2,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:5598:1, end:5598:2))"]
#[derive(Clone, Debug)]
struct sub_instructionVar243 {
    Rd: u8,
    shift3: Tableshift3,
    rn: Tablern,
    SBIT_CZNO: TableSBIT_CZNO,
    COND: TableCOND,
}
impl sub_instructionVar243 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub"));
        self.COND
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.SBIT_CZNO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.shift3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let COND = if let Some((len, table)) =
            TableCOND::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SBIT_CZNO = if let Some((len, table)) =
            TableSBIT_CZNO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let shift3 = if let Some((len, table)) =
            Tableshift3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Rd = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                shift3,
                rn,
                SBIT_CZNO,
                COND,
                Rd,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1526:1, end:1526:2))"]
#[derive(Clone, Debug)]
struct instructionVar244 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar244 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_ARMcondCk(u8::try_from(1i128 & 1).unwrap());
        context_instance.write_ARMcond(u8::try_from(1i128 & 1).unwrap());
        let mut sub_pattern_c43 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_30(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                if token_32(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                if token_33(tokens_param) == 0 {
                    return Some(((), (), 4));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c43(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1527:1, end:1527:2))"]
#[derive(Clone, Debug)]
struct instructionVar245 {
    instruction: Box<Tableinstruction>,
}
impl instructionVar245 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_ARMcondCk(u8::try_from(1i128 & 1).unwrap());
        context_instance.write_ARMcond(u8::try_from(0i128 & 1).unwrap());
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { instruction }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(mov_instructionVar0),
    Var1(mov_instructionVar1),
    Var2(bl_instructionVar2),
    Var3(mov_instructionVar3),
    Var4(adr_instructionVar4),
    Var5(msr_instructionVar5),
    Var6(msr_instructionVar6),
    Var7(msr_instructionVar7),
    Var8(msr_instructionVar8),
    Var9(cmn_instructionVar9),
    Var10(cmn_instructionVar10),
    Var11(cmn_instructionVar11),
    Var12(cmp_instructionVar12),
    Var13(cmp_instructionVar13),
    Var14(cmp_instructionVar14),
    Var15(mov_instructionVar15),
    Var16(sub_instructionVar16),
    Var17(mov_instructionVar17),
    Var18(mov_instructionVar18),
    Var19(mov_instructionVar19),
    Var20(mul_instructionVar20),
    Var21(mvn_instructionVar21),
    Var22(mvn_instructionVar22),
    Var23(mvn_instructionVar23),
    Var24(teq_instructionVar24),
    Var25(teq_instructionVar25),
    Var26(teq_instructionVar26),
    Var27(teq_instructionVar27),
    Var28(teq_instructionVar28),
    Var29(teq_instructionVar29),
    Var30(tst_instructionVar30),
    Var31(tst_instructionVar31),
    Var32(tst_instructionVar32),
    Var33(adc_instructionVar33),
    Var34(adc_instructionVar34),
    Var35(adc_instructionVar35),
    Var36(mcr_instructionVar36),
    Var37(mcr_instructionVar37),
    Var38(mcr_instructionVar38),
    Var39(mcr_instructionVar39),
    Var40(mcr_instructionVar40),
    Var41(mcr_instructionVar41),
    Var42(mcr_instructionVar42),
    Var43(mcr_instructionVar43),
    Var44(mcr_instructionVar44),
    Var45(mcr_instructionVar45),
    Var46(mcr_instructionVar46),
    Var47(mcr_instructionVar47),
    Var48(mcr_instructionVar48),
    Var49(mcr_instructionVar49),
    Var50(mcr_instructionVar50),
    Var51(mcr_instructionVar51),
    Var52(mcr_instructionVar52),
    Var53(mcr_instructionVar53),
    Var54(mcr_instructionVar54),
    Var55(mcr_instructionVar55),
    Var56(mcr_instructionVar56),
    Var57(mcr_instructionVar57),
    Var58(mcr_instructionVar58),
    Var59(mcr_instructionVar59),
    Var60(mcr_instructionVar60),
    Var61(mcr_instructionVar61),
    Var62(mcr_instructionVar62),
    Var63(mcr_instructionVar63),
    Var64(mcr_instructionVar64),
    Var65(mcr_instructionVar65),
    Var66(mcr_instructionVar66),
    Var67(mcr_instructionVar67),
    Var68(mcr_instructionVar68),
    Var69(mcr_instructionVar69),
    Var70(mcr_instructionVar70),
    Var71(mcr_instructionVar71),
    Var72(mcr_instructionVar72),
    Var73(mcr_instructionVar73),
    Var74(mcr_instructionVar74),
    Var75(mcr_instructionVar75),
    Var76(mcr_instructionVar76),
    Var77(mrc_instructionVar77),
    Var78(mrc_instructionVar78),
    Var79(mrc_instructionVar79),
    Var80(mrc_instructionVar80),
    Var81(mrc_instructionVar81),
    Var82(mrc_instructionVar82),
    Var83(mrc_instructionVar83),
    Var84(mrc_instructionVar84),
    Var85(mrc_instructionVar85),
    Var86(mrc_instructionVar86),
    Var87(mrc_instructionVar87),
    Var88(mrc_instructionVar88),
    Var89(mrc_instructionVar89),
    Var90(mrc_instructionVar90),
    Var91(mrc_instructionVar91),
    Var92(mrc_instructionVar92),
    Var93(mrc_instructionVar93),
    Var94(mrc_instructionVar94),
    Var95(mrc_instructionVar95),
    Var96(mrc_instructionVar96),
    Var97(mrc_instructionVar97),
    Var98(mrc_instructionVar98),
    Var99(mrc_instructionVar99),
    Var100(mrc_instructionVar100),
    Var101(mrc_instructionVar101),
    Var102(mrc_instructionVar102),
    Var103(mrc_instructionVar103),
    Var104(mrc_instructionVar104),
    Var105(mrc_instructionVar105),
    Var106(mrc_instructionVar106),
    Var107(mrc_instructionVar107),
    Var108(mrc_instructionVar108),
    Var109(mrc_instructionVar109),
    Var110(mrc_instructionVar110),
    Var111(mrc_instructionVar111),
    Var112(mrc_instructionVar112),
    Var113(mrc_instructionVar113),
    Var114(mrc_instructionVar114),
    Var115(mrc_instructionVar115),
    Var116(mrc_instructionVar116),
    Var117(mrc_instructionVar117),
    Var118(mrs_instructionVar118),
    Var119(mrs_instructionVar119),
    Var120(mcr_instructionVar120),
    Var121(mcr_instructionVar121),
    Var122(mcr_instructionVar122),
    Var123(mcr_instructionVar123),
    Var124(mcr_instructionVar124),
    Var125(mcr_instructionVar125),
    Var126(mcr_instructionVar126),
    Var127(mcr_instructionVar127),
    Var128(mrc_instructionVar128),
    Var129(mrc_instructionVar129),
    Var130(mrc_instructionVar130),
    Var131(mrc_instructionVar131),
    Var132(mrc_instructionVar132),
    Var133(mrc_instructionVar133),
    Var134(mrc_instructionVar134),
    Var135(mrc_instructionVar135),
    Var136(mcr_instructionVar136),
    Var137(mrc_instructionVar137),
    Var138(adr_instructionVar138),
    Var139(add_instructionVar139),
    Var140(add_instructionVar140),
    Var141(add_instructionVar141),
    Var142(and_instructionVar142),
    Var143(and_instructionVar143),
    Var144(and_instructionVar144),
    Var145(bic_instructionVar145),
    Var146(bic_instructionVar146),
    Var147(bic_instructionVar147),
    Var148(eor_instructionVar148),
    Var149(eor_instructionVar149),
    Var150(eor_instructionVar150),
    Var151(swp_instructionVar151),
    Var152(swpb_instructionVar152),
    Var153(mla_instructionVar153),
    Var154(mov_instructionVar154),
    Var155(mov_instructionVar155),
    Var156(mov_instructionVar156),
    Var157(mvn_instructionVar157),
    Var158(mvn_instructionVar158),
    Var159(mvn_instructionVar159),
    Var160(orr_instructionVar160),
    Var161(orr_instructionVar161),
    Var162(orr_instructionVar162),
    Var163(rsb_instructionVar163),
    Var164(rsb_instructionVar164),
    Var165(rsb_instructionVar165),
    Var166(rsc_instructionVar166),
    Var167(rsc_instructionVar167),
    Var168(rsc_instructionVar168),
    Var169(sbc_instructionVar169),
    Var170(sbc_instructionVar170),
    Var171(sbc_instructionVar171),
    Var172(smlal_instructionVar172),
    Var173(smull_instructionVar173),
    Var174(sub_instructionVar174),
    Var175(sub_instructionVar175),
    Var176(sub_instructionVar176),
    Var177(umlal_instructionVar177),
    Var178(umull_instructionVar178),
    Var179(adc_instructionVar179),
    Var180(adc_instructionVar180),
    Var181(adc_instructionVar181),
    Var182(add_instructionVar182),
    Var183(add_instructionVar183),
    Var184(add_instructionVar184),
    Var185(and_instructionVar185),
    Var186(and_instructionVar186),
    Var187(and_instructionVar187),
    Var188(bl_instructionVar188),
    Var189(b_instructionVar189),
    Var190(bl_instructionVar190),
    Var191(bl_instructionVar191),
    Var192(bl_instructionVar192),
    Var193(mcr_instructionVar193),
    Var194(mrc_instructionVar194),
    Var195(mcr_instructionVar195),
    Var196(mrc_instructionVar196),
    Var197(cdp_instructionVar197),
    Var198(ldr_instructionVar198),
    Var199(ldr_instructionVar199),
    Var200(ldr_instructionVar200),
    Var201(ldr_instructionVar201),
    Var202(ldrbt_instructionVar202),
    Var203(ldrt_instructionVar203),
    Var204(strbt_instructionVar204),
    Var205(strt_instructionVar205),
    Var206(swi_instructionVar206),
    Var207(b_instructionVar207),
    Var208(bic_instructionVar208),
    Var209(bic_instructionVar209),
    Var210(bic_instructionVar210),
    Var211(eor_instructionVar211),
    Var212(eor_instructionVar212),
    Var213(eor_instructionVar213),
    Var214(ldc_instructionVar214),
    Var215(ldcl_instructionVar215),
    Var216(ldm_instructionVar216),
    Var217(ldm_instructionVar217),
    Var218(ldr_instructionVar218),
    Var219(ldrb_instructionVar219),
    Var220(ldrh_instructionVar220),
    Var221(ldrsb_instructionVar221),
    Var222(ldrsh_instructionVar222),
    Var223(orr_instructionVar223),
    Var224(orr_instructionVar224),
    Var225(orr_instructionVar225),
    Var226(rsb_instructionVar226),
    Var227(rsb_instructionVar227),
    Var228(rsb_instructionVar228),
    Var229(rsc_instructionVar229),
    Var230(rsc_instructionVar230),
    Var231(rsc_instructionVar231),
    Var232(sbc_instructionVar232),
    Var233(sbc_instructionVar233),
    Var234(sbc_instructionVar234),
    Var235(stc_instructionVar235),
    Var236(stcl_instructionVar236),
    Var237(str_instructionVar237),
    Var238(strb_instructionVar238),
    Var239(strh_instructionVar239),
    Var240(stm_instructionVar240),
    Var241(sub_instructionVar241),
    Var242(sub_instructionVar242),
    Var243(sub_instructionVar243),
    Var244(instructionVar244),
    Var245(instructionVar245),
}
impl Tableinstruction {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var64(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var65(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var66(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var67(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var68(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var69(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var70(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var71(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var72(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var73(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var74(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var75(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var76(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var77(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var78(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var79(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var80(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var81(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var82(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var83(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var84(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var85(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var86(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var87(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var88(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var89(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var90(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var91(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var92(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var93(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var94(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var95(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var96(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var97(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var98(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var99(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var100(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var101(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var102(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var103(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var104(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var105(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var106(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var107(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var108(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var109(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var110(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var111(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var112(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var113(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var114(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var115(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var116(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var117(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var118(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var119(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var120(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var121(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var122(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var123(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var124(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var125(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var126(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var127(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var128(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var129(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var130(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var131(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var132(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var133(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var134(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var135(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var136(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var137(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var138(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var139(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var140(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var141(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var142(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var143(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var144(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var145(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var146(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var147(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var148(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var149(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var150(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var151(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var152(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var153(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var154(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var155(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var156(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var157(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var158(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var159(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var160(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var161(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var162(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var163(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var164(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var165(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var166(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var167(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var168(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var169(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var170(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var171(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var172(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var173(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var174(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var175(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var176(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var177(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var178(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var179(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var180(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var181(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var182(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var183(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var184(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var185(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var186(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var187(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var188(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var189(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var190(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var191(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var192(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var193(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var194(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var195(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var196(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var197(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var198(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var199(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var200(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var201(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var202(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var203(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var204(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var205(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var206(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var207(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var208(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var209(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var210(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var211(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var212(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var213(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var214(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var215(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var216(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var217(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var218(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var219(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var220(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var221(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var222(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var223(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var224(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var225(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var226(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var227(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var228(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var229(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var230(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var231(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var232(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var233(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var234(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var235(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var236(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var237(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var238(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var239(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var240(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var241(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var242(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var243(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var244(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var245(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 255) == 225
            && (tokens_param[1] & 255) == 160
            && (tokens_param[2] & 255) == 224
            && (tokens_param[3] & 255) == 15
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 16777216
            && (tokens_param[0] & 255) == 241
            && (tokens_param[1] & 255) == 160
            && (tokens_param[2] & 255) == 224
            && (tokens_param[3] & 255) == 15
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 11
            && (tokens_param[1] & 255) == 255
            && (tokens_param[2] & 255) == 255
            && (tokens_param[3] & 255) == 255
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 160
            && (tokens_param[2] & 255) == 240
            && (tokens_param[3] & 255) == 14
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 2
            && (tokens_param[1] & 63) == 15
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                adr_instructionVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 32
            && (tokens_param[2] & 255) == 240
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                msr_instructionVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 96
            && (tokens_param[2] & 255) == 240
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                msr_instructionVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 3
            && (tokens_param[1] & 240) == 32
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                msr_instructionVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 3
            && (tokens_param[1] & 240) == 96
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                msr_instructionVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 112
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmn_instructionVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 112
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmn_instructionVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 112
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmn_instructionVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 80
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 80
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 80
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165825 == 25165825
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 2
            && (tokens_param[1] & 239) == 78
            && (tokens_param[2] & 255) == 240
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 240) == 0
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                mul_instructionVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 48
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                teq_instructionVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 16
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                tst_instructionVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 16
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                tst_instructionVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 240) == 16
            && (tokens_param[2] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                tst_instructionVar32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 112
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 17
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 49
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 81
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 2
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 2
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 2
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 3
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 5
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 5
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 6
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 6
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 144
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 21
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 53
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 149
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 22
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 54
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 86
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 26
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 58
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 90
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 154
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar64::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var64(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 186
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar65::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var65(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 30
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar66::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var66(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 62
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar67::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var67(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 8
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 23
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar68::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var68(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 8
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 55
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar69::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var69(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 8
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 87
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar70::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var70(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar71::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var71(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar72::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var72(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar73::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var73(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 112
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar74::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var74(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 13
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 144
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar75::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var75(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 15
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 146
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar76::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var76(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar77::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var77(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar78::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var78(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar79::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var79(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 112
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar80::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var80(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar81::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var81(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar82::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var82(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar83::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var83(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 17
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar84::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var84(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 49
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar85::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var85(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 81
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar86::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var86(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 18
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar87::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var87(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 18
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar88::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var88(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 18
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar89::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var89(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 19
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar90::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var90(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 21
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar91::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var91(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 21
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar92::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var92(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 22
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar93::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var93(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 22
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar94::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var94(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 144
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar95::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var95(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 21
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar96::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var96(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 53
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar97::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var97(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 149
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar98::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var98(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 22
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar99::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var99(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 54
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar100::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var100(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 86
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar101::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var101(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 26
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar102::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var102(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 58
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar103::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var103(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 90
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar104::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var104(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 154
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar105::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var105(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 186
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar106::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var106(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 30
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar107::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var107(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 62
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar108::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var108(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 24
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 23
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar109::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var109(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 24
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 55
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar110::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var110(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 24
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 87
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar111::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var111(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 29
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar112::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var112(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 29
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar113::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var113(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 29
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 80
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar114::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var114(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 29
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 112
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar115::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var115(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 29
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 144
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar116::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var116(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 31
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 255) == 146
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar117::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var117(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 15
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                mrs_instructionVar118::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var118(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 255) == 79
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                mrs_instructionVar119::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var119(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 17
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar120::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var120(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 18
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar121::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var121(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 64
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 20
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar122::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var122(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar123::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var123(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 17
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar124::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var124(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 2
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar125::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var125(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 21
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar126::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var126(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 7
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 26
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar127::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var127(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 17
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar128::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var128(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 18
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar129::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var129(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 80
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 20
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar130::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var130(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar131::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var131(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 17
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 17
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar132::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var132(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 18
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar133::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var133(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 21
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar134::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var134(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 23
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 31) == 26
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar135::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var135(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar136::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var136(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 255) == 16
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar137::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var137(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 2
            && (tokens_param[1] & 63) == 15
        {
            if let Some((inst_len, parsed)) =
                adr_instructionVar138::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var138(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar139::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var139(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar140::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var140(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar141::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var141(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar142::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var142(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar143::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var143(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar144::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var144(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar145::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var145(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar146::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var146(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar147::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var147(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar148::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var148(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar149::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var149(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar150::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var150(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                swp_instructionVar151::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var151(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 1
            && (tokens_param[1] & 240) == 64
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                swpb_instructionVar152::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var152(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 32
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                mla_instructionVar153::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var153(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar154::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var154(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar155::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var155(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 160
        {
            if let Some((inst_len, parsed)) =
                mov_instructionVar156::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var156(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar157::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var157(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar158::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var158(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 239) == 224
        {
            if let Some((inst_len, parsed)) =
                mvn_instructionVar159::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var159(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar160::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var160(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar161::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var161(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar162::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var162(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar163::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var163(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar164::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var164(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar165::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var165(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar166::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var166(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar167::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var167(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar168::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var168(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar169::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var169(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar170::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var170(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar171::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var171(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 224
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                smlal_instructionVar172::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var172(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 192
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                smull_instructionVar173::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var173(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar174::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var174(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar175::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var175(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar176::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var176(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 160
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                umlal_instructionVar177::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var177(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 0
            && (tokens_param[1] & 224) == 128
            && (tokens_param[3] & 240) == 144
        {
            if let Some((inst_len, parsed)) =
                umull_instructionVar178::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var178(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar179::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var179(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar180::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var180(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 160
        {
            if let Some((inst_len, parsed)) =
                adc_instructionVar181::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var181(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar182::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var182(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar183::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var183(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar184::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var184(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar185::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var185(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar186::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var186(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar187::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var187(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16777216 == 16777216
            && (tokens_param[0] & 255) == 235
            && (tokens_param[1] & 255) == 255
            && (tokens_param[2] & 255) == 255
            && (tokens_param[3] & 255) == 255
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar188::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var188(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16777216 == 16777216
            && (tokens_param[0] & 255) == 234
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar189::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var189(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16777216 == 16777216
            && (tokens_param[0] & 255) == 235
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar190::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var190(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16777220 == 16777216
            && (tokens_param[0] & 15) == 11
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar191::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var191(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16777220 == 16777220
            && (tokens_param[0] & 15) == 11
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar192::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var192(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 31) == 15
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar193::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var193(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 31) == 31
            && (tokens_param[2] & 15) == 15
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar194::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var194(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 16) == 0
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mcr_instructionVar195::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var195(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[1] & 16) == 16
            && (tokens_param[3] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                mrc_instructionVar196::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var196(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 14
            && (tokens_param[3] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                cdp_instructionVar197::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var197(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165825 == 25165825
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 16
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar198::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var198(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165825 == 25165825
            && (tokens_param[0] & 13) == 5
            && (tokens_param[1] & 80) == 16
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar199::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var199(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 16
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar200::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var200(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 5
            && (tokens_param[1] & 80) == 16
            && (tokens_param[2] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar201::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var201(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 112
        {
            if let Some((inst_len, parsed)) =
                ldrbt_instructionVar202::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var202(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 48
        {
            if let Some((inst_len, parsed)) =
                ldrt_instructionVar203::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var203(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 96
        {
            if let Some((inst_len, parsed)) =
                strbt_instructionVar204::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var204(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 4
            && (tokens_param[1] & 112) == 32
        {
            if let Some((inst_len, parsed)) =
                strt_instructionVar205::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var205(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 15) == 15
        {
            if let Some((inst_len, parsed)) =
                swi_instructionVar206::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var206(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16777216 == 16777216
            && (tokens_param[0] & 15) == 10
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar207::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var207(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar208::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var208(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar209::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var209(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                bic_instructionVar210::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var210(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar211::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var211(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar212::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var212(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                eor_instructionVar213::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var213(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 12
            && (tokens_param[1] & 80) == 16
        {
            if let Some((inst_len, parsed)) =
                ldc_instructionVar214::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var214(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 12
            && (tokens_param[1] & 80) == 80
        {
            if let Some((inst_len, parsed)) =
                ldcl_instructionVar215::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var215(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 8
            && (tokens_param[1] & 16) == 16
            && (tokens_param[2] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                ldm_instructionVar216::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var216(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 8
            && (tokens_param[1] & 16) == 16
            && (tokens_param[2] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                ldm_instructionVar217::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var217(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 12) == 4
            && (tokens_param[1] & 80) == 16
        {
            if let Some((inst_len, parsed)) =
                ldr_instructionVar218::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var218(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 12) == 4
            && (tokens_param[1] & 80) == 80
        {
            if let Some((inst_len, parsed)) =
                ldrb_instructionVar219::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var219(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 0
            && (tokens_param[1] & 16) == 16
            && (tokens_param[3] & 240) == 176
        {
            if let Some((inst_len, parsed)) =
                ldrh_instructionVar220::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var220(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 0
            && (tokens_param[1] & 16) == 16
            && (tokens_param[3] & 240) == 208
        {
            if let Some((inst_len, parsed)) =
                ldrsb_instructionVar221::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var221(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 0
            && (tokens_param[1] & 16) == 16
            && (tokens_param[3] & 240) == 240
        {
            if let Some((inst_len, parsed)) =
                ldrsh_instructionVar222::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var222(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar223::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var223(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar224::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var224(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 1
            && (tokens_param[1] & 224) == 128
        {
            if let Some((inst_len, parsed)) =
                orr_instructionVar225::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var225(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar226::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var226(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar227::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var227(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 96
        {
            if let Some((inst_len, parsed)) =
                rsb_instructionVar228::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var228(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar229::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var229(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar230::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var230(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 224
        {
            if let Some((inst_len, parsed)) =
                rsc_instructionVar231::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var231(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar232::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var232(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar233::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var233(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 192
        {
            if let Some((inst_len, parsed)) =
                sbc_instructionVar234::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var234(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 12
            && (tokens_param[1] & 80) == 0
        {
            if let Some((inst_len, parsed)) =
                stc_instructionVar235::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var235(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 12
            && (tokens_param[1] & 80) == 64
        {
            if let Some((inst_len, parsed)) =
                stcl_instructionVar236::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var236(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 12) == 4
            && (tokens_param[1] & 80) == 0
        {
            if let Some((inst_len, parsed)) =
                str_instructionVar237::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var237(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 12) == 4
            && (tokens_param[1] & 80) == 64
        {
            if let Some((inst_len, parsed)) =
                strb_instructionVar238::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var238(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 0
            && (tokens_param[1] & 16) == 0
            && (tokens_param[3] & 240) == 176
        {
            if let Some((inst_len, parsed)) =
                strh_instructionVar239::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var239(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 14) == 8
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                stm_instructionVar240::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var240(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar241::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var241(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar242::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var242(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 25165824 == 25165824
            && (tokens_param[0] & 13) == 0
            && (tokens_param[1] & 224) == 64
        {
            if let Some((inst_len, parsed)) =
                sub_instructionVar243::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var243(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 16777216 == 0 {
            if let Some((inst_len, parsed)) =
                instructionVar244::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var244(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 16777216 == 0 {
            if let Some((inst_len, parsed)) =
                instructionVar245::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var245(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:626:1, end:626:3))"]
#[derive(Clone, Debug)]
struct rnVar0 {}
impl rnVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:627:1, end:627:3))"]
#[derive(Clone, Debug)]
struct rnVar1 {
    Rn: u8,
}
impl rnVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.Rn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rn = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rn }))
    }
}
#[derive(Clone, Debug)]
enum Tablern {
    Var0(rnVar0),
    Var1(rnVar1),
}
impl Tablern {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                rnVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                rnVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:629:1, end:629:3))"]
#[derive(Clone, Debug)]
struct rmVar0 {}
impl rmVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:630:1, end:630:3))"]
#[derive(Clone, Debug)]
struct rmVar1 {
    Rm: u8,
}
impl rmVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.Rm)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rm = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rm }))
    }
}
#[derive(Clone, Debug)]
enum Tablerm {
    Var0(rmVar0),
    Var1(rmVar1),
}
impl Tablerm {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                rmVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                rmVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:632:1, end:632:3))"]
#[derive(Clone, Debug)]
struct rsVar0 {}
impl rsVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:633:1, end:633:3))"]
#[derive(Clone, Debug)]
struct rsVar1 {
    Rs: u8,
}
impl rsVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.Rs)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let Rs = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Rs }))
    }
}
#[derive(Clone, Debug)]
enum Tablers {
    Var0(rsVar0),
    Var1(rsVar1),
}
impl Tablers {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                rsVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                rsVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:635:1, end:635:3))"]
#[derive(Clone, Debug)]
struct ccVar0 {}
impl ccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:636:1, end:636:3))"]
#[derive(Clone, Debug)]
struct ccVar1 {}
impl ccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:637:1, end:637:3))"]
#[derive(Clone, Debug)]
struct ccVar2 {}
impl ccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:638:1, end:638:3))"]
#[derive(Clone, Debug)]
struct ccVar3 {}
impl ccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:639:1, end:639:3))"]
#[derive(Clone, Debug)]
struct ccVar4 {}
impl ccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("mi")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:640:1, end:640:3))"]
#[derive(Clone, Debug)]
struct ccVar5 {}
impl ccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("pl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:641:1, end:641:3))"]
#[derive(Clone, Debug)]
struct ccVar6 {}
impl ccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:642:1, end:642:3))"]
#[derive(Clone, Debug)]
struct ccVar7 {}
impl ccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:643:1, end:643:3))"]
#[derive(Clone, Debug)]
struct ccVar8 {}
impl ccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("hi")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:644:1, end:644:3))"]
#[derive(Clone, Debug)]
struct ccVar9 {}
impl ccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ls")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:645:1, end:645:3))"]
#[derive(Clone, Debug)]
struct ccVar10 {}
impl ccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:646:1, end:646:3))"]
#[derive(Clone, Debug)]
struct ccVar11 {}
impl ccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:647:1, end:647:3))"]
#[derive(Clone, Debug)]
struct ccVar12 {}
impl ccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:648:1, end:648:3))"]
#[derive(Clone, Debug)]
struct ccVar13 {}
impl ccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablecc {
    Var0(ccVar0),
    Var1(ccVar1),
    Var2(ccVar2),
    Var3(ccVar3),
    Var4(ccVar4),
    Var5(ccVar5),
    Var6(ccVar6),
    Var7(ccVar7),
    Var8(ccVar8),
    Var9(ccVar9),
    Var10(ccVar10),
    Var11(ccVar11),
    Var12(ccVar12),
    Var13(ccVar13),
}
impl Tablecc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                ccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                ccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 32 {
            if let Some((inst_len, parsed)) =
                ccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 48 {
            if let Some((inst_len, parsed)) =
                ccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 64 {
            if let Some((inst_len, parsed)) =
                ccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 80 {
            if let Some((inst_len, parsed)) =
                ccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 96 {
            if let Some((inst_len, parsed)) =
                ccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 112 {
            if let Some((inst_len, parsed)) =
                ccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 128 {
            if let Some((inst_len, parsed)) =
                ccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 144 {
            if let Some((inst_len, parsed)) =
                ccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 160 {
            if let Some((inst_len, parsed)) =
                ccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 176 {
            if let Some((inst_len, parsed)) =
                ccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 192 {
            if let Some((inst_len, parsed)) =
                ccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 208 {
            if let Some((inst_len, parsed)) =
                ccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:651:1, end:651:5))"]
#[derive(Clone, Debug)]
struct CONDVar0 {}
impl CONDVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:650:1, end:650:5))"]
#[derive(Clone, Debug)]
struct CONDVar1 {
    cc: Tablecc,
}
impl CONDVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc }))
    }
}
#[derive(Clone, Debug)]
enum TableCOND {
    Var0(CONDVar0),
    Var1(CONDVar1),
}
impl TableCOND {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 240) == 224 {
            if let Some((inst_len, parsed)) =
                CONDVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                CONDVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:659:1, end:659:10))"]
#[derive(Clone, Debug)]
struct SBIT_CZNOVar0 {}
impl SBIT_CZNOVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:660:1, end:660:10))"]
#[derive(Clone, Debug)]
struct SBIT_CZNOVar1 {}
impl SBIT_CZNOVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSBIT_CZNO {
    Var0(SBIT_CZNOVar0),
    Var1(SBIT_CZNOVar1),
}
impl TableSBIT_CZNO {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                SBIT_CZNOVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                SBIT_CZNOVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:661:1, end:661:8))"]
#[derive(Clone, Debug)]
struct SBIT_ZNVar0 {}
impl SBIT_ZNVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:662:1, end:662:8))"]
#[derive(Clone, Debug)]
struct SBIT_ZNVar1 {}
impl SBIT_ZNVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSBIT_ZN {
    Var0(SBIT_ZNVar0),
    Var1(SBIT_ZNVar1),
}
impl TableSBIT_ZN {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                SBIT_ZNVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                SBIT_ZNVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:664:1, end:664:7))"]
#[derive(Clone, Debug)]
struct Addr24Var0 {
    addr24: u32,
}
impl Addr24Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_next)
            .unwrap()
            .wrapping_add(4i128)
            .wrapping_add(
                4i128.wrapping_mul(
                    i128::try_from(
                        (if self.addr24 & 8388608 != 0 {
                            -1 & !8388607
                        } else {
                            0
                        } | self.addr24 as i32),
                    )
                    .unwrap(),
                ),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        let addr24 = token_23(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr24 }))
    }
}
#[derive(Clone, Debug)]
enum TableAddr24 {
    Var0(Addr24Var0),
}
impl TableAddr24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                Addr24Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:690:1, end:690:7))"]
#[derive(Clone, Debug)]
struct shift1Var0 {
    immed: u8,
    rotate: u8,
}
impl shift1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_value: i128 = 0;
        calc_value = ((u32::try_from(
            32i128.wrapping_sub(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128)),
        )
        .ok()
        .and_then(|shl| i128::try_from(self.immed).unwrap().checked_shl(shl))
        .unwrap_or(0)
            | u32::try_from(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128))
                .ok()
                .and_then(|shr| i128::try_from(self.immed).unwrap().checked_shr(shr))
                .unwrap_or(0))
            & 4294967295i128);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            <DisplayElement>::Number(true, calc_value.is_negative(), calc_value.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_value: i128 = 0;
        let mut block_0_len = 4;
        calc_value = ((u32::try_from(
            32i128.wrapping_sub(
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .wrapping_mul(2i128),
            ),
        )
        .ok()
        .and_then(|shl| {
            i128::try_from(token_25(tokens_current))
                .unwrap()
                .checked_shl(shl)
        })
        .unwrap_or(0)
            | u32::try_from(
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .wrapping_mul(2i128),
            )
            .ok()
            .and_then(|shr| {
                i128::try_from(token_25(tokens_current))
                    .unwrap()
                    .checked_shr(shr)
            })
            .unwrap_or(0))
            & 4294967295i128);
        let immed = token_25(tokens_current);
        let rotate = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift1 {
    Var0(shift1Var0),
}
impl Tableshift1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                shift1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:803:1, end:803:12))"]
#[derive(Clone, Debug)]
struct mcrOperandsVar0 {
    cpn: u8,
    opc1: u8,
    Rd: u8,
    CRn: u8,
    CRm: u8,
    opc2: u8,
}
impl mcrOperandsVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 11usize] = [
            meaning_4_display(self.cpn),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc1 as u64),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.Rd),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRn),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.CRm),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.opc2 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRn = token_10(tokens_current);
        let cpn = token_14(tokens_current);
        let Rd = token_13(tokens_current);
        let CRm = token_11(tokens_current);
        let opc1 = token_16(tokens_current);
        let opc2 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                cpn,
                opc1,
                Rd,
                CRn,
                CRm,
                opc2,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TablemcrOperands {
    Var0(mcrOperandsVar0),
}
impl TablemcrOperands {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                mcrOperandsVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:809:1, end:809:7))"]
#[derive(Clone, Debug)]
struct shift2Var0 {
    rm: Tablerm,
}
impl shift2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:819:1, end:819:7))"]
#[derive(Clone, Debug)]
struct shift2Var1 {
    rm: Tablerm,
}
impl shift2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("lsr #32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:829:1, end:829:7))"]
#[derive(Clone, Debug)]
struct shift2Var2 {
    rm: Tablerm,
}
impl shift2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("asr #32"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:839:1, end:839:7))"]
#[derive(Clone, Debug)]
struct shift2Var3 {
    rm: Tablerm,
}
impl shift2Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("rrx"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:814:1, end:814:7))"]
#[derive(Clone, Debug)]
struct shift2Var4 {
    sftimm: u8,
    rm: Tablerm,
}
impl shift2Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("lsl #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:824:1, end:824:7))"]
#[derive(Clone, Debug)]
struct shift2Var5 {
    sftimm: u8,
    rm: Tablerm,
}
impl shift2Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("lsr #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:834:1, end:834:7))"]
#[derive(Clone, Debug)]
struct shift2Var6 {
    sftimm: u8,
    rm: Tablerm,
}
impl shift2Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("asr #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:844:1, end:844:7))"]
#[derive(Clone, Debug)]
struct shift2Var7 {
    sftimm: u8,
    rm: Tablerm,
}
impl shift2Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("ror #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift2 {
    Var0(shift2Var0),
    Var1(shift2Var1),
    Var2(shift2Var2),
    Var3(shift2Var3),
    Var4(shift2Var4),
    Var5(shift2Var5),
    Var6(shift2Var6),
    Var7(shift2Var7),
}
impl Tableshift2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && (tokens_param[0] & 2) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                shift2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 2) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 32
        {
            if let Some((inst_len, parsed)) =
                shift2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 2) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 64
        {
            if let Some((inst_len, parsed)) =
                shift2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 2) == 0
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 240) == 96
        {
            if let Some((inst_len, parsed)) =
                shift2Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 112) == 0 {
            if let Some((inst_len, parsed)) =
                shift2Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 112) == 32 {
            if let Some((inst_len, parsed)) =
                shift2Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 112) == 64 {
            if let Some((inst_len, parsed)) =
                shift2Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 112) == 96 {
            if let Some((inst_len, parsed)) =
                shift2Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:853:1, end:853:7))"]
#[derive(Clone, Debug)]
struct shift3Var0 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("lsl "),
        ];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:858:1, end:858:7))"]
#[derive(Clone, Debug)]
struct shift3Var1 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("lsr "),
        ];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:863:1, end:863:7))"]
#[derive(Clone, Debug)]
struct shift3Var2 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("asr "),
        ];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:868:1, end:868:7))"]
#[derive(Clone, Debug)]
struct shift3Var3 {
    rs: Tablers,
    rm: Tablerm,
}
impl shift3Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("ror "),
        ];
        display.extend_from_slice(&extend);
        self.rs
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rs = if let Some((len, table)) =
            Tablers::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rs, rm }))
    }
}
#[derive(Clone, Debug)]
enum Tableshift3 {
    Var0(shift3Var0),
    Var1(shift3Var1),
    Var2(shift3Var2),
    Var3(shift3Var3),
}
impl Tableshift3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                shift3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 240) == 48 {
            if let Some((inst_len, parsed)) =
                shift3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 240) == 80 {
            if let Some((inst_len, parsed)) =
                shift3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 && (tokens_param[3] & 240) == 112 {
            if let Some((inst_len, parsed)) =
                shift3Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:940:1, end:940:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar0 {
    rm: Tablerm,
}
impl addr2shiftVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:943:1, end:943:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar1 {
    rm: Tablerm,
}
impl addr2shiftVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",lsr #32")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:945:1, end:945:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar2 {
    rm: Tablerm,
}
impl addr2shiftVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",asr #32")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:947:1, end:947:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar3 {
    rm: Tablerm,
}
impl addr2shiftVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",rrx")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:941:1, end:941:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar4 {
    sftimm: u8,
    rm: Tablerm,
}
impl addr2shiftVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",lsl #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:942:1, end:942:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar5 {
    sftimm: u8,
    rm: Tablerm,
}
impl addr2shiftVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",lsr #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:944:1, end:944:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar6 {
    sftimm: u8,
    rm: Tablerm,
}
impl addr2shiftVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",asr #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:946:1, end:946:11))"]
#[derive(Clone, Debug)]
struct addr2shiftVar7 {
    sftimm: u8,
    rm: Tablerm,
}
impl addr2shiftVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",ror #"),
            DisplayElement::Number(true, false, self.sftimm as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let sftimm = token_20(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, sftimm }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddr2shift {
    Var0(addr2shiftVar0),
    Var1(addr2shiftVar1),
    Var2(addr2shiftVar2),
    Var3(addr2shiftVar3),
    Var4(addr2shiftVar4),
    Var5(addr2shiftVar5),
    Var6(addr2shiftVar6),
    Var7(addr2shiftVar7),
}
impl Tableaddr2shift {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 0 && (tokens_param[3] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 0 && (tokens_param[3] & 240) == 32 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 0 && (tokens_param[3] & 240) == 64 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 0 && (tokens_param[3] & 240) == 96 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 112) == 0 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 112) == 32 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 112) == 64 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 112) == 96 {
            if let Some((inst_len, parsed)) =
                addr2shiftVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:951:1, end:951:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var0 {
    offset_12: u16,
}
impl addrmode2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(i128::try_from(self.offset_12).unwrap());
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Number(true, calc_reloff.is_negative(), calc_reloff.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(i128::try_from(token_24(tokens_current)).unwrap());
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:957:1, end:957:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var1 {
    offset_12: u16,
}
impl addrmode2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128.wrapping_sub(i128::try_from(self.offset_12).unwrap()));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Number(true, calc_reloff.is_negative(), calc_reloff.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128.wrapping_sub(i128::try_from(token_24(tokens_current)).unwrap()));
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:963:1, end:963:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var2 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            DisplayElement::Number(true, false, self.offset_12 as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:964:1, end:964:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var3 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff: i128 = 0;
        calc_noff = (-i128::try_from(self.offset_12).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff.is_negative(), calc_noff.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4;
        calc_noff = (-i128::try_from(token_24(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:965:1, end:965:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var4 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:966:1, end:966:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var5 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",-")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:968:1, end:968:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var6 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            DisplayElement::Number(true, false, self.offset_12 as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:969:1, end:969:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var7 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff: i128 = 0;
        calc_noff = (-i128::try_from(self.offset_12).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff.is_negative(), calc_noff.abs() as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4;
        calc_noff = (-i128::try_from(token_24(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:970:1, end:970:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var8 {
    addr2shift: Tableaddr2shift,
    rn: Tablern,
}
impl addrmode2Var8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr2shift, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:971:1, end:971:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var9 {
    addr2shift: Tableaddr2shift,
    rn: Tablern,
}
impl addrmode2Var9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",-")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr2shift, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:973:1, end:973:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var10 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            DisplayElement::Number(true, false, self.offset_12 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:974:1, end:974:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var11 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff: i128 = 0;
        calc_noff = (-i128::try_from(self.offset_12).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_noff.is_negative(), calc_noff.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4;
        calc_noff = (-i128::try_from(token_24(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:975:1, end:975:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var12 {
    addr2shift: Tableaddr2shift,
    rn: Tablern,
}
impl addrmode2Var12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr2shift, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:976:1, end:976:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var13 {
    addr2shift: Tableaddr2shift,
    rn: Tablern,
}
impl addrmode2Var13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],-")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr2shift, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:978:1, end:978:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var14 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            DisplayElement::Number(true, false, self.offset_12 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:979:1, end:979:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var15 {
    offset_12: u16,
    rn: Tablern,
}
impl addrmode2Var15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff: i128 = 0;
        calc_noff = (-i128::try_from(self.offset_12).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_noff.is_negative(), calc_noff.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff: i128 = 0;
        let mut block_0_len = 4;
        calc_noff = (-i128::try_from(token_24(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let offset_12 = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, offset_12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:980:1, end:980:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var16 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:981:1, end:981:10))"]
#[derive(Clone, Debug)]
struct addrmode2Var17 {
    rn: Tablern,
    addr2shift: Tableaddr2shift,
}
impl addrmode2Var17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],-")];
        display.extend_from_slice(&extend);
        self.addr2shift
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr2shift = if let Some((len, table)) =
            Tableaddr2shift::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, addr2shift }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode2 {
    Var0(addrmode2Var0),
    Var1(addrmode2Var1),
    Var2(addrmode2Var2),
    Var3(addrmode2Var3),
    Var4(addrmode2Var4),
    Var5(addrmode2Var5),
    Var6(addrmode2Var6),
    Var7(addrmode2Var7),
    Var8(addrmode2Var8),
    Var9(addrmode2Var9),
    Var10(addrmode2Var10),
    Var11(addrmode2Var11),
    Var12(addrmode2Var12),
    Var13(addrmode2Var13),
    Var14(addrmode2Var14),
    Var15(addrmode2Var15),
    Var16(addrmode2Var16),
    Var17(addrmode2Var17),
}
impl Tableaddrmode2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 175) == 143 {
            if let Some((inst_len, parsed)) =
                addrmode2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 175) == 15 {
            if let Some((inst_len, parsed)) =
                addrmode2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 160) == 0 {
            if let Some((inst_len, parsed)) =
                addrmode2Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 3 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode2Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 3 && (tokens_param[1] & 160) == 0 {
            if let Some((inst_len, parsed)) =
                addrmode2Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode2Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 1 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode2Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 3 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode2Var8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 3 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode2Var9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 0 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode2Var10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 0 && (tokens_param[1] & 160) == 0 {
            if let Some((inst_len, parsed)) =
                addrmode2Var11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 2 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode2Var12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 2 && (tokens_param[1] & 160) == 0 {
            if let Some((inst_len, parsed)) =
                addrmode2Var13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 0 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode2Var14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 0 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode2Var15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 2 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode2Var16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 3) == 2 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode2Var17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:990:1, end:990:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var0 {
    immedH: u8,
    immedL: u8,
}
impl addrmode3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                (u32::try_from(4i128)
                    .ok()
                    .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
                    .unwrap_or(0)
                    | i128::try_from(self.immedL).unwrap()),
            );
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Number(true, calc_reloff.is_negative(), calc_reloff.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                (u32::try_from(4i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | i128::try_from(token_11(tokens_current)).unwrap()),
            );
        let immedH = token_14(tokens_current);
        let immedL = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:996:1, end:996:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var1 {
    immedH: u8,
    immedL: u8,
}
impl addrmode3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                (u32::try_from(4i128)
                    .ok()
                    .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
                    .unwrap_or(0)
                    | i128::try_from(self.immedL).unwrap()),
            ),
        );
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            <DisplayElement>::Number(true, calc_reloff.is_negative(), calc_reloff.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                (u32::try_from(4i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | i128::try_from(token_11(tokens_current)).unwrap()),
            ),
        );
        let immedH = token_14(tokens_current);
        let immedL = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1014:1, end:1014:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var2 {
    rm: Tablerm,
    rn: Tablern,
}
impl addrmode3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1019:1, end:1019:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var3 {
    rm: Tablerm,
    rn: Tablern,
}
impl addrmode3Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",-")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1036:1, end:1036:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var4 {
    rm: Tablerm,
    rn: Tablern,
}
impl addrmode3Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1041:1, end:1041:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var5 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",-")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]!")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1002:1, end:1002:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var6 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedL = token_11(tokens_current);
        let immedH = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1008:1, end:1008:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var7 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap()));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedL = token_11(tokens_current);
        let immedH = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1024:1, end:1024:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var8 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedL = token_11(tokens_current);
        let immedH = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1030:1, end:1030:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var9 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap()));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedH = token_14(tokens_current);
        let immedL = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1058:1, end:1058:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var10 {
    rn: Tablern,
    rm: Tablerm,
}
impl addrmode3Var10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, rm }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1063:1, end:1063:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var11 {
    rm: Tablerm,
    rn: Tablern,
}
impl addrmode3Var11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],-")];
        display.extend_from_slice(&extend);
        self.rm
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rm = if let Some((len, table)) =
            Tablerm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rm, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1046:1, end:1046:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var12 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = (u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap());
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedH = token_14(tokens_current);
        let immedL = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1052:1, end:1052:10))"]
#[derive(Clone, Debug)]
struct addrmode3Var13 {
    immedH: u8,
    immedL: u8,
    rn: Tablern,
}
impl addrmode3Var13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| i128::try_from(self.immedH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.immedL).unwrap()));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-(u32::try_from(4i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_14(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_11(tokens_current)).unwrap()));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immedH = token_14(tokens_current);
        let immedL = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immedH, immedL }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode3 {
    Var0(addrmode3Var0),
    Var1(addrmode3Var1),
    Var2(addrmode3Var2),
    Var3(addrmode3Var3),
    Var4(addrmode3Var4),
    Var5(addrmode3Var5),
    Var6(addrmode3Var6),
    Var7(addrmode3Var7),
    Var8(addrmode3Var8),
    Var9(addrmode3Var9),
    Var10(addrmode3Var10),
    Var11(addrmode3Var11),
    Var12(addrmode3Var12),
    Var13(addrmode3Var13),
}
impl Tableaddrmode3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 239) == 207 {
            if let Some((inst_len, parsed)) =
                addrmode3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 239) == 79 {
            if let Some((inst_len, parsed)) =
                addrmode3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 224) == 128
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 224) == 0
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 224) == 160
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 1
            && (tokens_param[1] & 224) == 32
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 224) == 192 {
            if let Some((inst_len, parsed)) =
                addrmode3Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 224) == 64 {
            if let Some((inst_len, parsed)) =
                addrmode3Var7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 224) == 224 {
            if let Some((inst_len, parsed)) =
                addrmode3Var8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 224) == 96 {
            if let Some((inst_len, parsed)) =
                addrmode3Var9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 0
            && (tokens_param[1] & 192) == 128
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 1) == 0
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                addrmode3Var11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                addrmode3Var12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                addrmode3Var13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1074:1, end:1074:7))"]
#[derive(Clone, Debug)]
struct linc15Var0 {}
impl linc15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1075:1, end:1075:7))"]
#[derive(Clone, Debug)]
struct linc15Var1 {}
impl linc15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc15 {
    Var0(linc15Var0),
    Var1(linc15Var1),
}
impl Tablelinc15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                linc15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                linc15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1077:1, end:1077:7))"]
#[derive(Clone, Debug)]
struct linc14Var0 {}
impl linc14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1076:1, end:1076:7))"]
#[derive(Clone, Debug)]
struct linc14Var1 {
    linc15: Tablelinc15,
}
impl linc14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc15
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc15 = if let Some((len, table)) =
            Tablelinc15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1078:1, end:1078:7))"]
#[derive(Clone, Debug)]
struct linc14Var2 {
    linc15: Tablelinc15,
}
impl linc14Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc15 = if let Some((len, table)) =
            Tablelinc15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc14 {
    Var0(linc14Var0),
    Var1(linc14Var1),
    Var2(linc14Var2),
}
impl Tablelinc14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                linc14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                linc14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                linc14Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1080:1, end:1080:7))"]
#[derive(Clone, Debug)]
struct linc13Var0 {}
impl linc13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1079:1, end:1079:7))"]
#[derive(Clone, Debug)]
struct linc13Var1 {
    linc14: Tablelinc14,
}
impl linc13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc14 = if let Some((len, table)) =
            Tablelinc14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1081:1, end:1081:7))"]
#[derive(Clone, Debug)]
struct linc13Var2 {
    linc14: Tablelinc14,
}
impl linc13Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc14 = if let Some((len, table)) =
            Tablelinc14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc13 {
    Var0(linc13Var0),
    Var1(linc13Var1),
    Var2(linc13Var2),
}
impl Tablelinc13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 7) == 4 {
            if let Some((inst_len, parsed)) =
                linc13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                linc13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                linc13Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1083:1, end:1083:7))"]
#[derive(Clone, Debug)]
struct linc12Var0 {}
impl linc12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1082:1, end:1082:7))"]
#[derive(Clone, Debug)]
struct linc12Var1 {
    linc13: Tablelinc13,
}
impl linc12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc13
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc13 = if let Some((len, table)) =
            Tablelinc13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1084:1, end:1084:7))"]
#[derive(Clone, Debug)]
struct linc12Var2 {
    linc13: Tablelinc13,
}
impl linc12Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc13 = if let Some((len, table)) =
            Tablelinc13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc12 {
    Var0(linc12Var0),
    Var1(linc12Var1),
    Var2(linc12Var2),
}
impl Tablelinc12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                linc12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                linc12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                linc12Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1086:1, end:1086:7))"]
#[derive(Clone, Debug)]
struct linc11Var0 {}
impl linc11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1085:1, end:1085:7))"]
#[derive(Clone, Debug)]
struct linc11Var1 {
    linc12: Tablelinc12,
}
impl linc11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc12 = if let Some((len, table)) =
            Tablelinc12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1087:1, end:1087:7))"]
#[derive(Clone, Debug)]
struct linc11Var2 {
    linc12: Tablelinc12,
}
impl linc11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc12 = if let Some((len, table)) =
            Tablelinc12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc11 {
    Var0(linc11Var0),
    Var1(linc11Var1),
    Var2(linc11Var2),
}
impl Tablelinc11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 16 {
            if let Some((inst_len, parsed)) =
                linc11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                linc11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                linc11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1089:1, end:1089:7))"]
#[derive(Clone, Debug)]
struct linc10Var0 {}
impl linc10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1088:1, end:1088:7))"]
#[derive(Clone, Debug)]
struct linc10Var1 {
    linc11: Tablelinc11,
}
impl linc10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc11 = if let Some((len, table)) =
            Tablelinc11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1090:1, end:1090:7))"]
#[derive(Clone, Debug)]
struct linc10Var2 {
    linc11: Tablelinc11,
}
impl linc10Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc11 = if let Some((len, table)) =
            Tablelinc11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc10 {
    Var0(linc10Var0),
    Var1(linc10Var1),
    Var2(linc10Var2),
}
impl Tablelinc10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 63) == 32 {
            if let Some((inst_len, parsed)) =
                linc10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                linc10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                linc10Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1092:1, end:1092:6))"]
#[derive(Clone, Debug)]
struct linc9Var0 {}
impl linc9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1091:1, end:1091:6))"]
#[derive(Clone, Debug)]
struct linc9Var1 {
    linc10: Tablelinc10,
}
impl linc9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc10
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc10 = if let Some((len, table)) =
            Tablelinc10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1093:1, end:1093:6))"]
#[derive(Clone, Debug)]
struct linc9Var2 {
    linc10: Tablelinc10,
}
impl linc9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc10 = if let Some((len, table)) =
            Tablelinc10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc9 {
    Var0(linc9Var0),
    Var1(linc9Var1),
    Var2(linc9Var2),
}
impl Tablelinc9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 127) == 64 {
            if let Some((inst_len, parsed)) =
                linc9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                linc9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                linc9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1095:1, end:1095:6))"]
#[derive(Clone, Debug)]
struct linc8Var0 {}
impl linc8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1094:1, end:1094:6))"]
#[derive(Clone, Debug)]
struct linc8Var1 {
    linc9: Tablelinc9,
}
impl linc8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc9 = if let Some((len, table)) =
            Tablelinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1096:1, end:1096:6))"]
#[derive(Clone, Debug)]
struct linc8Var2 {
    linc9: Tablelinc9,
}
impl linc8Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc9 = if let Some((len, table)) =
            Tablelinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc8 {
    Var0(linc8Var0),
    Var1(linc8Var1),
    Var2(linc8Var2),
}
impl Tablelinc8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 255) == 128 {
            if let Some((inst_len, parsed)) =
                linc8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                linc8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                linc8Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1098:1, end:1098:6))"]
#[derive(Clone, Debug)]
struct linc7Var0 {}
impl linc7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1097:1, end:1097:6))"]
#[derive(Clone, Debug)]
struct linc7Var1 {
    linc8: Tablelinc8,
}
impl linc7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc8 = if let Some((len, table)) =
            Tablelinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1099:1, end:1099:6))"]
#[derive(Clone, Debug)]
struct linc7Var2 {
    linc8: Tablelinc8,
}
impl linc7Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc8 = if let Some((len, table)) =
            Tablelinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc7 {
    Var0(linc7Var0),
    Var1(linc7Var1),
    Var2(linc7Var2),
}
impl Tablelinc7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                linc7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                linc7Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1101:1, end:1101:6))"]
#[derive(Clone, Debug)]
struct linc6Var0 {}
impl linc6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1100:1, end:1100:6))"]
#[derive(Clone, Debug)]
struct linc6Var1 {
    linc7: Tablelinc7,
}
impl linc6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r9),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc7 = if let Some((len, table)) =
            Tablelinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1102:1, end:1102:6))"]
#[derive(Clone, Debug)]
struct linc6Var2 {
    linc7: Tablelinc7,
}
impl linc6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc7 = if let Some((len, table)) =
            Tablelinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc6 {
    Var0(linc6Var0),
    Var1(linc6Var1),
    Var2(linc6Var2),
}
impl Tablelinc6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 2 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                linc6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                linc6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1104:1, end:1104:6))"]
#[derive(Clone, Debug)]
struct linc5Var0 {}
impl linc5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1103:1, end:1103:6))"]
#[derive(Clone, Debug)]
struct linc5Var1 {
    linc6: Tablelinc6,
}
impl linc5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r10),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc6 = if let Some((len, table)) =
            Tablelinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1105:1, end:1105:6))"]
#[derive(Clone, Debug)]
struct linc5Var2 {
    linc6: Tablelinc6,
}
impl linc5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc6 = if let Some((len, table)) =
            Tablelinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc5 {
    Var0(linc5Var0),
    Var1(linc5Var1),
    Var2(linc5Var2),
}
impl Tablelinc5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 7) == 4 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                linc5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                linc5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1107:1, end:1107:6))"]
#[derive(Clone, Debug)]
struct linc4Var0 {}
impl linc4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1106:1, end:1106:6))"]
#[derive(Clone, Debug)]
struct linc4Var1 {
    linc5: Tablelinc5,
}
impl linc4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r11),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc5 = if let Some((len, table)) =
            Tablelinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1108:1, end:1108:6))"]
#[derive(Clone, Debug)]
struct linc4Var2 {
    linc5: Tablelinc5,
}
impl linc4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc5 = if let Some((len, table)) =
            Tablelinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc4 {
    Var0(linc4Var0),
    Var1(linc4Var1),
    Var2(linc4Var2),
}
impl Tablelinc4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 8 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                linc4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                linc4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1110:1, end:1110:6))"]
#[derive(Clone, Debug)]
struct linc3Var0 {}
impl linc3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1109:1, end:1109:6))"]
#[derive(Clone, Debug)]
struct linc3Var1 {
    linc4: Tablelinc4,
}
impl linc3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r12),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc4 = if let Some((len, table)) =
            Tablelinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1111:1, end:1111:6))"]
#[derive(Clone, Debug)]
struct linc3Var2 {
    linc4: Tablelinc4,
}
impl linc3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc4 = if let Some((len, table)) =
            Tablelinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc3 {
    Var0(linc3Var0),
    Var1(linc3Var1),
    Var2(linc3Var2),
}
impl Tablelinc3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 16 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                linc3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                linc3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1113:1, end:1113:6))"]
#[derive(Clone, Debug)]
struct linc2Var0 {}
impl linc2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1112:1, end:1112:6))"]
#[derive(Clone, Debug)]
struct linc2Var1 {
    linc3: Tablelinc3,
}
impl linc2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::sp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc3 = if let Some((len, table)) =
            Tablelinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1114:1, end:1114:6))"]
#[derive(Clone, Debug)]
struct linc2Var2 {
    linc3: Tablelinc3,
}
impl linc2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc3 = if let Some((len, table)) =
            Tablelinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc2 {
    Var0(linc2Var0),
    Var1(linc2Var1),
    Var2(linc2Var2),
}
impl Tablelinc2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 63) == 32 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                linc2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                linc2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                linc2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1116:1, end:1116:6))"]
#[derive(Clone, Debug)]
struct linc1Var0 {}
impl linc1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1115:1, end:1115:6))"]
#[derive(Clone, Debug)]
struct linc1Var1 {
    linc2: Tablelinc2,
}
impl linc1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc2 = if let Some((len, table)) =
            Tablelinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1117:1, end:1117:6))"]
#[derive(Clone, Debug)]
struct linc1Var2 {
    linc2: Tablelinc2,
}
impl linc1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc2 = if let Some((len, table)) =
            Tablelinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc1 {
    Var0(linc1Var0),
    Var1(linc1Var1),
    Var2(linc1Var2),
}
impl Tablelinc1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 127) == 64 && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                linc1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                linc1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                linc1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1119:1, end:1119:6))"]
#[derive(Clone, Debug)]
struct linc0Var0 {}
impl linc0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1118:1, end:1118:6))"]
#[derive(Clone, Debug)]
struct linc0Var1 {
    linc1: Tablelinc1,
}
impl linc0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc1 = if let Some((len, table)) =
            Tablelinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1120:1, end:1120:6))"]
#[derive(Clone, Debug)]
struct linc0Var2 {
    linc1: Tablelinc1,
}
impl linc0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.linc1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc1 = if let Some((len, table)) =
            Tablelinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablelinc0 {
    Var0(linc0Var0),
    Var1(linc0Var1),
    Var2(linc0Var2),
}
impl Tablelinc0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 128 && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                linc0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                linc0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                linc0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1121:1, end:1121:11))"]
#[derive(Clone, Debug)]
struct ldlist_incVar0 {
    linc0: Tablelinc0,
}
impl ldlist_incVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.linc0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let linc0 = if let Some((len, table)) =
            Tablelinc0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { linc0 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldlist_inc {
    Var0(ldlist_incVar0),
}
impl Tableldlist_inc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                ldlist_incVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1124:1, end:1124:7))"]
#[derive(Clone, Debug)]
struct sinc15Var0 {}
impl sinc15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1125:1, end:1125:7))"]
#[derive(Clone, Debug)]
struct sinc15Var1 {}
impl sinc15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc15 {
    Var0(sinc15Var0),
    Var1(sinc15Var1),
}
impl Tablesinc15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                sinc15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                sinc15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1127:1, end:1127:7))"]
#[derive(Clone, Debug)]
struct sinc14Var0 {}
impl sinc14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1126:1, end:1126:7))"]
#[derive(Clone, Debug)]
struct sinc14Var1 {
    sinc15: Tablesinc15,
}
impl sinc14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc15
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc15 = if let Some((len, table)) =
            Tablesinc15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1128:1, end:1128:7))"]
#[derive(Clone, Debug)]
struct sinc14Var2 {
    sinc15: Tablesinc15,
}
impl sinc14Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc15 = if let Some((len, table)) =
            Tablesinc15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc14 {
    Var0(sinc14Var0),
    Var1(sinc14Var1),
    Var2(sinc14Var2),
}
impl Tablesinc14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                sinc14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                sinc14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                sinc14Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1130:1, end:1130:7))"]
#[derive(Clone, Debug)]
struct sinc13Var0 {}
impl sinc13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1129:1, end:1129:7))"]
#[derive(Clone, Debug)]
struct sinc13Var1 {
    sinc14: Tablesinc14,
}
impl sinc13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc14
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc14 = if let Some((len, table)) =
            Tablesinc14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1131:1, end:1131:7))"]
#[derive(Clone, Debug)]
struct sinc13Var2 {
    sinc14: Tablesinc14,
}
impl sinc13Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc14 = if let Some((len, table)) =
            Tablesinc14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc13 {
    Var0(sinc13Var0),
    Var1(sinc13Var1),
    Var2(sinc13Var2),
}
impl Tablesinc13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 7) == 4 {
            if let Some((inst_len, parsed)) =
                sinc13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                sinc13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                sinc13Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1133:1, end:1133:7))"]
#[derive(Clone, Debug)]
struct sinc12Var0 {}
impl sinc12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1132:1, end:1132:7))"]
#[derive(Clone, Debug)]
struct sinc12Var1 {
    sinc13: Tablesinc13,
}
impl sinc12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc13
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc13 = if let Some((len, table)) =
            Tablesinc13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1134:1, end:1134:7))"]
#[derive(Clone, Debug)]
struct sinc12Var2 {
    sinc13: Tablesinc13,
}
impl sinc12Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc13 = if let Some((len, table)) =
            Tablesinc13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc12 {
    Var0(sinc12Var0),
    Var1(sinc12Var1),
    Var2(sinc12Var2),
}
impl Tablesinc12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                sinc12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                sinc12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                sinc12Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1136:1, end:1136:7))"]
#[derive(Clone, Debug)]
struct sinc11Var0 {}
impl sinc11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1135:1, end:1135:7))"]
#[derive(Clone, Debug)]
struct sinc11Var1 {
    sinc12: Tablesinc12,
}
impl sinc11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc12
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc12 = if let Some((len, table)) =
            Tablesinc12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1137:1, end:1137:7))"]
#[derive(Clone, Debug)]
struct sinc11Var2 {
    sinc12: Tablesinc12,
}
impl sinc11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc12 = if let Some((len, table)) =
            Tablesinc12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc11 {
    Var0(sinc11Var0),
    Var1(sinc11Var1),
    Var2(sinc11Var2),
}
impl Tablesinc11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 31) == 16 {
            if let Some((inst_len, parsed)) =
                sinc11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                sinc11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                sinc11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1139:1, end:1139:7))"]
#[derive(Clone, Debug)]
struct sinc10Var0 {}
impl sinc10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1138:1, end:1138:7))"]
#[derive(Clone, Debug)]
struct sinc10Var1 {
    sinc11: Tablesinc11,
}
impl sinc10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc11
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc11 = if let Some((len, table)) =
            Tablesinc11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1140:1, end:1140:7))"]
#[derive(Clone, Debug)]
struct sinc10Var2 {
    sinc11: Tablesinc11,
}
impl sinc10Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc11 = if let Some((len, table)) =
            Tablesinc11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc10 {
    Var0(sinc10Var0),
    Var1(sinc10Var1),
    Var2(sinc10Var2),
}
impl Tablesinc10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 63) == 32 {
            if let Some((inst_len, parsed)) =
                sinc10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                sinc10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                sinc10Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1142:1, end:1142:6))"]
#[derive(Clone, Debug)]
struct sinc9Var0 {}
impl sinc9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1141:1, end:1141:6))"]
#[derive(Clone, Debug)]
struct sinc9Var1 {
    sinc10: Tablesinc10,
}
impl sinc9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc10
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc10 = if let Some((len, table)) =
            Tablesinc10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1143:1, end:1143:6))"]
#[derive(Clone, Debug)]
struct sinc9Var2 {
    sinc10: Tablesinc10,
}
impl sinc9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc10 = if let Some((len, table)) =
            Tablesinc10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc9 {
    Var0(sinc9Var0),
    Var1(sinc9Var1),
    Var2(sinc9Var2),
}
impl Tablesinc9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 127) == 64 {
            if let Some((inst_len, parsed)) =
                sinc9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                sinc9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                sinc9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1145:1, end:1145:6))"]
#[derive(Clone, Debug)]
struct sinc8Var0 {}
impl sinc8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1144:1, end:1144:6))"]
#[derive(Clone, Debug)]
struct sinc8Var1 {
    sinc9: Tablesinc9,
}
impl sinc8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc9 = if let Some((len, table)) =
            Tablesinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1146:1, end:1146:6))"]
#[derive(Clone, Debug)]
struct sinc8Var2 {
    sinc9: Tablesinc9,
}
impl sinc8Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc9 = if let Some((len, table)) =
            Tablesinc9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc8 {
    Var0(sinc8Var0),
    Var1(sinc8Var1),
    Var2(sinc8Var2),
}
impl Tablesinc8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 255) == 128 {
            if let Some((inst_len, parsed)) =
                sinc8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                sinc8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                sinc8Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1148:1, end:1148:6))"]
#[derive(Clone, Debug)]
struct sinc7Var0 {}
impl sinc7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1147:1, end:1147:6))"]
#[derive(Clone, Debug)]
struct sinc7Var1 {
    sinc8: Tablesinc8,
}
impl sinc7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r8),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc8 = if let Some((len, table)) =
            Tablesinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1149:1, end:1149:6))"]
#[derive(Clone, Debug)]
struct sinc7Var2 {
    sinc8: Tablesinc8,
}
impl sinc7Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc8 = if let Some((len, table)) =
            Tablesinc8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc7 {
    Var0(sinc7Var0),
    Var1(sinc7Var1),
    Var2(sinc7Var2),
}
impl Tablesinc7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                sinc7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                sinc7Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1151:1, end:1151:6))"]
#[derive(Clone, Debug)]
struct sinc6Var0 {}
impl sinc6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1150:1, end:1150:6))"]
#[derive(Clone, Debug)]
struct sinc6Var1 {
    sinc7: Tablesinc7,
}
impl sinc6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r9),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc7 = if let Some((len, table)) =
            Tablesinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1152:1, end:1152:6))"]
#[derive(Clone, Debug)]
struct sinc6Var2 {
    sinc7: Tablesinc7,
}
impl sinc6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc7 = if let Some((len, table)) =
            Tablesinc7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc6 {
    Var0(sinc6Var0),
    Var1(sinc6Var1),
    Var2(sinc6Var2),
}
impl Tablesinc6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 2 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                sinc6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                sinc6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1154:1, end:1154:6))"]
#[derive(Clone, Debug)]
struct sinc5Var0 {}
impl sinc5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1153:1, end:1153:6))"]
#[derive(Clone, Debug)]
struct sinc5Var1 {
    sinc6: Tablesinc6,
}
impl sinc5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r10),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc6 = if let Some((len, table)) =
            Tablesinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1155:1, end:1155:6))"]
#[derive(Clone, Debug)]
struct sinc5Var2 {
    sinc6: Tablesinc6,
}
impl sinc5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc6 = if let Some((len, table)) =
            Tablesinc6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc5 {
    Var0(sinc5Var0),
    Var1(sinc5Var1),
    Var2(sinc5Var2),
}
impl Tablesinc5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 7) == 4 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                sinc5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                sinc5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1157:1, end:1157:6))"]
#[derive(Clone, Debug)]
struct sinc4Var0 {}
impl sinc4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1156:1, end:1156:6))"]
#[derive(Clone, Debug)]
struct sinc4Var1 {
    sinc5: Tablesinc5,
}
impl sinc4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r11),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc5 = if let Some((len, table)) =
            Tablesinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1158:1, end:1158:6))"]
#[derive(Clone, Debug)]
struct sinc4Var2 {
    sinc5: Tablesinc5,
}
impl sinc4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc5 = if let Some((len, table)) =
            Tablesinc5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc4 {
    Var0(sinc4Var0),
    Var1(sinc4Var1),
    Var2(sinc4Var2),
}
impl Tablesinc4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 15) == 8 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                sinc4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                sinc4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1160:1, end:1160:6))"]
#[derive(Clone, Debug)]
struct sinc3Var0 {}
impl sinc3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1159:1, end:1159:6))"]
#[derive(Clone, Debug)]
struct sinc3Var1 {
    sinc4: Tablesinc4,
}
impl sinc3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::r12),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc4 = if let Some((len, table)) =
            Tablesinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1161:1, end:1161:6))"]
#[derive(Clone, Debug)]
struct sinc3Var2 {
    sinc4: Tablesinc4,
}
impl sinc3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc4 = if let Some((len, table)) =
            Tablesinc4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc3 {
    Var0(sinc3Var0),
    Var1(sinc3Var1),
    Var2(sinc3Var2),
}
impl Tablesinc3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 16 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                sinc3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                sinc3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1163:1, end:1163:6))"]
#[derive(Clone, Debug)]
struct sinc2Var0 {}
impl sinc2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1162:1, end:1162:6))"]
#[derive(Clone, Debug)]
struct sinc2Var1 {
    sinc3: Tablesinc3,
}
impl sinc2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::sp),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc3 = if let Some((len, table)) =
            Tablesinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1164:1, end:1164:6))"]
#[derive(Clone, Debug)]
struct sinc2Var2 {
    sinc3: Tablesinc3,
}
impl sinc2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc3 = if let Some((len, table)) =
            Tablesinc3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc2 {
    Var0(sinc2Var0),
    Var1(sinc2Var1),
    Var2(sinc2Var2),
}
impl Tablesinc2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 63) == 32 && (tokens_param[3] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                sinc2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                sinc2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                sinc2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1166:1, end:1166:6))"]
#[derive(Clone, Debug)]
struct sinc1Var0 {}
impl sinc1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1165:1, end:1165:6))"]
#[derive(Clone, Debug)]
struct sinc1Var1 {
    sinc2: Tablesinc2,
}
impl sinc1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::lr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc2 = if let Some((len, table)) =
            Tablesinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1167:1, end:1167:6))"]
#[derive(Clone, Debug)]
struct sinc1Var2 {
    sinc2: Tablesinc2,
}
impl sinc1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc2 = if let Some((len, table)) =
            Tablesinc2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc1 {
    Var0(sinc1Var0),
    Var1(sinc1Var1),
    Var2(sinc1Var2),
}
impl Tablesinc1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 127) == 64 && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                sinc1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                sinc1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                sinc1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1169:1, end:1169:6))"]
#[derive(Clone, Debug)]
struct sinc0Var0 {}
impl sinc0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1168:1, end:1168:6))"]
#[derive(Clone, Debug)]
struct sinc0Var1 {
    sinc1: Tablesinc1,
}
impl sinc0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::pc),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc1 = if let Some((len, table)) =
            Tablesinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1170:1, end:1170:6))"]
#[derive(Clone, Debug)]
struct sinc0Var2 {
    sinc1: Tablesinc1,
}
impl sinc0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sinc1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc1 = if let Some((len, table)) =
            Tablesinc1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesinc0 {
    Var0(sinc0Var0),
    Var1(sinc0Var1),
    Var2(sinc0Var2),
}
impl Tablesinc0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 128 && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                sinc0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                sinc0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                sinc0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1171:1, end:1171:11))"]
#[derive(Clone, Debug)]
struct stlist_incVar0 {
    sinc0: Tablesinc0,
}
impl stlist_incVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.sinc0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sinc0 = if let Some((len, table)) =
            Tablesinc0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sinc0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablestlist_inc {
    Var0(stlist_incVar0),
}
impl Tablestlist_inc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                stlist_incVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1175:1, end:1175:7))"]
#[derive(Clone, Debug)]
struct ldec15Var0 {}
impl ldec15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1176:1, end:1176:7))"]
#[derive(Clone, Debug)]
struct ldec15Var1 {}
impl ldec15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableldec15 {
    Var0(ldec15Var0),
    Var1(ldec15Var1),
}
impl Tableldec15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                ldec15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                ldec15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1178:1, end:1178:7))"]
#[derive(Clone, Debug)]
struct ldec14Var0 {}
impl ldec14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1177:1, end:1177:7))"]
#[derive(Clone, Debug)]
struct ldec14Var1 {
    ldec15: Tableldec15,
}
impl ldec14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec15 = if let Some((len, table)) =
            Tableldec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1179:1, end:1179:7))"]
#[derive(Clone, Debug)]
struct ldec14Var2 {
    ldec15: Tableldec15,
}
impl ldec14Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec15 = if let Some((len, table)) =
            Tableldec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec15 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec14 {
    Var0(ldec14Var0),
    Var1(ldec14Var1),
    Var2(ldec14Var2),
}
impl Tableldec14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                ldec14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                ldec14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                ldec14Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1181:1, end:1181:7))"]
#[derive(Clone, Debug)]
struct ldec13Var0 {}
impl ldec13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1180:1, end:1180:7))"]
#[derive(Clone, Debug)]
struct ldec13Var1 {
    ldec14: Tableldec14,
}
impl ldec13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec14 = if let Some((len, table)) =
            Tableldec14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1182:1, end:1182:7))"]
#[derive(Clone, Debug)]
struct ldec13Var2 {
    ldec14: Tableldec14,
}
impl ldec13Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec14 = if let Some((len, table)) =
            Tableldec14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec14 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec13 {
    Var0(ldec13Var0),
    Var1(ldec13Var1),
    Var2(ldec13Var2),
}
impl Tableldec13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                ldec13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                ldec13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                ldec13Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1184:1, end:1184:7))"]
#[derive(Clone, Debug)]
struct ldec12Var0 {}
impl ldec12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1183:1, end:1183:7))"]
#[derive(Clone, Debug)]
struct ldec12Var1 {
    ldec13: Tableldec13,
}
impl ldec12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r12),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec13 = if let Some((len, table)) =
            Tableldec13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1185:1, end:1185:7))"]
#[derive(Clone, Debug)]
struct ldec12Var2 {
    ldec13: Tableldec13,
}
impl ldec12Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec13 = if let Some((len, table)) =
            Tableldec13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec13 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec12 {
    Var0(ldec12Var0),
    Var1(ldec12Var1),
    Var2(ldec12Var2),
}
impl Tableldec12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                ldec12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                ldec12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                ldec12Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1187:1, end:1187:7))"]
#[derive(Clone, Debug)]
struct ldec11Var0 {}
impl ldec11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1186:1, end:1186:7))"]
#[derive(Clone, Debug)]
struct ldec11Var1 {
    ldec12: Tableldec12,
}
impl ldec11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r11),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec12 = if let Some((len, table)) =
            Tableldec12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1188:1, end:1188:7))"]
#[derive(Clone, Debug)]
struct ldec11Var2 {
    ldec12: Tableldec12,
}
impl ldec11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec12 = if let Some((len, table)) =
            Tableldec12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec12 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec11 {
    Var0(ldec11Var0),
    Var1(ldec11Var1),
    Var2(ldec11Var2),
}
impl Tableldec11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                ldec11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                ldec11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                ldec11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1190:1, end:1190:7))"]
#[derive(Clone, Debug)]
struct ldec10Var0 {}
impl ldec10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1189:1, end:1189:7))"]
#[derive(Clone, Debug)]
struct ldec10Var1 {
    ldec11: Tableldec11,
}
impl ldec10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r10),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec11 = if let Some((len, table)) =
            Tableldec11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1191:1, end:1191:7))"]
#[derive(Clone, Debug)]
struct ldec10Var2 {
    ldec11: Tableldec11,
}
impl ldec10Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec11 = if let Some((len, table)) =
            Tableldec11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec11 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec10 {
    Var0(ldec10Var0),
    Var1(ldec10Var1),
    Var2(ldec10Var2),
}
impl Tableldec10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                ldec10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                ldec10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                ldec10Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1193:1, end:1193:6))"]
#[derive(Clone, Debug)]
struct ldec9Var0 {}
impl ldec9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1192:1, end:1192:6))"]
#[derive(Clone, Debug)]
struct ldec9Var1 {
    ldec10: Tableldec10,
}
impl ldec9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r9),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec10 = if let Some((len, table)) =
            Tableldec10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1194:1, end:1194:6))"]
#[derive(Clone, Debug)]
struct ldec9Var2 {
    ldec10: Tableldec10,
}
impl ldec9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec10 = if let Some((len, table)) =
            Tableldec10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec10 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec9 {
    Var0(ldec9Var0),
    Var1(ldec9Var1),
    Var2(ldec9Var2),
}
impl Tableldec9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                ldec9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                ldec9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                ldec9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1196:1, end:1196:6))"]
#[derive(Clone, Debug)]
struct ldec8Var0 {}
impl ldec8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1195:1, end:1195:6))"]
#[derive(Clone, Debug)]
struct ldec8Var1 {
    ldec9: Tableldec9,
}
impl ldec8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r8),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec9 = if let Some((len, table)) =
            Tableldec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1197:1, end:1197:6))"]
#[derive(Clone, Debug)]
struct ldec8Var2 {
    ldec9: Tableldec9,
}
impl ldec8Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec9 = if let Some((len, table)) =
            Tableldec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec9 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec8 {
    Var0(ldec8Var0),
    Var1(ldec8Var1),
    Var2(ldec8Var2),
}
impl Tableldec8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                ldec8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                ldec8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                ldec8Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1199:1, end:1199:6))"]
#[derive(Clone, Debug)]
struct ldec7Var0 {}
impl ldec7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1198:1, end:1198:6))"]
#[derive(Clone, Debug)]
struct ldec7Var1 {
    ldec8: Tableldec8,
}
impl ldec7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r7),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec8 = if let Some((len, table)) =
            Tableldec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1200:1, end:1200:6))"]
#[derive(Clone, Debug)]
struct ldec7Var2 {
    ldec8: Tableldec8,
}
impl ldec7Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec8 = if let Some((len, table)) =
            Tableldec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec7 {
    Var0(ldec7Var0),
    Var1(ldec7Var1),
    Var2(ldec7Var2),
}
impl Tableldec7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                ldec7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                ldec7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                ldec7Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1202:1, end:1202:6))"]
#[derive(Clone, Debug)]
struct ldec6Var0 {}
impl ldec6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1201:1, end:1201:6))"]
#[derive(Clone, Debug)]
struct ldec6Var1 {
    ldec7: Tableldec7,
}
impl ldec6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r6),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec7 = if let Some((len, table)) =
            Tableldec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1203:1, end:1203:6))"]
#[derive(Clone, Debug)]
struct ldec6Var2 {
    ldec7: Tableldec7,
}
impl ldec6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec7 = if let Some((len, table)) =
            Tableldec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec7 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec6 {
    Var0(ldec6Var0),
    Var1(ldec6Var1),
    Var2(ldec6Var2),
}
impl Tableldec6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                ldec6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                ldec6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                ldec6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1205:1, end:1205:6))"]
#[derive(Clone, Debug)]
struct ldec5Var0 {}
impl ldec5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1204:1, end:1204:6))"]
#[derive(Clone, Debug)]
struct ldec5Var1 {
    ldec6: Tableldec6,
}
impl ldec5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec6 = if let Some((len, table)) =
            Tableldec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1206:1, end:1206:6))"]
#[derive(Clone, Debug)]
struct ldec5Var2 {
    ldec6: Tableldec6,
}
impl ldec5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec6 = if let Some((len, table)) =
            Tableldec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec6 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec5 {
    Var0(ldec5Var0),
    Var1(ldec5Var1),
    Var2(ldec5Var2),
}
impl Tableldec5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                ldec5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                ldec5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                ldec5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1208:1, end:1208:6))"]
#[derive(Clone, Debug)]
struct ldec4Var0 {}
impl ldec4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1207:1, end:1207:6))"]
#[derive(Clone, Debug)]
struct ldec4Var1 {
    ldec5: Tableldec5,
}
impl ldec4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r4),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec5 = if let Some((len, table)) =
            Tableldec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1209:1, end:1209:6))"]
#[derive(Clone, Debug)]
struct ldec4Var2 {
    ldec5: Tableldec5,
}
impl ldec4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec5 = if let Some((len, table)) =
            Tableldec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec5 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec4 {
    Var0(ldec4Var0),
    Var1(ldec4Var1),
    Var2(ldec4Var2),
}
impl Tableldec4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                ldec4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                ldec4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                ldec4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1211:1, end:1211:6))"]
#[derive(Clone, Debug)]
struct ldec3Var0 {}
impl ldec3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1210:1, end:1210:6))"]
#[derive(Clone, Debug)]
struct ldec3Var1 {
    ldec4: Tableldec4,
}
impl ldec3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r3),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec4 = if let Some((len, table)) =
            Tableldec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1212:1, end:1212:6))"]
#[derive(Clone, Debug)]
struct ldec3Var2 {
    ldec4: Tableldec4,
}
impl ldec3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec4 = if let Some((len, table)) =
            Tableldec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec4 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec3 {
    Var0(ldec3Var0),
    Var1(ldec3Var1),
    Var2(ldec3Var2),
}
impl Tableldec3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                ldec3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                ldec3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                ldec3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1214:1, end:1214:6))"]
#[derive(Clone, Debug)]
struct ldec2Var0 {}
impl ldec2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1213:1, end:1213:6))"]
#[derive(Clone, Debug)]
struct ldec2Var1 {
    ldec3: Tableldec3,
}
impl ldec2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec3 = if let Some((len, table)) =
            Tableldec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1215:1, end:1215:6))"]
#[derive(Clone, Debug)]
struct ldec2Var2 {
    ldec3: Tableldec3,
}
impl ldec2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec3 = if let Some((len, table)) =
            Tableldec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec3 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec2 {
    Var0(ldec2Var0),
    Var1(ldec2Var1),
    Var2(ldec2Var2),
}
impl Tableldec2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                ldec2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                ldec2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                ldec2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1217:1, end:1217:6))"]
#[derive(Clone, Debug)]
struct ldec1Var0 {}
impl ldec1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1216:1, end:1216:6))"]
#[derive(Clone, Debug)]
struct ldec1Var1 {
    ldec2: Tableldec2,
}
impl ldec1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec2 = if let Some((len, table)) =
            Tableldec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1218:1, end:1218:6))"]
#[derive(Clone, Debug)]
struct ldec1Var2 {
    ldec2: Tableldec2,
}
impl ldec1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec2 = if let Some((len, table)) =
            Tableldec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec2 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec1 {
    Var0(ldec1Var0),
    Var1(ldec1Var1),
    Var2(ldec1Var2),
}
impl Tableldec1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                ldec1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                ldec1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                ldec1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1220:1, end:1220:6))"]
#[derive(Clone, Debug)]
struct ldec0Var0 {}
impl ldec0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1219:1, end:1219:6))"]
#[derive(Clone, Debug)]
struct ldec0Var1 {
    ldec1: Tableldec1,
}
impl ldec0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r0),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ldec1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec1 = if let Some((len, table)) =
            Tableldec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1221:1, end:1221:6))"]
#[derive(Clone, Debug)]
struct ldec0Var2 {
    ldec1: Tableldec1,
}
impl ldec0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.ldec1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec1 = if let Some((len, table)) =
            Tableldec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec1 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldec0 {
    Var0(ldec0Var0),
    Var1(ldec0Var1),
    Var2(ldec0Var2),
}
impl Tableldec0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                ldec0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                ldec0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                ldec0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1222:1, end:1222:11))"]
#[derive(Clone, Debug)]
struct ldlist_decVar0 {
    ldec0: Tableldec0,
}
impl ldlist_decVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.ldec0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let ldec0 = if let Some((len, table)) =
            Tableldec0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldec0 }))
    }
}
#[derive(Clone, Debug)]
enum Tableldlist_dec {
    Var0(ldlist_decVar0),
}
impl Tableldlist_dec {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                ldlist_decVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1225:1, end:1225:7))"]
#[derive(Clone, Debug)]
struct sdec15Var0 {}
impl sdec15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::pc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1226:1, end:1226:7))"]
#[derive(Clone, Debug)]
struct sdec15Var1 {}
impl sdec15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec15 {
    Var0(sdec15Var0),
    Var1(sdec15Var1),
}
impl Tablesdec15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                sdec15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                sdec15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1228:1, end:1228:7))"]
#[derive(Clone, Debug)]
struct sdec14Var0 {}
impl sdec14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::lr)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1227:1, end:1227:7))"]
#[derive(Clone, Debug)]
struct sdec14Var1 {
    sdec15: Tablesdec15,
}
impl sdec14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::lr),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec15 = if let Some((len, table)) =
            Tablesdec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1229:1, end:1229:7))"]
#[derive(Clone, Debug)]
struct sdec14Var2 {
    sdec15: Tablesdec15,
}
impl sdec14Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec15
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec15 = if let Some((len, table)) =
            Tablesdec15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec15 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec14 {
    Var0(sdec14Var0),
    Var1(sdec14Var1),
    Var2(sdec14Var2),
}
impl Tablesdec14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                sdec14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                sdec14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                sdec14Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1231:1, end:1231:7))"]
#[derive(Clone, Debug)]
struct sdec13Var0 {}
impl sdec13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::sp)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1230:1, end:1230:7))"]
#[derive(Clone, Debug)]
struct sdec13Var1 {
    sdec14: Tablesdec14,
}
impl sdec13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::sp),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec14 = if let Some((len, table)) =
            Tablesdec14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec14 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1232:1, end:1232:7))"]
#[derive(Clone, Debug)]
struct sdec13Var2 {
    sdec14: Tablesdec14,
}
impl sdec13Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec14
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec14 = if let Some((len, table)) =
            Tablesdec14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec14 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec13 {
    Var0(sdec13Var0),
    Var1(sdec13Var1),
    Var2(sdec13Var2),
}
impl Tablesdec13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 {
            if let Some((inst_len, parsed)) =
                sdec13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                sdec13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                sdec13Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1234:1, end:1234:7))"]
#[derive(Clone, Debug)]
struct sdec12Var0 {}
impl sdec12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r12)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1233:1, end:1233:7))"]
#[derive(Clone, Debug)]
struct sdec12Var1 {
    sdec13: Tablesdec13,
}
impl sdec12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r12),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec13 = if let Some((len, table)) =
            Tablesdec13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec13 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1235:1, end:1235:7))"]
#[derive(Clone, Debug)]
struct sdec12Var2 {
    sdec13: Tablesdec13,
}
impl sdec12Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec13
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec13 = if let Some((len, table)) =
            Tablesdec13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec13 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec12 {
    Var0(sdec12Var0),
    Var1(sdec12Var1),
    Var2(sdec12Var2),
}
impl Tablesdec12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                sdec12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                sdec12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                sdec12Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1237:1, end:1237:7))"]
#[derive(Clone, Debug)]
struct sdec11Var0 {}
impl sdec11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r11)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1236:1, end:1236:7))"]
#[derive(Clone, Debug)]
struct sdec11Var1 {
    sdec12: Tablesdec12,
}
impl sdec11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r11),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec12 = if let Some((len, table)) =
            Tablesdec12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec12 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1238:1, end:1238:7))"]
#[derive(Clone, Debug)]
struct sdec11Var2 {
    sdec12: Tablesdec12,
}
impl sdec11Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec12
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec12 = if let Some((len, table)) =
            Tablesdec12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec12 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec11 {
    Var0(sdec11Var0),
    Var1(sdec11Var1),
    Var2(sdec11Var2),
}
impl Tablesdec11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                sdec11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                sdec11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                sdec11Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1240:1, end:1240:7))"]
#[derive(Clone, Debug)]
struct sdec10Var0 {}
impl sdec10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r10)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1239:1, end:1239:7))"]
#[derive(Clone, Debug)]
struct sdec10Var1 {
    sdec11: Tablesdec11,
}
impl sdec10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r10),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec11 = if let Some((len, table)) =
            Tablesdec11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec11 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1241:1, end:1241:7))"]
#[derive(Clone, Debug)]
struct sdec10Var2 {
    sdec11: Tablesdec11,
}
impl sdec10Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec11
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec11 = if let Some((len, table)) =
            Tablesdec11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec11 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec10 {
    Var0(sdec10Var0),
    Var1(sdec10Var1),
    Var2(sdec10Var2),
}
impl Tablesdec10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                sdec10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                sdec10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                sdec10Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1243:1, end:1243:6))"]
#[derive(Clone, Debug)]
struct sdec9Var0 {}
impl sdec9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r9)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1242:1, end:1242:6))"]
#[derive(Clone, Debug)]
struct sdec9Var1 {
    sdec10: Tablesdec10,
}
impl sdec9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r9),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec10 = if let Some((len, table)) =
            Tablesdec10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec10 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1244:1, end:1244:6))"]
#[derive(Clone, Debug)]
struct sdec9Var2 {
    sdec10: Tablesdec10,
}
impl sdec9Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec10
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec10 = if let Some((len, table)) =
            Tablesdec10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec10 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec9 {
    Var0(sdec9Var0),
    Var1(sdec9Var1),
    Var2(sdec9Var2),
}
impl Tablesdec9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                sdec9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                sdec9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                sdec9Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1246:1, end:1246:6))"]
#[derive(Clone, Debug)]
struct sdec8Var0 {}
impl sdec8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r8)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1245:1, end:1245:6))"]
#[derive(Clone, Debug)]
struct sdec8Var1 {
    sdec9: Tablesdec9,
}
impl sdec8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r8),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec9 = if let Some((len, table)) =
            Tablesdec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1247:1, end:1247:6))"]
#[derive(Clone, Debug)]
struct sdec8Var2 {
    sdec9: Tablesdec9,
}
impl sdec8Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec9 = if let Some((len, table)) =
            Tablesdec9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec8 {
    Var0(sdec8Var0),
    Var1(sdec8Var1),
    Var2(sdec8Var2),
}
impl Tablesdec8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                sdec8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                sdec8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                sdec8Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1249:1, end:1249:6))"]
#[derive(Clone, Debug)]
struct sdec7Var0 {}
impl sdec7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1248:1, end:1248:6))"]
#[derive(Clone, Debug)]
struct sdec7Var1 {
    sdec8: Tablesdec8,
}
impl sdec7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r7),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec8 = if let Some((len, table)) =
            Tablesdec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1250:1, end:1250:6))"]
#[derive(Clone, Debug)]
struct sdec7Var2 {
    sdec8: Tablesdec8,
}
impl sdec7Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec8 = if let Some((len, table)) =
            Tablesdec8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec7 {
    Var0(sdec7Var0),
    Var1(sdec7Var1),
    Var2(sdec7Var2),
}
impl Tablesdec7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                sdec7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                sdec7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                sdec7Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1252:1, end:1252:6))"]
#[derive(Clone, Debug)]
struct sdec6Var0 {}
impl sdec6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1251:1, end:1251:6))"]
#[derive(Clone, Debug)]
struct sdec6Var1 {
    sdec7: Tablesdec7,
}
impl sdec6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r6),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec7 = if let Some((len, table)) =
            Tablesdec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1253:1, end:1253:6))"]
#[derive(Clone, Debug)]
struct sdec6Var2 {
    sdec7: Tablesdec7,
}
impl sdec6Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec7 = if let Some((len, table)) =
            Tablesdec7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec6 {
    Var0(sdec6Var0),
    Var1(sdec6Var1),
    Var2(sdec6Var2),
}
impl Tablesdec6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                sdec6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                sdec6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                sdec6Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1255:1, end:1255:6))"]
#[derive(Clone, Debug)]
struct sdec5Var0 {}
impl sdec5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1254:1, end:1254:6))"]
#[derive(Clone, Debug)]
struct sdec5Var1 {
    sdec6: Tablesdec6,
}
impl sdec5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r5),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec6 = if let Some((len, table)) =
            Tablesdec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1256:1, end:1256:6))"]
#[derive(Clone, Debug)]
struct sdec5Var2 {
    sdec6: Tablesdec6,
}
impl sdec5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec6 = if let Some((len, table)) =
            Tablesdec6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec5 {
    Var0(sdec5Var0),
    Var1(sdec5Var1),
    Var2(sdec5Var2),
}
impl Tablesdec5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 224) == 32
        {
            if let Some((inst_len, parsed)) =
                sdec5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                sdec5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                sdec5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1258:1, end:1258:6))"]
#[derive(Clone, Debug)]
struct sdec4Var0 {}
impl sdec4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1257:1, end:1257:6))"]
#[derive(Clone, Debug)]
struct sdec4Var1 {
    sdec5: Tablesdec5,
}
impl sdec4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r4),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec5 = if let Some((len, table)) =
            Tablesdec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1259:1, end:1259:6))"]
#[derive(Clone, Debug)]
struct sdec4Var2 {
    sdec5: Tablesdec5,
}
impl sdec4Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec5 = if let Some((len, table)) =
            Tablesdec5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec4 {
    Var0(sdec4Var0),
    Var1(sdec4Var1),
    Var2(sdec4Var2),
}
impl Tablesdec4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                sdec4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 16 {
            if let Some((inst_len, parsed)) =
                sdec4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 16) == 0 {
            if let Some((inst_len, parsed)) =
                sdec4Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1261:1, end:1261:6))"]
#[derive(Clone, Debug)]
struct sdec3Var0 {}
impl sdec3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1260:1, end:1260:6))"]
#[derive(Clone, Debug)]
struct sdec3Var1 {
    sdec4: Tablesdec4,
}
impl sdec3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r3),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec4 = if let Some((len, table)) =
            Tablesdec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1262:1, end:1262:6))"]
#[derive(Clone, Debug)]
struct sdec3Var2 {
    sdec4: Tablesdec4,
}
impl sdec3Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec4 = if let Some((len, table)) =
            Tablesdec4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec3 {
    Var0(sdec3Var0),
    Var1(sdec3Var1),
    Var2(sdec3Var2),
}
impl Tablesdec3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                sdec3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                sdec3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                sdec3Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1264:1, end:1264:6))"]
#[derive(Clone, Debug)]
struct sdec2Var0 {}
impl sdec2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1263:1, end:1263:6))"]
#[derive(Clone, Debug)]
struct sdec2Var1 {
    sdec3: Tablesdec3,
}
impl sdec2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec3 = if let Some((len, table)) =
            Tablesdec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1265:1, end:1265:6))"]
#[derive(Clone, Debug)]
struct sdec2Var2 {
    sdec3: Tablesdec3,
}
impl sdec2Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec3 = if let Some((len, table)) =
            Tablesdec3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec2 {
    Var0(sdec2Var0),
    Var1(sdec2Var1),
    Var2(sdec2Var2),
}
impl Tablesdec2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 252) == 4 {
            if let Some((inst_len, parsed)) =
                sdec2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 4 {
            if let Some((inst_len, parsed)) =
                sdec2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 4) == 0 {
            if let Some((inst_len, parsed)) =
                sdec2Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1267:1, end:1267:6))"]
#[derive(Clone, Debug)]
struct sdec1Var0 {}
impl sdec1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1266:1, end:1266:6))"]
#[derive(Clone, Debug)]
struct sdec1Var1 {
    sdec2: Tablesdec2,
}
impl sdec1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec2 = if let Some((len, table)) =
            Tablesdec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1268:1, end:1268:6))"]
#[derive(Clone, Debug)]
struct sdec1Var2 {
    sdec2: Tablesdec2,
}
impl sdec1Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec2 = if let Some((len, table)) =
            Tablesdec2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec1 {
    Var0(sdec1Var0),
    Var1(sdec1Var1),
    Var2(sdec1Var2),
}
impl Tablesdec1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 254) == 2 {
            if let Some((inst_len, parsed)) =
                sdec1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                sdec1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                sdec1Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1270:1, end:1270:6))"]
#[derive(Clone, Debug)]
struct sdec0Var0 {}
impl sdec0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::r0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1269:1, end:1269:6))"]
#[derive(Clone, Debug)]
struct sdec0Var1 {
    sdec1: Tablesdec1,
}
impl sdec0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Register(Register::r0),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.sdec1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec1 = if let Some((len, table)) =
            Tablesdec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1271:1, end:1271:6))"]
#[derive(Clone, Debug)]
struct sdec0Var2 {
    sdec1: Tablesdec1,
}
impl sdec0Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.sdec1
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec1 = if let Some((len, table)) =
            Tablesdec1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablesdec0 {
    Var0(sdec0Var0),
    Var1(sdec0Var1),
    Var2(sdec0Var2),
}
impl Tablesdec0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 255) == 0 && (tokens_param[3] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                sdec0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                sdec0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                sdec0Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1273:1, end:1273:11))"]
#[derive(Clone, Debug)]
struct stlist_decVar0 {
    sdec0: Tablesdec0,
}
impl stlist_decVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.sdec0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let sdec0 = if let Some((len, table)) =
            Tablesdec0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { sdec0 }))
    }
}
#[derive(Clone, Debug)]
enum Tablestlist_dec {
    Var0(stlist_decVar0),
}
impl Tablestlist_dec {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                stlist_decVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1278:1, end:1278:8))"]
#[derive(Clone, Debug)]
struct reglistVar0 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1283:1, end:1283:8))"]
#[derive(Clone, Debug)]
struct reglistVar1 {
    ldlist_inc: Tableldlist_inc,
    rn: Tablern,
}
impl reglistVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1288:1, end:1288:8))"]
#[derive(Clone, Debug)]
struct reglistVar2 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1293:1, end:1293:8))"]
#[derive(Clone, Debug)]
struct reglistVar3 {
    ldlist_inc: Tableldlist_inc,
    rn: Tablern,
}
impl reglistVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1298:1, end:1298:8))"]
#[derive(Clone, Debug)]
struct reglistVar4 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1303:1, end:1303:8))"]
#[derive(Clone, Debug)]
struct reglistVar5 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1308:1, end:1308:8))"]
#[derive(Clone, Debug)]
struct reglistVar6 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1313:1, end:1313:8))"]
#[derive(Clone, Debug)]
struct reglistVar7 {
    rn: Tablern,
    ldlist_inc: Tableldlist_inc,
}
impl reglistVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_inc = if let Some((len, table)) =
            Tableldlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1318:1, end:1318:8))"]
#[derive(Clone, Debug)]
struct reglistVar8 {
    ldlist_dec: Tableldlist_dec,
    rn: Tablern,
}
impl reglistVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1323:1, end:1323:8))"]
#[derive(Clone, Debug)]
struct reglistVar9 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1328:1, end:1328:8))"]
#[derive(Clone, Debug)]
struct reglistVar10 {
    ldlist_dec: Tableldlist_dec,
    rn: Tablern,
}
impl reglistVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1333:1, end:1333:8))"]
#[derive(Clone, Debug)]
struct reglistVar11 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1338:1, end:1338:8))"]
#[derive(Clone, Debug)]
struct reglistVar12 {
    ldlist_dec: Tableldlist_dec,
    rn: Tablern,
}
impl reglistVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ldlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1343:1, end:1343:8))"]
#[derive(Clone, Debug)]
struct reglistVar13 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1348:1, end:1348:8))"]
#[derive(Clone, Debug)]
struct reglistVar14 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1353:1, end:1353:8))"]
#[derive(Clone, Debug)]
struct reglistVar15 {
    rn: Tablern,
    ldlist_dec: Tableldlist_dec,
}
impl reglistVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.ldlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ldlist_dec = if let Some((len, table)) =
            Tableldlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, ldlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1358:1, end:1358:8))"]
#[derive(Clone, Debug)]
struct reglistVar16 {
    stlist_inc: Tablestlist_inc,
    rn: Tablern,
}
impl reglistVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1363:1, end:1363:8))"]
#[derive(Clone, Debug)]
struct reglistVar17 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1374:1, end:1374:8))"]
#[derive(Clone, Debug)]
struct reglistVar18 {
    stlist_inc: Tablestlist_inc,
    rn: Tablern,
}
impl reglistVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1380:1, end:1380:8))"]
#[derive(Clone, Debug)]
struct reglistVar19 {
    stlist_inc: Tablestlist_inc,
    rn: Tablern,
}
impl reglistVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1385:1, end:1385:8))"]
#[derive(Clone, Debug)]
struct reglistVar20 {
    stlist_inc: Tablestlist_inc,
    rn: Tablern,
}
impl reglistVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1390:1, end:1390:8))"]
#[derive(Clone, Debug)]
struct reglistVar21 {
    stlist_inc: Tablestlist_inc,
    rn: Tablern,
}
impl reglistVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_inc, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1395:1, end:1395:8))"]
#[derive(Clone, Debug)]
struct reglistVar22 {
    rn: Tablern,
    stlist_inc: Tablestlist_inc,
}
impl reglistVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_inc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_inc = if let Some((len, table)) =
            Tablestlist_inc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_inc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1400:1, end:1400:8))"]
#[derive(Clone, Debug)]
struct reglistVar23 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1405:1, end:1405:8))"]
#[derive(Clone, Debug)]
struct reglistVar24 {
    stlist_dec: Tablestlist_dec,
    rn: Tablern,
}
impl reglistVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1410:1, end:1410:8))"]
#[derive(Clone, Debug)]
struct reglistVar25 {
    stlist_dec: Tablestlist_dec,
    rn: Tablern,
}
impl reglistVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1415:1, end:1415:8))"]
#[derive(Clone, Debug)]
struct reglistVar26 {
    stlist_dec: Tablestlist_dec,
    rn: Tablern,
}
impl reglistVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { stlist_dec, rn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1420:1, end:1420:8))"]
#[derive(Clone, Debug)]
struct reglistVar27 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("^")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1425:1, end:1425:8))"]
#[derive(Clone, Debug)]
struct reglistVar28 {
    rn: Tablern,
    stlist_dec: Tablestlist_dec,
}
impl reglistVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("!,")];
        display.extend_from_slice(&extend);
        self.stlist_dec
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let stlist_dec = if let Some((len, table)) =
            Tablestlist_dec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, stlist_dec }))
    }
}
#[derive(Clone, Debug)]
enum Tablereglist {
    Var0(reglistVar0),
    Var1(reglistVar1),
    Var2(reglistVar2),
    Var3(reglistVar3),
    Var4(reglistVar4),
    Var5(reglistVar5),
    Var6(reglistVar6),
    Var7(reglistVar7),
    Var8(reglistVar8),
    Var9(reglistVar9),
    Var10(reglistVar10),
    Var11(reglistVar11),
    Var12(reglistVar12),
    Var13(reglistVar13),
    Var14(reglistVar14),
    Var15(reglistVar15),
    Var16(reglistVar16),
    Var17(reglistVar17),
    Var18(reglistVar18),
    Var19(reglistVar19),
    Var20(reglistVar20),
    Var21(reglistVar21),
    Var22(reglistVar22),
    Var23(reglistVar23),
    Var24(reglistVar24),
    Var25(reglistVar25),
    Var26(reglistVar26),
    Var27(reglistVar27),
    Var28(reglistVar28),
}
impl Tablereglist {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 144 {
            if let Some((inst_len, parsed)) =
                reglistVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 208 {
            if let Some((inst_len, parsed)) =
                reglistVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 176 {
            if let Some((inst_len, parsed)) =
                reglistVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 240 {
            if let Some((inst_len, parsed)) =
                reglistVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 144 {
            if let Some((inst_len, parsed)) =
                reglistVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 208 {
            if let Some((inst_len, parsed)) =
                reglistVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 176 {
            if let Some((inst_len, parsed)) =
                reglistVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 240 {
            if let Some((inst_len, parsed)) =
                reglistVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                reglistVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 80 {
            if let Some((inst_len, parsed)) =
                reglistVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 48 {
            if let Some((inst_len, parsed)) =
                reglistVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 112 {
            if let Some((inst_len, parsed)) =
                reglistVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 16 {
            if let Some((inst_len, parsed)) =
                reglistVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 80 {
            if let Some((inst_len, parsed)) =
                reglistVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 48 {
            if let Some((inst_len, parsed)) =
                reglistVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 112 {
            if let Some((inst_len, parsed)) =
                reglistVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 128 {
            if let Some((inst_len, parsed)) =
                reglistVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 192 {
            if let Some((inst_len, parsed)) =
                reglistVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 224 {
            if let Some((inst_len, parsed)) =
                reglistVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 160 {
            if let Some((inst_len, parsed)) =
                reglistVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 128 {
            if let Some((inst_len, parsed)) =
                reglistVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 192 {
            if let Some((inst_len, parsed)) =
                reglistVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 160 {
            if let Some((inst_len, parsed)) =
                reglistVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                reglistVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 64 {
            if let Some((inst_len, parsed)) =
                reglistVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 240) == 32 {
            if let Some((inst_len, parsed)) =
                reglistVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 0 {
            if let Some((inst_len, parsed)) =
                reglistVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 64 {
            if let Some((inst_len, parsed)) =
                reglistVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 240) == 32 {
            if let Some((inst_len, parsed)) =
                reglistVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1431:1, end:1431:5))"]
#[derive(Clone, Debug)]
struct mdirVar0 {}
impl mdirVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ia")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1432:1, end:1432:5))"]
#[derive(Clone, Debug)]
struct mdirVar1 {}
impl mdirVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ib")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1433:1, end:1433:5))"]
#[derive(Clone, Debug)]
struct mdirVar2 {}
impl mdirVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("da")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1434:1, end:1434:5))"]
#[derive(Clone, Debug)]
struct mdirVar3 {}
impl mdirVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("db")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablemdir {
    Var0(mdirVar0),
    Var1(mdirVar1),
    Var2(mdirVar2),
    Var3(mdirVar3),
}
impl Tablemdir {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                mdirVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                mdirVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                mdirVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                mdirVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1439:1, end:1439:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var0 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = i128::try_from(self.immed).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1440:1, end:1440:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var1 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-i128::try_from(self.immed).unwrap().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
            <DisplayElement>::Literal("]"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1441:1, end:1441:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var2 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = i128::try_from(self.immed).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1442:1, end:1442:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var3 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-i128::try_from(self.immed).unwrap().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
            <DisplayElement>::Literal("]!"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1443:1, end:1443:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var4 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_off8: i128 = 0;
        calc_off8 = i128::try_from(self.immed).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_off8.is_negative(), calc_off8.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_off8: i128 = 0;
        let mut block_0_len = 4;
        calc_off8 = i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1444:1, end:1444:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var5 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_noff8: i128 = 0;
        calc_noff8 = (-i128::try_from(self.immed).unwrap().wrapping_mul(4i128));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],#"),
            <DisplayElement>::Number(true, calc_noff8.is_negative(), calc_noff8.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_noff8: i128 = 0;
        let mut block_0_len = 4;
        calc_noff8 = (-i128::try_from(token_25(tokens_current))
            .unwrap()
            .wrapping_mul(4i128));
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1445:1, end:1445:10))"]
#[derive(Clone, Debug)]
struct addrmode5Var6 {
    immed: u8,
    rn: Tablern,
}
impl addrmode5Var6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.rn
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("],{"),
            DisplayElement::Number(true, false, self.immed as u64),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rn = if let Some((len, table)) =
            Tablern::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rn, immed }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrmode5 {
    Var0(addrmode5Var0),
    Var1(addrmode5Var1),
    Var2(addrmode5Var2),
    Var3(addrmode5Var3),
    Var4(addrmode5Var4),
    Var5(addrmode5Var5),
    Var6(addrmode5Var6),
}
impl Tableaddrmode5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 160) == 0 {
            if let Some((inst_len, parsed)) =
                addrmode5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode5Var2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode5Var3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 160) == 160 {
            if let Some((inst_len, parsed)) =
                addrmode5Var4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 160) == 32 {
            if let Some((inst_len, parsed)) =
                addrmode5Var5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 0 && (tokens_param[1] & 160) == 128 {
            if let Some((inst_len, parsed)) =
                addrmode5Var6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1449:1, end:1449:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar0 {}
impl cpsrmaskVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1450:1, end:1450:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar1 {}
impl cpsrmaskVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_c")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1451:1, end:1451:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar2 {}
impl cpsrmaskVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_x")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1452:1, end:1452:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar3 {}
impl cpsrmaskVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cx")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1453:1, end:1453:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar4 {}
impl cpsrmaskVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_s")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1454:1, end:1454:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar5 {}
impl cpsrmaskVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1455:1, end:1455:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar6 {}
impl cpsrmaskVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_xs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1456:1, end:1456:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar7 {}
impl cpsrmaskVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cxs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1457:1, end:1457:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar8 {}
impl cpsrmaskVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_f")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1458:1, end:1458:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar9 {}
impl cpsrmaskVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1459:1, end:1459:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar10 {}
impl cpsrmaskVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_xf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1460:1, end:1460:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar11 {}
impl cpsrmaskVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cxf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1461:1, end:1461:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar12 {}
impl cpsrmaskVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_sf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1462:1, end:1462:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar13 {}
impl cpsrmaskVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_csf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1463:1, end:1463:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar14 {}
impl cpsrmaskVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_xsf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1464:1, end:1464:9))"]
#[derive(Clone, Debug)]
struct cpsrmaskVar15 {}
impl cpsrmaskVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cpsr_cxsf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablecpsrmask {
    Var0(cpsrmaskVar0),
    Var1(cpsrmaskVar1),
    Var2(cpsrmaskVar2),
    Var3(cpsrmaskVar3),
    Var4(cpsrmaskVar4),
    Var5(cpsrmaskVar5),
    Var6(cpsrmaskVar6),
    Var7(cpsrmaskVar7),
    Var8(cpsrmaskVar8),
    Var9(cpsrmaskVar9),
    Var10(cpsrmaskVar10),
    Var11(cpsrmaskVar11),
    Var12(cpsrmaskVar12),
    Var13(cpsrmaskVar13),
    Var14(cpsrmaskVar14),
    Var15(cpsrmaskVar15),
}
impl Tablecpsrmask {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 2 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 3 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 5 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 6 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 7 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 9 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 10 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 11 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 12 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 13 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 14 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                cpsrmaskVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1468:1, end:1468:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar0 {}
impl spsrmaskVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1469:1, end:1469:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar1 {}
impl spsrmaskVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_c")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1470:1, end:1470:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar2 {}
impl spsrmaskVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_x")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1471:1, end:1471:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar3 {}
impl spsrmaskVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cx")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1472:1, end:1472:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar4 {}
impl spsrmaskVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_s")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1473:1, end:1473:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar5 {}
impl spsrmaskVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1474:1, end:1474:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar6 {}
impl spsrmaskVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_xs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1475:1, end:1475:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar7 {}
impl spsrmaskVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cxs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1476:1, end:1476:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar8 {}
impl spsrmaskVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_f")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1477:1, end:1477:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar9 {}
impl spsrmaskVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1478:1, end:1478:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar10 {}
impl spsrmaskVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_xf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1479:1, end:1479:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar11 {}
impl spsrmaskVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cxf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1480:1, end:1480:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar12 {}
impl spsrmaskVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_sf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1481:1, end:1481:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar13 {}
impl spsrmaskVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_csf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1482:1, end:1482:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar14 {}
impl spsrmaskVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_xsf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1483:1, end:1483:9))"]
#[derive(Clone, Debug)]
struct spsrmaskVar15 {}
impl spsrmaskVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("spsr_cxsf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablespsrmask {
    Var0(spsrmaskVar0),
    Var1(spsrmaskVar1),
    Var2(spsrmaskVar2),
    Var3(spsrmaskVar3),
    Var4(spsrmaskVar4),
    Var5(spsrmaskVar5),
    Var6(spsrmaskVar6),
    Var7(spsrmaskVar7),
    Var8(spsrmaskVar8),
    Var9(spsrmaskVar9),
    Var10(spsrmaskVar10),
    Var11(spsrmaskVar11),
    Var12(spsrmaskVar12),
    Var13(spsrmaskVar13),
    Var14(spsrmaskVar14),
    Var15(spsrmaskVar15),
}
impl Tablespsrmask {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 2 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 3 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 5 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 6 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 7 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 9 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 10 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 11 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 12 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 13 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 14 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                spsrmaskVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1984:1, end:1984:16))"]
#[derive(Clone, Debug)]
struct ArmPCRelImmed12Var0 {
    immed: u8,
    rotate: u8,
}
impl ArmPCRelImmed12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                ((u32::try_from(
                    32i128.wrapping_sub(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128)),
                )
                .ok()
                .and_then(|shl| i128::try_from(self.immed).unwrap().checked_shl(shl))
                .unwrap_or(0)
                    | u32::try_from(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128))
                        .ok()
                        .and_then(|shr| i128::try_from(self.immed).unwrap().checked_shr(shr))
                        .unwrap_or(0))
                    & 4294967295i128),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloff.is_negative(),
            calc_reloff.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(8i128)
            .wrapping_add(
                ((u32::try_from(
                    32i128.wrapping_sub(
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .wrapping_mul(2i128),
                    ),
                )
                .ok()
                .and_then(|shl| {
                    i128::try_from(token_25(tokens_current))
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0)
                    | u32::try_from(
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .wrapping_mul(2i128),
                    )
                    .ok()
                    .and_then(|shr| {
                        i128::try_from(token_25(tokens_current))
                            .unwrap()
                            .checked_shr(shr)
                    })
                    .unwrap_or(0))
                    & 4294967295i128),
            );
        let rotate = token_14(tokens_current);
        let immed = token_25(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/ARM/data/languages/ARMinstructions.sinc, start:1990:1, end:1990:16))"]
#[derive(Clone, Debug)]
struct ArmPCRelImmed12Var1 {
    immed: u8,
    rotate: u8,
}
impl ArmPCRelImmed12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloff: i128 = 0;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                ((u32::try_from(
                    32i128.wrapping_sub(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128)),
                )
                .ok()
                .and_then(|shl| i128::try_from(self.immed).unwrap().checked_shl(shl))
                .unwrap_or(0)
                    | u32::try_from(i128::try_from(self.rotate).unwrap().wrapping_mul(2i128))
                        .ok()
                        .and_then(|shr| i128::try_from(self.immed).unwrap().checked_shr(shr))
                        .unwrap_or(0))
                    & 4294967295i128),
            ),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloff.is_negative(),
            calc_reloff.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloff: i128 = 0;
        let mut block_0_len = 4;
        calc_reloff = i128::try_from(inst_start).unwrap().wrapping_add(
            8i128.wrapping_sub(
                ((u32::try_from(
                    32i128.wrapping_sub(
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .wrapping_mul(2i128),
                    ),
                )
                .ok()
                .and_then(|shl| {
                    i128::try_from(token_25(tokens_current))
                        .unwrap()
                        .checked_shl(shl)
                })
                .unwrap_or(0)
                    | u32::try_from(
                        i128::try_from(token_14(tokens_current))
                            .unwrap()
                            .wrapping_mul(2i128),
                    )
                    .ok()
                    .and_then(|shr| {
                        i128::try_from(token_25(tokens_current))
                            .unwrap()
                            .checked_shr(shr)
                    })
                    .unwrap_or(0))
                    & 4294967295i128),
            ),
        );
        let immed = token_25(tokens_current);
        let rotate = token_14(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { immed, rotate }))
    }
}
#[derive(Clone, Debug)]
enum TableArmPCRelImmed12 {
    Var0(ArmPCRelImmed12Var0),
    Var1(ArmPCRelImmed12Var1),
}
impl TableArmPCRelImmed12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && context_param.0 & 16777216 == 16777216
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                ArmPCRelImmed12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16777216 == 16777216
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                ArmPCRelImmed12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
pub fn parse_instruction(
    tokens: &[u8],
    context: &mut ContextMemory,
    inst_start: AddrType,
    global_set: &mut GlobalSet,
) -> Option<(u32, Vec<DisplayElement>)> {
    let (inst_len, instruction) = Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(&mut display, context, inst_start, inst_next, global_set);
    Some((inst_next, display))
}
