pub type AddrType = u64;
#[derive(Clone, Copy, Debug)]
pub enum Register {
    r0,
    r1,
    r2,
    r3,
    r4,
    r5,
    r6,
    r7,
    r8,
    r9,
    r10,
    r11,
    r12,
    r13,
    r14,
    r15,
    r16,
    r17,
    r18,
    r19,
    r20,
    r21,
    r22,
    r23,
    r24,
    r25,
    r26,
    r27,
    r28,
    r29,
    r30,
    r31,
    xer_so,
    xer_ov,
    xer_ov32,
    xer_ca,
    xer_ca32,
    xer_count,
    fp_fx,
    fp_fex,
    fp_vx,
    fp_ox,
    fp_ux,
    fp_zx,
    fp_xx,
    fp_vxsnan,
    fp_vxisi,
    fp_vxidi,
    fp_vxzdz,
    fp_vximz,
    fp_vxvc,
    fp_fr,
    fp_fi,
    fp_c,
    fp_cc0,
    fp_cc1,
    fp_cc2,
    fp_cc3,
    fp_reserve1,
    fp_vxsoft,
    fp_vxsqrt,
    fp_vxcvi,
    fp_ve,
    fp_oe,
    fp_ue,
    fp_ze,
    fp_xe,
    fp_ni,
    fp_rn0,
    fp_rn1,
    MSR,
    RESERVE_ADDRESS,
    RESERVE,
    RESERVE_LENGTH,
    pc,
    sr0,
    sr1,
    sr2,
    sr3,
    sr4,
    sr5,
    sr6,
    sr7,
    sr8,
    sr9,
    sr10,
    sr11,
    sr12,
    sr13,
    sr14,
    sr15,
    cr0,
    cr1,
    cr2,
    cr3,
    cr4,
    cr5,
    cr6,
    cr7,
    crall,
    tea,
    r2Save,
    spr000,
    XER,
    spr002,
    spr003,
    spr004,
    spr005,
    spr006,
    spr007,
    LR,
    CTR,
    spr00a,
    spr00b,
    spr00c,
    spr00d,
    spr00e,
    spr00f,
    spr010,
    spr011,
    spr012,
    spr013,
    spr014,
    spr015,
    spr016,
    spr017,
    spr018,
    spr019,
    SRR0,
    SRR1,
    spr01c,
    spr01d,
    spr01e,
    spr01f,
    spr020,
    spr021,
    spr022,
    spr023,
    spr024,
    spr025,
    spr026,
    spr027,
    spr028,
    spr029,
    spr02a,
    spr02b,
    spr02c,
    spr02d,
    spr02e,
    spr02f,
    spr030,
    spr031,
    spr032,
    spr033,
    spr034,
    spr035,
    spr036,
    spr037,
    spr038,
    spr039,
    CSRR0,
    CSRR1,
    spr03c,
    spr03d,
    spr03e,
    spr03f,
    spr040,
    spr041,
    spr042,
    spr043,
    spr044,
    spr045,
    spr046,
    spr047,
    spr048,
    spr049,
    spr04a,
    spr04b,
    spr04c,
    spr04d,
    spr04e,
    spr04f,
    spr050,
    spr051,
    spr052,
    spr053,
    spr054,
    spr055,
    spr056,
    spr057,
    spr058,
    spr059,
    spr05a,
    spr05b,
    spr05c,
    spr05d,
    spr05e,
    spr05f,
    spr060,
    spr061,
    spr062,
    spr063,
    spr064,
    spr065,
    spr066,
    spr067,
    spr068,
    spr069,
    spr06a,
    spr06b,
    spr06c,
    spr06d,
    spr06e,
    spr06f,
    spr070,
    spr071,
    spr072,
    spr073,
    spr074,
    spr075,
    spr076,
    spr077,
    spr078,
    spr079,
    spr07a,
    spr07b,
    spr07c,
    spr07d,
    spr07e,
    spr07f,
    spr080,
    spr081,
    spr082,
    spr083,
    spr084,
    spr085,
    spr086,
    spr087,
    spr088,
    spr089,
    spr08a,
    spr08b,
    spr08c,
    spr08d,
    spr08e,
    spr08f,
    spr090,
    spr091,
    spr092,
    spr093,
    spr094,
    spr095,
    spr096,
    spr097,
    spr098,
    spr099,
    spr09a,
    spr09b,
    spr09c,
    spr09d,
    spr09e,
    spr09f,
    spr0a0,
    spr0a1,
    spr0a2,
    spr0a3,
    spr0a4,
    spr0a5,
    spr0a6,
    spr0a7,
    spr0a8,
    spr0a9,
    spr0aa,
    spr0ab,
    spr0ac,
    spr0ad,
    spr0ae,
    spr0af,
    spr0b0,
    spr0b1,
    spr0b2,
    spr0b3,
    spr0b4,
    spr0b5,
    spr0b6,
    spr0b7,
    spr0b8,
    spr0b9,
    spr0ba,
    spr0bb,
    spr0bc,
    spr0bd,
    spr0be,
    spr0bf,
    spr0c0,
    spr0c1,
    spr0c2,
    spr0c3,
    spr0c4,
    spr0c5,
    spr0c6,
    spr0c7,
    spr0c8,
    spr0c9,
    spr0ca,
    spr0cb,
    spr0cc,
    spr0cd,
    spr0ce,
    spr0cf,
    spr0d0,
    spr0d1,
    spr0d2,
    spr0d3,
    spr0d4,
    spr0d5,
    spr0d6,
    spr0d7,
    spr0d8,
    spr0d9,
    spr0da,
    spr0db,
    spr0dc,
    spr0dd,
    spr0de,
    spr0df,
    spr0e0,
    spr0e1,
    spr0e2,
    spr0e3,
    spr0e4,
    spr0e5,
    spr0e6,
    spr0e7,
    spr0e8,
    spr0e9,
    spr0ea,
    spr0eb,
    spr0ec,
    spr0ed,
    spr0ee,
    spr0ef,
    spr0f0,
    spr0f1,
    spr0f2,
    spr0f3,
    spr0f4,
    spr0f5,
    spr0f6,
    spr0f7,
    spr0f8,
    spr0f9,
    spr0fa,
    spr0fb,
    spr0fc,
    spr0fd,
    spr0fe,
    spr0ff,
    spr100,
    spr101,
    spr102,
    spr103,
    spr104,
    spr105,
    spr106,
    spr107,
    spr108,
    spr109,
    spr10a,
    spr10b,
    TBLr,
    TBUr,
    spr10e,
    spr10f,
    spr110,
    spr111,
    spr112,
    spr113,
    spr114,
    spr115,
    spr116,
    spr117,
    spr118,
    spr119,
    spr11a,
    spr11b,
    TBLw,
    TBUw,
    spr11e,
    spr11f,
    spr120,
    spr121,
    spr122,
    spr123,
    spr124,
    spr125,
    spr126,
    spr127,
    spr128,
    spr129,
    spr12a,
    spr12b,
    spr12c,
    spr12d,
    spr12e,
    spr12f,
    spr130,
    spr131,
    spr132,
    spr133,
    spr134,
    spr135,
    spr136,
    spr137,
    spr138,
    spr139,
    spr13a,
    spr13b,
    spr13c,
    spr13d,
    spr13e,
    spr13f,
    spr140,
    spr141,
    spr142,
    spr143,
    spr144,
    spr145,
    spr146,
    spr147,
    spr148,
    spr149,
    spr14a,
    spr14b,
    spr14c,
    spr14d,
    spr14e,
    spr14f,
    spr150,
    spr151,
    spr152,
    spr153,
    spr154,
    spr155,
    spr156,
    spr157,
    spr158,
    spr159,
    spr15a,
    spr15b,
    spr15c,
    spr15d,
    spr15e,
    spr15f,
    spr160,
    spr161,
    spr162,
    spr163,
    spr164,
    spr165,
    spr166,
    spr167,
    spr168,
    spr169,
    spr16a,
    spr16b,
    spr16c,
    spr16d,
    spr16e,
    spr16f,
    spr170,
    spr171,
    spr172,
    spr173,
    spr174,
    spr175,
    spr176,
    spr177,
    spr178,
    spr179,
    spr17a,
    spr17b,
    spr17c,
    spr17d,
    spr17e,
    spr17f,
    spr180,
    spr181,
    spr182,
    spr183,
    spr184,
    spr185,
    spr186,
    spr187,
    spr188,
    spr189,
    spr18a,
    spr18b,
    spr18c,
    spr18d,
    spr18e,
    spr18f,
    spr190,
    spr191,
    spr192,
    spr193,
    spr194,
    spr195,
    spr196,
    spr197,
    spr198,
    spr199,
    spr19a,
    spr19b,
    spr19c,
    spr19d,
    spr19e,
    spr19f,
    spr1a0,
    spr1a1,
    spr1a2,
    spr1a3,
    spr1a4,
    spr1a5,
    spr1a6,
    spr1a7,
    spr1a8,
    spr1a9,
    spr1aa,
    spr1ab,
    spr1ac,
    spr1ad,
    spr1ae,
    spr1af,
    spr1b0,
    spr1b1,
    spr1b2,
    spr1b3,
    spr1b4,
    spr1b5,
    spr1b6,
    spr1b7,
    spr1b8,
    spr1b9,
    spr1ba,
    spr1bb,
    spr1bc,
    spr1bd,
    spr1be,
    spr1bf,
    spr1c0,
    spr1c1,
    spr1c2,
    spr1c3,
    spr1c4,
    spr1c5,
    spr1c6,
    spr1c7,
    spr1c8,
    spr1c9,
    spr1ca,
    spr1cb,
    spr1cc,
    spr1cd,
    spr1ce,
    spr1cf,
    spr1d0,
    spr1d1,
    spr1d2,
    spr1d3,
    spr1d4,
    spr1d5,
    spr1d6,
    spr1d7,
    spr1d8,
    spr1d9,
    spr1da,
    spr1db,
    spr1dc,
    spr1dd,
    spr1de,
    spr1df,
    spr1e0,
    spr1e1,
    spr1e2,
    spr1e3,
    spr1e4,
    spr1e5,
    spr1e6,
    spr1e7,
    spr1e8,
    spr1e9,
    spr1ea,
    spr1eb,
    spr1ec,
    spr1ed,
    spr1ee,
    spr1ef,
    spr1f0,
    spr1f1,
    spr1f2,
    spr1f3,
    spr1f4,
    spr1f5,
    spr1f6,
    spr1f7,
    spr1f8,
    spr1f9,
    spr1fa,
    spr1fb,
    spr1fc,
    spr1fd,
    spr1fe,
    spr1ff,
    spr200,
    spr201,
    spr202,
    spr203,
    spr204,
    spr205,
    spr206,
    spr207,
    spr208,
    spr209,
    spr20a,
    spr20b,
    spr20c,
    spr20d,
    spr20e,
    spr20f,
    spr210,
    spr211,
    spr212,
    spr213,
    spr214,
    spr215,
    spr216,
    spr217,
    spr218,
    spr219,
    spr21a,
    spr21b,
    spr21c,
    spr21d,
    spr21e,
    spr21f,
    spr220,
    spr221,
    spr222,
    spr223,
    spr224,
    spr225,
    spr226,
    spr227,
    spr228,
    spr229,
    spr22a,
    spr22b,
    spr22c,
    spr22d,
    spr22e,
    spr22f,
    spr230,
    spr231,
    spr232,
    spr233,
    spr234,
    spr235,
    spr236,
    spr237,
    spr238,
    spr239,
    spr23a,
    spr23b,
    spr23c,
    spr23d,
    spr23e,
    spr23f,
    spr240,
    spr241,
    spr242,
    spr243,
    spr244,
    spr245,
    spr246,
    spr247,
    spr248,
    spr249,
    spr24a,
    spr24b,
    spr24c,
    spr24d,
    spr24e,
    spr24f,
    spr250,
    spr251,
    spr252,
    spr253,
    spr254,
    spr255,
    spr256,
    spr257,
    spr258,
    spr259,
    spr25a,
    spr25b,
    spr25c,
    spr25d,
    spr25e,
    spr25f,
    spr260,
    spr261,
    spr262,
    spr263,
    spr264,
    spr265,
    spr266,
    spr267,
    spr268,
    spr269,
    spr26a,
    spr26b,
    spr26c,
    spr26d,
    spr26e,
    spr26f,
    spr270,
    spr271,
    spr272,
    spr273,
    spr274,
    spr275,
    spr276,
    spr277,
    spr278,
    spr279,
    spr27a,
    spr27b,
    spr27c,
    spr27d,
    spr27e,
    spr27f,
    spr280,
    spr281,
    spr282,
    spr283,
    spr284,
    spr285,
    spr286,
    spr287,
    spr288,
    spr289,
    spr28a,
    spr28b,
    spr28c,
    spr28d,
    spr28e,
    spr28f,
    spr290,
    spr291,
    spr292,
    spr293,
    spr294,
    spr295,
    spr296,
    spr297,
    spr298,
    spr299,
    spr29a,
    spr29b,
    spr29c,
    spr29d,
    spr29e,
    spr29f,
    spr2a0,
    spr2a1,
    spr2a2,
    spr2a3,
    spr2a4,
    spr2a5,
    spr2a6,
    spr2a7,
    spr2a8,
    spr2a9,
    spr2aa,
    spr2ab,
    spr2ac,
    spr2ad,
    spr2ae,
    spr2af,
    spr2b0,
    spr2b1,
    spr2b2,
    spr2b3,
    spr2b4,
    spr2b5,
    spr2b6,
    spr2b7,
    spr2b8,
    spr2b9,
    spr2ba,
    spr2bb,
    spr2bc,
    spr2bd,
    spr2be,
    spr2bf,
    spr2c0,
    spr2c1,
    spr2c2,
    spr2c3,
    spr2c4,
    spr2c5,
    spr2c6,
    spr2c7,
    spr2c8,
    spr2c9,
    spr2ca,
    spr2cb,
    spr2cc,
    spr2cd,
    spr2ce,
    spr2cf,
    spr2d0,
    spr2d1,
    spr2d2,
    spr2d3,
    spr2d4,
    spr2d5,
    spr2d6,
    spr2d7,
    spr2d8,
    spr2d9,
    spr2da,
    spr2db,
    spr2dc,
    spr2dd,
    spr2de,
    spr2df,
    spr2e0,
    spr2e1,
    spr2e2,
    spr2e3,
    spr2e4,
    spr2e5,
    spr2e6,
    spr2e7,
    spr2e8,
    spr2e9,
    spr2ea,
    spr2eb,
    spr2ec,
    spr2ed,
    spr2ee,
    spr2ef,
    spr2f0,
    spr2f1,
    spr2f2,
    spr2f3,
    spr2f4,
    spr2f5,
    spr2f6,
    spr2f7,
    spr2f8,
    spr2f9,
    spr2fa,
    spr2fb,
    spr2fc,
    spr2fd,
    spr2fe,
    spr2ff,
    spr300,
    spr301,
    spr302,
    spr303,
    spr304,
    spr305,
    spr306,
    spr307,
    spr308,
    spr309,
    spr30a,
    spr30b,
    spr30c,
    spr30d,
    spr30e,
    spr30f,
    spr310,
    spr311,
    spr312,
    spr313,
    spr314,
    spr315,
    spr316,
    spr317,
    spr318,
    spr319,
    spr31a,
    spr31b,
    spr31c,
    spr31d,
    spr31e,
    spr31f,
    spr320,
    spr321,
    spr322,
    spr323,
    spr324,
    spr325,
    spr326,
    spr327,
    spr328,
    spr329,
    spr32a,
    spr32b,
    spr32c,
    spr32d,
    spr32e,
    TAR,
    spr330,
    spr331,
    spr332,
    spr333,
    spr334,
    spr335,
    spr336,
    spr337,
    spr338,
    spr339,
    spr33a,
    spr33b,
    spr33c,
    spr33d,
    spr33e,
    spr33f,
    spr340,
    spr341,
    spr342,
    spr343,
    spr344,
    spr345,
    spr346,
    spr347,
    spr348,
    spr349,
    spr34a,
    spr34b,
    spr34c,
    spr34d,
    spr34e,
    spr34f,
    spr350,
    spr351,
    spr352,
    spr353,
    spr354,
    spr355,
    spr356,
    spr357,
    spr358,
    spr359,
    spr35a,
    spr35b,
    spr35c,
    spr35d,
    spr35e,
    spr35f,
    spr360,
    spr361,
    spr362,
    spr363,
    spr364,
    spr365,
    spr366,
    spr367,
    spr368,
    spr369,
    spr36a,
    spr36b,
    spr36c,
    spr36d,
    spr36e,
    spr36f,
    spr370,
    spr371,
    spr372,
    spr373,
    spr374,
    spr375,
    spr376,
    spr377,
    spr378,
    spr379,
    spr37a,
    spr37b,
    spr37c,
    spr37d,
    spr37e,
    spr37f,
    spr380,
    spr381,
    spr382,
    spr383,
    spr384,
    spr385,
    spr386,
    spr387,
    spr388,
    spr389,
    spr38a,
    spr38b,
    spr38c,
    spr38d,
    spr38e,
    spr38f,
    spr390,
    spr391,
    spr392,
    spr393,
    spr394,
    spr395,
    spr396,
    spr397,
    spr398,
    spr399,
    spr39a,
    spr39b,
    spr39c,
    spr39d,
    spr39e,
    spr39f,
    spr3a0,
    spr3a1,
    spr3a2,
    spr3a3,
    spr3a4,
    spr3a5,
    spr3a6,
    spr3a7,
    spr3a8,
    spr3a9,
    spr3aa,
    spr3ab,
    spr3ac,
    spr3ad,
    spr3ae,
    spr3af,
    spr3b0,
    spr3b1,
    spr3b2,
    spr3b3,
    spr3b4,
    spr3b5,
    spr3b6,
    spr3b7,
    spr3b8,
    spr3b9,
    spr3ba,
    spr3bb,
    spr3bc,
    spr3bd,
    spr3be,
    spr3bf,
    spr3c0,
    spr3c1,
    spr3c2,
    spr3c3,
    spr3c4,
    spr3c5,
    spr3c6,
    spr3c7,
    spr3c8,
    spr3c9,
    spr3ca,
    spr3cb,
    spr3cc,
    spr3cd,
    spr3ce,
    spr3cf,
    spr3d0,
    spr3d1,
    spr3d2,
    spr3d3,
    spr3d4,
    spr3d5,
    spr3d6,
    spr3d7,
    spr3d8,
    spr3d9,
    spr3da,
    spr3db,
    spr3dc,
    spr3dd,
    spr3de,
    spr3df,
    spr3e0,
    spr3e1,
    spr3e2,
    spr3e3,
    spr3e4,
    spr3e5,
    spr3e6,
    spr3e7,
    spr3e8,
    spr3e9,
    spr3ea,
    spr3eb,
    spr3ec,
    spr3ed,
    spr3ee,
    spr3ef,
    spr3f0,
    spr3f1,
    spr3f2,
    spr3f3,
    spr3f4,
    spr3f5,
    spr3f6,
    spr3f7,
    spr3f8,
    spr3f9,
    spr3fa,
    spr3fb,
    spr3fc,
    spr3fd,
    spr3fe,
    spr3ff,
    vs0,
    vs1,
    vs2,
    vs3,
    vs4,
    vs5,
    vs6,
    vs7,
    vs8,
    vs9,
    vs10,
    vs11,
    vs12,
    vs13,
    vs14,
    vs15,
    vs16,
    vs17,
    vs18,
    vs19,
    vs20,
    vs21,
    vs22,
    vs23,
    vs24,
    vs25,
    vs26,
    vs27,
    vs28,
    vs29,
    vs30,
    vs31,
    vs32,
    vs33,
    vs34,
    vs35,
    vs36,
    vs37,
    vs38,
    vs39,
    vs40,
    vs41,
    vs42,
    vs43,
    vs44,
    vs45,
    vs46,
    vs47,
    vs48,
    vs49,
    vs50,
    vs51,
    vs52,
    vs53,
    vs54,
    vs55,
    vs56,
    vs57,
    vs58,
    vs59,
    vs60,
    vs61,
    vs62,
    vs63,
    f0,
    f1,
    f2,
    f3,
    f4,
    f5,
    f6,
    f7,
    f8,
    f9,
    f10,
    f11,
    f12,
    f13,
    f14,
    f15,
    f16,
    f17,
    f18,
    f19,
    f20,
    f21,
    f22,
    f23,
    f24,
    f25,
    f26,
    f27,
    f28,
    f29,
    f30,
    f31,
    vr0_64_1,
    vr0_64_0,
    vr1_64_1,
    vr1_64_0,
    vr2_64_1,
    vr2_64_0,
    vr3_64_1,
    vr3_64_0,
    vr4_64_1,
    vr4_64_0,
    vr5_64_1,
    vr5_64_0,
    vr6_64_1,
    vr6_64_0,
    vr7_64_1,
    vr7_64_0,
    vr8_64_1,
    vr8_64_0,
    vr9_64_1,
    vr9_64_0,
    vr10_64_1,
    vr10_64_0,
    vr11_64_1,
    vr11_64_0,
    vr12_64_1,
    vr12_64_0,
    vr13_64_1,
    vr13_64_0,
    vr14_64_1,
    vr14_64_0,
    vr15_64_1,
    vr15_64_0,
    vr16_64_1,
    vr16_64_0,
    vr17_64_1,
    vr17_64_0,
    vr18_64_1,
    vr18_64_0,
    vr19_64_1,
    vr19_64_0,
    vr20_64_1,
    vr20_64_0,
    vr21_64_1,
    vr21_64_0,
    vr22_64_1,
    vr22_64_0,
    vr23_64_1,
    vr23_64_0,
    vr24_64_1,
    vr24_64_0,
    vr25_64_1,
    vr25_64_0,
    vr26_64_1,
    vr26_64_0,
    vr27_64_1,
    vr27_64_0,
    vr28_64_1,
    vr28_64_0,
    vr29_64_1,
    vr29_64_0,
    vr30_64_1,
    vr30_64_0,
    vr31_64_1,
    vr31_64_0,
    vr0_32_3,
    vr0_32_2,
    vr0_32_1,
    vr0_32_0,
    vr1_32_3,
    vr1_32_2,
    vr1_32_1,
    vr1_32_0,
    vr2_32_3,
    vr2_32_2,
    vr2_32_1,
    vr2_32_0,
    vr3_32_3,
    vr3_32_2,
    vr3_32_1,
    vr3_32_0,
    vr4_32_3,
    vr4_32_2,
    vr4_32_1,
    vr4_32_0,
    vr5_32_3,
    vr5_32_2,
    vr5_32_1,
    vr5_32_0,
    vr6_32_3,
    vr6_32_2,
    vr6_32_1,
    vr6_32_0,
    vr7_32_3,
    vr7_32_2,
    vr7_32_1,
    vr7_32_0,
    vr8_32_3,
    vr8_32_2,
    vr8_32_1,
    vr8_32_0,
    vr9_32_3,
    vr9_32_2,
    vr9_32_1,
    vr9_32_0,
    vr10_32_3,
    vr10_32_2,
    vr10_32_1,
    vr10_32_0,
    vr11_32_3,
    vr11_32_2,
    vr11_32_1,
    vr11_32_0,
    vr12_32_3,
    vr12_32_2,
    vr12_32_1,
    vr12_32_0,
    vr13_32_3,
    vr13_32_2,
    vr13_32_1,
    vr13_32_0,
    vr14_32_3,
    vr14_32_2,
    vr14_32_1,
    vr14_32_0,
    vr15_32_3,
    vr15_32_2,
    vr15_32_1,
    vr15_32_0,
    vr16_32_3,
    vr16_32_2,
    vr16_32_1,
    vr16_32_0,
    vr17_32_3,
    vr17_32_2,
    vr17_32_1,
    vr17_32_0,
    vr18_32_3,
    vr18_32_2,
    vr18_32_1,
    vr18_32_0,
    vr19_32_3,
    vr19_32_2,
    vr19_32_1,
    vr19_32_0,
    vr20_32_3,
    vr20_32_2,
    vr20_32_1,
    vr20_32_0,
    vr21_32_3,
    vr21_32_2,
    vr21_32_1,
    vr21_32_0,
    vr22_32_3,
    vr22_32_2,
    vr22_32_1,
    vr22_32_0,
    vr23_32_3,
    vr23_32_2,
    vr23_32_1,
    vr23_32_0,
    vr24_32_3,
    vr24_32_2,
    vr24_32_1,
    vr24_32_0,
    vr25_32_3,
    vr25_32_2,
    vr25_32_1,
    vr25_32_0,
    vr26_32_3,
    vr26_32_2,
    vr26_32_1,
    vr26_32_0,
    vr27_32_3,
    vr27_32_2,
    vr27_32_1,
    vr27_32_0,
    vr28_32_3,
    vr28_32_2,
    vr28_32_1,
    vr28_32_0,
    vr29_32_3,
    vr29_32_2,
    vr29_32_1,
    vr29_32_0,
    vr30_32_3,
    vr30_32_2,
    vr30_32_1,
    vr30_32_0,
    vr31_32_3,
    vr31_32_2,
    vr31_32_1,
    vr31_32_0,
    vr0_16_7,
    vr0_16_6,
    vr0_16_5,
    vr0_16_4,
    vr0_16_3,
    vr0_16_2,
    vr0_16_1,
    vr0_16_0,
    vr1_16_7,
    vr1_16_6,
    vr1_16_5,
    vr1_16_4,
    vr1_16_3,
    vr1_16_2,
    vr1_16_1,
    vr1_16_0,
    vr2_16_7,
    vr2_16_6,
    vr2_16_5,
    vr2_16_4,
    vr2_16_3,
    vr2_16_2,
    vr2_16_1,
    vr2_16_0,
    vr3_16_7,
    vr3_16_6,
    vr3_16_5,
    vr3_16_4,
    vr3_16_3,
    vr3_16_2,
    vr3_16_1,
    vr3_16_0,
    vr4_16_7,
    vr4_16_6,
    vr4_16_5,
    vr4_16_4,
    vr4_16_3,
    vr4_16_2,
    vr4_16_1,
    vr4_16_0,
    vr5_16_7,
    vr5_16_6,
    vr5_16_5,
    vr5_16_4,
    vr5_16_3,
    vr5_16_2,
    vr5_16_1,
    vr5_16_0,
    vr6_16_7,
    vr6_16_6,
    vr6_16_5,
    vr6_16_4,
    vr6_16_3,
    vr6_16_2,
    vr6_16_1,
    vr6_16_0,
    vr7_16_7,
    vr7_16_6,
    vr7_16_5,
    vr7_16_4,
    vr7_16_3,
    vr7_16_2,
    vr7_16_1,
    vr7_16_0,
    vr8_16_7,
    vr8_16_6,
    vr8_16_5,
    vr8_16_4,
    vr8_16_3,
    vr8_16_2,
    vr8_16_1,
    vr8_16_0,
    vr9_16_7,
    vr9_16_6,
    vr9_16_5,
    vr9_16_4,
    vr9_16_3,
    vr9_16_2,
    vr9_16_1,
    vr9_16_0,
    vr10_16_7,
    vr10_16_6,
    vr10_16_5,
    vr10_16_4,
    vr10_16_3,
    vr10_16_2,
    vr10_16_1,
    vr10_16_0,
    vr11_16_7,
    vr11_16_6,
    vr11_16_5,
    vr11_16_4,
    vr11_16_3,
    vr11_16_2,
    vr11_16_1,
    vr11_16_0,
    vr12_16_7,
    vr12_16_6,
    vr12_16_5,
    vr12_16_4,
    vr12_16_3,
    vr12_16_2,
    vr12_16_1,
    vr12_16_0,
    vr13_16_7,
    vr13_16_6,
    vr13_16_5,
    vr13_16_4,
    vr13_16_3,
    vr13_16_2,
    vr13_16_1,
    vr13_16_0,
    vr14_16_7,
    vr14_16_6,
    vr14_16_5,
    vr14_16_4,
    vr14_16_3,
    vr14_16_2,
    vr14_16_1,
    vr14_16_0,
    vr15_16_7,
    vr15_16_6,
    vr15_16_5,
    vr15_16_4,
    vr15_16_3,
    vr15_16_2,
    vr15_16_1,
    vr15_16_0,
    vr16_16_7,
    vr16_16_6,
    vr16_16_5,
    vr16_16_4,
    vr16_16_3,
    vr16_16_2,
    vr16_16_1,
    vr16_16_0,
    vr17_16_7,
    vr17_16_6,
    vr17_16_5,
    vr17_16_4,
    vr17_16_3,
    vr17_16_2,
    vr17_16_1,
    vr17_16_0,
    vr18_16_7,
    vr18_16_6,
    vr18_16_5,
    vr18_16_4,
    vr18_16_3,
    vr18_16_2,
    vr18_16_1,
    vr18_16_0,
    vr19_16_7,
    vr19_16_6,
    vr19_16_5,
    vr19_16_4,
    vr19_16_3,
    vr19_16_2,
    vr19_16_1,
    vr19_16_0,
    vr20_16_7,
    vr20_16_6,
    vr20_16_5,
    vr20_16_4,
    vr20_16_3,
    vr20_16_2,
    vr20_16_1,
    vr20_16_0,
    vr21_16_7,
    vr21_16_6,
    vr21_16_5,
    vr21_16_4,
    vr21_16_3,
    vr21_16_2,
    vr21_16_1,
    vr21_16_0,
    vr22_16_7,
    vr22_16_6,
    vr22_16_5,
    vr22_16_4,
    vr22_16_3,
    vr22_16_2,
    vr22_16_1,
    vr22_16_0,
    vr23_16_7,
    vr23_16_6,
    vr23_16_5,
    vr23_16_4,
    vr23_16_3,
    vr23_16_2,
    vr23_16_1,
    vr23_16_0,
    vr24_16_7,
    vr24_16_6,
    vr24_16_5,
    vr24_16_4,
    vr24_16_3,
    vr24_16_2,
    vr24_16_1,
    vr24_16_0,
    vr25_16_7,
    vr25_16_6,
    vr25_16_5,
    vr25_16_4,
    vr25_16_3,
    vr25_16_2,
    vr25_16_1,
    vr25_16_0,
    vr26_16_7,
    vr26_16_6,
    vr26_16_5,
    vr26_16_4,
    vr26_16_3,
    vr26_16_2,
    vr26_16_1,
    vr26_16_0,
    vr27_16_7,
    vr27_16_6,
    vr27_16_5,
    vr27_16_4,
    vr27_16_3,
    vr27_16_2,
    vr27_16_1,
    vr27_16_0,
    vr28_16_7,
    vr28_16_6,
    vr28_16_5,
    vr28_16_4,
    vr28_16_3,
    vr28_16_2,
    vr28_16_1,
    vr28_16_0,
    vr29_16_7,
    vr29_16_6,
    vr29_16_5,
    vr29_16_4,
    vr29_16_3,
    vr29_16_2,
    vr29_16_1,
    vr29_16_0,
    vr30_16_7,
    vr30_16_6,
    vr30_16_5,
    vr30_16_4,
    vr30_16_3,
    vr30_16_2,
    vr30_16_1,
    vr30_16_0,
    vr31_16_7,
    vr31_16_6,
    vr31_16_5,
    vr31_16_4,
    vr31_16_3,
    vr31_16_2,
    vr31_16_1,
    vr31_16_0,
    vr0_8_15,
    vr0_8_14,
    vr0_8_13,
    vr0_8_12,
    vr0_8_11,
    vr0_8_10,
    vr0_8_9,
    vr0_8_8,
    vr0_8_7,
    vr0_8_6,
    vr0_8_5,
    vr0_8_4,
    vr0_8_3,
    vr0_8_2,
    vr0_8_1,
    vr0_8_0,
    vr1_8_15,
    vr1_8_14,
    vr1_8_13,
    vr1_8_12,
    vr1_8_11,
    vr1_8_10,
    vr1_8_9,
    vr1_8_8,
    vr1_8_7,
    vr1_8_6,
    vr1_8_5,
    vr1_8_4,
    vr1_8_3,
    vr1_8_2,
    vr1_8_1,
    vr1_8_0,
    vr2_8_15,
    vr2_8_14,
    vr2_8_13,
    vr2_8_12,
    vr2_8_11,
    vr2_8_10,
    vr2_8_9,
    vr2_8_8,
    vr2_8_7,
    vr2_8_6,
    vr2_8_5,
    vr2_8_4,
    vr2_8_3,
    vr2_8_2,
    vr2_8_1,
    vr2_8_0,
    vr3_8_15,
    vr3_8_14,
    vr3_8_13,
    vr3_8_12,
    vr3_8_11,
    vr3_8_10,
    vr3_8_9,
    vr3_8_8,
    vr3_8_7,
    vr3_8_6,
    vr3_8_5,
    vr3_8_4,
    vr3_8_3,
    vr3_8_2,
    vr3_8_1,
    vr3_8_0,
    vr4_8_15,
    vr4_8_14,
    vr4_8_13,
    vr4_8_12,
    vr4_8_11,
    vr4_8_10,
    vr4_8_9,
    vr4_8_8,
    vr4_8_7,
    vr4_8_6,
    vr4_8_5,
    vr4_8_4,
    vr4_8_3,
    vr4_8_2,
    vr4_8_1,
    vr4_8_0,
    vr5_8_15,
    vr5_8_14,
    vr5_8_13,
    vr5_8_12,
    vr5_8_11,
    vr5_8_10,
    vr5_8_9,
    vr5_8_8,
    vr5_8_7,
    vr5_8_6,
    vr5_8_5,
    vr5_8_4,
    vr5_8_3,
    vr5_8_2,
    vr5_8_1,
    vr5_8_0,
    vr6_8_15,
    vr6_8_14,
    vr6_8_13,
    vr6_8_12,
    vr6_8_11,
    vr6_8_10,
    vr6_8_9,
    vr6_8_8,
    vr6_8_7,
    vr6_8_6,
    vr6_8_5,
    vr6_8_4,
    vr6_8_3,
    vr6_8_2,
    vr6_8_1,
    vr6_8_0,
    vr7_8_15,
    vr7_8_14,
    vr7_8_13,
    vr7_8_12,
    vr7_8_11,
    vr7_8_10,
    vr7_8_9,
    vr7_8_8,
    vr7_8_7,
    vr7_8_6,
    vr7_8_5,
    vr7_8_4,
    vr7_8_3,
    vr7_8_2,
    vr7_8_1,
    vr7_8_0,
    vr8_8_15,
    vr8_8_14,
    vr8_8_13,
    vr8_8_12,
    vr8_8_11,
    vr8_8_10,
    vr8_8_9,
    vr8_8_8,
    vr8_8_7,
    vr8_8_6,
    vr8_8_5,
    vr8_8_4,
    vr8_8_3,
    vr8_8_2,
    vr8_8_1,
    vr8_8_0,
    vr9_8_15,
    vr9_8_14,
    vr9_8_13,
    vr9_8_12,
    vr9_8_11,
    vr9_8_10,
    vr9_8_9,
    vr9_8_8,
    vr9_8_7,
    vr9_8_6,
    vr9_8_5,
    vr9_8_4,
    vr9_8_3,
    vr9_8_2,
    vr9_8_1,
    vr9_8_0,
    vr10_8_15,
    vr10_8_14,
    vr10_8_13,
    vr10_8_12,
    vr10_8_11,
    vr10_8_10,
    vr10_8_9,
    vr10_8_8,
    vr10_8_7,
    vr10_8_6,
    vr10_8_5,
    vr10_8_4,
    vr10_8_3,
    vr10_8_2,
    vr10_8_1,
    vr10_8_0,
    vr11_8_15,
    vr11_8_14,
    vr11_8_13,
    vr11_8_12,
    vr11_8_11,
    vr11_8_10,
    vr11_8_9,
    vr11_8_8,
    vr11_8_7,
    vr11_8_6,
    vr11_8_5,
    vr11_8_4,
    vr11_8_3,
    vr11_8_2,
    vr11_8_1,
    vr11_8_0,
    vr12_8_15,
    vr12_8_14,
    vr12_8_13,
    vr12_8_12,
    vr12_8_11,
    vr12_8_10,
    vr12_8_9,
    vr12_8_8,
    vr12_8_7,
    vr12_8_6,
    vr12_8_5,
    vr12_8_4,
    vr12_8_3,
    vr12_8_2,
    vr12_8_1,
    vr12_8_0,
    vr13_8_15,
    vr13_8_14,
    vr13_8_13,
    vr13_8_12,
    vr13_8_11,
    vr13_8_10,
    vr13_8_9,
    vr13_8_8,
    vr13_8_7,
    vr13_8_6,
    vr13_8_5,
    vr13_8_4,
    vr13_8_3,
    vr13_8_2,
    vr13_8_1,
    vr13_8_0,
    vr14_8_15,
    vr14_8_14,
    vr14_8_13,
    vr14_8_12,
    vr14_8_11,
    vr14_8_10,
    vr14_8_9,
    vr14_8_8,
    vr14_8_7,
    vr14_8_6,
    vr14_8_5,
    vr14_8_4,
    vr14_8_3,
    vr14_8_2,
    vr14_8_1,
    vr14_8_0,
    vr15_8_15,
    vr15_8_14,
    vr15_8_13,
    vr15_8_12,
    vr15_8_11,
    vr15_8_10,
    vr15_8_9,
    vr15_8_8,
    vr15_8_7,
    vr15_8_6,
    vr15_8_5,
    vr15_8_4,
    vr15_8_3,
    vr15_8_2,
    vr15_8_1,
    vr15_8_0,
    vr16_8_15,
    vr16_8_14,
    vr16_8_13,
    vr16_8_12,
    vr16_8_11,
    vr16_8_10,
    vr16_8_9,
    vr16_8_8,
    vr16_8_7,
    vr16_8_6,
    vr16_8_5,
    vr16_8_4,
    vr16_8_3,
    vr16_8_2,
    vr16_8_1,
    vr16_8_0,
    vr17_8_15,
    vr17_8_14,
    vr17_8_13,
    vr17_8_12,
    vr17_8_11,
    vr17_8_10,
    vr17_8_9,
    vr17_8_8,
    vr17_8_7,
    vr17_8_6,
    vr17_8_5,
    vr17_8_4,
    vr17_8_3,
    vr17_8_2,
    vr17_8_1,
    vr17_8_0,
    vr18_8_15,
    vr18_8_14,
    vr18_8_13,
    vr18_8_12,
    vr18_8_11,
    vr18_8_10,
    vr18_8_9,
    vr18_8_8,
    vr18_8_7,
    vr18_8_6,
    vr18_8_5,
    vr18_8_4,
    vr18_8_3,
    vr18_8_2,
    vr18_8_1,
    vr18_8_0,
    vr19_8_15,
    vr19_8_14,
    vr19_8_13,
    vr19_8_12,
    vr19_8_11,
    vr19_8_10,
    vr19_8_9,
    vr19_8_8,
    vr19_8_7,
    vr19_8_6,
    vr19_8_5,
    vr19_8_4,
    vr19_8_3,
    vr19_8_2,
    vr19_8_1,
    vr19_8_0,
    vr20_8_15,
    vr20_8_14,
    vr20_8_13,
    vr20_8_12,
    vr20_8_11,
    vr20_8_10,
    vr20_8_9,
    vr20_8_8,
    vr20_8_7,
    vr20_8_6,
    vr20_8_5,
    vr20_8_4,
    vr20_8_3,
    vr20_8_2,
    vr20_8_1,
    vr20_8_0,
    vr21_8_15,
    vr21_8_14,
    vr21_8_13,
    vr21_8_12,
    vr21_8_11,
    vr21_8_10,
    vr21_8_9,
    vr21_8_8,
    vr21_8_7,
    vr21_8_6,
    vr21_8_5,
    vr21_8_4,
    vr21_8_3,
    vr21_8_2,
    vr21_8_1,
    vr21_8_0,
    vr22_8_15,
    vr22_8_14,
    vr22_8_13,
    vr22_8_12,
    vr22_8_11,
    vr22_8_10,
    vr22_8_9,
    vr22_8_8,
    vr22_8_7,
    vr22_8_6,
    vr22_8_5,
    vr22_8_4,
    vr22_8_3,
    vr22_8_2,
    vr22_8_1,
    vr22_8_0,
    vr23_8_15,
    vr23_8_14,
    vr23_8_13,
    vr23_8_12,
    vr23_8_11,
    vr23_8_10,
    vr23_8_9,
    vr23_8_8,
    vr23_8_7,
    vr23_8_6,
    vr23_8_5,
    vr23_8_4,
    vr23_8_3,
    vr23_8_2,
    vr23_8_1,
    vr23_8_0,
    vr24_8_15,
    vr24_8_14,
    vr24_8_13,
    vr24_8_12,
    vr24_8_11,
    vr24_8_10,
    vr24_8_9,
    vr24_8_8,
    vr24_8_7,
    vr24_8_6,
    vr24_8_5,
    vr24_8_4,
    vr24_8_3,
    vr24_8_2,
    vr24_8_1,
    vr24_8_0,
    vr25_8_15,
    vr25_8_14,
    vr25_8_13,
    vr25_8_12,
    vr25_8_11,
    vr25_8_10,
    vr25_8_9,
    vr25_8_8,
    vr25_8_7,
    vr25_8_6,
    vr25_8_5,
    vr25_8_4,
    vr25_8_3,
    vr25_8_2,
    vr25_8_1,
    vr25_8_0,
    vr26_8_15,
    vr26_8_14,
    vr26_8_13,
    vr26_8_12,
    vr26_8_11,
    vr26_8_10,
    vr26_8_9,
    vr26_8_8,
    vr26_8_7,
    vr26_8_6,
    vr26_8_5,
    vr26_8_4,
    vr26_8_3,
    vr26_8_2,
    vr26_8_1,
    vr26_8_0,
    vr27_8_15,
    vr27_8_14,
    vr27_8_13,
    vr27_8_12,
    vr27_8_11,
    vr27_8_10,
    vr27_8_9,
    vr27_8_8,
    vr27_8_7,
    vr27_8_6,
    vr27_8_5,
    vr27_8_4,
    vr27_8_3,
    vr27_8_2,
    vr27_8_1,
    vr27_8_0,
    vr28_8_15,
    vr28_8_14,
    vr28_8_13,
    vr28_8_12,
    vr28_8_11,
    vr28_8_10,
    vr28_8_9,
    vr28_8_8,
    vr28_8_7,
    vr28_8_6,
    vr28_8_5,
    vr28_8_4,
    vr28_8_3,
    vr28_8_2,
    vr28_8_1,
    vr28_8_0,
    vr29_8_15,
    vr29_8_14,
    vr29_8_13,
    vr29_8_12,
    vr29_8_11,
    vr29_8_10,
    vr29_8_9,
    vr29_8_8,
    vr29_8_7,
    vr29_8_6,
    vr29_8_5,
    vr29_8_4,
    vr29_8_3,
    vr29_8_2,
    vr29_8_1,
    vr29_8_0,
    vr30_8_15,
    vr30_8_14,
    vr30_8_13,
    vr30_8_12,
    vr30_8_11,
    vr30_8_10,
    vr30_8_9,
    vr30_8_8,
    vr30_8_7,
    vr30_8_6,
    vr30_8_5,
    vr30_8_4,
    vr30_8_3,
    vr30_8_2,
    vr30_8_1,
    vr30_8_0,
    vr31_8_15,
    vr31_8_14,
    vr31_8_13,
    vr31_8_12,
    vr31_8_11,
    vr31_8_10,
    vr31_8_9,
    vr31_8_8,
    vr31_8_7,
    vr31_8_6,
    vr31_8_5,
    vr31_8_4,
    vr31_8_3,
    vr31_8_2,
    vr31_8_1,
    vr31_8_0,
    contextreg,
    dcr000,
    dcr001,
    dcr002,
    dcr003,
    dcr004,
    dcr005,
    dcr006,
    dcr007,
    dcr008,
    dcr009,
    dcr00a,
    dcr00b,
    dcr00c,
    dcr00d,
    dcr00e,
    dcr00f,
    dcr010,
    dcr011,
    dcr012,
    dcr013,
    dcr014,
    dcr015,
    dcr016,
    dcr017,
    dcr018,
    dcr019,
    dcr01a,
    dcr01b,
    dcr01c,
    dcr01d,
    dcr01e,
    dcr01f,
    dcr020,
    dcr021,
    dcr022,
    dcr023,
    dcr024,
    dcr025,
    dcr026,
    dcr027,
    dcr028,
    dcr029,
    dcr02a,
    dcr02b,
    dcr02c,
    dcr02d,
    dcr02e,
    dcr02f,
    dcr030,
    dcr031,
    dcr032,
    dcr033,
    dcr034,
    dcr035,
    dcr036,
    dcr037,
    dcr038,
    dcr039,
    dcr03a,
    dcr03b,
    dcr03c,
    dcr03d,
    dcr03e,
    dcr03f,
    dcr040,
    dcr041,
    dcr042,
    dcr043,
    dcr044,
    dcr045,
    dcr046,
    dcr047,
    dcr048,
    dcr049,
    dcr04a,
    dcr04b,
    dcr04c,
    dcr04d,
    dcr04e,
    dcr04f,
    dcr050,
    dcr051,
    dcr052,
    dcr053,
    dcr054,
    dcr055,
    dcr056,
    dcr057,
    dcr058,
    dcr059,
    dcr05a,
    dcr05b,
    dcr05c,
    dcr05d,
    dcr05e,
    dcr05f,
    dcr060,
    dcr061,
    dcr062,
    dcr063,
    dcr064,
    dcr065,
    dcr066,
    dcr067,
    dcr068,
    dcr069,
    dcr06a,
    dcr06b,
    dcr06c,
    dcr06d,
    dcr06e,
    dcr06f,
    dcr070,
    dcr071,
    dcr072,
    dcr073,
    dcr074,
    dcr075,
    dcr076,
    dcr077,
    dcr078,
    dcr079,
    dcr07a,
    dcr07b,
    dcr07c,
    dcr07d,
    dcr07e,
    dcr07f,
    dcr080,
    dcr081,
    dcr082,
    dcr083,
    dcr084,
    dcr085,
    dcr086,
    dcr087,
    dcr088,
    dcr089,
    dcr08a,
    dcr08b,
    dcr08c,
    dcr08d,
    dcr08e,
    dcr08f,
    dcr090,
    dcr091,
    dcr092,
    dcr093,
    dcr094,
    dcr095,
    dcr096,
    dcr097,
    dcr098,
    dcr099,
    dcr09a,
    dcr09b,
    dcr09c,
    dcr09d,
    dcr09e,
    dcr09f,
    dcr0a0,
    dcr0a1,
    dcr0a2,
    dcr0a3,
    dcr0a4,
    dcr0a5,
    dcr0a6,
    dcr0a7,
    dcr0a8,
    dcr0a9,
    dcr0aa,
    dcr0ab,
    dcr0ac,
    dcr0ad,
    dcr0ae,
    dcr0af,
    dcr0b0,
    dcr0b1,
    dcr0b2,
    dcr0b3,
    dcr0b4,
    dcr0b5,
    dcr0b6,
    dcr0b7,
    dcr0b8,
    dcr0b9,
    dcr0ba,
    dcr0bb,
    dcr0bc,
    dcr0bd,
    dcr0be,
    dcr0bf,
    dcr0c0,
    dcr0c1,
    dcr0c2,
    dcr0c3,
    dcr0c4,
    dcr0c5,
    dcr0c6,
    dcr0c7,
    dcr0c8,
    dcr0c9,
    dcr0ca,
    dcr0cb,
    dcr0cc,
    dcr0cd,
    dcr0ce,
    dcr0cf,
    dcr0d0,
    dcr0d1,
    dcr0d2,
    dcr0d3,
    dcr0d4,
    dcr0d5,
    dcr0d6,
    dcr0d7,
    dcr0d8,
    dcr0d9,
    dcr0da,
    dcr0db,
    dcr0dc,
    dcr0dd,
    dcr0de,
    dcr0df,
    dcr0e0,
    dcr0e1,
    dcr0e2,
    dcr0e3,
    dcr0e4,
    dcr0e5,
    dcr0e6,
    dcr0e7,
    dcr0e8,
    dcr0e9,
    dcr0ea,
    dcr0eb,
    dcr0ec,
    dcr0ed,
    dcr0ee,
    dcr0ef,
    dcr0f0,
    dcr0f1,
    dcr0f2,
    dcr0f3,
    dcr0f4,
    dcr0f5,
    dcr0f6,
    dcr0f7,
    dcr0f8,
    dcr0f9,
    dcr0fa,
    dcr0fb,
    dcr0fc,
    dcr0fd,
    dcr0fe,
    dcr0ff,
    dcr100,
    dcr101,
    dcr102,
    dcr103,
    dcr104,
    dcr105,
    dcr106,
    dcr107,
    dcr108,
    dcr109,
    dcr10a,
    dcr10b,
    dcr10c,
    dcr10d,
    dcr10e,
    dcr10f,
    dcr110,
    dcr111,
    dcr112,
    dcr113,
    dcr114,
    dcr115,
    dcr116,
    dcr117,
    dcr118,
    dcr119,
    dcr11a,
    dcr11b,
    dcr11c,
    dcr11d,
    dcr11e,
    dcr11f,
    dcr120,
    dcr121,
    dcr122,
    dcr123,
    dcr124,
    dcr125,
    dcr126,
    dcr127,
    dcr128,
    dcr129,
    dcr12a,
    dcr12b,
    dcr12c,
    dcr12d,
    dcr12e,
    dcr12f,
    dcr130,
    dcr131,
    dcr132,
    dcr133,
    dcr134,
    dcr135,
    dcr136,
    dcr137,
    dcr138,
    dcr139,
    dcr13a,
    dcr13b,
    dcr13c,
    dcr13d,
    dcr13e,
    dcr13f,
    dcr140,
    dcr141,
    dcr142,
    dcr143,
    dcr144,
    dcr145,
    dcr146,
    dcr147,
    dcr148,
    dcr149,
    dcr14a,
    dcr14b,
    dcr14c,
    dcr14d,
    dcr14e,
    dcr14f,
    dcr150,
    dcr151,
    dcr152,
    dcr153,
    dcr154,
    dcr155,
    dcr156,
    dcr157,
    dcr158,
    dcr159,
    dcr15a,
    dcr15b,
    dcr15c,
    dcr15d,
    dcr15e,
    dcr15f,
    dcr160,
    dcr161,
    dcr162,
    dcr163,
    dcr164,
    dcr165,
    dcr166,
    dcr167,
    dcr168,
    dcr169,
    dcr16a,
    dcr16b,
    dcr16c,
    dcr16d,
    dcr16e,
    dcr16f,
    dcr170,
    dcr171,
    dcr172,
    dcr173,
    dcr174,
    dcr175,
    dcr176,
    dcr177,
    dcr178,
    dcr179,
    dcr17a,
    dcr17b,
    dcr17c,
    dcr17d,
    dcr17e,
    dcr17f,
    dcr180,
    dcr181,
    dcr182,
    dcr183,
    dcr184,
    dcr185,
    dcr186,
    dcr187,
    dcr188,
    dcr189,
    dcr18a,
    dcr18b,
    dcr18c,
    dcr18d,
    dcr18e,
    dcr18f,
    dcr190,
    dcr191,
    dcr192,
    dcr193,
    dcr194,
    dcr195,
    dcr196,
    dcr197,
    dcr198,
    dcr199,
    dcr19a,
    dcr19b,
    dcr19c,
    dcr19d,
    dcr19e,
    dcr19f,
    dcr1a0,
    dcr1a1,
    dcr1a2,
    dcr1a3,
    dcr1a4,
    dcr1a5,
    dcr1a6,
    dcr1a7,
    dcr1a8,
    dcr1a9,
    dcr1aa,
    dcr1ab,
    dcr1ac,
    dcr1ad,
    dcr1ae,
    dcr1af,
    dcr1b0,
    dcr1b1,
    dcr1b2,
    dcr1b3,
    dcr1b4,
    dcr1b5,
    dcr1b6,
    dcr1b7,
    dcr1b8,
    dcr1b9,
    dcr1ba,
    dcr1bb,
    dcr1bc,
    dcr1bd,
    dcr1be,
    dcr1bf,
    dcr1c0,
    dcr1c1,
    dcr1c2,
    dcr1c3,
    dcr1c4,
    dcr1c5,
    dcr1c6,
    dcr1c7,
    dcr1c8,
    dcr1c9,
    dcr1ca,
    dcr1cb,
    dcr1cc,
    dcr1cd,
    dcr1ce,
    dcr1cf,
    dcr1d0,
    dcr1d1,
    dcr1d2,
    dcr1d3,
    dcr1d4,
    dcr1d5,
    dcr1d6,
    dcr1d7,
    dcr1d8,
    dcr1d9,
    dcr1da,
    dcr1db,
    dcr1dc,
    dcr1dd,
    dcr1de,
    dcr1df,
    dcr1e0,
    dcr1e1,
    dcr1e2,
    dcr1e3,
    dcr1e4,
    dcr1e5,
    dcr1e6,
    dcr1e7,
    dcr1e8,
    dcr1e9,
    dcr1ea,
    dcr1eb,
    dcr1ec,
    dcr1ed,
    dcr1ee,
    dcr1ef,
    dcr1f0,
    dcr1f1,
    dcr1f2,
    dcr1f3,
    dcr1f4,
    dcr1f5,
    dcr1f6,
    dcr1f7,
    dcr1f8,
    dcr1f9,
    dcr1fa,
    dcr1fb,
    dcr1fc,
    dcr1fd,
    dcr1fe,
    dcr1ff,
    dcr200,
    dcr201,
    dcr202,
    dcr203,
    dcr204,
    dcr205,
    dcr206,
    dcr207,
    dcr208,
    dcr209,
    dcr20a,
    dcr20b,
    dcr20c,
    dcr20d,
    dcr20e,
    dcr20f,
    dcr210,
    dcr211,
    dcr212,
    dcr213,
    dcr214,
    dcr215,
    dcr216,
    dcr217,
    dcr218,
    dcr219,
    dcr21a,
    dcr21b,
    dcr21c,
    dcr21d,
    dcr21e,
    dcr21f,
    dcr220,
    dcr221,
    dcr222,
    dcr223,
    dcr224,
    dcr225,
    dcr226,
    dcr227,
    dcr228,
    dcr229,
    dcr22a,
    dcr22b,
    dcr22c,
    dcr22d,
    dcr22e,
    dcr22f,
    dcr230,
    dcr231,
    dcr232,
    dcr233,
    dcr234,
    dcr235,
    dcr236,
    dcr237,
    dcr238,
    dcr239,
    dcr23a,
    dcr23b,
    dcr23c,
    dcr23d,
    dcr23e,
    dcr23f,
    dcr240,
    dcr241,
    dcr242,
    dcr243,
    dcr244,
    dcr245,
    dcr246,
    dcr247,
    dcr248,
    dcr249,
    dcr24a,
    dcr24b,
    dcr24c,
    dcr24d,
    dcr24e,
    dcr24f,
    dcr250,
    dcr251,
    dcr252,
    dcr253,
    dcr254,
    dcr255,
    dcr256,
    dcr257,
    dcr258,
    dcr259,
    dcr25a,
    dcr25b,
    dcr25c,
    dcr25d,
    dcr25e,
    dcr25f,
    dcr260,
    dcr261,
    dcr262,
    dcr263,
    dcr264,
    dcr265,
    dcr266,
    dcr267,
    dcr268,
    dcr269,
    dcr26a,
    dcr26b,
    dcr26c,
    dcr26d,
    dcr26e,
    dcr26f,
    dcr270,
    dcr271,
    dcr272,
    dcr273,
    dcr274,
    dcr275,
    dcr276,
    dcr277,
    dcr278,
    dcr279,
    dcr27a,
    dcr27b,
    dcr27c,
    dcr27d,
    dcr27e,
    dcr27f,
    dcr280,
    dcr281,
    dcr282,
    dcr283,
    dcr284,
    dcr285,
    dcr286,
    dcr287,
    dcr288,
    dcr289,
    dcr28a,
    dcr28b,
    dcr28c,
    dcr28d,
    dcr28e,
    dcr28f,
    dcr290,
    dcr291,
    dcr292,
    dcr293,
    dcr294,
    dcr295,
    dcr296,
    dcr297,
    dcr298,
    dcr299,
    dcr29a,
    dcr29b,
    dcr29c,
    dcr29d,
    dcr29e,
    dcr29f,
    dcr2a0,
    dcr2a1,
    dcr2a2,
    dcr2a3,
    dcr2a4,
    dcr2a5,
    dcr2a6,
    dcr2a7,
    dcr2a8,
    dcr2a9,
    dcr2aa,
    dcr2ab,
    dcr2ac,
    dcr2ad,
    dcr2ae,
    dcr2af,
    dcr2b0,
    dcr2b1,
    dcr2b2,
    dcr2b3,
    dcr2b4,
    dcr2b5,
    dcr2b6,
    dcr2b7,
    dcr2b8,
    dcr2b9,
    dcr2ba,
    dcr2bb,
    dcr2bc,
    dcr2bd,
    dcr2be,
    dcr2bf,
    dcr2c0,
    dcr2c1,
    dcr2c2,
    dcr2c3,
    dcr2c4,
    dcr2c5,
    dcr2c6,
    dcr2c7,
    dcr2c8,
    dcr2c9,
    dcr2ca,
    dcr2cb,
    dcr2cc,
    dcr2cd,
    dcr2ce,
    dcr2cf,
    dcr2d0,
    dcr2d1,
    dcr2d2,
    dcr2d3,
    dcr2d4,
    dcr2d5,
    dcr2d6,
    dcr2d7,
    dcr2d8,
    dcr2d9,
    dcr2da,
    dcr2db,
    dcr2dc,
    dcr2dd,
    dcr2de,
    dcr2df,
    dcr2e0,
    dcr2e1,
    dcr2e2,
    dcr2e3,
    dcr2e4,
    dcr2e5,
    dcr2e6,
    dcr2e7,
    dcr2e8,
    dcr2e9,
    dcr2ea,
    dcr2eb,
    dcr2ec,
    dcr2ed,
    dcr2ee,
    dcr2ef,
    dcr2f0,
    dcr2f1,
    dcr2f2,
    dcr2f3,
    dcr2f4,
    dcr2f5,
    dcr2f6,
    dcr2f7,
    dcr2f8,
    dcr2f9,
    dcr2fa,
    dcr2fb,
    dcr2fc,
    dcr2fd,
    dcr2fe,
    dcr2ff,
    dcr300,
    dcr301,
    dcr302,
    dcr303,
    dcr304,
    dcr305,
    dcr306,
    dcr307,
    dcr308,
    dcr309,
    dcr30a,
    dcr30b,
    dcr30c,
    dcr30d,
    dcr30e,
    dcr30f,
    dcr310,
    dcr311,
    dcr312,
    dcr313,
    dcr314,
    dcr315,
    dcr316,
    dcr317,
    dcr318,
    dcr319,
    dcr31a,
    dcr31b,
    dcr31c,
    dcr31d,
    dcr31e,
    dcr31f,
    dcr320,
    dcr321,
    dcr322,
    dcr323,
    dcr324,
    dcr325,
    dcr326,
    dcr327,
    dcr328,
    dcr329,
    dcr32a,
    dcr32b,
    dcr32c,
    dcr32d,
    dcr32e,
    dcr32f,
    dcr330,
    dcr331,
    dcr332,
    dcr333,
    dcr334,
    dcr335,
    dcr336,
    dcr337,
    dcr338,
    dcr339,
    dcr33a,
    dcr33b,
    dcr33c,
    dcr33d,
    dcr33e,
    dcr33f,
    dcr340,
    dcr341,
    dcr342,
    dcr343,
    dcr344,
    dcr345,
    dcr346,
    dcr347,
    dcr348,
    dcr349,
    dcr34a,
    dcr34b,
    dcr34c,
    dcr34d,
    dcr34e,
    dcr34f,
    dcr350,
    dcr351,
    dcr352,
    dcr353,
    dcr354,
    dcr355,
    dcr356,
    dcr357,
    dcr358,
    dcr359,
    dcr35a,
    dcr35b,
    dcr35c,
    dcr35d,
    dcr35e,
    dcr35f,
    dcr360,
    dcr361,
    dcr362,
    dcr363,
    dcr364,
    dcr365,
    dcr366,
    dcr367,
    dcr368,
    dcr369,
    dcr36a,
    dcr36b,
    dcr36c,
    dcr36d,
    dcr36e,
    dcr36f,
    dcr370,
    dcr371,
    dcr372,
    dcr373,
    dcr374,
    dcr375,
    dcr376,
    dcr377,
    dcr378,
    dcr379,
    dcr37a,
    dcr37b,
    dcr37c,
    dcr37d,
    dcr37e,
    dcr37f,
    dcr380,
    dcr381,
    dcr382,
    dcr383,
    dcr384,
    dcr385,
    dcr386,
    dcr387,
    dcr388,
    dcr389,
    dcr38a,
    dcr38b,
    dcr38c,
    dcr38d,
    dcr38e,
    dcr38f,
    dcr390,
    dcr391,
    dcr392,
    dcr393,
    dcr394,
    dcr395,
    dcr396,
    dcr397,
    dcr398,
    dcr399,
    dcr39a,
    dcr39b,
    dcr39c,
    dcr39d,
    dcr39e,
    dcr39f,
    dcr3a0,
    dcr3a1,
    dcr3a2,
    dcr3a3,
    dcr3a4,
    dcr3a5,
    dcr3a6,
    dcr3a7,
    dcr3a8,
    dcr3a9,
    dcr3aa,
    dcr3ab,
    dcr3ac,
    dcr3ad,
    dcr3ae,
    dcr3af,
    dcr3b0,
    dcr3b1,
    dcr3b2,
    dcr3b3,
    dcr3b4,
    dcr3b5,
    dcr3b6,
    dcr3b7,
    dcr3b8,
    dcr3b9,
    dcr3ba,
    dcr3bb,
    dcr3bc,
    dcr3bd,
    dcr3be,
    dcr3bf,
    dcr3c0,
    dcr3c1,
    dcr3c2,
    dcr3c3,
    dcr3c4,
    dcr3c5,
    dcr3c6,
    dcr3c7,
    dcr3c8,
    dcr3c9,
    dcr3ca,
    dcr3cb,
    dcr3cc,
    dcr3cd,
    dcr3ce,
    dcr3cf,
    dcr3d0,
    dcr3d1,
    dcr3d2,
    dcr3d3,
    dcr3d4,
    dcr3d5,
    dcr3d6,
    dcr3d7,
    dcr3d8,
    dcr3d9,
    dcr3da,
    dcr3db,
    dcr3dc,
    dcr3dd,
    dcr3de,
    dcr3df,
    dcr3e0,
    dcr3e1,
    dcr3e2,
    dcr3e3,
    dcr3e4,
    dcr3e5,
    dcr3e6,
    dcr3e7,
    dcr3e8,
    dcr3e9,
    dcr3ea,
    dcr3eb,
    dcr3ec,
    dcr3ed,
    dcr3ee,
    dcr3ef,
    dcr3f0,
    dcr3f1,
    dcr3f2,
    dcr3f3,
    dcr3f4,
    dcr3f5,
    dcr3f6,
    dcr3f7,
    dcr3f8,
    dcr3f9,
    dcr3fa,
    dcr3fb,
    dcr3fc,
    dcr3fd,
    dcr3fe,
    dcr3ff,
    ACC,
}
impl Register {
    fn as_str(&self) -> &'static str {
        match self {
            Self::r0 => "r0",
            Self::r1 => "r1",
            Self::r2 => "r2",
            Self::r3 => "r3",
            Self::r4 => "r4",
            Self::r5 => "r5",
            Self::r6 => "r6",
            Self::r7 => "r7",
            Self::r8 => "r8",
            Self::r9 => "r9",
            Self::r10 => "r10",
            Self::r11 => "r11",
            Self::r12 => "r12",
            Self::r13 => "r13",
            Self::r14 => "r14",
            Self::r15 => "r15",
            Self::r16 => "r16",
            Self::r17 => "r17",
            Self::r18 => "r18",
            Self::r19 => "r19",
            Self::r20 => "r20",
            Self::r21 => "r21",
            Self::r22 => "r22",
            Self::r23 => "r23",
            Self::r24 => "r24",
            Self::r25 => "r25",
            Self::r26 => "r26",
            Self::r27 => "r27",
            Self::r28 => "r28",
            Self::r29 => "r29",
            Self::r30 => "r30",
            Self::r31 => "r31",
            Self::xer_so => "xer_so",
            Self::xer_ov => "xer_ov",
            Self::xer_ov32 => "xer_ov32",
            Self::xer_ca => "xer_ca",
            Self::xer_ca32 => "xer_ca32",
            Self::xer_count => "xer_count",
            Self::fp_fx => "fp_fx",
            Self::fp_fex => "fp_fex",
            Self::fp_vx => "fp_vx",
            Self::fp_ox => "fp_ox",
            Self::fp_ux => "fp_ux",
            Self::fp_zx => "fp_zx",
            Self::fp_xx => "fp_xx",
            Self::fp_vxsnan => "fp_vxsnan",
            Self::fp_vxisi => "fp_vxisi",
            Self::fp_vxidi => "fp_vxidi",
            Self::fp_vxzdz => "fp_vxzdz",
            Self::fp_vximz => "fp_vximz",
            Self::fp_vxvc => "fp_vxvc",
            Self::fp_fr => "fp_fr",
            Self::fp_fi => "fp_fi",
            Self::fp_c => "fp_c",
            Self::fp_cc0 => "fp_cc0",
            Self::fp_cc1 => "fp_cc1",
            Self::fp_cc2 => "fp_cc2",
            Self::fp_cc3 => "fp_cc3",
            Self::fp_reserve1 => "fp_reserve1",
            Self::fp_vxsoft => "fp_vxsoft",
            Self::fp_vxsqrt => "fp_vxsqrt",
            Self::fp_vxcvi => "fp_vxcvi",
            Self::fp_ve => "fp_ve",
            Self::fp_oe => "fp_oe",
            Self::fp_ue => "fp_ue",
            Self::fp_ze => "fp_ze",
            Self::fp_xe => "fp_xe",
            Self::fp_ni => "fp_ni",
            Self::fp_rn0 => "fp_rn0",
            Self::fp_rn1 => "fp_rn1",
            Self::MSR => "MSR",
            Self::RESERVE_ADDRESS => "RESERVE_ADDRESS",
            Self::RESERVE => "RESERVE",
            Self::RESERVE_LENGTH => "RESERVE_LENGTH",
            Self::pc => "pc",
            Self::sr0 => "sr0",
            Self::sr1 => "sr1",
            Self::sr2 => "sr2",
            Self::sr3 => "sr3",
            Self::sr4 => "sr4",
            Self::sr5 => "sr5",
            Self::sr6 => "sr6",
            Self::sr7 => "sr7",
            Self::sr8 => "sr8",
            Self::sr9 => "sr9",
            Self::sr10 => "sr10",
            Self::sr11 => "sr11",
            Self::sr12 => "sr12",
            Self::sr13 => "sr13",
            Self::sr14 => "sr14",
            Self::sr15 => "sr15",
            Self::cr0 => "cr0",
            Self::cr1 => "cr1",
            Self::cr2 => "cr2",
            Self::cr3 => "cr3",
            Self::cr4 => "cr4",
            Self::cr5 => "cr5",
            Self::cr6 => "cr6",
            Self::cr7 => "cr7",
            Self::crall => "crall",
            Self::tea => "tea",
            Self::r2Save => "r2Save",
            Self::spr000 => "spr000",
            Self::XER => "XER",
            Self::spr002 => "spr002",
            Self::spr003 => "spr003",
            Self::spr004 => "spr004",
            Self::spr005 => "spr005",
            Self::spr006 => "spr006",
            Self::spr007 => "spr007",
            Self::LR => "LR",
            Self::CTR => "CTR",
            Self::spr00a => "spr00a",
            Self::spr00b => "spr00b",
            Self::spr00c => "spr00c",
            Self::spr00d => "spr00d",
            Self::spr00e => "spr00e",
            Self::spr00f => "spr00f",
            Self::spr010 => "spr010",
            Self::spr011 => "spr011",
            Self::spr012 => "spr012",
            Self::spr013 => "spr013",
            Self::spr014 => "spr014",
            Self::spr015 => "spr015",
            Self::spr016 => "spr016",
            Self::spr017 => "spr017",
            Self::spr018 => "spr018",
            Self::spr019 => "spr019",
            Self::SRR0 => "SRR0",
            Self::SRR1 => "SRR1",
            Self::spr01c => "spr01c",
            Self::spr01d => "spr01d",
            Self::spr01e => "spr01e",
            Self::spr01f => "spr01f",
            Self::spr020 => "spr020",
            Self::spr021 => "spr021",
            Self::spr022 => "spr022",
            Self::spr023 => "spr023",
            Self::spr024 => "spr024",
            Self::spr025 => "spr025",
            Self::spr026 => "spr026",
            Self::spr027 => "spr027",
            Self::spr028 => "spr028",
            Self::spr029 => "spr029",
            Self::spr02a => "spr02a",
            Self::spr02b => "spr02b",
            Self::spr02c => "spr02c",
            Self::spr02d => "spr02d",
            Self::spr02e => "spr02e",
            Self::spr02f => "spr02f",
            Self::spr030 => "spr030",
            Self::spr031 => "spr031",
            Self::spr032 => "spr032",
            Self::spr033 => "spr033",
            Self::spr034 => "spr034",
            Self::spr035 => "spr035",
            Self::spr036 => "spr036",
            Self::spr037 => "spr037",
            Self::spr038 => "spr038",
            Self::spr039 => "spr039",
            Self::CSRR0 => "CSRR0",
            Self::CSRR1 => "CSRR1",
            Self::spr03c => "spr03c",
            Self::spr03d => "spr03d",
            Self::spr03e => "spr03e",
            Self::spr03f => "spr03f",
            Self::spr040 => "spr040",
            Self::spr041 => "spr041",
            Self::spr042 => "spr042",
            Self::spr043 => "spr043",
            Self::spr044 => "spr044",
            Self::spr045 => "spr045",
            Self::spr046 => "spr046",
            Self::spr047 => "spr047",
            Self::spr048 => "spr048",
            Self::spr049 => "spr049",
            Self::spr04a => "spr04a",
            Self::spr04b => "spr04b",
            Self::spr04c => "spr04c",
            Self::spr04d => "spr04d",
            Self::spr04e => "spr04e",
            Self::spr04f => "spr04f",
            Self::spr050 => "spr050",
            Self::spr051 => "spr051",
            Self::spr052 => "spr052",
            Self::spr053 => "spr053",
            Self::spr054 => "spr054",
            Self::spr055 => "spr055",
            Self::spr056 => "spr056",
            Self::spr057 => "spr057",
            Self::spr058 => "spr058",
            Self::spr059 => "spr059",
            Self::spr05a => "spr05a",
            Self::spr05b => "spr05b",
            Self::spr05c => "spr05c",
            Self::spr05d => "spr05d",
            Self::spr05e => "spr05e",
            Self::spr05f => "spr05f",
            Self::spr060 => "spr060",
            Self::spr061 => "spr061",
            Self::spr062 => "spr062",
            Self::spr063 => "spr063",
            Self::spr064 => "spr064",
            Self::spr065 => "spr065",
            Self::spr066 => "spr066",
            Self::spr067 => "spr067",
            Self::spr068 => "spr068",
            Self::spr069 => "spr069",
            Self::spr06a => "spr06a",
            Self::spr06b => "spr06b",
            Self::spr06c => "spr06c",
            Self::spr06d => "spr06d",
            Self::spr06e => "spr06e",
            Self::spr06f => "spr06f",
            Self::spr070 => "spr070",
            Self::spr071 => "spr071",
            Self::spr072 => "spr072",
            Self::spr073 => "spr073",
            Self::spr074 => "spr074",
            Self::spr075 => "spr075",
            Self::spr076 => "spr076",
            Self::spr077 => "spr077",
            Self::spr078 => "spr078",
            Self::spr079 => "spr079",
            Self::spr07a => "spr07a",
            Self::spr07b => "spr07b",
            Self::spr07c => "spr07c",
            Self::spr07d => "spr07d",
            Self::spr07e => "spr07e",
            Self::spr07f => "spr07f",
            Self::spr080 => "spr080",
            Self::spr081 => "spr081",
            Self::spr082 => "spr082",
            Self::spr083 => "spr083",
            Self::spr084 => "spr084",
            Self::spr085 => "spr085",
            Self::spr086 => "spr086",
            Self::spr087 => "spr087",
            Self::spr088 => "spr088",
            Self::spr089 => "spr089",
            Self::spr08a => "spr08a",
            Self::spr08b => "spr08b",
            Self::spr08c => "spr08c",
            Self::spr08d => "spr08d",
            Self::spr08e => "spr08e",
            Self::spr08f => "spr08f",
            Self::spr090 => "spr090",
            Self::spr091 => "spr091",
            Self::spr092 => "spr092",
            Self::spr093 => "spr093",
            Self::spr094 => "spr094",
            Self::spr095 => "spr095",
            Self::spr096 => "spr096",
            Self::spr097 => "spr097",
            Self::spr098 => "spr098",
            Self::spr099 => "spr099",
            Self::spr09a => "spr09a",
            Self::spr09b => "spr09b",
            Self::spr09c => "spr09c",
            Self::spr09d => "spr09d",
            Self::spr09e => "spr09e",
            Self::spr09f => "spr09f",
            Self::spr0a0 => "spr0a0",
            Self::spr0a1 => "spr0a1",
            Self::spr0a2 => "spr0a2",
            Self::spr0a3 => "spr0a3",
            Self::spr0a4 => "spr0a4",
            Self::spr0a5 => "spr0a5",
            Self::spr0a6 => "spr0a6",
            Self::spr0a7 => "spr0a7",
            Self::spr0a8 => "spr0a8",
            Self::spr0a9 => "spr0a9",
            Self::spr0aa => "spr0aa",
            Self::spr0ab => "spr0ab",
            Self::spr0ac => "spr0ac",
            Self::spr0ad => "spr0ad",
            Self::spr0ae => "spr0ae",
            Self::spr0af => "spr0af",
            Self::spr0b0 => "spr0b0",
            Self::spr0b1 => "spr0b1",
            Self::spr0b2 => "spr0b2",
            Self::spr0b3 => "spr0b3",
            Self::spr0b4 => "spr0b4",
            Self::spr0b5 => "spr0b5",
            Self::spr0b6 => "spr0b6",
            Self::spr0b7 => "spr0b7",
            Self::spr0b8 => "spr0b8",
            Self::spr0b9 => "spr0b9",
            Self::spr0ba => "spr0ba",
            Self::spr0bb => "spr0bb",
            Self::spr0bc => "spr0bc",
            Self::spr0bd => "spr0bd",
            Self::spr0be => "spr0be",
            Self::spr0bf => "spr0bf",
            Self::spr0c0 => "spr0c0",
            Self::spr0c1 => "spr0c1",
            Self::spr0c2 => "spr0c2",
            Self::spr0c3 => "spr0c3",
            Self::spr0c4 => "spr0c4",
            Self::spr0c5 => "spr0c5",
            Self::spr0c6 => "spr0c6",
            Self::spr0c7 => "spr0c7",
            Self::spr0c8 => "spr0c8",
            Self::spr0c9 => "spr0c9",
            Self::spr0ca => "spr0ca",
            Self::spr0cb => "spr0cb",
            Self::spr0cc => "spr0cc",
            Self::spr0cd => "spr0cd",
            Self::spr0ce => "spr0ce",
            Self::spr0cf => "spr0cf",
            Self::spr0d0 => "spr0d0",
            Self::spr0d1 => "spr0d1",
            Self::spr0d2 => "spr0d2",
            Self::spr0d3 => "spr0d3",
            Self::spr0d4 => "spr0d4",
            Self::spr0d5 => "spr0d5",
            Self::spr0d6 => "spr0d6",
            Self::spr0d7 => "spr0d7",
            Self::spr0d8 => "spr0d8",
            Self::spr0d9 => "spr0d9",
            Self::spr0da => "spr0da",
            Self::spr0db => "spr0db",
            Self::spr0dc => "spr0dc",
            Self::spr0dd => "spr0dd",
            Self::spr0de => "spr0de",
            Self::spr0df => "spr0df",
            Self::spr0e0 => "spr0e0",
            Self::spr0e1 => "spr0e1",
            Self::spr0e2 => "spr0e2",
            Self::spr0e3 => "spr0e3",
            Self::spr0e4 => "spr0e4",
            Self::spr0e5 => "spr0e5",
            Self::spr0e6 => "spr0e6",
            Self::spr0e7 => "spr0e7",
            Self::spr0e8 => "spr0e8",
            Self::spr0e9 => "spr0e9",
            Self::spr0ea => "spr0ea",
            Self::spr0eb => "spr0eb",
            Self::spr0ec => "spr0ec",
            Self::spr0ed => "spr0ed",
            Self::spr0ee => "spr0ee",
            Self::spr0ef => "spr0ef",
            Self::spr0f0 => "spr0f0",
            Self::spr0f1 => "spr0f1",
            Self::spr0f2 => "spr0f2",
            Self::spr0f3 => "spr0f3",
            Self::spr0f4 => "spr0f4",
            Self::spr0f5 => "spr0f5",
            Self::spr0f6 => "spr0f6",
            Self::spr0f7 => "spr0f7",
            Self::spr0f8 => "spr0f8",
            Self::spr0f9 => "spr0f9",
            Self::spr0fa => "spr0fa",
            Self::spr0fb => "spr0fb",
            Self::spr0fc => "spr0fc",
            Self::spr0fd => "spr0fd",
            Self::spr0fe => "spr0fe",
            Self::spr0ff => "spr0ff",
            Self::spr100 => "spr100",
            Self::spr101 => "spr101",
            Self::spr102 => "spr102",
            Self::spr103 => "spr103",
            Self::spr104 => "spr104",
            Self::spr105 => "spr105",
            Self::spr106 => "spr106",
            Self::spr107 => "spr107",
            Self::spr108 => "spr108",
            Self::spr109 => "spr109",
            Self::spr10a => "spr10a",
            Self::spr10b => "spr10b",
            Self::TBLr => "TBLr",
            Self::TBUr => "TBUr",
            Self::spr10e => "spr10e",
            Self::spr10f => "spr10f",
            Self::spr110 => "spr110",
            Self::spr111 => "spr111",
            Self::spr112 => "spr112",
            Self::spr113 => "spr113",
            Self::spr114 => "spr114",
            Self::spr115 => "spr115",
            Self::spr116 => "spr116",
            Self::spr117 => "spr117",
            Self::spr118 => "spr118",
            Self::spr119 => "spr119",
            Self::spr11a => "spr11a",
            Self::spr11b => "spr11b",
            Self::TBLw => "TBLw",
            Self::TBUw => "TBUw",
            Self::spr11e => "spr11e",
            Self::spr11f => "spr11f",
            Self::spr120 => "spr120",
            Self::spr121 => "spr121",
            Self::spr122 => "spr122",
            Self::spr123 => "spr123",
            Self::spr124 => "spr124",
            Self::spr125 => "spr125",
            Self::spr126 => "spr126",
            Self::spr127 => "spr127",
            Self::spr128 => "spr128",
            Self::spr129 => "spr129",
            Self::spr12a => "spr12a",
            Self::spr12b => "spr12b",
            Self::spr12c => "spr12c",
            Self::spr12d => "spr12d",
            Self::spr12e => "spr12e",
            Self::spr12f => "spr12f",
            Self::spr130 => "spr130",
            Self::spr131 => "spr131",
            Self::spr132 => "spr132",
            Self::spr133 => "spr133",
            Self::spr134 => "spr134",
            Self::spr135 => "spr135",
            Self::spr136 => "spr136",
            Self::spr137 => "spr137",
            Self::spr138 => "spr138",
            Self::spr139 => "spr139",
            Self::spr13a => "spr13a",
            Self::spr13b => "spr13b",
            Self::spr13c => "spr13c",
            Self::spr13d => "spr13d",
            Self::spr13e => "spr13e",
            Self::spr13f => "spr13f",
            Self::spr140 => "spr140",
            Self::spr141 => "spr141",
            Self::spr142 => "spr142",
            Self::spr143 => "spr143",
            Self::spr144 => "spr144",
            Self::spr145 => "spr145",
            Self::spr146 => "spr146",
            Self::spr147 => "spr147",
            Self::spr148 => "spr148",
            Self::spr149 => "spr149",
            Self::spr14a => "spr14a",
            Self::spr14b => "spr14b",
            Self::spr14c => "spr14c",
            Self::spr14d => "spr14d",
            Self::spr14e => "spr14e",
            Self::spr14f => "spr14f",
            Self::spr150 => "spr150",
            Self::spr151 => "spr151",
            Self::spr152 => "spr152",
            Self::spr153 => "spr153",
            Self::spr154 => "spr154",
            Self::spr155 => "spr155",
            Self::spr156 => "spr156",
            Self::spr157 => "spr157",
            Self::spr158 => "spr158",
            Self::spr159 => "spr159",
            Self::spr15a => "spr15a",
            Self::spr15b => "spr15b",
            Self::spr15c => "spr15c",
            Self::spr15d => "spr15d",
            Self::spr15e => "spr15e",
            Self::spr15f => "spr15f",
            Self::spr160 => "spr160",
            Self::spr161 => "spr161",
            Self::spr162 => "spr162",
            Self::spr163 => "spr163",
            Self::spr164 => "spr164",
            Self::spr165 => "spr165",
            Self::spr166 => "spr166",
            Self::spr167 => "spr167",
            Self::spr168 => "spr168",
            Self::spr169 => "spr169",
            Self::spr16a => "spr16a",
            Self::spr16b => "spr16b",
            Self::spr16c => "spr16c",
            Self::spr16d => "spr16d",
            Self::spr16e => "spr16e",
            Self::spr16f => "spr16f",
            Self::spr170 => "spr170",
            Self::spr171 => "spr171",
            Self::spr172 => "spr172",
            Self::spr173 => "spr173",
            Self::spr174 => "spr174",
            Self::spr175 => "spr175",
            Self::spr176 => "spr176",
            Self::spr177 => "spr177",
            Self::spr178 => "spr178",
            Self::spr179 => "spr179",
            Self::spr17a => "spr17a",
            Self::spr17b => "spr17b",
            Self::spr17c => "spr17c",
            Self::spr17d => "spr17d",
            Self::spr17e => "spr17e",
            Self::spr17f => "spr17f",
            Self::spr180 => "spr180",
            Self::spr181 => "spr181",
            Self::spr182 => "spr182",
            Self::spr183 => "spr183",
            Self::spr184 => "spr184",
            Self::spr185 => "spr185",
            Self::spr186 => "spr186",
            Self::spr187 => "spr187",
            Self::spr188 => "spr188",
            Self::spr189 => "spr189",
            Self::spr18a => "spr18a",
            Self::spr18b => "spr18b",
            Self::spr18c => "spr18c",
            Self::spr18d => "spr18d",
            Self::spr18e => "spr18e",
            Self::spr18f => "spr18f",
            Self::spr190 => "spr190",
            Self::spr191 => "spr191",
            Self::spr192 => "spr192",
            Self::spr193 => "spr193",
            Self::spr194 => "spr194",
            Self::spr195 => "spr195",
            Self::spr196 => "spr196",
            Self::spr197 => "spr197",
            Self::spr198 => "spr198",
            Self::spr199 => "spr199",
            Self::spr19a => "spr19a",
            Self::spr19b => "spr19b",
            Self::spr19c => "spr19c",
            Self::spr19d => "spr19d",
            Self::spr19e => "spr19e",
            Self::spr19f => "spr19f",
            Self::spr1a0 => "spr1a0",
            Self::spr1a1 => "spr1a1",
            Self::spr1a2 => "spr1a2",
            Self::spr1a3 => "spr1a3",
            Self::spr1a4 => "spr1a4",
            Self::spr1a5 => "spr1a5",
            Self::spr1a6 => "spr1a6",
            Self::spr1a7 => "spr1a7",
            Self::spr1a8 => "spr1a8",
            Self::spr1a9 => "spr1a9",
            Self::spr1aa => "spr1aa",
            Self::spr1ab => "spr1ab",
            Self::spr1ac => "spr1ac",
            Self::spr1ad => "spr1ad",
            Self::spr1ae => "spr1ae",
            Self::spr1af => "spr1af",
            Self::spr1b0 => "spr1b0",
            Self::spr1b1 => "spr1b1",
            Self::spr1b2 => "spr1b2",
            Self::spr1b3 => "spr1b3",
            Self::spr1b4 => "spr1b4",
            Self::spr1b5 => "spr1b5",
            Self::spr1b6 => "spr1b6",
            Self::spr1b7 => "spr1b7",
            Self::spr1b8 => "spr1b8",
            Self::spr1b9 => "spr1b9",
            Self::spr1ba => "spr1ba",
            Self::spr1bb => "spr1bb",
            Self::spr1bc => "spr1bc",
            Self::spr1bd => "spr1bd",
            Self::spr1be => "spr1be",
            Self::spr1bf => "spr1bf",
            Self::spr1c0 => "spr1c0",
            Self::spr1c1 => "spr1c1",
            Self::spr1c2 => "spr1c2",
            Self::spr1c3 => "spr1c3",
            Self::spr1c4 => "spr1c4",
            Self::spr1c5 => "spr1c5",
            Self::spr1c6 => "spr1c6",
            Self::spr1c7 => "spr1c7",
            Self::spr1c8 => "spr1c8",
            Self::spr1c9 => "spr1c9",
            Self::spr1ca => "spr1ca",
            Self::spr1cb => "spr1cb",
            Self::spr1cc => "spr1cc",
            Self::spr1cd => "spr1cd",
            Self::spr1ce => "spr1ce",
            Self::spr1cf => "spr1cf",
            Self::spr1d0 => "spr1d0",
            Self::spr1d1 => "spr1d1",
            Self::spr1d2 => "spr1d2",
            Self::spr1d3 => "spr1d3",
            Self::spr1d4 => "spr1d4",
            Self::spr1d5 => "spr1d5",
            Self::spr1d6 => "spr1d6",
            Self::spr1d7 => "spr1d7",
            Self::spr1d8 => "spr1d8",
            Self::spr1d9 => "spr1d9",
            Self::spr1da => "spr1da",
            Self::spr1db => "spr1db",
            Self::spr1dc => "spr1dc",
            Self::spr1dd => "spr1dd",
            Self::spr1de => "spr1de",
            Self::spr1df => "spr1df",
            Self::spr1e0 => "spr1e0",
            Self::spr1e1 => "spr1e1",
            Self::spr1e2 => "spr1e2",
            Self::spr1e3 => "spr1e3",
            Self::spr1e4 => "spr1e4",
            Self::spr1e5 => "spr1e5",
            Self::spr1e6 => "spr1e6",
            Self::spr1e7 => "spr1e7",
            Self::spr1e8 => "spr1e8",
            Self::spr1e9 => "spr1e9",
            Self::spr1ea => "spr1ea",
            Self::spr1eb => "spr1eb",
            Self::spr1ec => "spr1ec",
            Self::spr1ed => "spr1ed",
            Self::spr1ee => "spr1ee",
            Self::spr1ef => "spr1ef",
            Self::spr1f0 => "spr1f0",
            Self::spr1f1 => "spr1f1",
            Self::spr1f2 => "spr1f2",
            Self::spr1f3 => "spr1f3",
            Self::spr1f4 => "spr1f4",
            Self::spr1f5 => "spr1f5",
            Self::spr1f6 => "spr1f6",
            Self::spr1f7 => "spr1f7",
            Self::spr1f8 => "spr1f8",
            Self::spr1f9 => "spr1f9",
            Self::spr1fa => "spr1fa",
            Self::spr1fb => "spr1fb",
            Self::spr1fc => "spr1fc",
            Self::spr1fd => "spr1fd",
            Self::spr1fe => "spr1fe",
            Self::spr1ff => "spr1ff",
            Self::spr200 => "spr200",
            Self::spr201 => "spr201",
            Self::spr202 => "spr202",
            Self::spr203 => "spr203",
            Self::spr204 => "spr204",
            Self::spr205 => "spr205",
            Self::spr206 => "spr206",
            Self::spr207 => "spr207",
            Self::spr208 => "spr208",
            Self::spr209 => "spr209",
            Self::spr20a => "spr20a",
            Self::spr20b => "spr20b",
            Self::spr20c => "spr20c",
            Self::spr20d => "spr20d",
            Self::spr20e => "spr20e",
            Self::spr20f => "spr20f",
            Self::spr210 => "spr210",
            Self::spr211 => "spr211",
            Self::spr212 => "spr212",
            Self::spr213 => "spr213",
            Self::spr214 => "spr214",
            Self::spr215 => "spr215",
            Self::spr216 => "spr216",
            Self::spr217 => "spr217",
            Self::spr218 => "spr218",
            Self::spr219 => "spr219",
            Self::spr21a => "spr21a",
            Self::spr21b => "spr21b",
            Self::spr21c => "spr21c",
            Self::spr21d => "spr21d",
            Self::spr21e => "spr21e",
            Self::spr21f => "spr21f",
            Self::spr220 => "spr220",
            Self::spr221 => "spr221",
            Self::spr222 => "spr222",
            Self::spr223 => "spr223",
            Self::spr224 => "spr224",
            Self::spr225 => "spr225",
            Self::spr226 => "spr226",
            Self::spr227 => "spr227",
            Self::spr228 => "spr228",
            Self::spr229 => "spr229",
            Self::spr22a => "spr22a",
            Self::spr22b => "spr22b",
            Self::spr22c => "spr22c",
            Self::spr22d => "spr22d",
            Self::spr22e => "spr22e",
            Self::spr22f => "spr22f",
            Self::spr230 => "spr230",
            Self::spr231 => "spr231",
            Self::spr232 => "spr232",
            Self::spr233 => "spr233",
            Self::spr234 => "spr234",
            Self::spr235 => "spr235",
            Self::spr236 => "spr236",
            Self::spr237 => "spr237",
            Self::spr238 => "spr238",
            Self::spr239 => "spr239",
            Self::spr23a => "spr23a",
            Self::spr23b => "spr23b",
            Self::spr23c => "spr23c",
            Self::spr23d => "spr23d",
            Self::spr23e => "spr23e",
            Self::spr23f => "spr23f",
            Self::spr240 => "spr240",
            Self::spr241 => "spr241",
            Self::spr242 => "spr242",
            Self::spr243 => "spr243",
            Self::spr244 => "spr244",
            Self::spr245 => "spr245",
            Self::spr246 => "spr246",
            Self::spr247 => "spr247",
            Self::spr248 => "spr248",
            Self::spr249 => "spr249",
            Self::spr24a => "spr24a",
            Self::spr24b => "spr24b",
            Self::spr24c => "spr24c",
            Self::spr24d => "spr24d",
            Self::spr24e => "spr24e",
            Self::spr24f => "spr24f",
            Self::spr250 => "spr250",
            Self::spr251 => "spr251",
            Self::spr252 => "spr252",
            Self::spr253 => "spr253",
            Self::spr254 => "spr254",
            Self::spr255 => "spr255",
            Self::spr256 => "spr256",
            Self::spr257 => "spr257",
            Self::spr258 => "spr258",
            Self::spr259 => "spr259",
            Self::spr25a => "spr25a",
            Self::spr25b => "spr25b",
            Self::spr25c => "spr25c",
            Self::spr25d => "spr25d",
            Self::spr25e => "spr25e",
            Self::spr25f => "spr25f",
            Self::spr260 => "spr260",
            Self::spr261 => "spr261",
            Self::spr262 => "spr262",
            Self::spr263 => "spr263",
            Self::spr264 => "spr264",
            Self::spr265 => "spr265",
            Self::spr266 => "spr266",
            Self::spr267 => "spr267",
            Self::spr268 => "spr268",
            Self::spr269 => "spr269",
            Self::spr26a => "spr26a",
            Self::spr26b => "spr26b",
            Self::spr26c => "spr26c",
            Self::spr26d => "spr26d",
            Self::spr26e => "spr26e",
            Self::spr26f => "spr26f",
            Self::spr270 => "spr270",
            Self::spr271 => "spr271",
            Self::spr272 => "spr272",
            Self::spr273 => "spr273",
            Self::spr274 => "spr274",
            Self::spr275 => "spr275",
            Self::spr276 => "spr276",
            Self::spr277 => "spr277",
            Self::spr278 => "spr278",
            Self::spr279 => "spr279",
            Self::spr27a => "spr27a",
            Self::spr27b => "spr27b",
            Self::spr27c => "spr27c",
            Self::spr27d => "spr27d",
            Self::spr27e => "spr27e",
            Self::spr27f => "spr27f",
            Self::spr280 => "spr280",
            Self::spr281 => "spr281",
            Self::spr282 => "spr282",
            Self::spr283 => "spr283",
            Self::spr284 => "spr284",
            Self::spr285 => "spr285",
            Self::spr286 => "spr286",
            Self::spr287 => "spr287",
            Self::spr288 => "spr288",
            Self::spr289 => "spr289",
            Self::spr28a => "spr28a",
            Self::spr28b => "spr28b",
            Self::spr28c => "spr28c",
            Self::spr28d => "spr28d",
            Self::spr28e => "spr28e",
            Self::spr28f => "spr28f",
            Self::spr290 => "spr290",
            Self::spr291 => "spr291",
            Self::spr292 => "spr292",
            Self::spr293 => "spr293",
            Self::spr294 => "spr294",
            Self::spr295 => "spr295",
            Self::spr296 => "spr296",
            Self::spr297 => "spr297",
            Self::spr298 => "spr298",
            Self::spr299 => "spr299",
            Self::spr29a => "spr29a",
            Self::spr29b => "spr29b",
            Self::spr29c => "spr29c",
            Self::spr29d => "spr29d",
            Self::spr29e => "spr29e",
            Self::spr29f => "spr29f",
            Self::spr2a0 => "spr2a0",
            Self::spr2a1 => "spr2a1",
            Self::spr2a2 => "spr2a2",
            Self::spr2a3 => "spr2a3",
            Self::spr2a4 => "spr2a4",
            Self::spr2a5 => "spr2a5",
            Self::spr2a6 => "spr2a6",
            Self::spr2a7 => "spr2a7",
            Self::spr2a8 => "spr2a8",
            Self::spr2a9 => "spr2a9",
            Self::spr2aa => "spr2aa",
            Self::spr2ab => "spr2ab",
            Self::spr2ac => "spr2ac",
            Self::spr2ad => "spr2ad",
            Self::spr2ae => "spr2ae",
            Self::spr2af => "spr2af",
            Self::spr2b0 => "spr2b0",
            Self::spr2b1 => "spr2b1",
            Self::spr2b2 => "spr2b2",
            Self::spr2b3 => "spr2b3",
            Self::spr2b4 => "spr2b4",
            Self::spr2b5 => "spr2b5",
            Self::spr2b6 => "spr2b6",
            Self::spr2b7 => "spr2b7",
            Self::spr2b8 => "spr2b8",
            Self::spr2b9 => "spr2b9",
            Self::spr2ba => "spr2ba",
            Self::spr2bb => "spr2bb",
            Self::spr2bc => "spr2bc",
            Self::spr2bd => "spr2bd",
            Self::spr2be => "spr2be",
            Self::spr2bf => "spr2bf",
            Self::spr2c0 => "spr2c0",
            Self::spr2c1 => "spr2c1",
            Self::spr2c2 => "spr2c2",
            Self::spr2c3 => "spr2c3",
            Self::spr2c4 => "spr2c4",
            Self::spr2c5 => "spr2c5",
            Self::spr2c6 => "spr2c6",
            Self::spr2c7 => "spr2c7",
            Self::spr2c8 => "spr2c8",
            Self::spr2c9 => "spr2c9",
            Self::spr2ca => "spr2ca",
            Self::spr2cb => "spr2cb",
            Self::spr2cc => "spr2cc",
            Self::spr2cd => "spr2cd",
            Self::spr2ce => "spr2ce",
            Self::spr2cf => "spr2cf",
            Self::spr2d0 => "spr2d0",
            Self::spr2d1 => "spr2d1",
            Self::spr2d2 => "spr2d2",
            Self::spr2d3 => "spr2d3",
            Self::spr2d4 => "spr2d4",
            Self::spr2d5 => "spr2d5",
            Self::spr2d6 => "spr2d6",
            Self::spr2d7 => "spr2d7",
            Self::spr2d8 => "spr2d8",
            Self::spr2d9 => "spr2d9",
            Self::spr2da => "spr2da",
            Self::spr2db => "spr2db",
            Self::spr2dc => "spr2dc",
            Self::spr2dd => "spr2dd",
            Self::spr2de => "spr2de",
            Self::spr2df => "spr2df",
            Self::spr2e0 => "spr2e0",
            Self::spr2e1 => "spr2e1",
            Self::spr2e2 => "spr2e2",
            Self::spr2e3 => "spr2e3",
            Self::spr2e4 => "spr2e4",
            Self::spr2e5 => "spr2e5",
            Self::spr2e6 => "spr2e6",
            Self::spr2e7 => "spr2e7",
            Self::spr2e8 => "spr2e8",
            Self::spr2e9 => "spr2e9",
            Self::spr2ea => "spr2ea",
            Self::spr2eb => "spr2eb",
            Self::spr2ec => "spr2ec",
            Self::spr2ed => "spr2ed",
            Self::spr2ee => "spr2ee",
            Self::spr2ef => "spr2ef",
            Self::spr2f0 => "spr2f0",
            Self::spr2f1 => "spr2f1",
            Self::spr2f2 => "spr2f2",
            Self::spr2f3 => "spr2f3",
            Self::spr2f4 => "spr2f4",
            Self::spr2f5 => "spr2f5",
            Self::spr2f6 => "spr2f6",
            Self::spr2f7 => "spr2f7",
            Self::spr2f8 => "spr2f8",
            Self::spr2f9 => "spr2f9",
            Self::spr2fa => "spr2fa",
            Self::spr2fb => "spr2fb",
            Self::spr2fc => "spr2fc",
            Self::spr2fd => "spr2fd",
            Self::spr2fe => "spr2fe",
            Self::spr2ff => "spr2ff",
            Self::spr300 => "spr300",
            Self::spr301 => "spr301",
            Self::spr302 => "spr302",
            Self::spr303 => "spr303",
            Self::spr304 => "spr304",
            Self::spr305 => "spr305",
            Self::spr306 => "spr306",
            Self::spr307 => "spr307",
            Self::spr308 => "spr308",
            Self::spr309 => "spr309",
            Self::spr30a => "spr30a",
            Self::spr30b => "spr30b",
            Self::spr30c => "spr30c",
            Self::spr30d => "spr30d",
            Self::spr30e => "spr30e",
            Self::spr30f => "spr30f",
            Self::spr310 => "spr310",
            Self::spr311 => "spr311",
            Self::spr312 => "spr312",
            Self::spr313 => "spr313",
            Self::spr314 => "spr314",
            Self::spr315 => "spr315",
            Self::spr316 => "spr316",
            Self::spr317 => "spr317",
            Self::spr318 => "spr318",
            Self::spr319 => "spr319",
            Self::spr31a => "spr31a",
            Self::spr31b => "spr31b",
            Self::spr31c => "spr31c",
            Self::spr31d => "spr31d",
            Self::spr31e => "spr31e",
            Self::spr31f => "spr31f",
            Self::spr320 => "spr320",
            Self::spr321 => "spr321",
            Self::spr322 => "spr322",
            Self::spr323 => "spr323",
            Self::spr324 => "spr324",
            Self::spr325 => "spr325",
            Self::spr326 => "spr326",
            Self::spr327 => "spr327",
            Self::spr328 => "spr328",
            Self::spr329 => "spr329",
            Self::spr32a => "spr32a",
            Self::spr32b => "spr32b",
            Self::spr32c => "spr32c",
            Self::spr32d => "spr32d",
            Self::spr32e => "spr32e",
            Self::TAR => "TAR",
            Self::spr330 => "spr330",
            Self::spr331 => "spr331",
            Self::spr332 => "spr332",
            Self::spr333 => "spr333",
            Self::spr334 => "spr334",
            Self::spr335 => "spr335",
            Self::spr336 => "spr336",
            Self::spr337 => "spr337",
            Self::spr338 => "spr338",
            Self::spr339 => "spr339",
            Self::spr33a => "spr33a",
            Self::spr33b => "spr33b",
            Self::spr33c => "spr33c",
            Self::spr33d => "spr33d",
            Self::spr33e => "spr33e",
            Self::spr33f => "spr33f",
            Self::spr340 => "spr340",
            Self::spr341 => "spr341",
            Self::spr342 => "spr342",
            Self::spr343 => "spr343",
            Self::spr344 => "spr344",
            Self::spr345 => "spr345",
            Self::spr346 => "spr346",
            Self::spr347 => "spr347",
            Self::spr348 => "spr348",
            Self::spr349 => "spr349",
            Self::spr34a => "spr34a",
            Self::spr34b => "spr34b",
            Self::spr34c => "spr34c",
            Self::spr34d => "spr34d",
            Self::spr34e => "spr34e",
            Self::spr34f => "spr34f",
            Self::spr350 => "spr350",
            Self::spr351 => "spr351",
            Self::spr352 => "spr352",
            Self::spr353 => "spr353",
            Self::spr354 => "spr354",
            Self::spr355 => "spr355",
            Self::spr356 => "spr356",
            Self::spr357 => "spr357",
            Self::spr358 => "spr358",
            Self::spr359 => "spr359",
            Self::spr35a => "spr35a",
            Self::spr35b => "spr35b",
            Self::spr35c => "spr35c",
            Self::spr35d => "spr35d",
            Self::spr35e => "spr35e",
            Self::spr35f => "spr35f",
            Self::spr360 => "spr360",
            Self::spr361 => "spr361",
            Self::spr362 => "spr362",
            Self::spr363 => "spr363",
            Self::spr364 => "spr364",
            Self::spr365 => "spr365",
            Self::spr366 => "spr366",
            Self::spr367 => "spr367",
            Self::spr368 => "spr368",
            Self::spr369 => "spr369",
            Self::spr36a => "spr36a",
            Self::spr36b => "spr36b",
            Self::spr36c => "spr36c",
            Self::spr36d => "spr36d",
            Self::spr36e => "spr36e",
            Self::spr36f => "spr36f",
            Self::spr370 => "spr370",
            Self::spr371 => "spr371",
            Self::spr372 => "spr372",
            Self::spr373 => "spr373",
            Self::spr374 => "spr374",
            Self::spr375 => "spr375",
            Self::spr376 => "spr376",
            Self::spr377 => "spr377",
            Self::spr378 => "spr378",
            Self::spr379 => "spr379",
            Self::spr37a => "spr37a",
            Self::spr37b => "spr37b",
            Self::spr37c => "spr37c",
            Self::spr37d => "spr37d",
            Self::spr37e => "spr37e",
            Self::spr37f => "spr37f",
            Self::spr380 => "spr380",
            Self::spr381 => "spr381",
            Self::spr382 => "spr382",
            Self::spr383 => "spr383",
            Self::spr384 => "spr384",
            Self::spr385 => "spr385",
            Self::spr386 => "spr386",
            Self::spr387 => "spr387",
            Self::spr388 => "spr388",
            Self::spr389 => "spr389",
            Self::spr38a => "spr38a",
            Self::spr38b => "spr38b",
            Self::spr38c => "spr38c",
            Self::spr38d => "spr38d",
            Self::spr38e => "spr38e",
            Self::spr38f => "spr38f",
            Self::spr390 => "spr390",
            Self::spr391 => "spr391",
            Self::spr392 => "spr392",
            Self::spr393 => "spr393",
            Self::spr394 => "spr394",
            Self::spr395 => "spr395",
            Self::spr396 => "spr396",
            Self::spr397 => "spr397",
            Self::spr398 => "spr398",
            Self::spr399 => "spr399",
            Self::spr39a => "spr39a",
            Self::spr39b => "spr39b",
            Self::spr39c => "spr39c",
            Self::spr39d => "spr39d",
            Self::spr39e => "spr39e",
            Self::spr39f => "spr39f",
            Self::spr3a0 => "spr3a0",
            Self::spr3a1 => "spr3a1",
            Self::spr3a2 => "spr3a2",
            Self::spr3a3 => "spr3a3",
            Self::spr3a4 => "spr3a4",
            Self::spr3a5 => "spr3a5",
            Self::spr3a6 => "spr3a6",
            Self::spr3a7 => "spr3a7",
            Self::spr3a8 => "spr3a8",
            Self::spr3a9 => "spr3a9",
            Self::spr3aa => "spr3aa",
            Self::spr3ab => "spr3ab",
            Self::spr3ac => "spr3ac",
            Self::spr3ad => "spr3ad",
            Self::spr3ae => "spr3ae",
            Self::spr3af => "spr3af",
            Self::spr3b0 => "spr3b0",
            Self::spr3b1 => "spr3b1",
            Self::spr3b2 => "spr3b2",
            Self::spr3b3 => "spr3b3",
            Self::spr3b4 => "spr3b4",
            Self::spr3b5 => "spr3b5",
            Self::spr3b6 => "spr3b6",
            Self::spr3b7 => "spr3b7",
            Self::spr3b8 => "spr3b8",
            Self::spr3b9 => "spr3b9",
            Self::spr3ba => "spr3ba",
            Self::spr3bb => "spr3bb",
            Self::spr3bc => "spr3bc",
            Self::spr3bd => "spr3bd",
            Self::spr3be => "spr3be",
            Self::spr3bf => "spr3bf",
            Self::spr3c0 => "spr3c0",
            Self::spr3c1 => "spr3c1",
            Self::spr3c2 => "spr3c2",
            Self::spr3c3 => "spr3c3",
            Self::spr3c4 => "spr3c4",
            Self::spr3c5 => "spr3c5",
            Self::spr3c6 => "spr3c6",
            Self::spr3c7 => "spr3c7",
            Self::spr3c8 => "spr3c8",
            Self::spr3c9 => "spr3c9",
            Self::spr3ca => "spr3ca",
            Self::spr3cb => "spr3cb",
            Self::spr3cc => "spr3cc",
            Self::spr3cd => "spr3cd",
            Self::spr3ce => "spr3ce",
            Self::spr3cf => "spr3cf",
            Self::spr3d0 => "spr3d0",
            Self::spr3d1 => "spr3d1",
            Self::spr3d2 => "spr3d2",
            Self::spr3d3 => "spr3d3",
            Self::spr3d4 => "spr3d4",
            Self::spr3d5 => "spr3d5",
            Self::spr3d6 => "spr3d6",
            Self::spr3d7 => "spr3d7",
            Self::spr3d8 => "spr3d8",
            Self::spr3d9 => "spr3d9",
            Self::spr3da => "spr3da",
            Self::spr3db => "spr3db",
            Self::spr3dc => "spr3dc",
            Self::spr3dd => "spr3dd",
            Self::spr3de => "spr3de",
            Self::spr3df => "spr3df",
            Self::spr3e0 => "spr3e0",
            Self::spr3e1 => "spr3e1",
            Self::spr3e2 => "spr3e2",
            Self::spr3e3 => "spr3e3",
            Self::spr3e4 => "spr3e4",
            Self::spr3e5 => "spr3e5",
            Self::spr3e6 => "spr3e6",
            Self::spr3e7 => "spr3e7",
            Self::spr3e8 => "spr3e8",
            Self::spr3e9 => "spr3e9",
            Self::spr3ea => "spr3ea",
            Self::spr3eb => "spr3eb",
            Self::spr3ec => "spr3ec",
            Self::spr3ed => "spr3ed",
            Self::spr3ee => "spr3ee",
            Self::spr3ef => "spr3ef",
            Self::spr3f0 => "spr3f0",
            Self::spr3f1 => "spr3f1",
            Self::spr3f2 => "spr3f2",
            Self::spr3f3 => "spr3f3",
            Self::spr3f4 => "spr3f4",
            Self::spr3f5 => "spr3f5",
            Self::spr3f6 => "spr3f6",
            Self::spr3f7 => "spr3f7",
            Self::spr3f8 => "spr3f8",
            Self::spr3f9 => "spr3f9",
            Self::spr3fa => "spr3fa",
            Self::spr3fb => "spr3fb",
            Self::spr3fc => "spr3fc",
            Self::spr3fd => "spr3fd",
            Self::spr3fe => "spr3fe",
            Self::spr3ff => "spr3ff",
            Self::vs0 => "vs0",
            Self::vs1 => "vs1",
            Self::vs2 => "vs2",
            Self::vs3 => "vs3",
            Self::vs4 => "vs4",
            Self::vs5 => "vs5",
            Self::vs6 => "vs6",
            Self::vs7 => "vs7",
            Self::vs8 => "vs8",
            Self::vs9 => "vs9",
            Self::vs10 => "vs10",
            Self::vs11 => "vs11",
            Self::vs12 => "vs12",
            Self::vs13 => "vs13",
            Self::vs14 => "vs14",
            Self::vs15 => "vs15",
            Self::vs16 => "vs16",
            Self::vs17 => "vs17",
            Self::vs18 => "vs18",
            Self::vs19 => "vs19",
            Self::vs20 => "vs20",
            Self::vs21 => "vs21",
            Self::vs22 => "vs22",
            Self::vs23 => "vs23",
            Self::vs24 => "vs24",
            Self::vs25 => "vs25",
            Self::vs26 => "vs26",
            Self::vs27 => "vs27",
            Self::vs28 => "vs28",
            Self::vs29 => "vs29",
            Self::vs30 => "vs30",
            Self::vs31 => "vs31",
            Self::vs32 => "vs32",
            Self::vs33 => "vs33",
            Self::vs34 => "vs34",
            Self::vs35 => "vs35",
            Self::vs36 => "vs36",
            Self::vs37 => "vs37",
            Self::vs38 => "vs38",
            Self::vs39 => "vs39",
            Self::vs40 => "vs40",
            Self::vs41 => "vs41",
            Self::vs42 => "vs42",
            Self::vs43 => "vs43",
            Self::vs44 => "vs44",
            Self::vs45 => "vs45",
            Self::vs46 => "vs46",
            Self::vs47 => "vs47",
            Self::vs48 => "vs48",
            Self::vs49 => "vs49",
            Self::vs50 => "vs50",
            Self::vs51 => "vs51",
            Self::vs52 => "vs52",
            Self::vs53 => "vs53",
            Self::vs54 => "vs54",
            Self::vs55 => "vs55",
            Self::vs56 => "vs56",
            Self::vs57 => "vs57",
            Self::vs58 => "vs58",
            Self::vs59 => "vs59",
            Self::vs60 => "vs60",
            Self::vs61 => "vs61",
            Self::vs62 => "vs62",
            Self::vs63 => "vs63",
            Self::f0 => "f0",
            Self::f1 => "f1",
            Self::f2 => "f2",
            Self::f3 => "f3",
            Self::f4 => "f4",
            Self::f5 => "f5",
            Self::f6 => "f6",
            Self::f7 => "f7",
            Self::f8 => "f8",
            Self::f9 => "f9",
            Self::f10 => "f10",
            Self::f11 => "f11",
            Self::f12 => "f12",
            Self::f13 => "f13",
            Self::f14 => "f14",
            Self::f15 => "f15",
            Self::f16 => "f16",
            Self::f17 => "f17",
            Self::f18 => "f18",
            Self::f19 => "f19",
            Self::f20 => "f20",
            Self::f21 => "f21",
            Self::f22 => "f22",
            Self::f23 => "f23",
            Self::f24 => "f24",
            Self::f25 => "f25",
            Self::f26 => "f26",
            Self::f27 => "f27",
            Self::f28 => "f28",
            Self::f29 => "f29",
            Self::f30 => "f30",
            Self::f31 => "f31",
            Self::vr0_64_1 => "vr0_64_1",
            Self::vr0_64_0 => "vr0_64_0",
            Self::vr1_64_1 => "vr1_64_1",
            Self::vr1_64_0 => "vr1_64_0",
            Self::vr2_64_1 => "vr2_64_1",
            Self::vr2_64_0 => "vr2_64_0",
            Self::vr3_64_1 => "vr3_64_1",
            Self::vr3_64_0 => "vr3_64_0",
            Self::vr4_64_1 => "vr4_64_1",
            Self::vr4_64_0 => "vr4_64_0",
            Self::vr5_64_1 => "vr5_64_1",
            Self::vr5_64_0 => "vr5_64_0",
            Self::vr6_64_1 => "vr6_64_1",
            Self::vr6_64_0 => "vr6_64_0",
            Self::vr7_64_1 => "vr7_64_1",
            Self::vr7_64_0 => "vr7_64_0",
            Self::vr8_64_1 => "vr8_64_1",
            Self::vr8_64_0 => "vr8_64_0",
            Self::vr9_64_1 => "vr9_64_1",
            Self::vr9_64_0 => "vr9_64_0",
            Self::vr10_64_1 => "vr10_64_1",
            Self::vr10_64_0 => "vr10_64_0",
            Self::vr11_64_1 => "vr11_64_1",
            Self::vr11_64_0 => "vr11_64_0",
            Self::vr12_64_1 => "vr12_64_1",
            Self::vr12_64_0 => "vr12_64_0",
            Self::vr13_64_1 => "vr13_64_1",
            Self::vr13_64_0 => "vr13_64_0",
            Self::vr14_64_1 => "vr14_64_1",
            Self::vr14_64_0 => "vr14_64_0",
            Self::vr15_64_1 => "vr15_64_1",
            Self::vr15_64_0 => "vr15_64_0",
            Self::vr16_64_1 => "vr16_64_1",
            Self::vr16_64_0 => "vr16_64_0",
            Self::vr17_64_1 => "vr17_64_1",
            Self::vr17_64_0 => "vr17_64_0",
            Self::vr18_64_1 => "vr18_64_1",
            Self::vr18_64_0 => "vr18_64_0",
            Self::vr19_64_1 => "vr19_64_1",
            Self::vr19_64_0 => "vr19_64_0",
            Self::vr20_64_1 => "vr20_64_1",
            Self::vr20_64_0 => "vr20_64_0",
            Self::vr21_64_1 => "vr21_64_1",
            Self::vr21_64_0 => "vr21_64_0",
            Self::vr22_64_1 => "vr22_64_1",
            Self::vr22_64_0 => "vr22_64_0",
            Self::vr23_64_1 => "vr23_64_1",
            Self::vr23_64_0 => "vr23_64_0",
            Self::vr24_64_1 => "vr24_64_1",
            Self::vr24_64_0 => "vr24_64_0",
            Self::vr25_64_1 => "vr25_64_1",
            Self::vr25_64_0 => "vr25_64_0",
            Self::vr26_64_1 => "vr26_64_1",
            Self::vr26_64_0 => "vr26_64_0",
            Self::vr27_64_1 => "vr27_64_1",
            Self::vr27_64_0 => "vr27_64_0",
            Self::vr28_64_1 => "vr28_64_1",
            Self::vr28_64_0 => "vr28_64_0",
            Self::vr29_64_1 => "vr29_64_1",
            Self::vr29_64_0 => "vr29_64_0",
            Self::vr30_64_1 => "vr30_64_1",
            Self::vr30_64_0 => "vr30_64_0",
            Self::vr31_64_1 => "vr31_64_1",
            Self::vr31_64_0 => "vr31_64_0",
            Self::vr0_32_3 => "vr0_32_3",
            Self::vr0_32_2 => "vr0_32_2",
            Self::vr0_32_1 => "vr0_32_1",
            Self::vr0_32_0 => "vr0_32_0",
            Self::vr1_32_3 => "vr1_32_3",
            Self::vr1_32_2 => "vr1_32_2",
            Self::vr1_32_1 => "vr1_32_1",
            Self::vr1_32_0 => "vr1_32_0",
            Self::vr2_32_3 => "vr2_32_3",
            Self::vr2_32_2 => "vr2_32_2",
            Self::vr2_32_1 => "vr2_32_1",
            Self::vr2_32_0 => "vr2_32_0",
            Self::vr3_32_3 => "vr3_32_3",
            Self::vr3_32_2 => "vr3_32_2",
            Self::vr3_32_1 => "vr3_32_1",
            Self::vr3_32_0 => "vr3_32_0",
            Self::vr4_32_3 => "vr4_32_3",
            Self::vr4_32_2 => "vr4_32_2",
            Self::vr4_32_1 => "vr4_32_1",
            Self::vr4_32_0 => "vr4_32_0",
            Self::vr5_32_3 => "vr5_32_3",
            Self::vr5_32_2 => "vr5_32_2",
            Self::vr5_32_1 => "vr5_32_1",
            Self::vr5_32_0 => "vr5_32_0",
            Self::vr6_32_3 => "vr6_32_3",
            Self::vr6_32_2 => "vr6_32_2",
            Self::vr6_32_1 => "vr6_32_1",
            Self::vr6_32_0 => "vr6_32_0",
            Self::vr7_32_3 => "vr7_32_3",
            Self::vr7_32_2 => "vr7_32_2",
            Self::vr7_32_1 => "vr7_32_1",
            Self::vr7_32_0 => "vr7_32_0",
            Self::vr8_32_3 => "vr8_32_3",
            Self::vr8_32_2 => "vr8_32_2",
            Self::vr8_32_1 => "vr8_32_1",
            Self::vr8_32_0 => "vr8_32_0",
            Self::vr9_32_3 => "vr9_32_3",
            Self::vr9_32_2 => "vr9_32_2",
            Self::vr9_32_1 => "vr9_32_1",
            Self::vr9_32_0 => "vr9_32_0",
            Self::vr10_32_3 => "vr10_32_3",
            Self::vr10_32_2 => "vr10_32_2",
            Self::vr10_32_1 => "vr10_32_1",
            Self::vr10_32_0 => "vr10_32_0",
            Self::vr11_32_3 => "vr11_32_3",
            Self::vr11_32_2 => "vr11_32_2",
            Self::vr11_32_1 => "vr11_32_1",
            Self::vr11_32_0 => "vr11_32_0",
            Self::vr12_32_3 => "vr12_32_3",
            Self::vr12_32_2 => "vr12_32_2",
            Self::vr12_32_1 => "vr12_32_1",
            Self::vr12_32_0 => "vr12_32_0",
            Self::vr13_32_3 => "vr13_32_3",
            Self::vr13_32_2 => "vr13_32_2",
            Self::vr13_32_1 => "vr13_32_1",
            Self::vr13_32_0 => "vr13_32_0",
            Self::vr14_32_3 => "vr14_32_3",
            Self::vr14_32_2 => "vr14_32_2",
            Self::vr14_32_1 => "vr14_32_1",
            Self::vr14_32_0 => "vr14_32_0",
            Self::vr15_32_3 => "vr15_32_3",
            Self::vr15_32_2 => "vr15_32_2",
            Self::vr15_32_1 => "vr15_32_1",
            Self::vr15_32_0 => "vr15_32_0",
            Self::vr16_32_3 => "vr16_32_3",
            Self::vr16_32_2 => "vr16_32_2",
            Self::vr16_32_1 => "vr16_32_1",
            Self::vr16_32_0 => "vr16_32_0",
            Self::vr17_32_3 => "vr17_32_3",
            Self::vr17_32_2 => "vr17_32_2",
            Self::vr17_32_1 => "vr17_32_1",
            Self::vr17_32_0 => "vr17_32_0",
            Self::vr18_32_3 => "vr18_32_3",
            Self::vr18_32_2 => "vr18_32_2",
            Self::vr18_32_1 => "vr18_32_1",
            Self::vr18_32_0 => "vr18_32_0",
            Self::vr19_32_3 => "vr19_32_3",
            Self::vr19_32_2 => "vr19_32_2",
            Self::vr19_32_1 => "vr19_32_1",
            Self::vr19_32_0 => "vr19_32_0",
            Self::vr20_32_3 => "vr20_32_3",
            Self::vr20_32_2 => "vr20_32_2",
            Self::vr20_32_1 => "vr20_32_1",
            Self::vr20_32_0 => "vr20_32_0",
            Self::vr21_32_3 => "vr21_32_3",
            Self::vr21_32_2 => "vr21_32_2",
            Self::vr21_32_1 => "vr21_32_1",
            Self::vr21_32_0 => "vr21_32_0",
            Self::vr22_32_3 => "vr22_32_3",
            Self::vr22_32_2 => "vr22_32_2",
            Self::vr22_32_1 => "vr22_32_1",
            Self::vr22_32_0 => "vr22_32_0",
            Self::vr23_32_3 => "vr23_32_3",
            Self::vr23_32_2 => "vr23_32_2",
            Self::vr23_32_1 => "vr23_32_1",
            Self::vr23_32_0 => "vr23_32_0",
            Self::vr24_32_3 => "vr24_32_3",
            Self::vr24_32_2 => "vr24_32_2",
            Self::vr24_32_1 => "vr24_32_1",
            Self::vr24_32_0 => "vr24_32_0",
            Self::vr25_32_3 => "vr25_32_3",
            Self::vr25_32_2 => "vr25_32_2",
            Self::vr25_32_1 => "vr25_32_1",
            Self::vr25_32_0 => "vr25_32_0",
            Self::vr26_32_3 => "vr26_32_3",
            Self::vr26_32_2 => "vr26_32_2",
            Self::vr26_32_1 => "vr26_32_1",
            Self::vr26_32_0 => "vr26_32_0",
            Self::vr27_32_3 => "vr27_32_3",
            Self::vr27_32_2 => "vr27_32_2",
            Self::vr27_32_1 => "vr27_32_1",
            Self::vr27_32_0 => "vr27_32_0",
            Self::vr28_32_3 => "vr28_32_3",
            Self::vr28_32_2 => "vr28_32_2",
            Self::vr28_32_1 => "vr28_32_1",
            Self::vr28_32_0 => "vr28_32_0",
            Self::vr29_32_3 => "vr29_32_3",
            Self::vr29_32_2 => "vr29_32_2",
            Self::vr29_32_1 => "vr29_32_1",
            Self::vr29_32_0 => "vr29_32_0",
            Self::vr30_32_3 => "vr30_32_3",
            Self::vr30_32_2 => "vr30_32_2",
            Self::vr30_32_1 => "vr30_32_1",
            Self::vr30_32_0 => "vr30_32_0",
            Self::vr31_32_3 => "vr31_32_3",
            Self::vr31_32_2 => "vr31_32_2",
            Self::vr31_32_1 => "vr31_32_1",
            Self::vr31_32_0 => "vr31_32_0",
            Self::vr0_16_7 => "vr0_16_7",
            Self::vr0_16_6 => "vr0_16_6",
            Self::vr0_16_5 => "vr0_16_5",
            Self::vr0_16_4 => "vr0_16_4",
            Self::vr0_16_3 => "vr0_16_3",
            Self::vr0_16_2 => "vr0_16_2",
            Self::vr0_16_1 => "vr0_16_1",
            Self::vr0_16_0 => "vr0_16_0",
            Self::vr1_16_7 => "vr1_16_7",
            Self::vr1_16_6 => "vr1_16_6",
            Self::vr1_16_5 => "vr1_16_5",
            Self::vr1_16_4 => "vr1_16_4",
            Self::vr1_16_3 => "vr1_16_3",
            Self::vr1_16_2 => "vr1_16_2",
            Self::vr1_16_1 => "vr1_16_1",
            Self::vr1_16_0 => "vr1_16_0",
            Self::vr2_16_7 => "vr2_16_7",
            Self::vr2_16_6 => "vr2_16_6",
            Self::vr2_16_5 => "vr2_16_5",
            Self::vr2_16_4 => "vr2_16_4",
            Self::vr2_16_3 => "vr2_16_3",
            Self::vr2_16_2 => "vr2_16_2",
            Self::vr2_16_1 => "vr2_16_1",
            Self::vr2_16_0 => "vr2_16_0",
            Self::vr3_16_7 => "vr3_16_7",
            Self::vr3_16_6 => "vr3_16_6",
            Self::vr3_16_5 => "vr3_16_5",
            Self::vr3_16_4 => "vr3_16_4",
            Self::vr3_16_3 => "vr3_16_3",
            Self::vr3_16_2 => "vr3_16_2",
            Self::vr3_16_1 => "vr3_16_1",
            Self::vr3_16_0 => "vr3_16_0",
            Self::vr4_16_7 => "vr4_16_7",
            Self::vr4_16_6 => "vr4_16_6",
            Self::vr4_16_5 => "vr4_16_5",
            Self::vr4_16_4 => "vr4_16_4",
            Self::vr4_16_3 => "vr4_16_3",
            Self::vr4_16_2 => "vr4_16_2",
            Self::vr4_16_1 => "vr4_16_1",
            Self::vr4_16_0 => "vr4_16_0",
            Self::vr5_16_7 => "vr5_16_7",
            Self::vr5_16_6 => "vr5_16_6",
            Self::vr5_16_5 => "vr5_16_5",
            Self::vr5_16_4 => "vr5_16_4",
            Self::vr5_16_3 => "vr5_16_3",
            Self::vr5_16_2 => "vr5_16_2",
            Self::vr5_16_1 => "vr5_16_1",
            Self::vr5_16_0 => "vr5_16_0",
            Self::vr6_16_7 => "vr6_16_7",
            Self::vr6_16_6 => "vr6_16_6",
            Self::vr6_16_5 => "vr6_16_5",
            Self::vr6_16_4 => "vr6_16_4",
            Self::vr6_16_3 => "vr6_16_3",
            Self::vr6_16_2 => "vr6_16_2",
            Self::vr6_16_1 => "vr6_16_1",
            Self::vr6_16_0 => "vr6_16_0",
            Self::vr7_16_7 => "vr7_16_7",
            Self::vr7_16_6 => "vr7_16_6",
            Self::vr7_16_5 => "vr7_16_5",
            Self::vr7_16_4 => "vr7_16_4",
            Self::vr7_16_3 => "vr7_16_3",
            Self::vr7_16_2 => "vr7_16_2",
            Self::vr7_16_1 => "vr7_16_1",
            Self::vr7_16_0 => "vr7_16_0",
            Self::vr8_16_7 => "vr8_16_7",
            Self::vr8_16_6 => "vr8_16_6",
            Self::vr8_16_5 => "vr8_16_5",
            Self::vr8_16_4 => "vr8_16_4",
            Self::vr8_16_3 => "vr8_16_3",
            Self::vr8_16_2 => "vr8_16_2",
            Self::vr8_16_1 => "vr8_16_1",
            Self::vr8_16_0 => "vr8_16_0",
            Self::vr9_16_7 => "vr9_16_7",
            Self::vr9_16_6 => "vr9_16_6",
            Self::vr9_16_5 => "vr9_16_5",
            Self::vr9_16_4 => "vr9_16_4",
            Self::vr9_16_3 => "vr9_16_3",
            Self::vr9_16_2 => "vr9_16_2",
            Self::vr9_16_1 => "vr9_16_1",
            Self::vr9_16_0 => "vr9_16_0",
            Self::vr10_16_7 => "vr10_16_7",
            Self::vr10_16_6 => "vr10_16_6",
            Self::vr10_16_5 => "vr10_16_5",
            Self::vr10_16_4 => "vr10_16_4",
            Self::vr10_16_3 => "vr10_16_3",
            Self::vr10_16_2 => "vr10_16_2",
            Self::vr10_16_1 => "vr10_16_1",
            Self::vr10_16_0 => "vr10_16_0",
            Self::vr11_16_7 => "vr11_16_7",
            Self::vr11_16_6 => "vr11_16_6",
            Self::vr11_16_5 => "vr11_16_5",
            Self::vr11_16_4 => "vr11_16_4",
            Self::vr11_16_3 => "vr11_16_3",
            Self::vr11_16_2 => "vr11_16_2",
            Self::vr11_16_1 => "vr11_16_1",
            Self::vr11_16_0 => "vr11_16_0",
            Self::vr12_16_7 => "vr12_16_7",
            Self::vr12_16_6 => "vr12_16_6",
            Self::vr12_16_5 => "vr12_16_5",
            Self::vr12_16_4 => "vr12_16_4",
            Self::vr12_16_3 => "vr12_16_3",
            Self::vr12_16_2 => "vr12_16_2",
            Self::vr12_16_1 => "vr12_16_1",
            Self::vr12_16_0 => "vr12_16_0",
            Self::vr13_16_7 => "vr13_16_7",
            Self::vr13_16_6 => "vr13_16_6",
            Self::vr13_16_5 => "vr13_16_5",
            Self::vr13_16_4 => "vr13_16_4",
            Self::vr13_16_3 => "vr13_16_3",
            Self::vr13_16_2 => "vr13_16_2",
            Self::vr13_16_1 => "vr13_16_1",
            Self::vr13_16_0 => "vr13_16_0",
            Self::vr14_16_7 => "vr14_16_7",
            Self::vr14_16_6 => "vr14_16_6",
            Self::vr14_16_5 => "vr14_16_5",
            Self::vr14_16_4 => "vr14_16_4",
            Self::vr14_16_3 => "vr14_16_3",
            Self::vr14_16_2 => "vr14_16_2",
            Self::vr14_16_1 => "vr14_16_1",
            Self::vr14_16_0 => "vr14_16_0",
            Self::vr15_16_7 => "vr15_16_7",
            Self::vr15_16_6 => "vr15_16_6",
            Self::vr15_16_5 => "vr15_16_5",
            Self::vr15_16_4 => "vr15_16_4",
            Self::vr15_16_3 => "vr15_16_3",
            Self::vr15_16_2 => "vr15_16_2",
            Self::vr15_16_1 => "vr15_16_1",
            Self::vr15_16_0 => "vr15_16_0",
            Self::vr16_16_7 => "vr16_16_7",
            Self::vr16_16_6 => "vr16_16_6",
            Self::vr16_16_5 => "vr16_16_5",
            Self::vr16_16_4 => "vr16_16_4",
            Self::vr16_16_3 => "vr16_16_3",
            Self::vr16_16_2 => "vr16_16_2",
            Self::vr16_16_1 => "vr16_16_1",
            Self::vr16_16_0 => "vr16_16_0",
            Self::vr17_16_7 => "vr17_16_7",
            Self::vr17_16_6 => "vr17_16_6",
            Self::vr17_16_5 => "vr17_16_5",
            Self::vr17_16_4 => "vr17_16_4",
            Self::vr17_16_3 => "vr17_16_3",
            Self::vr17_16_2 => "vr17_16_2",
            Self::vr17_16_1 => "vr17_16_1",
            Self::vr17_16_0 => "vr17_16_0",
            Self::vr18_16_7 => "vr18_16_7",
            Self::vr18_16_6 => "vr18_16_6",
            Self::vr18_16_5 => "vr18_16_5",
            Self::vr18_16_4 => "vr18_16_4",
            Self::vr18_16_3 => "vr18_16_3",
            Self::vr18_16_2 => "vr18_16_2",
            Self::vr18_16_1 => "vr18_16_1",
            Self::vr18_16_0 => "vr18_16_0",
            Self::vr19_16_7 => "vr19_16_7",
            Self::vr19_16_6 => "vr19_16_6",
            Self::vr19_16_5 => "vr19_16_5",
            Self::vr19_16_4 => "vr19_16_4",
            Self::vr19_16_3 => "vr19_16_3",
            Self::vr19_16_2 => "vr19_16_2",
            Self::vr19_16_1 => "vr19_16_1",
            Self::vr19_16_0 => "vr19_16_0",
            Self::vr20_16_7 => "vr20_16_7",
            Self::vr20_16_6 => "vr20_16_6",
            Self::vr20_16_5 => "vr20_16_5",
            Self::vr20_16_4 => "vr20_16_4",
            Self::vr20_16_3 => "vr20_16_3",
            Self::vr20_16_2 => "vr20_16_2",
            Self::vr20_16_1 => "vr20_16_1",
            Self::vr20_16_0 => "vr20_16_0",
            Self::vr21_16_7 => "vr21_16_7",
            Self::vr21_16_6 => "vr21_16_6",
            Self::vr21_16_5 => "vr21_16_5",
            Self::vr21_16_4 => "vr21_16_4",
            Self::vr21_16_3 => "vr21_16_3",
            Self::vr21_16_2 => "vr21_16_2",
            Self::vr21_16_1 => "vr21_16_1",
            Self::vr21_16_0 => "vr21_16_0",
            Self::vr22_16_7 => "vr22_16_7",
            Self::vr22_16_6 => "vr22_16_6",
            Self::vr22_16_5 => "vr22_16_5",
            Self::vr22_16_4 => "vr22_16_4",
            Self::vr22_16_3 => "vr22_16_3",
            Self::vr22_16_2 => "vr22_16_2",
            Self::vr22_16_1 => "vr22_16_1",
            Self::vr22_16_0 => "vr22_16_0",
            Self::vr23_16_7 => "vr23_16_7",
            Self::vr23_16_6 => "vr23_16_6",
            Self::vr23_16_5 => "vr23_16_5",
            Self::vr23_16_4 => "vr23_16_4",
            Self::vr23_16_3 => "vr23_16_3",
            Self::vr23_16_2 => "vr23_16_2",
            Self::vr23_16_1 => "vr23_16_1",
            Self::vr23_16_0 => "vr23_16_0",
            Self::vr24_16_7 => "vr24_16_7",
            Self::vr24_16_6 => "vr24_16_6",
            Self::vr24_16_5 => "vr24_16_5",
            Self::vr24_16_4 => "vr24_16_4",
            Self::vr24_16_3 => "vr24_16_3",
            Self::vr24_16_2 => "vr24_16_2",
            Self::vr24_16_1 => "vr24_16_1",
            Self::vr24_16_0 => "vr24_16_0",
            Self::vr25_16_7 => "vr25_16_7",
            Self::vr25_16_6 => "vr25_16_6",
            Self::vr25_16_5 => "vr25_16_5",
            Self::vr25_16_4 => "vr25_16_4",
            Self::vr25_16_3 => "vr25_16_3",
            Self::vr25_16_2 => "vr25_16_2",
            Self::vr25_16_1 => "vr25_16_1",
            Self::vr25_16_0 => "vr25_16_0",
            Self::vr26_16_7 => "vr26_16_7",
            Self::vr26_16_6 => "vr26_16_6",
            Self::vr26_16_5 => "vr26_16_5",
            Self::vr26_16_4 => "vr26_16_4",
            Self::vr26_16_3 => "vr26_16_3",
            Self::vr26_16_2 => "vr26_16_2",
            Self::vr26_16_1 => "vr26_16_1",
            Self::vr26_16_0 => "vr26_16_0",
            Self::vr27_16_7 => "vr27_16_7",
            Self::vr27_16_6 => "vr27_16_6",
            Self::vr27_16_5 => "vr27_16_5",
            Self::vr27_16_4 => "vr27_16_4",
            Self::vr27_16_3 => "vr27_16_3",
            Self::vr27_16_2 => "vr27_16_2",
            Self::vr27_16_1 => "vr27_16_1",
            Self::vr27_16_0 => "vr27_16_0",
            Self::vr28_16_7 => "vr28_16_7",
            Self::vr28_16_6 => "vr28_16_6",
            Self::vr28_16_5 => "vr28_16_5",
            Self::vr28_16_4 => "vr28_16_4",
            Self::vr28_16_3 => "vr28_16_3",
            Self::vr28_16_2 => "vr28_16_2",
            Self::vr28_16_1 => "vr28_16_1",
            Self::vr28_16_0 => "vr28_16_0",
            Self::vr29_16_7 => "vr29_16_7",
            Self::vr29_16_6 => "vr29_16_6",
            Self::vr29_16_5 => "vr29_16_5",
            Self::vr29_16_4 => "vr29_16_4",
            Self::vr29_16_3 => "vr29_16_3",
            Self::vr29_16_2 => "vr29_16_2",
            Self::vr29_16_1 => "vr29_16_1",
            Self::vr29_16_0 => "vr29_16_0",
            Self::vr30_16_7 => "vr30_16_7",
            Self::vr30_16_6 => "vr30_16_6",
            Self::vr30_16_5 => "vr30_16_5",
            Self::vr30_16_4 => "vr30_16_4",
            Self::vr30_16_3 => "vr30_16_3",
            Self::vr30_16_2 => "vr30_16_2",
            Self::vr30_16_1 => "vr30_16_1",
            Self::vr30_16_0 => "vr30_16_0",
            Self::vr31_16_7 => "vr31_16_7",
            Self::vr31_16_6 => "vr31_16_6",
            Self::vr31_16_5 => "vr31_16_5",
            Self::vr31_16_4 => "vr31_16_4",
            Self::vr31_16_3 => "vr31_16_3",
            Self::vr31_16_2 => "vr31_16_2",
            Self::vr31_16_1 => "vr31_16_1",
            Self::vr31_16_0 => "vr31_16_0",
            Self::vr0_8_15 => "vr0_8_15",
            Self::vr0_8_14 => "vr0_8_14",
            Self::vr0_8_13 => "vr0_8_13",
            Self::vr0_8_12 => "vr0_8_12",
            Self::vr0_8_11 => "vr0_8_11",
            Self::vr0_8_10 => "vr0_8_10",
            Self::vr0_8_9 => "vr0_8_9",
            Self::vr0_8_8 => "vr0_8_8",
            Self::vr0_8_7 => "vr0_8_7",
            Self::vr0_8_6 => "vr0_8_6",
            Self::vr0_8_5 => "vr0_8_5",
            Self::vr0_8_4 => "vr0_8_4",
            Self::vr0_8_3 => "vr0_8_3",
            Self::vr0_8_2 => "vr0_8_2",
            Self::vr0_8_1 => "vr0_8_1",
            Self::vr0_8_0 => "vr0_8_0",
            Self::vr1_8_15 => "vr1_8_15",
            Self::vr1_8_14 => "vr1_8_14",
            Self::vr1_8_13 => "vr1_8_13",
            Self::vr1_8_12 => "vr1_8_12",
            Self::vr1_8_11 => "vr1_8_11",
            Self::vr1_8_10 => "vr1_8_10",
            Self::vr1_8_9 => "vr1_8_9",
            Self::vr1_8_8 => "vr1_8_8",
            Self::vr1_8_7 => "vr1_8_7",
            Self::vr1_8_6 => "vr1_8_6",
            Self::vr1_8_5 => "vr1_8_5",
            Self::vr1_8_4 => "vr1_8_4",
            Self::vr1_8_3 => "vr1_8_3",
            Self::vr1_8_2 => "vr1_8_2",
            Self::vr1_8_1 => "vr1_8_1",
            Self::vr1_8_0 => "vr1_8_0",
            Self::vr2_8_15 => "vr2_8_15",
            Self::vr2_8_14 => "vr2_8_14",
            Self::vr2_8_13 => "vr2_8_13",
            Self::vr2_8_12 => "vr2_8_12",
            Self::vr2_8_11 => "vr2_8_11",
            Self::vr2_8_10 => "vr2_8_10",
            Self::vr2_8_9 => "vr2_8_9",
            Self::vr2_8_8 => "vr2_8_8",
            Self::vr2_8_7 => "vr2_8_7",
            Self::vr2_8_6 => "vr2_8_6",
            Self::vr2_8_5 => "vr2_8_5",
            Self::vr2_8_4 => "vr2_8_4",
            Self::vr2_8_3 => "vr2_8_3",
            Self::vr2_8_2 => "vr2_8_2",
            Self::vr2_8_1 => "vr2_8_1",
            Self::vr2_8_0 => "vr2_8_0",
            Self::vr3_8_15 => "vr3_8_15",
            Self::vr3_8_14 => "vr3_8_14",
            Self::vr3_8_13 => "vr3_8_13",
            Self::vr3_8_12 => "vr3_8_12",
            Self::vr3_8_11 => "vr3_8_11",
            Self::vr3_8_10 => "vr3_8_10",
            Self::vr3_8_9 => "vr3_8_9",
            Self::vr3_8_8 => "vr3_8_8",
            Self::vr3_8_7 => "vr3_8_7",
            Self::vr3_8_6 => "vr3_8_6",
            Self::vr3_8_5 => "vr3_8_5",
            Self::vr3_8_4 => "vr3_8_4",
            Self::vr3_8_3 => "vr3_8_3",
            Self::vr3_8_2 => "vr3_8_2",
            Self::vr3_8_1 => "vr3_8_1",
            Self::vr3_8_0 => "vr3_8_0",
            Self::vr4_8_15 => "vr4_8_15",
            Self::vr4_8_14 => "vr4_8_14",
            Self::vr4_8_13 => "vr4_8_13",
            Self::vr4_8_12 => "vr4_8_12",
            Self::vr4_8_11 => "vr4_8_11",
            Self::vr4_8_10 => "vr4_8_10",
            Self::vr4_8_9 => "vr4_8_9",
            Self::vr4_8_8 => "vr4_8_8",
            Self::vr4_8_7 => "vr4_8_7",
            Self::vr4_8_6 => "vr4_8_6",
            Self::vr4_8_5 => "vr4_8_5",
            Self::vr4_8_4 => "vr4_8_4",
            Self::vr4_8_3 => "vr4_8_3",
            Self::vr4_8_2 => "vr4_8_2",
            Self::vr4_8_1 => "vr4_8_1",
            Self::vr4_8_0 => "vr4_8_0",
            Self::vr5_8_15 => "vr5_8_15",
            Self::vr5_8_14 => "vr5_8_14",
            Self::vr5_8_13 => "vr5_8_13",
            Self::vr5_8_12 => "vr5_8_12",
            Self::vr5_8_11 => "vr5_8_11",
            Self::vr5_8_10 => "vr5_8_10",
            Self::vr5_8_9 => "vr5_8_9",
            Self::vr5_8_8 => "vr5_8_8",
            Self::vr5_8_7 => "vr5_8_7",
            Self::vr5_8_6 => "vr5_8_6",
            Self::vr5_8_5 => "vr5_8_5",
            Self::vr5_8_4 => "vr5_8_4",
            Self::vr5_8_3 => "vr5_8_3",
            Self::vr5_8_2 => "vr5_8_2",
            Self::vr5_8_1 => "vr5_8_1",
            Self::vr5_8_0 => "vr5_8_0",
            Self::vr6_8_15 => "vr6_8_15",
            Self::vr6_8_14 => "vr6_8_14",
            Self::vr6_8_13 => "vr6_8_13",
            Self::vr6_8_12 => "vr6_8_12",
            Self::vr6_8_11 => "vr6_8_11",
            Self::vr6_8_10 => "vr6_8_10",
            Self::vr6_8_9 => "vr6_8_9",
            Self::vr6_8_8 => "vr6_8_8",
            Self::vr6_8_7 => "vr6_8_7",
            Self::vr6_8_6 => "vr6_8_6",
            Self::vr6_8_5 => "vr6_8_5",
            Self::vr6_8_4 => "vr6_8_4",
            Self::vr6_8_3 => "vr6_8_3",
            Self::vr6_8_2 => "vr6_8_2",
            Self::vr6_8_1 => "vr6_8_1",
            Self::vr6_8_0 => "vr6_8_0",
            Self::vr7_8_15 => "vr7_8_15",
            Self::vr7_8_14 => "vr7_8_14",
            Self::vr7_8_13 => "vr7_8_13",
            Self::vr7_8_12 => "vr7_8_12",
            Self::vr7_8_11 => "vr7_8_11",
            Self::vr7_8_10 => "vr7_8_10",
            Self::vr7_8_9 => "vr7_8_9",
            Self::vr7_8_8 => "vr7_8_8",
            Self::vr7_8_7 => "vr7_8_7",
            Self::vr7_8_6 => "vr7_8_6",
            Self::vr7_8_5 => "vr7_8_5",
            Self::vr7_8_4 => "vr7_8_4",
            Self::vr7_8_3 => "vr7_8_3",
            Self::vr7_8_2 => "vr7_8_2",
            Self::vr7_8_1 => "vr7_8_1",
            Self::vr7_8_0 => "vr7_8_0",
            Self::vr8_8_15 => "vr8_8_15",
            Self::vr8_8_14 => "vr8_8_14",
            Self::vr8_8_13 => "vr8_8_13",
            Self::vr8_8_12 => "vr8_8_12",
            Self::vr8_8_11 => "vr8_8_11",
            Self::vr8_8_10 => "vr8_8_10",
            Self::vr8_8_9 => "vr8_8_9",
            Self::vr8_8_8 => "vr8_8_8",
            Self::vr8_8_7 => "vr8_8_7",
            Self::vr8_8_6 => "vr8_8_6",
            Self::vr8_8_5 => "vr8_8_5",
            Self::vr8_8_4 => "vr8_8_4",
            Self::vr8_8_3 => "vr8_8_3",
            Self::vr8_8_2 => "vr8_8_2",
            Self::vr8_8_1 => "vr8_8_1",
            Self::vr8_8_0 => "vr8_8_0",
            Self::vr9_8_15 => "vr9_8_15",
            Self::vr9_8_14 => "vr9_8_14",
            Self::vr9_8_13 => "vr9_8_13",
            Self::vr9_8_12 => "vr9_8_12",
            Self::vr9_8_11 => "vr9_8_11",
            Self::vr9_8_10 => "vr9_8_10",
            Self::vr9_8_9 => "vr9_8_9",
            Self::vr9_8_8 => "vr9_8_8",
            Self::vr9_8_7 => "vr9_8_7",
            Self::vr9_8_6 => "vr9_8_6",
            Self::vr9_8_5 => "vr9_8_5",
            Self::vr9_8_4 => "vr9_8_4",
            Self::vr9_8_3 => "vr9_8_3",
            Self::vr9_8_2 => "vr9_8_2",
            Self::vr9_8_1 => "vr9_8_1",
            Self::vr9_8_0 => "vr9_8_0",
            Self::vr10_8_15 => "vr10_8_15",
            Self::vr10_8_14 => "vr10_8_14",
            Self::vr10_8_13 => "vr10_8_13",
            Self::vr10_8_12 => "vr10_8_12",
            Self::vr10_8_11 => "vr10_8_11",
            Self::vr10_8_10 => "vr10_8_10",
            Self::vr10_8_9 => "vr10_8_9",
            Self::vr10_8_8 => "vr10_8_8",
            Self::vr10_8_7 => "vr10_8_7",
            Self::vr10_8_6 => "vr10_8_6",
            Self::vr10_8_5 => "vr10_8_5",
            Self::vr10_8_4 => "vr10_8_4",
            Self::vr10_8_3 => "vr10_8_3",
            Self::vr10_8_2 => "vr10_8_2",
            Self::vr10_8_1 => "vr10_8_1",
            Self::vr10_8_0 => "vr10_8_0",
            Self::vr11_8_15 => "vr11_8_15",
            Self::vr11_8_14 => "vr11_8_14",
            Self::vr11_8_13 => "vr11_8_13",
            Self::vr11_8_12 => "vr11_8_12",
            Self::vr11_8_11 => "vr11_8_11",
            Self::vr11_8_10 => "vr11_8_10",
            Self::vr11_8_9 => "vr11_8_9",
            Self::vr11_8_8 => "vr11_8_8",
            Self::vr11_8_7 => "vr11_8_7",
            Self::vr11_8_6 => "vr11_8_6",
            Self::vr11_8_5 => "vr11_8_5",
            Self::vr11_8_4 => "vr11_8_4",
            Self::vr11_8_3 => "vr11_8_3",
            Self::vr11_8_2 => "vr11_8_2",
            Self::vr11_8_1 => "vr11_8_1",
            Self::vr11_8_0 => "vr11_8_0",
            Self::vr12_8_15 => "vr12_8_15",
            Self::vr12_8_14 => "vr12_8_14",
            Self::vr12_8_13 => "vr12_8_13",
            Self::vr12_8_12 => "vr12_8_12",
            Self::vr12_8_11 => "vr12_8_11",
            Self::vr12_8_10 => "vr12_8_10",
            Self::vr12_8_9 => "vr12_8_9",
            Self::vr12_8_8 => "vr12_8_8",
            Self::vr12_8_7 => "vr12_8_7",
            Self::vr12_8_6 => "vr12_8_6",
            Self::vr12_8_5 => "vr12_8_5",
            Self::vr12_8_4 => "vr12_8_4",
            Self::vr12_8_3 => "vr12_8_3",
            Self::vr12_8_2 => "vr12_8_2",
            Self::vr12_8_1 => "vr12_8_1",
            Self::vr12_8_0 => "vr12_8_0",
            Self::vr13_8_15 => "vr13_8_15",
            Self::vr13_8_14 => "vr13_8_14",
            Self::vr13_8_13 => "vr13_8_13",
            Self::vr13_8_12 => "vr13_8_12",
            Self::vr13_8_11 => "vr13_8_11",
            Self::vr13_8_10 => "vr13_8_10",
            Self::vr13_8_9 => "vr13_8_9",
            Self::vr13_8_8 => "vr13_8_8",
            Self::vr13_8_7 => "vr13_8_7",
            Self::vr13_8_6 => "vr13_8_6",
            Self::vr13_8_5 => "vr13_8_5",
            Self::vr13_8_4 => "vr13_8_4",
            Self::vr13_8_3 => "vr13_8_3",
            Self::vr13_8_2 => "vr13_8_2",
            Self::vr13_8_1 => "vr13_8_1",
            Self::vr13_8_0 => "vr13_8_0",
            Self::vr14_8_15 => "vr14_8_15",
            Self::vr14_8_14 => "vr14_8_14",
            Self::vr14_8_13 => "vr14_8_13",
            Self::vr14_8_12 => "vr14_8_12",
            Self::vr14_8_11 => "vr14_8_11",
            Self::vr14_8_10 => "vr14_8_10",
            Self::vr14_8_9 => "vr14_8_9",
            Self::vr14_8_8 => "vr14_8_8",
            Self::vr14_8_7 => "vr14_8_7",
            Self::vr14_8_6 => "vr14_8_6",
            Self::vr14_8_5 => "vr14_8_5",
            Self::vr14_8_4 => "vr14_8_4",
            Self::vr14_8_3 => "vr14_8_3",
            Self::vr14_8_2 => "vr14_8_2",
            Self::vr14_8_1 => "vr14_8_1",
            Self::vr14_8_0 => "vr14_8_0",
            Self::vr15_8_15 => "vr15_8_15",
            Self::vr15_8_14 => "vr15_8_14",
            Self::vr15_8_13 => "vr15_8_13",
            Self::vr15_8_12 => "vr15_8_12",
            Self::vr15_8_11 => "vr15_8_11",
            Self::vr15_8_10 => "vr15_8_10",
            Self::vr15_8_9 => "vr15_8_9",
            Self::vr15_8_8 => "vr15_8_8",
            Self::vr15_8_7 => "vr15_8_7",
            Self::vr15_8_6 => "vr15_8_6",
            Self::vr15_8_5 => "vr15_8_5",
            Self::vr15_8_4 => "vr15_8_4",
            Self::vr15_8_3 => "vr15_8_3",
            Self::vr15_8_2 => "vr15_8_2",
            Self::vr15_8_1 => "vr15_8_1",
            Self::vr15_8_0 => "vr15_8_0",
            Self::vr16_8_15 => "vr16_8_15",
            Self::vr16_8_14 => "vr16_8_14",
            Self::vr16_8_13 => "vr16_8_13",
            Self::vr16_8_12 => "vr16_8_12",
            Self::vr16_8_11 => "vr16_8_11",
            Self::vr16_8_10 => "vr16_8_10",
            Self::vr16_8_9 => "vr16_8_9",
            Self::vr16_8_8 => "vr16_8_8",
            Self::vr16_8_7 => "vr16_8_7",
            Self::vr16_8_6 => "vr16_8_6",
            Self::vr16_8_5 => "vr16_8_5",
            Self::vr16_8_4 => "vr16_8_4",
            Self::vr16_8_3 => "vr16_8_3",
            Self::vr16_8_2 => "vr16_8_2",
            Self::vr16_8_1 => "vr16_8_1",
            Self::vr16_8_0 => "vr16_8_0",
            Self::vr17_8_15 => "vr17_8_15",
            Self::vr17_8_14 => "vr17_8_14",
            Self::vr17_8_13 => "vr17_8_13",
            Self::vr17_8_12 => "vr17_8_12",
            Self::vr17_8_11 => "vr17_8_11",
            Self::vr17_8_10 => "vr17_8_10",
            Self::vr17_8_9 => "vr17_8_9",
            Self::vr17_8_8 => "vr17_8_8",
            Self::vr17_8_7 => "vr17_8_7",
            Self::vr17_8_6 => "vr17_8_6",
            Self::vr17_8_5 => "vr17_8_5",
            Self::vr17_8_4 => "vr17_8_4",
            Self::vr17_8_3 => "vr17_8_3",
            Self::vr17_8_2 => "vr17_8_2",
            Self::vr17_8_1 => "vr17_8_1",
            Self::vr17_8_0 => "vr17_8_0",
            Self::vr18_8_15 => "vr18_8_15",
            Self::vr18_8_14 => "vr18_8_14",
            Self::vr18_8_13 => "vr18_8_13",
            Self::vr18_8_12 => "vr18_8_12",
            Self::vr18_8_11 => "vr18_8_11",
            Self::vr18_8_10 => "vr18_8_10",
            Self::vr18_8_9 => "vr18_8_9",
            Self::vr18_8_8 => "vr18_8_8",
            Self::vr18_8_7 => "vr18_8_7",
            Self::vr18_8_6 => "vr18_8_6",
            Self::vr18_8_5 => "vr18_8_5",
            Self::vr18_8_4 => "vr18_8_4",
            Self::vr18_8_3 => "vr18_8_3",
            Self::vr18_8_2 => "vr18_8_2",
            Self::vr18_8_1 => "vr18_8_1",
            Self::vr18_8_0 => "vr18_8_0",
            Self::vr19_8_15 => "vr19_8_15",
            Self::vr19_8_14 => "vr19_8_14",
            Self::vr19_8_13 => "vr19_8_13",
            Self::vr19_8_12 => "vr19_8_12",
            Self::vr19_8_11 => "vr19_8_11",
            Self::vr19_8_10 => "vr19_8_10",
            Self::vr19_8_9 => "vr19_8_9",
            Self::vr19_8_8 => "vr19_8_8",
            Self::vr19_8_7 => "vr19_8_7",
            Self::vr19_8_6 => "vr19_8_6",
            Self::vr19_8_5 => "vr19_8_5",
            Self::vr19_8_4 => "vr19_8_4",
            Self::vr19_8_3 => "vr19_8_3",
            Self::vr19_8_2 => "vr19_8_2",
            Self::vr19_8_1 => "vr19_8_1",
            Self::vr19_8_0 => "vr19_8_0",
            Self::vr20_8_15 => "vr20_8_15",
            Self::vr20_8_14 => "vr20_8_14",
            Self::vr20_8_13 => "vr20_8_13",
            Self::vr20_8_12 => "vr20_8_12",
            Self::vr20_8_11 => "vr20_8_11",
            Self::vr20_8_10 => "vr20_8_10",
            Self::vr20_8_9 => "vr20_8_9",
            Self::vr20_8_8 => "vr20_8_8",
            Self::vr20_8_7 => "vr20_8_7",
            Self::vr20_8_6 => "vr20_8_6",
            Self::vr20_8_5 => "vr20_8_5",
            Self::vr20_8_4 => "vr20_8_4",
            Self::vr20_8_3 => "vr20_8_3",
            Self::vr20_8_2 => "vr20_8_2",
            Self::vr20_8_1 => "vr20_8_1",
            Self::vr20_8_0 => "vr20_8_0",
            Self::vr21_8_15 => "vr21_8_15",
            Self::vr21_8_14 => "vr21_8_14",
            Self::vr21_8_13 => "vr21_8_13",
            Self::vr21_8_12 => "vr21_8_12",
            Self::vr21_8_11 => "vr21_8_11",
            Self::vr21_8_10 => "vr21_8_10",
            Self::vr21_8_9 => "vr21_8_9",
            Self::vr21_8_8 => "vr21_8_8",
            Self::vr21_8_7 => "vr21_8_7",
            Self::vr21_8_6 => "vr21_8_6",
            Self::vr21_8_5 => "vr21_8_5",
            Self::vr21_8_4 => "vr21_8_4",
            Self::vr21_8_3 => "vr21_8_3",
            Self::vr21_8_2 => "vr21_8_2",
            Self::vr21_8_1 => "vr21_8_1",
            Self::vr21_8_0 => "vr21_8_0",
            Self::vr22_8_15 => "vr22_8_15",
            Self::vr22_8_14 => "vr22_8_14",
            Self::vr22_8_13 => "vr22_8_13",
            Self::vr22_8_12 => "vr22_8_12",
            Self::vr22_8_11 => "vr22_8_11",
            Self::vr22_8_10 => "vr22_8_10",
            Self::vr22_8_9 => "vr22_8_9",
            Self::vr22_8_8 => "vr22_8_8",
            Self::vr22_8_7 => "vr22_8_7",
            Self::vr22_8_6 => "vr22_8_6",
            Self::vr22_8_5 => "vr22_8_5",
            Self::vr22_8_4 => "vr22_8_4",
            Self::vr22_8_3 => "vr22_8_3",
            Self::vr22_8_2 => "vr22_8_2",
            Self::vr22_8_1 => "vr22_8_1",
            Self::vr22_8_0 => "vr22_8_0",
            Self::vr23_8_15 => "vr23_8_15",
            Self::vr23_8_14 => "vr23_8_14",
            Self::vr23_8_13 => "vr23_8_13",
            Self::vr23_8_12 => "vr23_8_12",
            Self::vr23_8_11 => "vr23_8_11",
            Self::vr23_8_10 => "vr23_8_10",
            Self::vr23_8_9 => "vr23_8_9",
            Self::vr23_8_8 => "vr23_8_8",
            Self::vr23_8_7 => "vr23_8_7",
            Self::vr23_8_6 => "vr23_8_6",
            Self::vr23_8_5 => "vr23_8_5",
            Self::vr23_8_4 => "vr23_8_4",
            Self::vr23_8_3 => "vr23_8_3",
            Self::vr23_8_2 => "vr23_8_2",
            Self::vr23_8_1 => "vr23_8_1",
            Self::vr23_8_0 => "vr23_8_0",
            Self::vr24_8_15 => "vr24_8_15",
            Self::vr24_8_14 => "vr24_8_14",
            Self::vr24_8_13 => "vr24_8_13",
            Self::vr24_8_12 => "vr24_8_12",
            Self::vr24_8_11 => "vr24_8_11",
            Self::vr24_8_10 => "vr24_8_10",
            Self::vr24_8_9 => "vr24_8_9",
            Self::vr24_8_8 => "vr24_8_8",
            Self::vr24_8_7 => "vr24_8_7",
            Self::vr24_8_6 => "vr24_8_6",
            Self::vr24_8_5 => "vr24_8_5",
            Self::vr24_8_4 => "vr24_8_4",
            Self::vr24_8_3 => "vr24_8_3",
            Self::vr24_8_2 => "vr24_8_2",
            Self::vr24_8_1 => "vr24_8_1",
            Self::vr24_8_0 => "vr24_8_0",
            Self::vr25_8_15 => "vr25_8_15",
            Self::vr25_8_14 => "vr25_8_14",
            Self::vr25_8_13 => "vr25_8_13",
            Self::vr25_8_12 => "vr25_8_12",
            Self::vr25_8_11 => "vr25_8_11",
            Self::vr25_8_10 => "vr25_8_10",
            Self::vr25_8_9 => "vr25_8_9",
            Self::vr25_8_8 => "vr25_8_8",
            Self::vr25_8_7 => "vr25_8_7",
            Self::vr25_8_6 => "vr25_8_6",
            Self::vr25_8_5 => "vr25_8_5",
            Self::vr25_8_4 => "vr25_8_4",
            Self::vr25_8_3 => "vr25_8_3",
            Self::vr25_8_2 => "vr25_8_2",
            Self::vr25_8_1 => "vr25_8_1",
            Self::vr25_8_0 => "vr25_8_0",
            Self::vr26_8_15 => "vr26_8_15",
            Self::vr26_8_14 => "vr26_8_14",
            Self::vr26_8_13 => "vr26_8_13",
            Self::vr26_8_12 => "vr26_8_12",
            Self::vr26_8_11 => "vr26_8_11",
            Self::vr26_8_10 => "vr26_8_10",
            Self::vr26_8_9 => "vr26_8_9",
            Self::vr26_8_8 => "vr26_8_8",
            Self::vr26_8_7 => "vr26_8_7",
            Self::vr26_8_6 => "vr26_8_6",
            Self::vr26_8_5 => "vr26_8_5",
            Self::vr26_8_4 => "vr26_8_4",
            Self::vr26_8_3 => "vr26_8_3",
            Self::vr26_8_2 => "vr26_8_2",
            Self::vr26_8_1 => "vr26_8_1",
            Self::vr26_8_0 => "vr26_8_0",
            Self::vr27_8_15 => "vr27_8_15",
            Self::vr27_8_14 => "vr27_8_14",
            Self::vr27_8_13 => "vr27_8_13",
            Self::vr27_8_12 => "vr27_8_12",
            Self::vr27_8_11 => "vr27_8_11",
            Self::vr27_8_10 => "vr27_8_10",
            Self::vr27_8_9 => "vr27_8_9",
            Self::vr27_8_8 => "vr27_8_8",
            Self::vr27_8_7 => "vr27_8_7",
            Self::vr27_8_6 => "vr27_8_6",
            Self::vr27_8_5 => "vr27_8_5",
            Self::vr27_8_4 => "vr27_8_4",
            Self::vr27_8_3 => "vr27_8_3",
            Self::vr27_8_2 => "vr27_8_2",
            Self::vr27_8_1 => "vr27_8_1",
            Self::vr27_8_0 => "vr27_8_0",
            Self::vr28_8_15 => "vr28_8_15",
            Self::vr28_8_14 => "vr28_8_14",
            Self::vr28_8_13 => "vr28_8_13",
            Self::vr28_8_12 => "vr28_8_12",
            Self::vr28_8_11 => "vr28_8_11",
            Self::vr28_8_10 => "vr28_8_10",
            Self::vr28_8_9 => "vr28_8_9",
            Self::vr28_8_8 => "vr28_8_8",
            Self::vr28_8_7 => "vr28_8_7",
            Self::vr28_8_6 => "vr28_8_6",
            Self::vr28_8_5 => "vr28_8_5",
            Self::vr28_8_4 => "vr28_8_4",
            Self::vr28_8_3 => "vr28_8_3",
            Self::vr28_8_2 => "vr28_8_2",
            Self::vr28_8_1 => "vr28_8_1",
            Self::vr28_8_0 => "vr28_8_0",
            Self::vr29_8_15 => "vr29_8_15",
            Self::vr29_8_14 => "vr29_8_14",
            Self::vr29_8_13 => "vr29_8_13",
            Self::vr29_8_12 => "vr29_8_12",
            Self::vr29_8_11 => "vr29_8_11",
            Self::vr29_8_10 => "vr29_8_10",
            Self::vr29_8_9 => "vr29_8_9",
            Self::vr29_8_8 => "vr29_8_8",
            Self::vr29_8_7 => "vr29_8_7",
            Self::vr29_8_6 => "vr29_8_6",
            Self::vr29_8_5 => "vr29_8_5",
            Self::vr29_8_4 => "vr29_8_4",
            Self::vr29_8_3 => "vr29_8_3",
            Self::vr29_8_2 => "vr29_8_2",
            Self::vr29_8_1 => "vr29_8_1",
            Self::vr29_8_0 => "vr29_8_0",
            Self::vr30_8_15 => "vr30_8_15",
            Self::vr30_8_14 => "vr30_8_14",
            Self::vr30_8_13 => "vr30_8_13",
            Self::vr30_8_12 => "vr30_8_12",
            Self::vr30_8_11 => "vr30_8_11",
            Self::vr30_8_10 => "vr30_8_10",
            Self::vr30_8_9 => "vr30_8_9",
            Self::vr30_8_8 => "vr30_8_8",
            Self::vr30_8_7 => "vr30_8_7",
            Self::vr30_8_6 => "vr30_8_6",
            Self::vr30_8_5 => "vr30_8_5",
            Self::vr30_8_4 => "vr30_8_4",
            Self::vr30_8_3 => "vr30_8_3",
            Self::vr30_8_2 => "vr30_8_2",
            Self::vr30_8_1 => "vr30_8_1",
            Self::vr30_8_0 => "vr30_8_0",
            Self::vr31_8_15 => "vr31_8_15",
            Self::vr31_8_14 => "vr31_8_14",
            Self::vr31_8_13 => "vr31_8_13",
            Self::vr31_8_12 => "vr31_8_12",
            Self::vr31_8_11 => "vr31_8_11",
            Self::vr31_8_10 => "vr31_8_10",
            Self::vr31_8_9 => "vr31_8_9",
            Self::vr31_8_8 => "vr31_8_8",
            Self::vr31_8_7 => "vr31_8_7",
            Self::vr31_8_6 => "vr31_8_6",
            Self::vr31_8_5 => "vr31_8_5",
            Self::vr31_8_4 => "vr31_8_4",
            Self::vr31_8_3 => "vr31_8_3",
            Self::vr31_8_2 => "vr31_8_2",
            Self::vr31_8_1 => "vr31_8_1",
            Self::vr31_8_0 => "vr31_8_0",
            Self::contextreg => "contextreg",
            Self::dcr000 => "dcr000",
            Self::dcr001 => "dcr001",
            Self::dcr002 => "dcr002",
            Self::dcr003 => "dcr003",
            Self::dcr004 => "dcr004",
            Self::dcr005 => "dcr005",
            Self::dcr006 => "dcr006",
            Self::dcr007 => "dcr007",
            Self::dcr008 => "dcr008",
            Self::dcr009 => "dcr009",
            Self::dcr00a => "dcr00a",
            Self::dcr00b => "dcr00b",
            Self::dcr00c => "dcr00c",
            Self::dcr00d => "dcr00d",
            Self::dcr00e => "dcr00e",
            Self::dcr00f => "dcr00f",
            Self::dcr010 => "dcr010",
            Self::dcr011 => "dcr011",
            Self::dcr012 => "dcr012",
            Self::dcr013 => "dcr013",
            Self::dcr014 => "dcr014",
            Self::dcr015 => "dcr015",
            Self::dcr016 => "dcr016",
            Self::dcr017 => "dcr017",
            Self::dcr018 => "dcr018",
            Self::dcr019 => "dcr019",
            Self::dcr01a => "dcr01a",
            Self::dcr01b => "dcr01b",
            Self::dcr01c => "dcr01c",
            Self::dcr01d => "dcr01d",
            Self::dcr01e => "dcr01e",
            Self::dcr01f => "dcr01f",
            Self::dcr020 => "dcr020",
            Self::dcr021 => "dcr021",
            Self::dcr022 => "dcr022",
            Self::dcr023 => "dcr023",
            Self::dcr024 => "dcr024",
            Self::dcr025 => "dcr025",
            Self::dcr026 => "dcr026",
            Self::dcr027 => "dcr027",
            Self::dcr028 => "dcr028",
            Self::dcr029 => "dcr029",
            Self::dcr02a => "dcr02a",
            Self::dcr02b => "dcr02b",
            Self::dcr02c => "dcr02c",
            Self::dcr02d => "dcr02d",
            Self::dcr02e => "dcr02e",
            Self::dcr02f => "dcr02f",
            Self::dcr030 => "dcr030",
            Self::dcr031 => "dcr031",
            Self::dcr032 => "dcr032",
            Self::dcr033 => "dcr033",
            Self::dcr034 => "dcr034",
            Self::dcr035 => "dcr035",
            Self::dcr036 => "dcr036",
            Self::dcr037 => "dcr037",
            Self::dcr038 => "dcr038",
            Self::dcr039 => "dcr039",
            Self::dcr03a => "dcr03a",
            Self::dcr03b => "dcr03b",
            Self::dcr03c => "dcr03c",
            Self::dcr03d => "dcr03d",
            Self::dcr03e => "dcr03e",
            Self::dcr03f => "dcr03f",
            Self::dcr040 => "dcr040",
            Self::dcr041 => "dcr041",
            Self::dcr042 => "dcr042",
            Self::dcr043 => "dcr043",
            Self::dcr044 => "dcr044",
            Self::dcr045 => "dcr045",
            Self::dcr046 => "dcr046",
            Self::dcr047 => "dcr047",
            Self::dcr048 => "dcr048",
            Self::dcr049 => "dcr049",
            Self::dcr04a => "dcr04a",
            Self::dcr04b => "dcr04b",
            Self::dcr04c => "dcr04c",
            Self::dcr04d => "dcr04d",
            Self::dcr04e => "dcr04e",
            Self::dcr04f => "dcr04f",
            Self::dcr050 => "dcr050",
            Self::dcr051 => "dcr051",
            Self::dcr052 => "dcr052",
            Self::dcr053 => "dcr053",
            Self::dcr054 => "dcr054",
            Self::dcr055 => "dcr055",
            Self::dcr056 => "dcr056",
            Self::dcr057 => "dcr057",
            Self::dcr058 => "dcr058",
            Self::dcr059 => "dcr059",
            Self::dcr05a => "dcr05a",
            Self::dcr05b => "dcr05b",
            Self::dcr05c => "dcr05c",
            Self::dcr05d => "dcr05d",
            Self::dcr05e => "dcr05e",
            Self::dcr05f => "dcr05f",
            Self::dcr060 => "dcr060",
            Self::dcr061 => "dcr061",
            Self::dcr062 => "dcr062",
            Self::dcr063 => "dcr063",
            Self::dcr064 => "dcr064",
            Self::dcr065 => "dcr065",
            Self::dcr066 => "dcr066",
            Self::dcr067 => "dcr067",
            Self::dcr068 => "dcr068",
            Self::dcr069 => "dcr069",
            Self::dcr06a => "dcr06a",
            Self::dcr06b => "dcr06b",
            Self::dcr06c => "dcr06c",
            Self::dcr06d => "dcr06d",
            Self::dcr06e => "dcr06e",
            Self::dcr06f => "dcr06f",
            Self::dcr070 => "dcr070",
            Self::dcr071 => "dcr071",
            Self::dcr072 => "dcr072",
            Self::dcr073 => "dcr073",
            Self::dcr074 => "dcr074",
            Self::dcr075 => "dcr075",
            Self::dcr076 => "dcr076",
            Self::dcr077 => "dcr077",
            Self::dcr078 => "dcr078",
            Self::dcr079 => "dcr079",
            Self::dcr07a => "dcr07a",
            Self::dcr07b => "dcr07b",
            Self::dcr07c => "dcr07c",
            Self::dcr07d => "dcr07d",
            Self::dcr07e => "dcr07e",
            Self::dcr07f => "dcr07f",
            Self::dcr080 => "dcr080",
            Self::dcr081 => "dcr081",
            Self::dcr082 => "dcr082",
            Self::dcr083 => "dcr083",
            Self::dcr084 => "dcr084",
            Self::dcr085 => "dcr085",
            Self::dcr086 => "dcr086",
            Self::dcr087 => "dcr087",
            Self::dcr088 => "dcr088",
            Self::dcr089 => "dcr089",
            Self::dcr08a => "dcr08a",
            Self::dcr08b => "dcr08b",
            Self::dcr08c => "dcr08c",
            Self::dcr08d => "dcr08d",
            Self::dcr08e => "dcr08e",
            Self::dcr08f => "dcr08f",
            Self::dcr090 => "dcr090",
            Self::dcr091 => "dcr091",
            Self::dcr092 => "dcr092",
            Self::dcr093 => "dcr093",
            Self::dcr094 => "dcr094",
            Self::dcr095 => "dcr095",
            Self::dcr096 => "dcr096",
            Self::dcr097 => "dcr097",
            Self::dcr098 => "dcr098",
            Self::dcr099 => "dcr099",
            Self::dcr09a => "dcr09a",
            Self::dcr09b => "dcr09b",
            Self::dcr09c => "dcr09c",
            Self::dcr09d => "dcr09d",
            Self::dcr09e => "dcr09e",
            Self::dcr09f => "dcr09f",
            Self::dcr0a0 => "dcr0a0",
            Self::dcr0a1 => "dcr0a1",
            Self::dcr0a2 => "dcr0a2",
            Self::dcr0a3 => "dcr0a3",
            Self::dcr0a4 => "dcr0a4",
            Self::dcr0a5 => "dcr0a5",
            Self::dcr0a6 => "dcr0a6",
            Self::dcr0a7 => "dcr0a7",
            Self::dcr0a8 => "dcr0a8",
            Self::dcr0a9 => "dcr0a9",
            Self::dcr0aa => "dcr0aa",
            Self::dcr0ab => "dcr0ab",
            Self::dcr0ac => "dcr0ac",
            Self::dcr0ad => "dcr0ad",
            Self::dcr0ae => "dcr0ae",
            Self::dcr0af => "dcr0af",
            Self::dcr0b0 => "dcr0b0",
            Self::dcr0b1 => "dcr0b1",
            Self::dcr0b2 => "dcr0b2",
            Self::dcr0b3 => "dcr0b3",
            Self::dcr0b4 => "dcr0b4",
            Self::dcr0b5 => "dcr0b5",
            Self::dcr0b6 => "dcr0b6",
            Self::dcr0b7 => "dcr0b7",
            Self::dcr0b8 => "dcr0b8",
            Self::dcr0b9 => "dcr0b9",
            Self::dcr0ba => "dcr0ba",
            Self::dcr0bb => "dcr0bb",
            Self::dcr0bc => "dcr0bc",
            Self::dcr0bd => "dcr0bd",
            Self::dcr0be => "dcr0be",
            Self::dcr0bf => "dcr0bf",
            Self::dcr0c0 => "dcr0c0",
            Self::dcr0c1 => "dcr0c1",
            Self::dcr0c2 => "dcr0c2",
            Self::dcr0c3 => "dcr0c3",
            Self::dcr0c4 => "dcr0c4",
            Self::dcr0c5 => "dcr0c5",
            Self::dcr0c6 => "dcr0c6",
            Self::dcr0c7 => "dcr0c7",
            Self::dcr0c8 => "dcr0c8",
            Self::dcr0c9 => "dcr0c9",
            Self::dcr0ca => "dcr0ca",
            Self::dcr0cb => "dcr0cb",
            Self::dcr0cc => "dcr0cc",
            Self::dcr0cd => "dcr0cd",
            Self::dcr0ce => "dcr0ce",
            Self::dcr0cf => "dcr0cf",
            Self::dcr0d0 => "dcr0d0",
            Self::dcr0d1 => "dcr0d1",
            Self::dcr0d2 => "dcr0d2",
            Self::dcr0d3 => "dcr0d3",
            Self::dcr0d4 => "dcr0d4",
            Self::dcr0d5 => "dcr0d5",
            Self::dcr0d6 => "dcr0d6",
            Self::dcr0d7 => "dcr0d7",
            Self::dcr0d8 => "dcr0d8",
            Self::dcr0d9 => "dcr0d9",
            Self::dcr0da => "dcr0da",
            Self::dcr0db => "dcr0db",
            Self::dcr0dc => "dcr0dc",
            Self::dcr0dd => "dcr0dd",
            Self::dcr0de => "dcr0de",
            Self::dcr0df => "dcr0df",
            Self::dcr0e0 => "dcr0e0",
            Self::dcr0e1 => "dcr0e1",
            Self::dcr0e2 => "dcr0e2",
            Self::dcr0e3 => "dcr0e3",
            Self::dcr0e4 => "dcr0e4",
            Self::dcr0e5 => "dcr0e5",
            Self::dcr0e6 => "dcr0e6",
            Self::dcr0e7 => "dcr0e7",
            Self::dcr0e8 => "dcr0e8",
            Self::dcr0e9 => "dcr0e9",
            Self::dcr0ea => "dcr0ea",
            Self::dcr0eb => "dcr0eb",
            Self::dcr0ec => "dcr0ec",
            Self::dcr0ed => "dcr0ed",
            Self::dcr0ee => "dcr0ee",
            Self::dcr0ef => "dcr0ef",
            Self::dcr0f0 => "dcr0f0",
            Self::dcr0f1 => "dcr0f1",
            Self::dcr0f2 => "dcr0f2",
            Self::dcr0f3 => "dcr0f3",
            Self::dcr0f4 => "dcr0f4",
            Self::dcr0f5 => "dcr0f5",
            Self::dcr0f6 => "dcr0f6",
            Self::dcr0f7 => "dcr0f7",
            Self::dcr0f8 => "dcr0f8",
            Self::dcr0f9 => "dcr0f9",
            Self::dcr0fa => "dcr0fa",
            Self::dcr0fb => "dcr0fb",
            Self::dcr0fc => "dcr0fc",
            Self::dcr0fd => "dcr0fd",
            Self::dcr0fe => "dcr0fe",
            Self::dcr0ff => "dcr0ff",
            Self::dcr100 => "dcr100",
            Self::dcr101 => "dcr101",
            Self::dcr102 => "dcr102",
            Self::dcr103 => "dcr103",
            Self::dcr104 => "dcr104",
            Self::dcr105 => "dcr105",
            Self::dcr106 => "dcr106",
            Self::dcr107 => "dcr107",
            Self::dcr108 => "dcr108",
            Self::dcr109 => "dcr109",
            Self::dcr10a => "dcr10a",
            Self::dcr10b => "dcr10b",
            Self::dcr10c => "dcr10c",
            Self::dcr10d => "dcr10d",
            Self::dcr10e => "dcr10e",
            Self::dcr10f => "dcr10f",
            Self::dcr110 => "dcr110",
            Self::dcr111 => "dcr111",
            Self::dcr112 => "dcr112",
            Self::dcr113 => "dcr113",
            Self::dcr114 => "dcr114",
            Self::dcr115 => "dcr115",
            Self::dcr116 => "dcr116",
            Self::dcr117 => "dcr117",
            Self::dcr118 => "dcr118",
            Self::dcr119 => "dcr119",
            Self::dcr11a => "dcr11a",
            Self::dcr11b => "dcr11b",
            Self::dcr11c => "dcr11c",
            Self::dcr11d => "dcr11d",
            Self::dcr11e => "dcr11e",
            Self::dcr11f => "dcr11f",
            Self::dcr120 => "dcr120",
            Self::dcr121 => "dcr121",
            Self::dcr122 => "dcr122",
            Self::dcr123 => "dcr123",
            Self::dcr124 => "dcr124",
            Self::dcr125 => "dcr125",
            Self::dcr126 => "dcr126",
            Self::dcr127 => "dcr127",
            Self::dcr128 => "dcr128",
            Self::dcr129 => "dcr129",
            Self::dcr12a => "dcr12a",
            Self::dcr12b => "dcr12b",
            Self::dcr12c => "dcr12c",
            Self::dcr12d => "dcr12d",
            Self::dcr12e => "dcr12e",
            Self::dcr12f => "dcr12f",
            Self::dcr130 => "dcr130",
            Self::dcr131 => "dcr131",
            Self::dcr132 => "dcr132",
            Self::dcr133 => "dcr133",
            Self::dcr134 => "dcr134",
            Self::dcr135 => "dcr135",
            Self::dcr136 => "dcr136",
            Self::dcr137 => "dcr137",
            Self::dcr138 => "dcr138",
            Self::dcr139 => "dcr139",
            Self::dcr13a => "dcr13a",
            Self::dcr13b => "dcr13b",
            Self::dcr13c => "dcr13c",
            Self::dcr13d => "dcr13d",
            Self::dcr13e => "dcr13e",
            Self::dcr13f => "dcr13f",
            Self::dcr140 => "dcr140",
            Self::dcr141 => "dcr141",
            Self::dcr142 => "dcr142",
            Self::dcr143 => "dcr143",
            Self::dcr144 => "dcr144",
            Self::dcr145 => "dcr145",
            Self::dcr146 => "dcr146",
            Self::dcr147 => "dcr147",
            Self::dcr148 => "dcr148",
            Self::dcr149 => "dcr149",
            Self::dcr14a => "dcr14a",
            Self::dcr14b => "dcr14b",
            Self::dcr14c => "dcr14c",
            Self::dcr14d => "dcr14d",
            Self::dcr14e => "dcr14e",
            Self::dcr14f => "dcr14f",
            Self::dcr150 => "dcr150",
            Self::dcr151 => "dcr151",
            Self::dcr152 => "dcr152",
            Self::dcr153 => "dcr153",
            Self::dcr154 => "dcr154",
            Self::dcr155 => "dcr155",
            Self::dcr156 => "dcr156",
            Self::dcr157 => "dcr157",
            Self::dcr158 => "dcr158",
            Self::dcr159 => "dcr159",
            Self::dcr15a => "dcr15a",
            Self::dcr15b => "dcr15b",
            Self::dcr15c => "dcr15c",
            Self::dcr15d => "dcr15d",
            Self::dcr15e => "dcr15e",
            Self::dcr15f => "dcr15f",
            Self::dcr160 => "dcr160",
            Self::dcr161 => "dcr161",
            Self::dcr162 => "dcr162",
            Self::dcr163 => "dcr163",
            Self::dcr164 => "dcr164",
            Self::dcr165 => "dcr165",
            Self::dcr166 => "dcr166",
            Self::dcr167 => "dcr167",
            Self::dcr168 => "dcr168",
            Self::dcr169 => "dcr169",
            Self::dcr16a => "dcr16a",
            Self::dcr16b => "dcr16b",
            Self::dcr16c => "dcr16c",
            Self::dcr16d => "dcr16d",
            Self::dcr16e => "dcr16e",
            Self::dcr16f => "dcr16f",
            Self::dcr170 => "dcr170",
            Self::dcr171 => "dcr171",
            Self::dcr172 => "dcr172",
            Self::dcr173 => "dcr173",
            Self::dcr174 => "dcr174",
            Self::dcr175 => "dcr175",
            Self::dcr176 => "dcr176",
            Self::dcr177 => "dcr177",
            Self::dcr178 => "dcr178",
            Self::dcr179 => "dcr179",
            Self::dcr17a => "dcr17a",
            Self::dcr17b => "dcr17b",
            Self::dcr17c => "dcr17c",
            Self::dcr17d => "dcr17d",
            Self::dcr17e => "dcr17e",
            Self::dcr17f => "dcr17f",
            Self::dcr180 => "dcr180",
            Self::dcr181 => "dcr181",
            Self::dcr182 => "dcr182",
            Self::dcr183 => "dcr183",
            Self::dcr184 => "dcr184",
            Self::dcr185 => "dcr185",
            Self::dcr186 => "dcr186",
            Self::dcr187 => "dcr187",
            Self::dcr188 => "dcr188",
            Self::dcr189 => "dcr189",
            Self::dcr18a => "dcr18a",
            Self::dcr18b => "dcr18b",
            Self::dcr18c => "dcr18c",
            Self::dcr18d => "dcr18d",
            Self::dcr18e => "dcr18e",
            Self::dcr18f => "dcr18f",
            Self::dcr190 => "dcr190",
            Self::dcr191 => "dcr191",
            Self::dcr192 => "dcr192",
            Self::dcr193 => "dcr193",
            Self::dcr194 => "dcr194",
            Self::dcr195 => "dcr195",
            Self::dcr196 => "dcr196",
            Self::dcr197 => "dcr197",
            Self::dcr198 => "dcr198",
            Self::dcr199 => "dcr199",
            Self::dcr19a => "dcr19a",
            Self::dcr19b => "dcr19b",
            Self::dcr19c => "dcr19c",
            Self::dcr19d => "dcr19d",
            Self::dcr19e => "dcr19e",
            Self::dcr19f => "dcr19f",
            Self::dcr1a0 => "dcr1a0",
            Self::dcr1a1 => "dcr1a1",
            Self::dcr1a2 => "dcr1a2",
            Self::dcr1a3 => "dcr1a3",
            Self::dcr1a4 => "dcr1a4",
            Self::dcr1a5 => "dcr1a5",
            Self::dcr1a6 => "dcr1a6",
            Self::dcr1a7 => "dcr1a7",
            Self::dcr1a8 => "dcr1a8",
            Self::dcr1a9 => "dcr1a9",
            Self::dcr1aa => "dcr1aa",
            Self::dcr1ab => "dcr1ab",
            Self::dcr1ac => "dcr1ac",
            Self::dcr1ad => "dcr1ad",
            Self::dcr1ae => "dcr1ae",
            Self::dcr1af => "dcr1af",
            Self::dcr1b0 => "dcr1b0",
            Self::dcr1b1 => "dcr1b1",
            Self::dcr1b2 => "dcr1b2",
            Self::dcr1b3 => "dcr1b3",
            Self::dcr1b4 => "dcr1b4",
            Self::dcr1b5 => "dcr1b5",
            Self::dcr1b6 => "dcr1b6",
            Self::dcr1b7 => "dcr1b7",
            Self::dcr1b8 => "dcr1b8",
            Self::dcr1b9 => "dcr1b9",
            Self::dcr1ba => "dcr1ba",
            Self::dcr1bb => "dcr1bb",
            Self::dcr1bc => "dcr1bc",
            Self::dcr1bd => "dcr1bd",
            Self::dcr1be => "dcr1be",
            Self::dcr1bf => "dcr1bf",
            Self::dcr1c0 => "dcr1c0",
            Self::dcr1c1 => "dcr1c1",
            Self::dcr1c2 => "dcr1c2",
            Self::dcr1c3 => "dcr1c3",
            Self::dcr1c4 => "dcr1c4",
            Self::dcr1c5 => "dcr1c5",
            Self::dcr1c6 => "dcr1c6",
            Self::dcr1c7 => "dcr1c7",
            Self::dcr1c8 => "dcr1c8",
            Self::dcr1c9 => "dcr1c9",
            Self::dcr1ca => "dcr1ca",
            Self::dcr1cb => "dcr1cb",
            Self::dcr1cc => "dcr1cc",
            Self::dcr1cd => "dcr1cd",
            Self::dcr1ce => "dcr1ce",
            Self::dcr1cf => "dcr1cf",
            Self::dcr1d0 => "dcr1d0",
            Self::dcr1d1 => "dcr1d1",
            Self::dcr1d2 => "dcr1d2",
            Self::dcr1d3 => "dcr1d3",
            Self::dcr1d4 => "dcr1d4",
            Self::dcr1d5 => "dcr1d5",
            Self::dcr1d6 => "dcr1d6",
            Self::dcr1d7 => "dcr1d7",
            Self::dcr1d8 => "dcr1d8",
            Self::dcr1d9 => "dcr1d9",
            Self::dcr1da => "dcr1da",
            Self::dcr1db => "dcr1db",
            Self::dcr1dc => "dcr1dc",
            Self::dcr1dd => "dcr1dd",
            Self::dcr1de => "dcr1de",
            Self::dcr1df => "dcr1df",
            Self::dcr1e0 => "dcr1e0",
            Self::dcr1e1 => "dcr1e1",
            Self::dcr1e2 => "dcr1e2",
            Self::dcr1e3 => "dcr1e3",
            Self::dcr1e4 => "dcr1e4",
            Self::dcr1e5 => "dcr1e5",
            Self::dcr1e6 => "dcr1e6",
            Self::dcr1e7 => "dcr1e7",
            Self::dcr1e8 => "dcr1e8",
            Self::dcr1e9 => "dcr1e9",
            Self::dcr1ea => "dcr1ea",
            Self::dcr1eb => "dcr1eb",
            Self::dcr1ec => "dcr1ec",
            Self::dcr1ed => "dcr1ed",
            Self::dcr1ee => "dcr1ee",
            Self::dcr1ef => "dcr1ef",
            Self::dcr1f0 => "dcr1f0",
            Self::dcr1f1 => "dcr1f1",
            Self::dcr1f2 => "dcr1f2",
            Self::dcr1f3 => "dcr1f3",
            Self::dcr1f4 => "dcr1f4",
            Self::dcr1f5 => "dcr1f5",
            Self::dcr1f6 => "dcr1f6",
            Self::dcr1f7 => "dcr1f7",
            Self::dcr1f8 => "dcr1f8",
            Self::dcr1f9 => "dcr1f9",
            Self::dcr1fa => "dcr1fa",
            Self::dcr1fb => "dcr1fb",
            Self::dcr1fc => "dcr1fc",
            Self::dcr1fd => "dcr1fd",
            Self::dcr1fe => "dcr1fe",
            Self::dcr1ff => "dcr1ff",
            Self::dcr200 => "dcr200",
            Self::dcr201 => "dcr201",
            Self::dcr202 => "dcr202",
            Self::dcr203 => "dcr203",
            Self::dcr204 => "dcr204",
            Self::dcr205 => "dcr205",
            Self::dcr206 => "dcr206",
            Self::dcr207 => "dcr207",
            Self::dcr208 => "dcr208",
            Self::dcr209 => "dcr209",
            Self::dcr20a => "dcr20a",
            Self::dcr20b => "dcr20b",
            Self::dcr20c => "dcr20c",
            Self::dcr20d => "dcr20d",
            Self::dcr20e => "dcr20e",
            Self::dcr20f => "dcr20f",
            Self::dcr210 => "dcr210",
            Self::dcr211 => "dcr211",
            Self::dcr212 => "dcr212",
            Self::dcr213 => "dcr213",
            Self::dcr214 => "dcr214",
            Self::dcr215 => "dcr215",
            Self::dcr216 => "dcr216",
            Self::dcr217 => "dcr217",
            Self::dcr218 => "dcr218",
            Self::dcr219 => "dcr219",
            Self::dcr21a => "dcr21a",
            Self::dcr21b => "dcr21b",
            Self::dcr21c => "dcr21c",
            Self::dcr21d => "dcr21d",
            Self::dcr21e => "dcr21e",
            Self::dcr21f => "dcr21f",
            Self::dcr220 => "dcr220",
            Self::dcr221 => "dcr221",
            Self::dcr222 => "dcr222",
            Self::dcr223 => "dcr223",
            Self::dcr224 => "dcr224",
            Self::dcr225 => "dcr225",
            Self::dcr226 => "dcr226",
            Self::dcr227 => "dcr227",
            Self::dcr228 => "dcr228",
            Self::dcr229 => "dcr229",
            Self::dcr22a => "dcr22a",
            Self::dcr22b => "dcr22b",
            Self::dcr22c => "dcr22c",
            Self::dcr22d => "dcr22d",
            Self::dcr22e => "dcr22e",
            Self::dcr22f => "dcr22f",
            Self::dcr230 => "dcr230",
            Self::dcr231 => "dcr231",
            Self::dcr232 => "dcr232",
            Self::dcr233 => "dcr233",
            Self::dcr234 => "dcr234",
            Self::dcr235 => "dcr235",
            Self::dcr236 => "dcr236",
            Self::dcr237 => "dcr237",
            Self::dcr238 => "dcr238",
            Self::dcr239 => "dcr239",
            Self::dcr23a => "dcr23a",
            Self::dcr23b => "dcr23b",
            Self::dcr23c => "dcr23c",
            Self::dcr23d => "dcr23d",
            Self::dcr23e => "dcr23e",
            Self::dcr23f => "dcr23f",
            Self::dcr240 => "dcr240",
            Self::dcr241 => "dcr241",
            Self::dcr242 => "dcr242",
            Self::dcr243 => "dcr243",
            Self::dcr244 => "dcr244",
            Self::dcr245 => "dcr245",
            Self::dcr246 => "dcr246",
            Self::dcr247 => "dcr247",
            Self::dcr248 => "dcr248",
            Self::dcr249 => "dcr249",
            Self::dcr24a => "dcr24a",
            Self::dcr24b => "dcr24b",
            Self::dcr24c => "dcr24c",
            Self::dcr24d => "dcr24d",
            Self::dcr24e => "dcr24e",
            Self::dcr24f => "dcr24f",
            Self::dcr250 => "dcr250",
            Self::dcr251 => "dcr251",
            Self::dcr252 => "dcr252",
            Self::dcr253 => "dcr253",
            Self::dcr254 => "dcr254",
            Self::dcr255 => "dcr255",
            Self::dcr256 => "dcr256",
            Self::dcr257 => "dcr257",
            Self::dcr258 => "dcr258",
            Self::dcr259 => "dcr259",
            Self::dcr25a => "dcr25a",
            Self::dcr25b => "dcr25b",
            Self::dcr25c => "dcr25c",
            Self::dcr25d => "dcr25d",
            Self::dcr25e => "dcr25e",
            Self::dcr25f => "dcr25f",
            Self::dcr260 => "dcr260",
            Self::dcr261 => "dcr261",
            Self::dcr262 => "dcr262",
            Self::dcr263 => "dcr263",
            Self::dcr264 => "dcr264",
            Self::dcr265 => "dcr265",
            Self::dcr266 => "dcr266",
            Self::dcr267 => "dcr267",
            Self::dcr268 => "dcr268",
            Self::dcr269 => "dcr269",
            Self::dcr26a => "dcr26a",
            Self::dcr26b => "dcr26b",
            Self::dcr26c => "dcr26c",
            Self::dcr26d => "dcr26d",
            Self::dcr26e => "dcr26e",
            Self::dcr26f => "dcr26f",
            Self::dcr270 => "dcr270",
            Self::dcr271 => "dcr271",
            Self::dcr272 => "dcr272",
            Self::dcr273 => "dcr273",
            Self::dcr274 => "dcr274",
            Self::dcr275 => "dcr275",
            Self::dcr276 => "dcr276",
            Self::dcr277 => "dcr277",
            Self::dcr278 => "dcr278",
            Self::dcr279 => "dcr279",
            Self::dcr27a => "dcr27a",
            Self::dcr27b => "dcr27b",
            Self::dcr27c => "dcr27c",
            Self::dcr27d => "dcr27d",
            Self::dcr27e => "dcr27e",
            Self::dcr27f => "dcr27f",
            Self::dcr280 => "dcr280",
            Self::dcr281 => "dcr281",
            Self::dcr282 => "dcr282",
            Self::dcr283 => "dcr283",
            Self::dcr284 => "dcr284",
            Self::dcr285 => "dcr285",
            Self::dcr286 => "dcr286",
            Self::dcr287 => "dcr287",
            Self::dcr288 => "dcr288",
            Self::dcr289 => "dcr289",
            Self::dcr28a => "dcr28a",
            Self::dcr28b => "dcr28b",
            Self::dcr28c => "dcr28c",
            Self::dcr28d => "dcr28d",
            Self::dcr28e => "dcr28e",
            Self::dcr28f => "dcr28f",
            Self::dcr290 => "dcr290",
            Self::dcr291 => "dcr291",
            Self::dcr292 => "dcr292",
            Self::dcr293 => "dcr293",
            Self::dcr294 => "dcr294",
            Self::dcr295 => "dcr295",
            Self::dcr296 => "dcr296",
            Self::dcr297 => "dcr297",
            Self::dcr298 => "dcr298",
            Self::dcr299 => "dcr299",
            Self::dcr29a => "dcr29a",
            Self::dcr29b => "dcr29b",
            Self::dcr29c => "dcr29c",
            Self::dcr29d => "dcr29d",
            Self::dcr29e => "dcr29e",
            Self::dcr29f => "dcr29f",
            Self::dcr2a0 => "dcr2a0",
            Self::dcr2a1 => "dcr2a1",
            Self::dcr2a2 => "dcr2a2",
            Self::dcr2a3 => "dcr2a3",
            Self::dcr2a4 => "dcr2a4",
            Self::dcr2a5 => "dcr2a5",
            Self::dcr2a6 => "dcr2a6",
            Self::dcr2a7 => "dcr2a7",
            Self::dcr2a8 => "dcr2a8",
            Self::dcr2a9 => "dcr2a9",
            Self::dcr2aa => "dcr2aa",
            Self::dcr2ab => "dcr2ab",
            Self::dcr2ac => "dcr2ac",
            Self::dcr2ad => "dcr2ad",
            Self::dcr2ae => "dcr2ae",
            Self::dcr2af => "dcr2af",
            Self::dcr2b0 => "dcr2b0",
            Self::dcr2b1 => "dcr2b1",
            Self::dcr2b2 => "dcr2b2",
            Self::dcr2b3 => "dcr2b3",
            Self::dcr2b4 => "dcr2b4",
            Self::dcr2b5 => "dcr2b5",
            Self::dcr2b6 => "dcr2b6",
            Self::dcr2b7 => "dcr2b7",
            Self::dcr2b8 => "dcr2b8",
            Self::dcr2b9 => "dcr2b9",
            Self::dcr2ba => "dcr2ba",
            Self::dcr2bb => "dcr2bb",
            Self::dcr2bc => "dcr2bc",
            Self::dcr2bd => "dcr2bd",
            Self::dcr2be => "dcr2be",
            Self::dcr2bf => "dcr2bf",
            Self::dcr2c0 => "dcr2c0",
            Self::dcr2c1 => "dcr2c1",
            Self::dcr2c2 => "dcr2c2",
            Self::dcr2c3 => "dcr2c3",
            Self::dcr2c4 => "dcr2c4",
            Self::dcr2c5 => "dcr2c5",
            Self::dcr2c6 => "dcr2c6",
            Self::dcr2c7 => "dcr2c7",
            Self::dcr2c8 => "dcr2c8",
            Self::dcr2c9 => "dcr2c9",
            Self::dcr2ca => "dcr2ca",
            Self::dcr2cb => "dcr2cb",
            Self::dcr2cc => "dcr2cc",
            Self::dcr2cd => "dcr2cd",
            Self::dcr2ce => "dcr2ce",
            Self::dcr2cf => "dcr2cf",
            Self::dcr2d0 => "dcr2d0",
            Self::dcr2d1 => "dcr2d1",
            Self::dcr2d2 => "dcr2d2",
            Self::dcr2d3 => "dcr2d3",
            Self::dcr2d4 => "dcr2d4",
            Self::dcr2d5 => "dcr2d5",
            Self::dcr2d6 => "dcr2d6",
            Self::dcr2d7 => "dcr2d7",
            Self::dcr2d8 => "dcr2d8",
            Self::dcr2d9 => "dcr2d9",
            Self::dcr2da => "dcr2da",
            Self::dcr2db => "dcr2db",
            Self::dcr2dc => "dcr2dc",
            Self::dcr2dd => "dcr2dd",
            Self::dcr2de => "dcr2de",
            Self::dcr2df => "dcr2df",
            Self::dcr2e0 => "dcr2e0",
            Self::dcr2e1 => "dcr2e1",
            Self::dcr2e2 => "dcr2e2",
            Self::dcr2e3 => "dcr2e3",
            Self::dcr2e4 => "dcr2e4",
            Self::dcr2e5 => "dcr2e5",
            Self::dcr2e6 => "dcr2e6",
            Self::dcr2e7 => "dcr2e7",
            Self::dcr2e8 => "dcr2e8",
            Self::dcr2e9 => "dcr2e9",
            Self::dcr2ea => "dcr2ea",
            Self::dcr2eb => "dcr2eb",
            Self::dcr2ec => "dcr2ec",
            Self::dcr2ed => "dcr2ed",
            Self::dcr2ee => "dcr2ee",
            Self::dcr2ef => "dcr2ef",
            Self::dcr2f0 => "dcr2f0",
            Self::dcr2f1 => "dcr2f1",
            Self::dcr2f2 => "dcr2f2",
            Self::dcr2f3 => "dcr2f3",
            Self::dcr2f4 => "dcr2f4",
            Self::dcr2f5 => "dcr2f5",
            Self::dcr2f6 => "dcr2f6",
            Self::dcr2f7 => "dcr2f7",
            Self::dcr2f8 => "dcr2f8",
            Self::dcr2f9 => "dcr2f9",
            Self::dcr2fa => "dcr2fa",
            Self::dcr2fb => "dcr2fb",
            Self::dcr2fc => "dcr2fc",
            Self::dcr2fd => "dcr2fd",
            Self::dcr2fe => "dcr2fe",
            Self::dcr2ff => "dcr2ff",
            Self::dcr300 => "dcr300",
            Self::dcr301 => "dcr301",
            Self::dcr302 => "dcr302",
            Self::dcr303 => "dcr303",
            Self::dcr304 => "dcr304",
            Self::dcr305 => "dcr305",
            Self::dcr306 => "dcr306",
            Self::dcr307 => "dcr307",
            Self::dcr308 => "dcr308",
            Self::dcr309 => "dcr309",
            Self::dcr30a => "dcr30a",
            Self::dcr30b => "dcr30b",
            Self::dcr30c => "dcr30c",
            Self::dcr30d => "dcr30d",
            Self::dcr30e => "dcr30e",
            Self::dcr30f => "dcr30f",
            Self::dcr310 => "dcr310",
            Self::dcr311 => "dcr311",
            Self::dcr312 => "dcr312",
            Self::dcr313 => "dcr313",
            Self::dcr314 => "dcr314",
            Self::dcr315 => "dcr315",
            Self::dcr316 => "dcr316",
            Self::dcr317 => "dcr317",
            Self::dcr318 => "dcr318",
            Self::dcr319 => "dcr319",
            Self::dcr31a => "dcr31a",
            Self::dcr31b => "dcr31b",
            Self::dcr31c => "dcr31c",
            Self::dcr31d => "dcr31d",
            Self::dcr31e => "dcr31e",
            Self::dcr31f => "dcr31f",
            Self::dcr320 => "dcr320",
            Self::dcr321 => "dcr321",
            Self::dcr322 => "dcr322",
            Self::dcr323 => "dcr323",
            Self::dcr324 => "dcr324",
            Self::dcr325 => "dcr325",
            Self::dcr326 => "dcr326",
            Self::dcr327 => "dcr327",
            Self::dcr328 => "dcr328",
            Self::dcr329 => "dcr329",
            Self::dcr32a => "dcr32a",
            Self::dcr32b => "dcr32b",
            Self::dcr32c => "dcr32c",
            Self::dcr32d => "dcr32d",
            Self::dcr32e => "dcr32e",
            Self::dcr32f => "dcr32f",
            Self::dcr330 => "dcr330",
            Self::dcr331 => "dcr331",
            Self::dcr332 => "dcr332",
            Self::dcr333 => "dcr333",
            Self::dcr334 => "dcr334",
            Self::dcr335 => "dcr335",
            Self::dcr336 => "dcr336",
            Self::dcr337 => "dcr337",
            Self::dcr338 => "dcr338",
            Self::dcr339 => "dcr339",
            Self::dcr33a => "dcr33a",
            Self::dcr33b => "dcr33b",
            Self::dcr33c => "dcr33c",
            Self::dcr33d => "dcr33d",
            Self::dcr33e => "dcr33e",
            Self::dcr33f => "dcr33f",
            Self::dcr340 => "dcr340",
            Self::dcr341 => "dcr341",
            Self::dcr342 => "dcr342",
            Self::dcr343 => "dcr343",
            Self::dcr344 => "dcr344",
            Self::dcr345 => "dcr345",
            Self::dcr346 => "dcr346",
            Self::dcr347 => "dcr347",
            Self::dcr348 => "dcr348",
            Self::dcr349 => "dcr349",
            Self::dcr34a => "dcr34a",
            Self::dcr34b => "dcr34b",
            Self::dcr34c => "dcr34c",
            Self::dcr34d => "dcr34d",
            Self::dcr34e => "dcr34e",
            Self::dcr34f => "dcr34f",
            Self::dcr350 => "dcr350",
            Self::dcr351 => "dcr351",
            Self::dcr352 => "dcr352",
            Self::dcr353 => "dcr353",
            Self::dcr354 => "dcr354",
            Self::dcr355 => "dcr355",
            Self::dcr356 => "dcr356",
            Self::dcr357 => "dcr357",
            Self::dcr358 => "dcr358",
            Self::dcr359 => "dcr359",
            Self::dcr35a => "dcr35a",
            Self::dcr35b => "dcr35b",
            Self::dcr35c => "dcr35c",
            Self::dcr35d => "dcr35d",
            Self::dcr35e => "dcr35e",
            Self::dcr35f => "dcr35f",
            Self::dcr360 => "dcr360",
            Self::dcr361 => "dcr361",
            Self::dcr362 => "dcr362",
            Self::dcr363 => "dcr363",
            Self::dcr364 => "dcr364",
            Self::dcr365 => "dcr365",
            Self::dcr366 => "dcr366",
            Self::dcr367 => "dcr367",
            Self::dcr368 => "dcr368",
            Self::dcr369 => "dcr369",
            Self::dcr36a => "dcr36a",
            Self::dcr36b => "dcr36b",
            Self::dcr36c => "dcr36c",
            Self::dcr36d => "dcr36d",
            Self::dcr36e => "dcr36e",
            Self::dcr36f => "dcr36f",
            Self::dcr370 => "dcr370",
            Self::dcr371 => "dcr371",
            Self::dcr372 => "dcr372",
            Self::dcr373 => "dcr373",
            Self::dcr374 => "dcr374",
            Self::dcr375 => "dcr375",
            Self::dcr376 => "dcr376",
            Self::dcr377 => "dcr377",
            Self::dcr378 => "dcr378",
            Self::dcr379 => "dcr379",
            Self::dcr37a => "dcr37a",
            Self::dcr37b => "dcr37b",
            Self::dcr37c => "dcr37c",
            Self::dcr37d => "dcr37d",
            Self::dcr37e => "dcr37e",
            Self::dcr37f => "dcr37f",
            Self::dcr380 => "dcr380",
            Self::dcr381 => "dcr381",
            Self::dcr382 => "dcr382",
            Self::dcr383 => "dcr383",
            Self::dcr384 => "dcr384",
            Self::dcr385 => "dcr385",
            Self::dcr386 => "dcr386",
            Self::dcr387 => "dcr387",
            Self::dcr388 => "dcr388",
            Self::dcr389 => "dcr389",
            Self::dcr38a => "dcr38a",
            Self::dcr38b => "dcr38b",
            Self::dcr38c => "dcr38c",
            Self::dcr38d => "dcr38d",
            Self::dcr38e => "dcr38e",
            Self::dcr38f => "dcr38f",
            Self::dcr390 => "dcr390",
            Self::dcr391 => "dcr391",
            Self::dcr392 => "dcr392",
            Self::dcr393 => "dcr393",
            Self::dcr394 => "dcr394",
            Self::dcr395 => "dcr395",
            Self::dcr396 => "dcr396",
            Self::dcr397 => "dcr397",
            Self::dcr398 => "dcr398",
            Self::dcr399 => "dcr399",
            Self::dcr39a => "dcr39a",
            Self::dcr39b => "dcr39b",
            Self::dcr39c => "dcr39c",
            Self::dcr39d => "dcr39d",
            Self::dcr39e => "dcr39e",
            Self::dcr39f => "dcr39f",
            Self::dcr3a0 => "dcr3a0",
            Self::dcr3a1 => "dcr3a1",
            Self::dcr3a2 => "dcr3a2",
            Self::dcr3a3 => "dcr3a3",
            Self::dcr3a4 => "dcr3a4",
            Self::dcr3a5 => "dcr3a5",
            Self::dcr3a6 => "dcr3a6",
            Self::dcr3a7 => "dcr3a7",
            Self::dcr3a8 => "dcr3a8",
            Self::dcr3a9 => "dcr3a9",
            Self::dcr3aa => "dcr3aa",
            Self::dcr3ab => "dcr3ab",
            Self::dcr3ac => "dcr3ac",
            Self::dcr3ad => "dcr3ad",
            Self::dcr3ae => "dcr3ae",
            Self::dcr3af => "dcr3af",
            Self::dcr3b0 => "dcr3b0",
            Self::dcr3b1 => "dcr3b1",
            Self::dcr3b2 => "dcr3b2",
            Self::dcr3b3 => "dcr3b3",
            Self::dcr3b4 => "dcr3b4",
            Self::dcr3b5 => "dcr3b5",
            Self::dcr3b6 => "dcr3b6",
            Self::dcr3b7 => "dcr3b7",
            Self::dcr3b8 => "dcr3b8",
            Self::dcr3b9 => "dcr3b9",
            Self::dcr3ba => "dcr3ba",
            Self::dcr3bb => "dcr3bb",
            Self::dcr3bc => "dcr3bc",
            Self::dcr3bd => "dcr3bd",
            Self::dcr3be => "dcr3be",
            Self::dcr3bf => "dcr3bf",
            Self::dcr3c0 => "dcr3c0",
            Self::dcr3c1 => "dcr3c1",
            Self::dcr3c2 => "dcr3c2",
            Self::dcr3c3 => "dcr3c3",
            Self::dcr3c4 => "dcr3c4",
            Self::dcr3c5 => "dcr3c5",
            Self::dcr3c6 => "dcr3c6",
            Self::dcr3c7 => "dcr3c7",
            Self::dcr3c8 => "dcr3c8",
            Self::dcr3c9 => "dcr3c9",
            Self::dcr3ca => "dcr3ca",
            Self::dcr3cb => "dcr3cb",
            Self::dcr3cc => "dcr3cc",
            Self::dcr3cd => "dcr3cd",
            Self::dcr3ce => "dcr3ce",
            Self::dcr3cf => "dcr3cf",
            Self::dcr3d0 => "dcr3d0",
            Self::dcr3d1 => "dcr3d1",
            Self::dcr3d2 => "dcr3d2",
            Self::dcr3d3 => "dcr3d3",
            Self::dcr3d4 => "dcr3d4",
            Self::dcr3d5 => "dcr3d5",
            Self::dcr3d6 => "dcr3d6",
            Self::dcr3d7 => "dcr3d7",
            Self::dcr3d8 => "dcr3d8",
            Self::dcr3d9 => "dcr3d9",
            Self::dcr3da => "dcr3da",
            Self::dcr3db => "dcr3db",
            Self::dcr3dc => "dcr3dc",
            Self::dcr3dd => "dcr3dd",
            Self::dcr3de => "dcr3de",
            Self::dcr3df => "dcr3df",
            Self::dcr3e0 => "dcr3e0",
            Self::dcr3e1 => "dcr3e1",
            Self::dcr3e2 => "dcr3e2",
            Self::dcr3e3 => "dcr3e3",
            Self::dcr3e4 => "dcr3e4",
            Self::dcr3e5 => "dcr3e5",
            Self::dcr3e6 => "dcr3e6",
            Self::dcr3e7 => "dcr3e7",
            Self::dcr3e8 => "dcr3e8",
            Self::dcr3e9 => "dcr3e9",
            Self::dcr3ea => "dcr3ea",
            Self::dcr3eb => "dcr3eb",
            Self::dcr3ec => "dcr3ec",
            Self::dcr3ed => "dcr3ed",
            Self::dcr3ee => "dcr3ee",
            Self::dcr3ef => "dcr3ef",
            Self::dcr3f0 => "dcr3f0",
            Self::dcr3f1 => "dcr3f1",
            Self::dcr3f2 => "dcr3f2",
            Self::dcr3f3 => "dcr3f3",
            Self::dcr3f4 => "dcr3f4",
            Self::dcr3f5 => "dcr3f5",
            Self::dcr3f6 => "dcr3f6",
            Self::dcr3f7 => "dcr3f7",
            Self::dcr3f8 => "dcr3f8",
            Self::dcr3f9 => "dcr3f9",
            Self::dcr3fa => "dcr3fa",
            Self::dcr3fb => "dcr3fb",
            Self::dcr3fc => "dcr3fc",
            Self::dcr3fd => "dcr3fd",
            Self::dcr3fe => "dcr3fe",
            Self::dcr3ff => "dcr3ff",
            Self::ACC => "ACC",
        }
    }
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vs0,
        1 => Register::vs1,
        2 => Register::vs2,
        3 => Register::vs3,
        4 => Register::vs4,
        5 => Register::vs5,
        6 => Register::vs6,
        7 => Register::vs7,
        8 => Register::vs8,
        9 => Register::vs9,
        10 => Register::vs10,
        11 => Register::vs11,
        12 => Register::vs12,
        13 => Register::vs13,
        14 => Register::vs14,
        15 => Register::vs15,
        16 => Register::vs16,
        17 => Register::vs17,
        18 => Register::vs18,
        19 => Register::vs19,
        20 => Register::vs20,
        21 => Register::vs21,
        22 => Register::vs22,
        23 => Register::vs23,
        24 => Register::vs24,
        25 => Register::vs25,
        26 => Register::vs26,
        27 => Register::vs27,
        28 => Register::vs28,
        29 => Register::vs29,
        30 => Register::vs30,
        31 => Register::vs31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r24,
        9 => Register::r25,
        10 => Register::r26,
        11 => Register::r27,
        12 => Register::r28,
        13 => Register::r29,
        14 => Register::r30,
        15 => Register::r31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r8,
        1 => Register::r9,
        2 => Register::r10,
        3 => Register::r11,
        4 => Register::r12,
        5 => Register::r13,
        6 => Register::r14,
        7 => Register::r15,
        8 => Register::r16,
        9 => Register::r17,
        10 => Register::r18,
        11 => Register::r19,
        12 => Register::r20,
        13 => Register::r21,
        14 => Register::r22,
        15 => Register::r23,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::r0,
        1 => Register::r1,
        2 => Register::r2,
        3 => Register::r3,
        4 => Register::r4,
        5 => Register::r5,
        6 => Register::r6,
        7 => Register::r7,
        8 => Register::r8,
        9 => Register::r9,
        10 => Register::r10,
        11 => Register::r11,
        12 => Register::r12,
        13 => Register::r13,
        14 => Register::r14,
        15 => Register::r15,
        16 => Register::r16,
        17 => Register::r17,
        18 => Register::r18,
        19 => Register::r19,
        20 => Register::r20,
        21 => Register::r21,
        22 => Register::r22,
        23 => Register::r23,
        24 => Register::r24,
        25 => Register::r25,
        26 => Register::r26,
        27 => Register::r27,
        28 => Register::r28,
        29 => Register::r29,
        30 => Register::r30,
        31 => Register::r31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        4 => Register::cr4,
        5 => Register::cr5,
        6 => Register::cr6,
        7 => Register::cr7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::cr0,
        1 => Register::cr1,
        2 => Register::cr2,
        3 => Register::cr3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::f0,
        1 => Register::f1,
        2 => Register::f2,
        3 => Register::f3,
        4 => Register::f4,
        5 => Register::f5,
        6 => Register::f6,
        7 => Register::f7,
        8 => Register::f8,
        9 => Register::f9,
        10 => Register::f10,
        11 => Register::f11,
        12 => Register::f12,
        13 => Register::f13,
        14 => Register::f14,
        15 => Register::f15,
        16 => Register::f16,
        17 => Register::f17,
        18 => Register::f18,
        19 => Register::f19,
        20 => Register::f20,
        21 => Register::f21,
        22 => Register::f22,
        23 => Register::f23,
        24 => Register::f24,
        25 => Register::f25,
        26 => Register::f26,
        27 => Register::f27,
        28 => Register::f28,
        29 => Register::f29,
        30 => Register::f30,
        31 => Register::f31,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::fp_fx,
        1 => Register::fp_fex,
        2 => Register::fp_vx,
        3 => Register::fp_ox,
        4 => Register::fp_ux,
        5 => Register::fp_zx,
        6 => Register::fp_xx,
        7 => Register::fp_vxsnan,
        8 => Register::fp_vxisi,
        9 => Register::fp_vxidi,
        10 => Register::fp_vxzdz,
        11 => Register::fp_vximz,
        12 => Register::fp_vxvc,
        13 => Register::fp_fr,
        14 => Register::fp_fi,
        15 => Register::fp_c,
        16 => Register::fp_cc0,
        17 => Register::fp_cc1,
        18 => Register::fp_cc2,
        19 => Register::fp_cc3,
        20 => Register::fp_reserve1,
        21 => Register::fp_vxsoft,
        22 => Register::fp_vxsqrt,
        23 => Register::fp_vxcvi,
        24 => Register::fp_ve,
        25 => Register::fp_oe,
        26 => Register::fp_ue,
        27 => Register::fp_ze,
        28 => Register::fp_xe,
        29 => Register::fp_ni,
        30 => Register::fp_rn0,
        31 => Register::fp_rn1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_8_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::sr0,
        1 => Register::sr1,
        2 => Register::sr2,
        3 => Register::sr3,
        4 => Register::sr4,
        5 => Register::sr5,
        6 => Register::sr6,
        7 => Register::sr7,
        8 => Register::sr8,
        9 => Register::sr9,
        10 => Register::sr10,
        11 => Register::sr11,
        12 => Register::sr12,
        13 => Register::sr13,
        14 => Register::sr14,
        15 => Register::sr15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_8_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_9_value<T>(num: T) -> Register
where
    u16: TryFrom<T>,
    <u16 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u16::try_from(num).unwrap() {
        0 => Register::spr000,
        1 => Register::spr020,
        2 => Register::spr040,
        3 => Register::spr060,
        4 => Register::spr080,
        5 => Register::spr0a0,
        6 => Register::spr0c0,
        7 => Register::spr0e0,
        8 => Register::spr100,
        9 => Register::spr120,
        10 => Register::spr140,
        11 => Register::spr160,
        12 => Register::spr180,
        13 => Register::spr1a0,
        14 => Register::spr1c0,
        15 => Register::spr1e0,
        16 => Register::spr200,
        17 => Register::spr220,
        18 => Register::spr240,
        19 => Register::spr260,
        20 => Register::spr280,
        21 => Register::spr2a0,
        22 => Register::spr2c0,
        23 => Register::spr2e0,
        24 => Register::spr300,
        25 => Register::spr320,
        26 => Register::spr340,
        27 => Register::spr360,
        28 => Register::spr380,
        29 => Register::spr3a0,
        30 => Register::spr3c0,
        31 => Register::spr3e0,
        32 => Register::XER,
        33 => Register::spr021,
        34 => Register::spr041,
        35 => Register::spr061,
        36 => Register::spr081,
        37 => Register::spr0a1,
        38 => Register::spr0c1,
        39 => Register::spr0e1,
        40 => Register::spr101,
        41 => Register::spr121,
        42 => Register::spr141,
        43 => Register::spr161,
        44 => Register::spr181,
        45 => Register::spr1a1,
        46 => Register::spr1c1,
        47 => Register::spr1e1,
        48 => Register::spr201,
        49 => Register::spr221,
        50 => Register::spr241,
        51 => Register::spr261,
        52 => Register::spr281,
        53 => Register::spr2a1,
        54 => Register::spr2c1,
        55 => Register::spr2e1,
        56 => Register::spr301,
        57 => Register::spr321,
        58 => Register::spr341,
        59 => Register::spr361,
        60 => Register::spr381,
        61 => Register::spr3a1,
        62 => Register::spr3c1,
        63 => Register::spr3e1,
        64 => Register::spr002,
        65 => Register::spr022,
        66 => Register::spr042,
        67 => Register::spr062,
        68 => Register::spr082,
        69 => Register::spr0a2,
        70 => Register::spr0c2,
        71 => Register::spr0e2,
        72 => Register::spr102,
        73 => Register::spr122,
        74 => Register::spr142,
        75 => Register::spr162,
        76 => Register::spr182,
        77 => Register::spr1a2,
        78 => Register::spr1c2,
        79 => Register::spr1e2,
        80 => Register::spr202,
        81 => Register::spr222,
        82 => Register::spr242,
        83 => Register::spr262,
        84 => Register::spr282,
        85 => Register::spr2a2,
        86 => Register::spr2c2,
        87 => Register::spr2e2,
        88 => Register::spr302,
        89 => Register::spr322,
        90 => Register::spr342,
        91 => Register::spr362,
        92 => Register::spr382,
        93 => Register::spr3a2,
        94 => Register::spr3c2,
        95 => Register::spr3e2,
        96 => Register::spr003,
        97 => Register::spr023,
        98 => Register::spr043,
        99 => Register::spr063,
        100 => Register::spr083,
        101 => Register::spr0a3,
        102 => Register::spr0c3,
        103 => Register::spr0e3,
        104 => Register::spr103,
        105 => Register::spr123,
        106 => Register::spr143,
        107 => Register::spr163,
        108 => Register::spr183,
        109 => Register::spr1a3,
        110 => Register::spr1c3,
        111 => Register::spr1e3,
        112 => Register::spr203,
        113 => Register::spr223,
        114 => Register::spr243,
        115 => Register::spr263,
        116 => Register::spr283,
        117 => Register::spr2a3,
        118 => Register::spr2c3,
        119 => Register::spr2e3,
        120 => Register::spr303,
        121 => Register::spr323,
        122 => Register::spr343,
        123 => Register::spr363,
        124 => Register::spr383,
        125 => Register::spr3a3,
        126 => Register::spr3c3,
        127 => Register::spr3e3,
        128 => Register::spr004,
        129 => Register::spr024,
        130 => Register::spr044,
        131 => Register::spr064,
        132 => Register::spr084,
        133 => Register::spr0a4,
        134 => Register::spr0c4,
        135 => Register::spr0e4,
        136 => Register::spr104,
        137 => Register::spr124,
        138 => Register::spr144,
        139 => Register::spr164,
        140 => Register::spr184,
        141 => Register::spr1a4,
        142 => Register::spr1c4,
        143 => Register::spr1e4,
        144 => Register::spr204,
        145 => Register::spr224,
        146 => Register::spr244,
        147 => Register::spr264,
        148 => Register::spr284,
        149 => Register::spr2a4,
        150 => Register::spr2c4,
        151 => Register::spr2e4,
        152 => Register::spr304,
        153 => Register::spr324,
        154 => Register::spr344,
        155 => Register::spr364,
        156 => Register::spr384,
        157 => Register::spr3a4,
        158 => Register::spr3c4,
        159 => Register::spr3e4,
        160 => Register::spr005,
        161 => Register::spr025,
        162 => Register::spr045,
        163 => Register::spr065,
        164 => Register::spr085,
        165 => Register::spr0a5,
        166 => Register::spr0c5,
        167 => Register::spr0e5,
        168 => Register::spr105,
        169 => Register::spr125,
        170 => Register::spr145,
        171 => Register::spr165,
        172 => Register::spr185,
        173 => Register::spr1a5,
        174 => Register::spr1c5,
        175 => Register::spr1e5,
        176 => Register::spr205,
        177 => Register::spr225,
        178 => Register::spr245,
        179 => Register::spr265,
        180 => Register::spr285,
        181 => Register::spr2a5,
        182 => Register::spr2c5,
        183 => Register::spr2e5,
        184 => Register::spr305,
        185 => Register::spr325,
        186 => Register::spr345,
        187 => Register::spr365,
        188 => Register::spr385,
        189 => Register::spr3a5,
        190 => Register::spr3c5,
        191 => Register::spr3e5,
        192 => Register::spr006,
        193 => Register::spr026,
        194 => Register::spr046,
        195 => Register::spr066,
        196 => Register::spr086,
        197 => Register::spr0a6,
        198 => Register::spr0c6,
        199 => Register::spr0e6,
        200 => Register::spr106,
        201 => Register::spr126,
        202 => Register::spr146,
        203 => Register::spr166,
        204 => Register::spr186,
        205 => Register::spr1a6,
        206 => Register::spr1c6,
        207 => Register::spr1e6,
        208 => Register::spr206,
        209 => Register::spr226,
        210 => Register::spr246,
        211 => Register::spr266,
        212 => Register::spr286,
        213 => Register::spr2a6,
        214 => Register::spr2c6,
        215 => Register::spr2e6,
        216 => Register::spr306,
        217 => Register::spr326,
        218 => Register::spr346,
        219 => Register::spr366,
        220 => Register::spr386,
        221 => Register::spr3a6,
        222 => Register::spr3c6,
        223 => Register::spr3e6,
        224 => Register::spr007,
        225 => Register::spr027,
        226 => Register::spr047,
        227 => Register::spr067,
        228 => Register::spr087,
        229 => Register::spr0a7,
        230 => Register::spr0c7,
        231 => Register::spr0e7,
        232 => Register::spr107,
        233 => Register::spr127,
        234 => Register::spr147,
        235 => Register::spr167,
        236 => Register::spr187,
        237 => Register::spr1a7,
        238 => Register::spr1c7,
        239 => Register::spr1e7,
        240 => Register::spr207,
        241 => Register::spr227,
        242 => Register::spr247,
        243 => Register::spr267,
        244 => Register::spr287,
        245 => Register::spr2a7,
        246 => Register::spr2c7,
        247 => Register::spr2e7,
        248 => Register::spr307,
        249 => Register::spr327,
        250 => Register::spr347,
        251 => Register::spr367,
        252 => Register::spr387,
        253 => Register::spr3a7,
        254 => Register::spr3c7,
        255 => Register::spr3e7,
        256 => Register::LR,
        257 => Register::spr028,
        258 => Register::spr048,
        259 => Register::spr068,
        260 => Register::spr088,
        261 => Register::spr0a8,
        262 => Register::spr0c8,
        263 => Register::spr0e8,
        264 => Register::spr108,
        265 => Register::spr128,
        266 => Register::spr148,
        267 => Register::spr168,
        268 => Register::spr188,
        269 => Register::spr1a8,
        270 => Register::spr1c8,
        271 => Register::spr1e8,
        272 => Register::spr208,
        273 => Register::spr228,
        274 => Register::spr248,
        275 => Register::spr268,
        276 => Register::spr288,
        277 => Register::spr2a8,
        278 => Register::spr2c8,
        279 => Register::spr2e8,
        280 => Register::spr308,
        281 => Register::spr328,
        282 => Register::spr348,
        283 => Register::spr368,
        284 => Register::spr388,
        285 => Register::spr3a8,
        286 => Register::spr3c8,
        287 => Register::spr3e8,
        288 => Register::CTR,
        289 => Register::spr029,
        290 => Register::spr049,
        291 => Register::spr069,
        292 => Register::spr089,
        293 => Register::spr0a9,
        294 => Register::spr0c9,
        295 => Register::spr0e9,
        296 => Register::spr109,
        297 => Register::spr129,
        298 => Register::spr149,
        299 => Register::spr169,
        300 => Register::spr189,
        301 => Register::spr1a9,
        302 => Register::spr1c9,
        303 => Register::spr1e9,
        304 => Register::spr209,
        305 => Register::spr229,
        306 => Register::spr249,
        307 => Register::spr269,
        308 => Register::spr289,
        309 => Register::spr2a9,
        310 => Register::spr2c9,
        311 => Register::spr2e9,
        312 => Register::spr309,
        313 => Register::spr329,
        314 => Register::spr349,
        315 => Register::spr369,
        316 => Register::spr389,
        317 => Register::spr3a9,
        318 => Register::spr3c9,
        319 => Register::spr3e9,
        320 => Register::spr00a,
        321 => Register::spr02a,
        322 => Register::spr04a,
        323 => Register::spr06a,
        324 => Register::spr08a,
        325 => Register::spr0aa,
        326 => Register::spr0ca,
        327 => Register::spr0ea,
        328 => Register::spr10a,
        329 => Register::spr12a,
        330 => Register::spr14a,
        331 => Register::spr16a,
        332 => Register::spr18a,
        333 => Register::spr1aa,
        334 => Register::spr1ca,
        335 => Register::spr1ea,
        336 => Register::spr20a,
        337 => Register::spr22a,
        338 => Register::spr24a,
        339 => Register::spr26a,
        340 => Register::spr28a,
        341 => Register::spr2aa,
        342 => Register::spr2ca,
        343 => Register::spr2ea,
        344 => Register::spr30a,
        345 => Register::spr32a,
        346 => Register::spr34a,
        347 => Register::spr36a,
        348 => Register::spr38a,
        349 => Register::spr3aa,
        350 => Register::spr3ca,
        351 => Register::spr3ea,
        352 => Register::spr00b,
        353 => Register::spr02b,
        354 => Register::spr04b,
        355 => Register::spr06b,
        356 => Register::spr08b,
        357 => Register::spr0ab,
        358 => Register::spr0cb,
        359 => Register::spr0eb,
        360 => Register::spr10b,
        361 => Register::spr12b,
        362 => Register::spr14b,
        363 => Register::spr16b,
        364 => Register::spr18b,
        365 => Register::spr1ab,
        366 => Register::spr1cb,
        367 => Register::spr1eb,
        368 => Register::spr20b,
        369 => Register::spr22b,
        370 => Register::spr24b,
        371 => Register::spr26b,
        372 => Register::spr28b,
        373 => Register::spr2ab,
        374 => Register::spr2cb,
        375 => Register::spr2eb,
        376 => Register::spr30b,
        377 => Register::spr32b,
        378 => Register::spr34b,
        379 => Register::spr36b,
        380 => Register::spr38b,
        381 => Register::spr3ab,
        382 => Register::spr3cb,
        383 => Register::spr3eb,
        384 => Register::spr00c,
        385 => Register::spr02c,
        386 => Register::spr04c,
        387 => Register::spr06c,
        388 => Register::spr08c,
        389 => Register::spr0ac,
        390 => Register::spr0cc,
        391 => Register::spr0ec,
        392 => Register::TBLr,
        393 => Register::spr12c,
        394 => Register::spr14c,
        395 => Register::spr16c,
        396 => Register::spr18c,
        397 => Register::spr1ac,
        398 => Register::spr1cc,
        399 => Register::spr1ec,
        400 => Register::spr20c,
        401 => Register::spr22c,
        402 => Register::spr24c,
        403 => Register::spr26c,
        404 => Register::spr28c,
        405 => Register::spr2ac,
        406 => Register::spr2cc,
        407 => Register::spr2ec,
        408 => Register::spr30c,
        409 => Register::spr32c,
        410 => Register::spr34c,
        411 => Register::spr36c,
        412 => Register::spr38c,
        413 => Register::spr3ac,
        414 => Register::spr3cc,
        415 => Register::spr3ec,
        416 => Register::spr00d,
        417 => Register::spr02d,
        418 => Register::spr04d,
        419 => Register::spr06d,
        420 => Register::spr08d,
        421 => Register::spr0ad,
        422 => Register::spr0cd,
        423 => Register::spr0ed,
        424 => Register::TBUr,
        425 => Register::spr12d,
        426 => Register::spr14d,
        427 => Register::spr16d,
        428 => Register::spr18d,
        429 => Register::spr1ad,
        430 => Register::spr1cd,
        431 => Register::spr1ed,
        432 => Register::spr20d,
        433 => Register::spr22d,
        434 => Register::spr24d,
        435 => Register::spr26d,
        436 => Register::spr28d,
        437 => Register::spr2ad,
        438 => Register::spr2cd,
        439 => Register::spr2ed,
        440 => Register::spr30d,
        441 => Register::spr32d,
        442 => Register::spr34d,
        443 => Register::spr36d,
        444 => Register::spr38d,
        445 => Register::spr3ad,
        446 => Register::spr3cd,
        447 => Register::spr3ed,
        448 => Register::spr00e,
        449 => Register::spr02e,
        450 => Register::spr04e,
        451 => Register::spr06e,
        452 => Register::spr08e,
        453 => Register::spr0ae,
        454 => Register::spr0ce,
        455 => Register::spr0ee,
        456 => Register::spr10e,
        457 => Register::spr12e,
        458 => Register::spr14e,
        459 => Register::spr16e,
        460 => Register::spr18e,
        461 => Register::spr1ae,
        462 => Register::spr1ce,
        463 => Register::spr1ee,
        464 => Register::spr20e,
        465 => Register::spr22e,
        466 => Register::spr24e,
        467 => Register::spr26e,
        468 => Register::spr28e,
        469 => Register::spr2ae,
        470 => Register::spr2ce,
        471 => Register::spr2ee,
        472 => Register::spr30e,
        473 => Register::spr32e,
        474 => Register::spr34e,
        475 => Register::spr36e,
        476 => Register::spr38e,
        477 => Register::spr3ae,
        478 => Register::spr3ce,
        479 => Register::spr3ee,
        480 => Register::spr00f,
        481 => Register::spr02f,
        482 => Register::spr04f,
        483 => Register::spr06f,
        484 => Register::spr08f,
        485 => Register::spr0af,
        486 => Register::spr0cf,
        487 => Register::spr0ef,
        488 => Register::spr10f,
        489 => Register::spr12f,
        490 => Register::spr14f,
        491 => Register::spr16f,
        492 => Register::spr18f,
        493 => Register::spr1af,
        494 => Register::spr1cf,
        495 => Register::spr1ef,
        496 => Register::spr20f,
        497 => Register::spr22f,
        498 => Register::spr24f,
        499 => Register::spr26f,
        500 => Register::spr28f,
        501 => Register::spr2af,
        502 => Register::spr2cf,
        503 => Register::spr2ef,
        504 => Register::spr30f,
        505 => Register::TAR,
        506 => Register::spr34f,
        507 => Register::spr36f,
        508 => Register::spr38f,
        509 => Register::spr3af,
        510 => Register::spr3cf,
        511 => Register::spr3ef,
        512 => Register::spr010,
        513 => Register::spr030,
        514 => Register::spr050,
        515 => Register::spr070,
        516 => Register::spr090,
        517 => Register::spr0b0,
        518 => Register::spr0d0,
        519 => Register::spr0f0,
        520 => Register::spr110,
        521 => Register::spr130,
        522 => Register::spr150,
        523 => Register::spr170,
        524 => Register::spr190,
        525 => Register::spr1b0,
        526 => Register::spr1d0,
        527 => Register::spr1f0,
        528 => Register::spr210,
        529 => Register::spr230,
        530 => Register::spr250,
        531 => Register::spr270,
        532 => Register::spr290,
        533 => Register::spr2b0,
        534 => Register::spr2d0,
        535 => Register::spr2f0,
        536 => Register::spr310,
        537 => Register::spr330,
        538 => Register::spr350,
        539 => Register::spr370,
        540 => Register::spr390,
        541 => Register::spr3b0,
        542 => Register::spr3d0,
        543 => Register::spr3f0,
        544 => Register::spr011,
        545 => Register::spr031,
        546 => Register::spr051,
        547 => Register::spr071,
        548 => Register::spr091,
        549 => Register::spr0b1,
        550 => Register::spr0d1,
        551 => Register::spr0f1,
        552 => Register::spr111,
        553 => Register::spr131,
        554 => Register::spr151,
        555 => Register::spr171,
        556 => Register::spr191,
        557 => Register::spr1b1,
        558 => Register::spr1d1,
        559 => Register::spr1f1,
        560 => Register::spr211,
        561 => Register::spr231,
        562 => Register::spr251,
        563 => Register::spr271,
        564 => Register::spr291,
        565 => Register::spr2b1,
        566 => Register::spr2d1,
        567 => Register::spr2f1,
        568 => Register::spr311,
        569 => Register::spr331,
        570 => Register::spr351,
        571 => Register::spr371,
        572 => Register::spr391,
        573 => Register::spr3b1,
        574 => Register::spr3d1,
        575 => Register::spr3f1,
        576 => Register::spr012,
        577 => Register::spr032,
        578 => Register::spr052,
        579 => Register::spr072,
        580 => Register::spr092,
        581 => Register::spr0b2,
        582 => Register::spr0d2,
        583 => Register::spr0f2,
        584 => Register::spr112,
        585 => Register::spr132,
        586 => Register::spr152,
        587 => Register::spr172,
        588 => Register::spr192,
        589 => Register::spr1b2,
        590 => Register::spr1d2,
        591 => Register::spr1f2,
        592 => Register::spr212,
        593 => Register::spr232,
        594 => Register::spr252,
        595 => Register::spr272,
        596 => Register::spr292,
        597 => Register::spr2b2,
        598 => Register::spr2d2,
        599 => Register::spr2f2,
        600 => Register::spr312,
        601 => Register::spr332,
        602 => Register::spr352,
        603 => Register::spr372,
        604 => Register::spr392,
        605 => Register::spr3b2,
        606 => Register::spr3d2,
        607 => Register::spr3f2,
        608 => Register::spr013,
        609 => Register::spr033,
        610 => Register::spr053,
        611 => Register::spr073,
        612 => Register::spr093,
        613 => Register::spr0b3,
        614 => Register::spr0d3,
        615 => Register::spr0f3,
        616 => Register::spr113,
        617 => Register::spr133,
        618 => Register::spr153,
        619 => Register::spr173,
        620 => Register::spr193,
        621 => Register::spr1b3,
        622 => Register::spr1d3,
        623 => Register::spr1f3,
        624 => Register::spr213,
        625 => Register::spr233,
        626 => Register::spr253,
        627 => Register::spr273,
        628 => Register::spr293,
        629 => Register::spr2b3,
        630 => Register::spr2d3,
        631 => Register::spr2f3,
        632 => Register::spr313,
        633 => Register::spr333,
        634 => Register::spr353,
        635 => Register::spr373,
        636 => Register::spr393,
        637 => Register::spr3b3,
        638 => Register::spr3d3,
        639 => Register::spr3f3,
        640 => Register::spr014,
        641 => Register::spr034,
        642 => Register::spr054,
        643 => Register::spr074,
        644 => Register::spr094,
        645 => Register::spr0b4,
        646 => Register::spr0d4,
        647 => Register::spr0f4,
        648 => Register::spr114,
        649 => Register::spr134,
        650 => Register::spr154,
        651 => Register::spr174,
        652 => Register::spr194,
        653 => Register::spr1b4,
        654 => Register::spr1d4,
        655 => Register::spr1f4,
        656 => Register::spr214,
        657 => Register::spr234,
        658 => Register::spr254,
        659 => Register::spr274,
        660 => Register::spr294,
        661 => Register::spr2b4,
        662 => Register::spr2d4,
        663 => Register::spr2f4,
        664 => Register::spr314,
        665 => Register::spr334,
        666 => Register::spr354,
        667 => Register::spr374,
        668 => Register::spr394,
        669 => Register::spr3b4,
        670 => Register::spr3d4,
        671 => Register::spr3f4,
        672 => Register::spr015,
        673 => Register::spr035,
        674 => Register::spr055,
        675 => Register::spr075,
        676 => Register::spr095,
        677 => Register::spr0b5,
        678 => Register::spr0d5,
        679 => Register::spr0f5,
        680 => Register::spr115,
        681 => Register::spr135,
        682 => Register::spr155,
        683 => Register::spr175,
        684 => Register::spr195,
        685 => Register::spr1b5,
        686 => Register::spr1d5,
        687 => Register::spr1f5,
        688 => Register::spr215,
        689 => Register::spr235,
        690 => Register::spr255,
        691 => Register::spr275,
        692 => Register::spr295,
        693 => Register::spr2b5,
        694 => Register::spr2d5,
        695 => Register::spr2f5,
        696 => Register::spr315,
        697 => Register::spr335,
        698 => Register::spr355,
        699 => Register::spr375,
        700 => Register::spr395,
        701 => Register::spr3b5,
        702 => Register::spr3d5,
        703 => Register::spr3f5,
        704 => Register::spr016,
        705 => Register::spr036,
        706 => Register::spr056,
        707 => Register::spr076,
        708 => Register::spr096,
        709 => Register::spr0b6,
        710 => Register::spr0d6,
        711 => Register::spr0f6,
        712 => Register::spr116,
        713 => Register::spr136,
        714 => Register::spr156,
        715 => Register::spr176,
        716 => Register::spr196,
        717 => Register::spr1b6,
        718 => Register::spr1d6,
        719 => Register::spr1f6,
        720 => Register::spr216,
        721 => Register::spr236,
        722 => Register::spr256,
        723 => Register::spr276,
        724 => Register::spr296,
        725 => Register::spr2b6,
        726 => Register::spr2d6,
        727 => Register::spr2f6,
        728 => Register::spr316,
        729 => Register::spr336,
        730 => Register::spr356,
        731 => Register::spr376,
        732 => Register::spr396,
        733 => Register::spr3b6,
        734 => Register::spr3d6,
        735 => Register::spr3f6,
        736 => Register::spr017,
        737 => Register::spr037,
        738 => Register::spr057,
        739 => Register::spr077,
        740 => Register::spr097,
        741 => Register::spr0b7,
        742 => Register::spr0d7,
        743 => Register::spr0f7,
        744 => Register::spr117,
        745 => Register::spr137,
        746 => Register::spr157,
        747 => Register::spr177,
        748 => Register::spr197,
        749 => Register::spr1b7,
        750 => Register::spr1d7,
        751 => Register::spr1f7,
        752 => Register::spr217,
        753 => Register::spr237,
        754 => Register::spr257,
        755 => Register::spr277,
        756 => Register::spr297,
        757 => Register::spr2b7,
        758 => Register::spr2d7,
        759 => Register::spr2f7,
        760 => Register::spr317,
        761 => Register::spr337,
        762 => Register::spr357,
        763 => Register::spr377,
        764 => Register::spr397,
        765 => Register::spr3b7,
        766 => Register::spr3d7,
        767 => Register::spr3f7,
        768 => Register::spr018,
        769 => Register::spr038,
        770 => Register::spr058,
        771 => Register::spr078,
        772 => Register::spr098,
        773 => Register::spr0b8,
        774 => Register::spr0d8,
        775 => Register::spr0f8,
        776 => Register::spr118,
        777 => Register::spr138,
        778 => Register::spr158,
        779 => Register::spr178,
        780 => Register::spr198,
        781 => Register::spr1b8,
        782 => Register::spr1d8,
        783 => Register::spr1f8,
        784 => Register::spr218,
        785 => Register::spr238,
        786 => Register::spr258,
        787 => Register::spr278,
        788 => Register::spr298,
        789 => Register::spr2b8,
        790 => Register::spr2d8,
        791 => Register::spr2f8,
        792 => Register::spr318,
        793 => Register::spr338,
        794 => Register::spr358,
        795 => Register::spr378,
        796 => Register::spr398,
        797 => Register::spr3b8,
        798 => Register::spr3d8,
        799 => Register::spr3f8,
        800 => Register::spr019,
        801 => Register::spr039,
        802 => Register::spr059,
        803 => Register::spr079,
        804 => Register::spr099,
        805 => Register::spr0b9,
        806 => Register::spr0d9,
        807 => Register::spr0f9,
        808 => Register::spr119,
        809 => Register::spr139,
        810 => Register::spr159,
        811 => Register::spr179,
        812 => Register::spr199,
        813 => Register::spr1b9,
        814 => Register::spr1d9,
        815 => Register::spr1f9,
        816 => Register::spr219,
        817 => Register::spr239,
        818 => Register::spr259,
        819 => Register::spr279,
        820 => Register::spr299,
        821 => Register::spr2b9,
        822 => Register::spr2d9,
        823 => Register::spr2f9,
        824 => Register::spr319,
        825 => Register::spr339,
        826 => Register::spr359,
        827 => Register::spr379,
        828 => Register::spr399,
        829 => Register::spr3b9,
        830 => Register::spr3d9,
        831 => Register::spr3f9,
        832 => Register::SRR0,
        833 => Register::CSRR0,
        834 => Register::spr05a,
        835 => Register::spr07a,
        836 => Register::spr09a,
        837 => Register::spr0ba,
        838 => Register::spr0da,
        839 => Register::spr0fa,
        840 => Register::spr11a,
        841 => Register::spr13a,
        842 => Register::spr15a,
        843 => Register::spr17a,
        844 => Register::spr19a,
        845 => Register::spr1ba,
        846 => Register::spr1da,
        847 => Register::spr1fa,
        848 => Register::spr21a,
        849 => Register::spr23a,
        850 => Register::spr25a,
        851 => Register::spr27a,
        852 => Register::spr29a,
        853 => Register::spr2ba,
        854 => Register::spr2da,
        855 => Register::spr2fa,
        856 => Register::spr31a,
        857 => Register::spr33a,
        858 => Register::spr35a,
        859 => Register::spr37a,
        860 => Register::spr39a,
        861 => Register::spr3ba,
        862 => Register::spr3da,
        863 => Register::spr3fa,
        864 => Register::SRR1,
        865 => Register::CSRR1,
        866 => Register::spr05b,
        867 => Register::spr07b,
        868 => Register::spr09b,
        869 => Register::spr0bb,
        870 => Register::spr0db,
        871 => Register::spr0fb,
        872 => Register::spr11b,
        873 => Register::spr13b,
        874 => Register::spr15b,
        875 => Register::spr17b,
        876 => Register::spr19b,
        877 => Register::spr1bb,
        878 => Register::spr1db,
        879 => Register::spr1fb,
        880 => Register::spr21b,
        881 => Register::spr23b,
        882 => Register::spr25b,
        883 => Register::spr27b,
        884 => Register::spr29b,
        885 => Register::spr2bb,
        886 => Register::spr2db,
        887 => Register::spr2fb,
        888 => Register::spr31b,
        889 => Register::spr33b,
        890 => Register::spr35b,
        891 => Register::spr37b,
        892 => Register::spr39b,
        893 => Register::spr3bb,
        894 => Register::spr3db,
        895 => Register::spr3fb,
        896 => Register::spr01c,
        897 => Register::spr03c,
        898 => Register::spr05c,
        899 => Register::spr07c,
        900 => Register::spr09c,
        901 => Register::spr0bc,
        902 => Register::spr0dc,
        903 => Register::spr0fc,
        904 => Register::TBLw,
        905 => Register::spr13c,
        906 => Register::spr15c,
        907 => Register::spr17c,
        908 => Register::spr19c,
        909 => Register::spr1bc,
        910 => Register::spr1dc,
        911 => Register::spr1fc,
        912 => Register::spr21c,
        913 => Register::spr23c,
        914 => Register::spr25c,
        915 => Register::spr27c,
        916 => Register::spr29c,
        917 => Register::spr2bc,
        918 => Register::spr2dc,
        919 => Register::spr2fc,
        920 => Register::spr31c,
        921 => Register::spr33c,
        922 => Register::spr35c,
        923 => Register::spr37c,
        924 => Register::spr39c,
        925 => Register::spr3bc,
        926 => Register::spr3dc,
        927 => Register::spr3fc,
        928 => Register::spr01d,
        929 => Register::spr03d,
        930 => Register::spr05d,
        931 => Register::spr07d,
        932 => Register::spr09d,
        933 => Register::spr0bd,
        934 => Register::spr0dd,
        935 => Register::spr0fd,
        936 => Register::TBUw,
        937 => Register::spr13d,
        938 => Register::spr15d,
        939 => Register::spr17d,
        940 => Register::spr19d,
        941 => Register::spr1bd,
        942 => Register::spr1dd,
        943 => Register::spr1fd,
        944 => Register::spr21d,
        945 => Register::spr23d,
        946 => Register::spr25d,
        947 => Register::spr27d,
        948 => Register::spr29d,
        949 => Register::spr2bd,
        950 => Register::spr2dd,
        951 => Register::spr2fd,
        952 => Register::spr31d,
        953 => Register::spr33d,
        954 => Register::spr35d,
        955 => Register::spr37d,
        956 => Register::spr39d,
        957 => Register::spr3bd,
        958 => Register::spr3dd,
        959 => Register::spr3fd,
        960 => Register::spr01e,
        961 => Register::spr03e,
        962 => Register::spr05e,
        963 => Register::spr07e,
        964 => Register::spr09e,
        965 => Register::spr0be,
        966 => Register::spr0de,
        967 => Register::spr0fe,
        968 => Register::spr11e,
        969 => Register::spr13e,
        970 => Register::spr15e,
        971 => Register::spr17e,
        972 => Register::spr19e,
        973 => Register::spr1be,
        974 => Register::spr1de,
        975 => Register::spr1fe,
        976 => Register::spr21e,
        977 => Register::spr23e,
        978 => Register::spr25e,
        979 => Register::spr27e,
        980 => Register::spr29e,
        981 => Register::spr2be,
        982 => Register::spr2de,
        983 => Register::spr2fe,
        984 => Register::spr31e,
        985 => Register::spr33e,
        986 => Register::spr35e,
        987 => Register::spr37e,
        988 => Register::spr39e,
        989 => Register::spr3be,
        990 => Register::spr3de,
        991 => Register::spr3fe,
        992 => Register::spr01f,
        993 => Register::spr03f,
        994 => Register::spr05f,
        995 => Register::spr07f,
        996 => Register::spr09f,
        997 => Register::spr0bf,
        998 => Register::spr0df,
        999 => Register::spr0ff,
        1000 => Register::spr11f,
        1001 => Register::spr13f,
        1002 => Register::spr15f,
        1003 => Register::spr17f,
        1004 => Register::spr19f,
        1005 => Register::spr1bf,
        1006 => Register::spr1df,
        1007 => Register::spr1ff,
        1008 => Register::spr21f,
        1009 => Register::spr23f,
        1010 => Register::spr25f,
        1011 => Register::spr27f,
        1012 => Register::spr29f,
        1013 => Register::spr2bf,
        1014 => Register::spr2df,
        1015 => Register::spr2ff,
        1016 => Register::spr31f,
        1017 => Register::spr33f,
        1018 => Register::spr35f,
        1019 => Register::spr37f,
        1020 => Register::spr39f,
        1021 => Register::spr3bf,
        1022 => Register::spr3df,
        1023 => Register::spr3ff,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(num: T) -> DisplayElement
where
    u16: TryFrom<T>,
    <u16 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_9_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_10_value<T>(num: T) -> Register
where
    u16: TryFrom<T>,
    <u16 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u16::try_from(num).unwrap() {
        0 => Register::dcr000,
        1 => Register::dcr020,
        2 => Register::dcr040,
        3 => Register::dcr060,
        4 => Register::dcr080,
        5 => Register::dcr0a0,
        6 => Register::dcr0c0,
        7 => Register::dcr0e0,
        8 => Register::dcr100,
        9 => Register::dcr120,
        10 => Register::dcr140,
        11 => Register::dcr160,
        12 => Register::dcr180,
        13 => Register::dcr1a0,
        14 => Register::dcr1c0,
        15 => Register::dcr1e0,
        16 => Register::dcr200,
        17 => Register::dcr220,
        18 => Register::dcr240,
        19 => Register::dcr260,
        20 => Register::dcr280,
        21 => Register::dcr2a0,
        22 => Register::dcr2c0,
        23 => Register::dcr2e0,
        24 => Register::dcr300,
        25 => Register::dcr320,
        26 => Register::dcr340,
        27 => Register::dcr360,
        28 => Register::dcr380,
        29 => Register::dcr3a0,
        30 => Register::dcr3c0,
        31 => Register::dcr3e0,
        32 => Register::dcr001,
        33 => Register::dcr021,
        34 => Register::dcr041,
        35 => Register::dcr061,
        36 => Register::dcr081,
        37 => Register::dcr0a1,
        38 => Register::dcr0c1,
        39 => Register::dcr0e1,
        40 => Register::dcr101,
        41 => Register::dcr121,
        42 => Register::dcr141,
        43 => Register::dcr161,
        44 => Register::dcr181,
        45 => Register::dcr1a1,
        46 => Register::dcr1c1,
        47 => Register::dcr1e1,
        48 => Register::dcr201,
        49 => Register::dcr221,
        50 => Register::dcr241,
        51 => Register::dcr261,
        52 => Register::dcr281,
        53 => Register::dcr2a1,
        54 => Register::dcr2c1,
        55 => Register::dcr2e1,
        56 => Register::dcr301,
        57 => Register::dcr321,
        58 => Register::dcr341,
        59 => Register::dcr361,
        60 => Register::dcr381,
        61 => Register::dcr3a1,
        62 => Register::dcr3c1,
        63 => Register::dcr3e1,
        64 => Register::dcr002,
        65 => Register::dcr022,
        66 => Register::dcr042,
        67 => Register::dcr062,
        68 => Register::dcr082,
        69 => Register::dcr0a2,
        70 => Register::dcr0c2,
        71 => Register::dcr0e2,
        72 => Register::dcr102,
        73 => Register::dcr122,
        74 => Register::dcr142,
        75 => Register::dcr162,
        76 => Register::dcr182,
        77 => Register::dcr1a2,
        78 => Register::dcr1c2,
        79 => Register::dcr1e2,
        80 => Register::dcr202,
        81 => Register::dcr222,
        82 => Register::dcr242,
        83 => Register::dcr262,
        84 => Register::dcr282,
        85 => Register::dcr2a2,
        86 => Register::dcr2c2,
        87 => Register::dcr2e2,
        88 => Register::dcr302,
        89 => Register::dcr322,
        90 => Register::dcr342,
        91 => Register::dcr362,
        92 => Register::dcr382,
        93 => Register::dcr3a2,
        94 => Register::dcr3c2,
        95 => Register::dcr3e2,
        96 => Register::dcr003,
        97 => Register::dcr023,
        98 => Register::dcr043,
        99 => Register::dcr063,
        100 => Register::dcr083,
        101 => Register::dcr0a3,
        102 => Register::dcr0c3,
        103 => Register::dcr0e3,
        104 => Register::dcr103,
        105 => Register::dcr123,
        106 => Register::dcr143,
        107 => Register::dcr163,
        108 => Register::dcr183,
        109 => Register::dcr1a3,
        110 => Register::dcr1c3,
        111 => Register::dcr1e3,
        112 => Register::dcr203,
        113 => Register::dcr223,
        114 => Register::dcr243,
        115 => Register::dcr263,
        116 => Register::dcr283,
        117 => Register::dcr2a3,
        118 => Register::dcr2c3,
        119 => Register::dcr2e3,
        120 => Register::dcr303,
        121 => Register::dcr323,
        122 => Register::dcr343,
        123 => Register::dcr363,
        124 => Register::dcr383,
        125 => Register::dcr3a3,
        126 => Register::dcr3c3,
        127 => Register::dcr3e3,
        128 => Register::dcr004,
        129 => Register::dcr024,
        130 => Register::dcr044,
        131 => Register::dcr064,
        132 => Register::dcr084,
        133 => Register::dcr0a4,
        134 => Register::dcr0c4,
        135 => Register::dcr0e4,
        136 => Register::dcr104,
        137 => Register::dcr124,
        138 => Register::dcr144,
        139 => Register::dcr164,
        140 => Register::dcr184,
        141 => Register::dcr1a4,
        142 => Register::dcr1c4,
        143 => Register::dcr1e4,
        144 => Register::dcr204,
        145 => Register::dcr224,
        146 => Register::dcr244,
        147 => Register::dcr264,
        148 => Register::dcr284,
        149 => Register::dcr2a4,
        150 => Register::dcr2c4,
        151 => Register::dcr2e4,
        152 => Register::dcr304,
        153 => Register::dcr324,
        154 => Register::dcr344,
        155 => Register::dcr364,
        156 => Register::dcr384,
        157 => Register::dcr3a4,
        158 => Register::dcr3c4,
        159 => Register::dcr3e4,
        160 => Register::dcr005,
        161 => Register::dcr025,
        162 => Register::dcr045,
        163 => Register::dcr065,
        164 => Register::dcr085,
        165 => Register::dcr0a5,
        166 => Register::dcr0c5,
        167 => Register::dcr0e5,
        168 => Register::dcr105,
        169 => Register::dcr125,
        170 => Register::dcr145,
        171 => Register::dcr165,
        172 => Register::dcr185,
        173 => Register::dcr1a5,
        174 => Register::dcr1c5,
        175 => Register::dcr1e5,
        176 => Register::dcr205,
        177 => Register::dcr225,
        178 => Register::dcr245,
        179 => Register::dcr265,
        180 => Register::dcr285,
        181 => Register::dcr2a5,
        182 => Register::dcr2c5,
        183 => Register::dcr2e5,
        184 => Register::dcr305,
        185 => Register::dcr325,
        186 => Register::dcr345,
        187 => Register::dcr365,
        188 => Register::dcr385,
        189 => Register::dcr3a5,
        190 => Register::dcr3c5,
        191 => Register::dcr3e5,
        192 => Register::dcr006,
        193 => Register::dcr026,
        194 => Register::dcr046,
        195 => Register::dcr066,
        196 => Register::dcr086,
        197 => Register::dcr0a6,
        198 => Register::dcr0c6,
        199 => Register::dcr0e6,
        200 => Register::dcr106,
        201 => Register::dcr126,
        202 => Register::dcr146,
        203 => Register::dcr166,
        204 => Register::dcr186,
        205 => Register::dcr1a6,
        206 => Register::dcr1c6,
        207 => Register::dcr1e6,
        208 => Register::dcr206,
        209 => Register::dcr226,
        210 => Register::dcr246,
        211 => Register::dcr266,
        212 => Register::dcr286,
        213 => Register::dcr2a6,
        214 => Register::dcr2c6,
        215 => Register::dcr2e6,
        216 => Register::dcr306,
        217 => Register::dcr326,
        218 => Register::dcr346,
        219 => Register::dcr366,
        220 => Register::dcr386,
        221 => Register::dcr3a6,
        222 => Register::dcr3c6,
        223 => Register::dcr3e6,
        224 => Register::dcr007,
        225 => Register::dcr027,
        226 => Register::dcr047,
        227 => Register::dcr067,
        228 => Register::dcr087,
        229 => Register::dcr0a7,
        230 => Register::dcr0c7,
        231 => Register::dcr0e7,
        232 => Register::dcr107,
        233 => Register::dcr127,
        234 => Register::dcr147,
        235 => Register::dcr167,
        236 => Register::dcr187,
        237 => Register::dcr1a7,
        238 => Register::dcr1c7,
        239 => Register::dcr1e7,
        240 => Register::dcr207,
        241 => Register::dcr227,
        242 => Register::dcr247,
        243 => Register::dcr267,
        244 => Register::dcr287,
        245 => Register::dcr2a7,
        246 => Register::dcr2c7,
        247 => Register::dcr2e7,
        248 => Register::dcr307,
        249 => Register::dcr327,
        250 => Register::dcr347,
        251 => Register::dcr367,
        252 => Register::dcr387,
        253 => Register::dcr3a7,
        254 => Register::dcr3c7,
        255 => Register::dcr3e7,
        256 => Register::dcr008,
        257 => Register::dcr028,
        258 => Register::dcr048,
        259 => Register::dcr068,
        260 => Register::dcr088,
        261 => Register::dcr0a8,
        262 => Register::dcr0c8,
        263 => Register::dcr0e8,
        264 => Register::dcr108,
        265 => Register::dcr128,
        266 => Register::dcr148,
        267 => Register::dcr168,
        268 => Register::dcr188,
        269 => Register::dcr1a8,
        270 => Register::dcr1c8,
        271 => Register::dcr1e8,
        272 => Register::dcr208,
        273 => Register::dcr228,
        274 => Register::dcr248,
        275 => Register::dcr268,
        276 => Register::dcr288,
        277 => Register::dcr2a8,
        278 => Register::dcr2c8,
        279 => Register::dcr2e8,
        280 => Register::dcr308,
        281 => Register::dcr328,
        282 => Register::dcr348,
        283 => Register::dcr368,
        284 => Register::dcr388,
        285 => Register::dcr3a8,
        286 => Register::dcr3c8,
        287 => Register::dcr3e8,
        288 => Register::dcr009,
        289 => Register::dcr029,
        290 => Register::dcr049,
        291 => Register::dcr069,
        292 => Register::dcr089,
        293 => Register::dcr0a9,
        294 => Register::dcr0c9,
        295 => Register::dcr0e9,
        296 => Register::dcr109,
        297 => Register::dcr129,
        298 => Register::dcr149,
        299 => Register::dcr169,
        300 => Register::dcr189,
        301 => Register::dcr1a9,
        302 => Register::dcr1c9,
        303 => Register::dcr1e9,
        304 => Register::dcr209,
        305 => Register::dcr229,
        306 => Register::dcr249,
        307 => Register::dcr269,
        308 => Register::dcr289,
        309 => Register::dcr2a9,
        310 => Register::dcr2c9,
        311 => Register::dcr2e9,
        312 => Register::dcr309,
        313 => Register::dcr329,
        314 => Register::dcr349,
        315 => Register::dcr369,
        316 => Register::dcr389,
        317 => Register::dcr3a9,
        318 => Register::dcr3c9,
        319 => Register::dcr3e9,
        320 => Register::dcr00a,
        321 => Register::dcr02a,
        322 => Register::dcr04a,
        323 => Register::dcr06a,
        324 => Register::dcr08a,
        325 => Register::dcr0aa,
        326 => Register::dcr0ca,
        327 => Register::dcr0ea,
        328 => Register::dcr10a,
        329 => Register::dcr12a,
        330 => Register::dcr14a,
        331 => Register::dcr16a,
        332 => Register::dcr18a,
        333 => Register::dcr1aa,
        334 => Register::dcr1ca,
        335 => Register::dcr1ea,
        336 => Register::dcr20a,
        337 => Register::dcr22a,
        338 => Register::dcr24a,
        339 => Register::dcr26a,
        340 => Register::dcr28a,
        341 => Register::dcr2aa,
        342 => Register::dcr2ca,
        343 => Register::dcr2ea,
        344 => Register::dcr30a,
        345 => Register::dcr32a,
        346 => Register::dcr34a,
        347 => Register::dcr36a,
        348 => Register::dcr38a,
        349 => Register::dcr3aa,
        350 => Register::dcr3ca,
        351 => Register::dcr3ea,
        352 => Register::dcr00b,
        353 => Register::dcr02b,
        354 => Register::dcr04b,
        355 => Register::dcr06b,
        356 => Register::dcr08b,
        357 => Register::dcr0ab,
        358 => Register::dcr0cb,
        359 => Register::dcr0eb,
        360 => Register::dcr10b,
        361 => Register::dcr12b,
        362 => Register::dcr14b,
        363 => Register::dcr16b,
        364 => Register::dcr18b,
        365 => Register::dcr1ab,
        366 => Register::dcr1cb,
        367 => Register::dcr1eb,
        368 => Register::dcr20b,
        369 => Register::dcr22b,
        370 => Register::dcr24b,
        371 => Register::dcr26b,
        372 => Register::dcr28b,
        373 => Register::dcr2ab,
        374 => Register::dcr2cb,
        375 => Register::dcr2eb,
        376 => Register::dcr30b,
        377 => Register::dcr32b,
        378 => Register::dcr34b,
        379 => Register::dcr36b,
        380 => Register::dcr38b,
        381 => Register::dcr3ab,
        382 => Register::dcr3cb,
        383 => Register::dcr3eb,
        384 => Register::dcr00c,
        385 => Register::dcr02c,
        386 => Register::dcr04c,
        387 => Register::dcr06c,
        388 => Register::dcr08c,
        389 => Register::dcr0ac,
        390 => Register::dcr0cc,
        391 => Register::dcr0ec,
        392 => Register::dcr10c,
        393 => Register::dcr12c,
        394 => Register::dcr14c,
        395 => Register::dcr16c,
        396 => Register::dcr18c,
        397 => Register::dcr1ac,
        398 => Register::dcr1cc,
        399 => Register::dcr1ec,
        400 => Register::dcr20c,
        401 => Register::dcr22c,
        402 => Register::dcr24c,
        403 => Register::dcr26c,
        404 => Register::dcr28c,
        405 => Register::dcr2ac,
        406 => Register::dcr2cc,
        407 => Register::dcr2ec,
        408 => Register::dcr30c,
        409 => Register::dcr32c,
        410 => Register::dcr34c,
        411 => Register::dcr36c,
        412 => Register::dcr38c,
        413 => Register::dcr3ac,
        414 => Register::dcr3cc,
        415 => Register::dcr3ec,
        416 => Register::dcr00d,
        417 => Register::dcr02d,
        418 => Register::dcr04d,
        419 => Register::dcr06d,
        420 => Register::dcr08d,
        421 => Register::dcr0ad,
        422 => Register::dcr0cd,
        423 => Register::dcr0ed,
        424 => Register::dcr10d,
        425 => Register::dcr12d,
        426 => Register::dcr14d,
        427 => Register::dcr16d,
        428 => Register::dcr18d,
        429 => Register::dcr1ad,
        430 => Register::dcr1cd,
        431 => Register::dcr1ed,
        432 => Register::dcr20d,
        433 => Register::dcr22d,
        434 => Register::dcr24d,
        435 => Register::dcr26d,
        436 => Register::dcr28d,
        437 => Register::dcr2ad,
        438 => Register::dcr2cd,
        439 => Register::dcr2ed,
        440 => Register::dcr30d,
        441 => Register::dcr32d,
        442 => Register::dcr34d,
        443 => Register::dcr36d,
        444 => Register::dcr38d,
        445 => Register::dcr3ad,
        446 => Register::dcr3cd,
        447 => Register::dcr3ed,
        448 => Register::dcr00e,
        449 => Register::dcr02e,
        450 => Register::dcr04e,
        451 => Register::dcr06e,
        452 => Register::dcr08e,
        453 => Register::dcr0ae,
        454 => Register::dcr0ce,
        455 => Register::dcr0ee,
        456 => Register::dcr10e,
        457 => Register::dcr12e,
        458 => Register::dcr14e,
        459 => Register::dcr16e,
        460 => Register::dcr18e,
        461 => Register::dcr1ae,
        462 => Register::dcr1ce,
        463 => Register::dcr1ee,
        464 => Register::dcr20e,
        465 => Register::dcr22e,
        466 => Register::dcr24e,
        467 => Register::dcr26e,
        468 => Register::dcr28e,
        469 => Register::dcr2ae,
        470 => Register::dcr2ce,
        471 => Register::dcr2ee,
        472 => Register::dcr30e,
        473 => Register::dcr32e,
        474 => Register::dcr34e,
        475 => Register::dcr36e,
        476 => Register::dcr38e,
        477 => Register::dcr3ae,
        478 => Register::dcr3ce,
        479 => Register::dcr3ee,
        480 => Register::dcr00f,
        481 => Register::dcr02f,
        482 => Register::dcr04f,
        483 => Register::dcr06f,
        484 => Register::dcr08f,
        485 => Register::dcr0af,
        486 => Register::dcr0cf,
        487 => Register::dcr0ef,
        488 => Register::dcr10f,
        489 => Register::dcr12f,
        490 => Register::dcr14f,
        491 => Register::dcr16f,
        492 => Register::dcr18f,
        493 => Register::dcr1af,
        494 => Register::dcr1cf,
        495 => Register::dcr1ef,
        496 => Register::dcr20f,
        497 => Register::dcr22f,
        498 => Register::dcr24f,
        499 => Register::dcr26f,
        500 => Register::dcr28f,
        501 => Register::dcr2af,
        502 => Register::dcr2cf,
        503 => Register::dcr2ef,
        504 => Register::dcr30f,
        505 => Register::dcr32f,
        506 => Register::dcr34f,
        507 => Register::dcr36f,
        508 => Register::dcr38f,
        509 => Register::dcr3af,
        510 => Register::dcr3cf,
        511 => Register::dcr3ef,
        512 => Register::dcr010,
        513 => Register::dcr030,
        514 => Register::dcr050,
        515 => Register::dcr070,
        516 => Register::dcr090,
        517 => Register::dcr0b0,
        518 => Register::dcr0d0,
        519 => Register::dcr0f0,
        520 => Register::dcr110,
        521 => Register::dcr130,
        522 => Register::dcr150,
        523 => Register::dcr170,
        524 => Register::dcr190,
        525 => Register::dcr1b0,
        526 => Register::dcr1d0,
        527 => Register::dcr1f0,
        528 => Register::dcr210,
        529 => Register::dcr230,
        530 => Register::dcr250,
        531 => Register::dcr270,
        532 => Register::dcr290,
        533 => Register::dcr2b0,
        534 => Register::dcr2d0,
        535 => Register::dcr2f0,
        536 => Register::dcr310,
        537 => Register::dcr330,
        538 => Register::dcr350,
        539 => Register::dcr370,
        540 => Register::dcr390,
        541 => Register::dcr3b0,
        542 => Register::dcr3d0,
        543 => Register::dcr3f0,
        544 => Register::dcr011,
        545 => Register::dcr031,
        546 => Register::dcr051,
        547 => Register::dcr071,
        548 => Register::dcr091,
        549 => Register::dcr0b1,
        550 => Register::dcr0d1,
        551 => Register::dcr0f1,
        552 => Register::dcr111,
        553 => Register::dcr131,
        554 => Register::dcr151,
        555 => Register::dcr171,
        556 => Register::dcr191,
        557 => Register::dcr1b1,
        558 => Register::dcr1d1,
        559 => Register::dcr1f1,
        560 => Register::dcr211,
        561 => Register::dcr231,
        562 => Register::dcr251,
        563 => Register::dcr271,
        564 => Register::dcr291,
        565 => Register::dcr2b1,
        566 => Register::dcr2d1,
        567 => Register::dcr2f1,
        568 => Register::dcr311,
        569 => Register::dcr331,
        570 => Register::dcr351,
        571 => Register::dcr371,
        572 => Register::dcr391,
        573 => Register::dcr3b1,
        574 => Register::dcr3d1,
        575 => Register::dcr3f1,
        576 => Register::dcr012,
        577 => Register::dcr032,
        578 => Register::dcr052,
        579 => Register::dcr072,
        580 => Register::dcr092,
        581 => Register::dcr0b2,
        582 => Register::dcr0d2,
        583 => Register::dcr0f2,
        584 => Register::dcr112,
        585 => Register::dcr132,
        586 => Register::dcr152,
        587 => Register::dcr172,
        588 => Register::dcr192,
        589 => Register::dcr1b2,
        590 => Register::dcr1d2,
        591 => Register::dcr1f2,
        592 => Register::dcr212,
        593 => Register::dcr232,
        594 => Register::dcr252,
        595 => Register::dcr272,
        596 => Register::dcr292,
        597 => Register::dcr2b2,
        598 => Register::dcr2d2,
        599 => Register::dcr2f2,
        600 => Register::dcr312,
        601 => Register::dcr332,
        602 => Register::dcr352,
        603 => Register::dcr372,
        604 => Register::dcr392,
        605 => Register::dcr3b2,
        606 => Register::dcr3d2,
        607 => Register::dcr3f2,
        608 => Register::dcr013,
        609 => Register::dcr033,
        610 => Register::dcr053,
        611 => Register::dcr073,
        612 => Register::dcr093,
        613 => Register::dcr0b3,
        614 => Register::dcr0d3,
        615 => Register::dcr0f3,
        616 => Register::dcr113,
        617 => Register::dcr133,
        618 => Register::dcr153,
        619 => Register::dcr173,
        620 => Register::dcr193,
        621 => Register::dcr1b3,
        622 => Register::dcr1d3,
        623 => Register::dcr1f3,
        624 => Register::dcr213,
        625 => Register::dcr233,
        626 => Register::dcr253,
        627 => Register::dcr273,
        628 => Register::dcr293,
        629 => Register::dcr2b3,
        630 => Register::dcr2d3,
        631 => Register::dcr2f3,
        632 => Register::dcr313,
        633 => Register::dcr333,
        634 => Register::dcr353,
        635 => Register::dcr373,
        636 => Register::dcr393,
        637 => Register::dcr3b3,
        638 => Register::dcr3d3,
        639 => Register::dcr3f3,
        640 => Register::dcr014,
        641 => Register::dcr034,
        642 => Register::dcr054,
        643 => Register::dcr074,
        644 => Register::dcr094,
        645 => Register::dcr0b4,
        646 => Register::dcr0d4,
        647 => Register::dcr0f4,
        648 => Register::dcr114,
        649 => Register::dcr134,
        650 => Register::dcr154,
        651 => Register::dcr174,
        652 => Register::dcr194,
        653 => Register::dcr1b4,
        654 => Register::dcr1d4,
        655 => Register::dcr1f4,
        656 => Register::dcr214,
        657 => Register::dcr234,
        658 => Register::dcr254,
        659 => Register::dcr274,
        660 => Register::dcr294,
        661 => Register::dcr2b4,
        662 => Register::dcr2d4,
        663 => Register::dcr2f4,
        664 => Register::dcr314,
        665 => Register::dcr334,
        666 => Register::dcr354,
        667 => Register::dcr374,
        668 => Register::dcr394,
        669 => Register::dcr3b4,
        670 => Register::dcr3d4,
        671 => Register::dcr3f4,
        672 => Register::dcr015,
        673 => Register::dcr035,
        674 => Register::dcr055,
        675 => Register::dcr075,
        676 => Register::dcr095,
        677 => Register::dcr0b5,
        678 => Register::dcr0d5,
        679 => Register::dcr0f5,
        680 => Register::dcr115,
        681 => Register::dcr135,
        682 => Register::dcr155,
        683 => Register::dcr175,
        684 => Register::dcr195,
        685 => Register::dcr1b5,
        686 => Register::dcr1d5,
        687 => Register::dcr1f5,
        688 => Register::dcr215,
        689 => Register::dcr235,
        690 => Register::dcr255,
        691 => Register::dcr275,
        692 => Register::dcr295,
        693 => Register::dcr2b5,
        694 => Register::dcr2d5,
        695 => Register::dcr2f5,
        696 => Register::dcr315,
        697 => Register::dcr335,
        698 => Register::dcr355,
        699 => Register::dcr375,
        700 => Register::dcr395,
        701 => Register::dcr3b5,
        702 => Register::dcr3d5,
        703 => Register::dcr3f5,
        704 => Register::dcr016,
        705 => Register::dcr036,
        706 => Register::dcr056,
        707 => Register::dcr076,
        708 => Register::dcr096,
        709 => Register::dcr0b6,
        710 => Register::dcr0d6,
        711 => Register::dcr0f6,
        712 => Register::dcr116,
        713 => Register::dcr136,
        714 => Register::dcr156,
        715 => Register::dcr176,
        716 => Register::dcr196,
        717 => Register::dcr1b6,
        718 => Register::dcr1d6,
        719 => Register::dcr1f6,
        720 => Register::dcr216,
        721 => Register::dcr236,
        722 => Register::dcr256,
        723 => Register::dcr276,
        724 => Register::dcr296,
        725 => Register::dcr2b6,
        726 => Register::dcr2d6,
        727 => Register::dcr2f6,
        728 => Register::dcr316,
        729 => Register::dcr336,
        730 => Register::dcr356,
        731 => Register::dcr376,
        732 => Register::dcr396,
        733 => Register::dcr3b6,
        734 => Register::dcr3d6,
        735 => Register::dcr3f6,
        736 => Register::dcr017,
        737 => Register::dcr037,
        738 => Register::dcr057,
        739 => Register::dcr077,
        740 => Register::dcr097,
        741 => Register::dcr0b7,
        742 => Register::dcr0d7,
        743 => Register::dcr0f7,
        744 => Register::dcr117,
        745 => Register::dcr137,
        746 => Register::dcr157,
        747 => Register::dcr177,
        748 => Register::dcr197,
        749 => Register::dcr1b7,
        750 => Register::dcr1d7,
        751 => Register::dcr1f7,
        752 => Register::dcr217,
        753 => Register::dcr237,
        754 => Register::dcr257,
        755 => Register::dcr277,
        756 => Register::dcr297,
        757 => Register::dcr2b7,
        758 => Register::dcr2d7,
        759 => Register::dcr2f7,
        760 => Register::dcr317,
        761 => Register::dcr337,
        762 => Register::dcr357,
        763 => Register::dcr377,
        764 => Register::dcr397,
        765 => Register::dcr3b7,
        766 => Register::dcr3d7,
        767 => Register::dcr3f7,
        768 => Register::dcr018,
        769 => Register::dcr038,
        770 => Register::dcr058,
        771 => Register::dcr078,
        772 => Register::dcr098,
        773 => Register::dcr0b8,
        774 => Register::dcr0d8,
        775 => Register::dcr0f8,
        776 => Register::dcr118,
        777 => Register::dcr138,
        778 => Register::dcr158,
        779 => Register::dcr178,
        780 => Register::dcr198,
        781 => Register::dcr1b8,
        782 => Register::dcr1d8,
        783 => Register::dcr1f8,
        784 => Register::dcr218,
        785 => Register::dcr238,
        786 => Register::dcr258,
        787 => Register::dcr278,
        788 => Register::dcr298,
        789 => Register::dcr2b8,
        790 => Register::dcr2d8,
        791 => Register::dcr2f8,
        792 => Register::dcr318,
        793 => Register::dcr338,
        794 => Register::dcr358,
        795 => Register::dcr378,
        796 => Register::dcr398,
        797 => Register::dcr3b8,
        798 => Register::dcr3d8,
        799 => Register::dcr3f8,
        800 => Register::dcr019,
        801 => Register::dcr039,
        802 => Register::dcr059,
        803 => Register::dcr079,
        804 => Register::dcr099,
        805 => Register::dcr0b9,
        806 => Register::dcr0d9,
        807 => Register::dcr0f9,
        808 => Register::dcr119,
        809 => Register::dcr139,
        810 => Register::dcr159,
        811 => Register::dcr179,
        812 => Register::dcr199,
        813 => Register::dcr1b9,
        814 => Register::dcr1d9,
        815 => Register::dcr1f9,
        816 => Register::dcr219,
        817 => Register::dcr239,
        818 => Register::dcr259,
        819 => Register::dcr279,
        820 => Register::dcr299,
        821 => Register::dcr2b9,
        822 => Register::dcr2d9,
        823 => Register::dcr2f9,
        824 => Register::dcr319,
        825 => Register::dcr339,
        826 => Register::dcr359,
        827 => Register::dcr379,
        828 => Register::dcr399,
        829 => Register::dcr3b9,
        830 => Register::dcr3d9,
        831 => Register::dcr3f9,
        832 => Register::dcr01a,
        833 => Register::dcr03a,
        834 => Register::dcr05a,
        835 => Register::dcr07a,
        836 => Register::dcr09a,
        837 => Register::dcr0ba,
        838 => Register::dcr0da,
        839 => Register::dcr0fa,
        840 => Register::dcr11a,
        841 => Register::dcr13a,
        842 => Register::dcr15a,
        843 => Register::dcr17a,
        844 => Register::dcr19a,
        845 => Register::dcr1ba,
        846 => Register::dcr1da,
        847 => Register::dcr1fa,
        848 => Register::dcr21a,
        849 => Register::dcr23a,
        850 => Register::dcr25a,
        851 => Register::dcr27a,
        852 => Register::dcr29a,
        853 => Register::dcr2ba,
        854 => Register::dcr2da,
        855 => Register::dcr2fa,
        856 => Register::dcr31a,
        857 => Register::dcr33a,
        858 => Register::dcr35a,
        859 => Register::dcr37a,
        860 => Register::dcr39a,
        861 => Register::dcr3ba,
        862 => Register::dcr3da,
        863 => Register::dcr3fa,
        864 => Register::dcr01b,
        865 => Register::dcr03b,
        866 => Register::dcr05b,
        867 => Register::dcr07b,
        868 => Register::dcr09b,
        869 => Register::dcr0bb,
        870 => Register::dcr0db,
        871 => Register::dcr0fb,
        872 => Register::dcr11b,
        873 => Register::dcr13b,
        874 => Register::dcr15b,
        875 => Register::dcr17b,
        876 => Register::dcr19b,
        877 => Register::dcr1bb,
        878 => Register::dcr1db,
        879 => Register::dcr1fb,
        880 => Register::dcr21b,
        881 => Register::dcr23b,
        882 => Register::dcr25b,
        883 => Register::dcr27b,
        884 => Register::dcr29b,
        885 => Register::dcr2bb,
        886 => Register::dcr2db,
        887 => Register::dcr2fb,
        888 => Register::dcr31b,
        889 => Register::dcr33b,
        890 => Register::dcr35b,
        891 => Register::dcr37b,
        892 => Register::dcr39b,
        893 => Register::dcr3bb,
        894 => Register::dcr3db,
        895 => Register::dcr3fb,
        896 => Register::dcr01c,
        897 => Register::dcr03c,
        898 => Register::dcr05c,
        899 => Register::dcr07c,
        900 => Register::dcr09c,
        901 => Register::dcr0bc,
        902 => Register::dcr0dc,
        903 => Register::dcr0fc,
        904 => Register::dcr11c,
        905 => Register::dcr13c,
        906 => Register::dcr15c,
        907 => Register::dcr17c,
        908 => Register::dcr19c,
        909 => Register::dcr1bc,
        910 => Register::dcr1dc,
        911 => Register::dcr1fc,
        912 => Register::dcr21c,
        913 => Register::dcr23c,
        914 => Register::dcr25c,
        915 => Register::dcr27c,
        916 => Register::dcr29c,
        917 => Register::dcr2bc,
        918 => Register::dcr2dc,
        919 => Register::dcr2fc,
        920 => Register::dcr31c,
        921 => Register::dcr33c,
        922 => Register::dcr35c,
        923 => Register::dcr37c,
        924 => Register::dcr39c,
        925 => Register::dcr3bc,
        926 => Register::dcr3dc,
        927 => Register::dcr3fc,
        928 => Register::dcr01d,
        929 => Register::dcr03d,
        930 => Register::dcr05d,
        931 => Register::dcr07d,
        932 => Register::dcr09d,
        933 => Register::dcr0bd,
        934 => Register::dcr0dd,
        935 => Register::dcr0fd,
        936 => Register::dcr11d,
        937 => Register::dcr13d,
        938 => Register::dcr15d,
        939 => Register::dcr17d,
        940 => Register::dcr19d,
        941 => Register::dcr1bd,
        942 => Register::dcr1dd,
        943 => Register::dcr1fd,
        944 => Register::dcr21d,
        945 => Register::dcr23d,
        946 => Register::dcr25d,
        947 => Register::dcr27d,
        948 => Register::dcr29d,
        949 => Register::dcr2bd,
        950 => Register::dcr2dd,
        951 => Register::dcr2fd,
        952 => Register::dcr31d,
        953 => Register::dcr33d,
        954 => Register::dcr35d,
        955 => Register::dcr37d,
        956 => Register::dcr39d,
        957 => Register::dcr3bd,
        958 => Register::dcr3dd,
        959 => Register::dcr3fd,
        960 => Register::dcr01e,
        961 => Register::dcr03e,
        962 => Register::dcr05e,
        963 => Register::dcr07e,
        964 => Register::dcr09e,
        965 => Register::dcr0be,
        966 => Register::dcr0de,
        967 => Register::dcr0fe,
        968 => Register::dcr11e,
        969 => Register::dcr13e,
        970 => Register::dcr15e,
        971 => Register::dcr17e,
        972 => Register::dcr19e,
        973 => Register::dcr1be,
        974 => Register::dcr1de,
        975 => Register::dcr1fe,
        976 => Register::dcr21e,
        977 => Register::dcr23e,
        978 => Register::dcr25e,
        979 => Register::dcr27e,
        980 => Register::dcr29e,
        981 => Register::dcr2be,
        982 => Register::dcr2de,
        983 => Register::dcr2fe,
        984 => Register::dcr31e,
        985 => Register::dcr33e,
        986 => Register::dcr35e,
        987 => Register::dcr37e,
        988 => Register::dcr39e,
        989 => Register::dcr3be,
        990 => Register::dcr3de,
        991 => Register::dcr3fe,
        992 => Register::dcr01f,
        993 => Register::dcr03f,
        994 => Register::dcr05f,
        995 => Register::dcr07f,
        996 => Register::dcr09f,
        997 => Register::dcr0bf,
        998 => Register::dcr0df,
        999 => Register::dcr0ff,
        1000 => Register::dcr11f,
        1001 => Register::dcr13f,
        1002 => Register::dcr15f,
        1003 => Register::dcr17f,
        1004 => Register::dcr19f,
        1005 => Register::dcr1bf,
        1006 => Register::dcr1df,
        1007 => Register::dcr1ff,
        1008 => Register::dcr21f,
        1009 => Register::dcr23f,
        1010 => Register::dcr25f,
        1011 => Register::dcr27f,
        1012 => Register::dcr29f,
        1013 => Register::dcr2bf,
        1014 => Register::dcr2df,
        1015 => Register::dcr2ff,
        1016 => Register::dcr31f,
        1017 => Register::dcr33f,
        1018 => Register::dcr35f,
        1019 => Register::dcr37f,
        1020 => Register::dcr39f,
        1021 => Register::dcr3bf,
        1022 => Register::dcr3df,
        1023 => Register::dcr3ff,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(num: T) -> DisplayElement
where
    u16: TryFrom<T>,
    <u16 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_10_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_11_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vs32,
        1 => Register::vs33,
        2 => Register::vs34,
        3 => Register::vs35,
        4 => Register::vs36,
        5 => Register::vs37,
        6 => Register::vs38,
        7 => Register::vs39,
        8 => Register::vs40,
        9 => Register::vs41,
        10 => Register::vs42,
        11 => Register::vs43,
        12 => Register::vs44,
        13 => Register::vs45,
        14 => Register::vs46,
        15 => Register::vs47,
        16 => Register::vs48,
        17 => Register::vs49,
        18 => Register::vs50,
        19 => Register::vs51,
        20 => Register::vs52,
        21 => Register::vs53,
        22 => Register::vs54,
        23 => Register::vs55,
        24 => Register::vs56,
        25 => Register::vs57,
        26 => Register::vs58,
        27 => Register::vs59,
        28 => Register::vs60,
        29 => Register::vs61,
        30 => Register::vs62,
        31 => Register::vs63,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_11_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_11_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_12_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_0,
        1 => Register::vr1_64_0,
        2 => Register::vr2_64_0,
        3 => Register::vr3_64_0,
        4 => Register::vr4_64_0,
        5 => Register::vr5_64_0,
        6 => Register::vr6_64_0,
        7 => Register::vr7_64_0,
        8 => Register::vr8_64_0,
        9 => Register::vr9_64_0,
        10 => Register::vr10_64_0,
        11 => Register::vr11_64_0,
        12 => Register::vr12_64_0,
        13 => Register::vr13_64_0,
        14 => Register::vr14_64_0,
        15 => Register::vr15_64_0,
        16 => Register::vr16_64_0,
        17 => Register::vr17_64_0,
        18 => Register::vr18_64_0,
        19 => Register::vr19_64_0,
        20 => Register::vr20_64_0,
        21 => Register::vr21_64_0,
        22 => Register::vr22_64_0,
        23 => Register::vr23_64_0,
        24 => Register::vr24_64_0,
        25 => Register::vr25_64_0,
        26 => Register::vr26_64_0,
        27 => Register::vr27_64_0,
        28 => Register::vr28_64_0,
        29 => Register::vr29_64_0,
        30 => Register::vr30_64_0,
        31 => Register::vr31_64_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_12_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_12_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_13_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_1,
        1 => Register::vr1_64_1,
        2 => Register::vr2_64_1,
        3 => Register::vr3_64_1,
        4 => Register::vr4_64_1,
        5 => Register::vr5_64_1,
        6 => Register::vr6_64_1,
        7 => Register::vr7_64_1,
        8 => Register::vr8_64_1,
        9 => Register::vr9_64_1,
        10 => Register::vr10_64_1,
        11 => Register::vr11_64_1,
        12 => Register::vr12_64_1,
        13 => Register::vr13_64_1,
        14 => Register::vr14_64_1,
        15 => Register::vr15_64_1,
        16 => Register::vr16_64_1,
        17 => Register::vr17_64_1,
        18 => Register::vr18_64_1,
        19 => Register::vr19_64_1,
        20 => Register::vr20_64_1,
        21 => Register::vr21_64_1,
        22 => Register::vr22_64_1,
        23 => Register::vr23_64_1,
        24 => Register::vr24_64_1,
        25 => Register::vr25_64_1,
        26 => Register::vr26_64_1,
        27 => Register::vr27_64_1,
        28 => Register::vr28_64_1,
        29 => Register::vr29_64_1,
        30 => Register::vr30_64_1,
        31 => Register::vr31_64_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_13_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_13_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_14_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_0,
        1 => Register::vr1_32_0,
        2 => Register::vr2_32_0,
        3 => Register::vr3_32_0,
        4 => Register::vr4_32_0,
        5 => Register::vr5_32_0,
        6 => Register::vr6_32_0,
        7 => Register::vr7_32_0,
        8 => Register::vr8_32_0,
        9 => Register::vr9_32_0,
        10 => Register::vr10_32_0,
        11 => Register::vr11_32_0,
        12 => Register::vr12_32_0,
        13 => Register::vr13_32_0,
        14 => Register::vr14_32_0,
        15 => Register::vr15_32_0,
        16 => Register::vr16_32_0,
        17 => Register::vr17_32_0,
        18 => Register::vr18_32_0,
        19 => Register::vr19_32_0,
        20 => Register::vr20_32_0,
        21 => Register::vr21_32_0,
        22 => Register::vr22_32_0,
        23 => Register::vr23_32_0,
        24 => Register::vr24_32_0,
        25 => Register::vr25_32_0,
        26 => Register::vr26_32_0,
        27 => Register::vr27_32_0,
        28 => Register::vr28_32_0,
        29 => Register::vr29_32_0,
        30 => Register::vr30_32_0,
        31 => Register::vr31_32_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_14_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_14_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_15_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_1,
        1 => Register::vr1_32_1,
        2 => Register::vr2_32_1,
        3 => Register::vr3_32_1,
        4 => Register::vr4_32_1,
        5 => Register::vr5_32_1,
        6 => Register::vr6_32_1,
        7 => Register::vr7_32_1,
        8 => Register::vr8_32_1,
        9 => Register::vr9_32_1,
        10 => Register::vr10_32_1,
        11 => Register::vr11_32_1,
        12 => Register::vr12_32_1,
        13 => Register::vr13_32_1,
        14 => Register::vr14_32_1,
        15 => Register::vr15_32_1,
        16 => Register::vr16_32_1,
        17 => Register::vr17_32_1,
        18 => Register::vr18_32_1,
        19 => Register::vr19_32_1,
        20 => Register::vr20_32_1,
        21 => Register::vr21_32_1,
        22 => Register::vr22_32_1,
        23 => Register::vr23_32_1,
        24 => Register::vr24_32_1,
        25 => Register::vr25_32_1,
        26 => Register::vr26_32_1,
        27 => Register::vr27_32_1,
        28 => Register::vr28_32_1,
        29 => Register::vr29_32_1,
        30 => Register::vr30_32_1,
        31 => Register::vr31_32_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_15_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_15_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_16_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_2,
        1 => Register::vr1_32_2,
        2 => Register::vr2_32_2,
        3 => Register::vr3_32_2,
        4 => Register::vr4_32_2,
        5 => Register::vr5_32_2,
        6 => Register::vr6_32_2,
        7 => Register::vr7_32_2,
        8 => Register::vr8_32_2,
        9 => Register::vr9_32_2,
        10 => Register::vr10_32_2,
        11 => Register::vr11_32_2,
        12 => Register::vr12_32_2,
        13 => Register::vr13_32_2,
        14 => Register::vr14_32_2,
        15 => Register::vr15_32_2,
        16 => Register::vr16_32_2,
        17 => Register::vr17_32_2,
        18 => Register::vr18_32_2,
        19 => Register::vr19_32_2,
        20 => Register::vr20_32_2,
        21 => Register::vr21_32_2,
        22 => Register::vr22_32_2,
        23 => Register::vr23_32_2,
        24 => Register::vr24_32_2,
        25 => Register::vr25_32_2,
        26 => Register::vr26_32_2,
        27 => Register::vr27_32_2,
        28 => Register::vr28_32_2,
        29 => Register::vr29_32_2,
        30 => Register::vr30_32_2,
        31 => Register::vr31_32_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_16_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_16_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_17_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_3,
        1 => Register::vr1_32_3,
        2 => Register::vr2_32_3,
        3 => Register::vr3_32_3,
        4 => Register::vr4_32_3,
        5 => Register::vr5_32_3,
        6 => Register::vr6_32_3,
        7 => Register::vr7_32_3,
        8 => Register::vr8_32_3,
        9 => Register::vr9_32_3,
        10 => Register::vr10_32_3,
        11 => Register::vr11_32_3,
        12 => Register::vr12_32_3,
        13 => Register::vr13_32_3,
        14 => Register::vr14_32_3,
        15 => Register::vr15_32_3,
        16 => Register::vr16_32_3,
        17 => Register::vr17_32_3,
        18 => Register::vr18_32_3,
        19 => Register::vr19_32_3,
        20 => Register::vr20_32_3,
        21 => Register::vr21_32_3,
        22 => Register::vr22_32_3,
        23 => Register::vr23_32_3,
        24 => Register::vr24_32_3,
        25 => Register::vr25_32_3,
        26 => Register::vr26_32_3,
        27 => Register::vr27_32_3,
        28 => Register::vr28_32_3,
        29 => Register::vr29_32_3,
        30 => Register::vr30_32_3,
        31 => Register::vr31_32_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_17_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_17_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_18_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_0,
        1 => Register::vr1_16_0,
        2 => Register::vr2_16_0,
        3 => Register::vr3_16_0,
        4 => Register::vr4_16_0,
        5 => Register::vr5_16_0,
        6 => Register::vr6_16_0,
        7 => Register::vr7_16_0,
        8 => Register::vr8_16_0,
        9 => Register::vr9_16_0,
        10 => Register::vr10_16_0,
        11 => Register::vr11_16_0,
        12 => Register::vr12_16_0,
        13 => Register::vr13_16_0,
        14 => Register::vr14_16_0,
        15 => Register::vr15_16_0,
        16 => Register::vr16_16_0,
        17 => Register::vr17_16_0,
        18 => Register::vr18_16_0,
        19 => Register::vr19_16_0,
        20 => Register::vr20_16_0,
        21 => Register::vr21_16_0,
        22 => Register::vr22_16_0,
        23 => Register::vr23_16_0,
        24 => Register::vr24_16_0,
        25 => Register::vr25_16_0,
        26 => Register::vr26_16_0,
        27 => Register::vr27_16_0,
        28 => Register::vr28_16_0,
        29 => Register::vr29_16_0,
        30 => Register::vr30_16_0,
        31 => Register::vr31_16_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_18_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_18_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_19_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_1,
        1 => Register::vr1_16_1,
        2 => Register::vr2_16_1,
        3 => Register::vr3_16_1,
        4 => Register::vr4_16_1,
        5 => Register::vr5_16_1,
        6 => Register::vr6_16_1,
        7 => Register::vr7_16_1,
        8 => Register::vr8_16_1,
        9 => Register::vr9_16_1,
        10 => Register::vr10_16_1,
        11 => Register::vr11_16_1,
        12 => Register::vr12_16_1,
        13 => Register::vr13_16_1,
        14 => Register::vr14_16_1,
        15 => Register::vr15_16_1,
        16 => Register::vr16_16_1,
        17 => Register::vr17_16_1,
        18 => Register::vr18_16_1,
        19 => Register::vr19_16_1,
        20 => Register::vr20_16_1,
        21 => Register::vr21_16_1,
        22 => Register::vr22_16_1,
        23 => Register::vr23_16_1,
        24 => Register::vr24_16_1,
        25 => Register::vr25_16_1,
        26 => Register::vr26_16_1,
        27 => Register::vr27_16_1,
        28 => Register::vr28_16_1,
        29 => Register::vr29_16_1,
        30 => Register::vr30_16_1,
        31 => Register::vr31_16_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_19_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_19_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_20_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_2,
        1 => Register::vr1_16_2,
        2 => Register::vr2_16_2,
        3 => Register::vr3_16_2,
        4 => Register::vr4_16_2,
        5 => Register::vr5_16_2,
        6 => Register::vr6_16_2,
        7 => Register::vr7_16_2,
        8 => Register::vr8_16_2,
        9 => Register::vr9_16_2,
        10 => Register::vr10_16_2,
        11 => Register::vr11_16_2,
        12 => Register::vr12_16_2,
        13 => Register::vr13_16_2,
        14 => Register::vr14_16_2,
        15 => Register::vr15_16_2,
        16 => Register::vr16_16_2,
        17 => Register::vr17_16_2,
        18 => Register::vr18_16_2,
        19 => Register::vr19_16_2,
        20 => Register::vr20_16_2,
        21 => Register::vr21_16_2,
        22 => Register::vr22_16_2,
        23 => Register::vr23_16_2,
        24 => Register::vr24_16_2,
        25 => Register::vr25_16_2,
        26 => Register::vr26_16_2,
        27 => Register::vr27_16_2,
        28 => Register::vr28_16_2,
        29 => Register::vr29_16_2,
        30 => Register::vr30_16_2,
        31 => Register::vr31_16_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_20_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_20_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_21_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_3,
        1 => Register::vr1_16_3,
        2 => Register::vr2_16_3,
        3 => Register::vr3_16_3,
        4 => Register::vr4_16_3,
        5 => Register::vr5_16_3,
        6 => Register::vr6_16_3,
        7 => Register::vr7_16_3,
        8 => Register::vr8_16_3,
        9 => Register::vr9_16_3,
        10 => Register::vr10_16_3,
        11 => Register::vr11_16_3,
        12 => Register::vr12_16_3,
        13 => Register::vr13_16_3,
        14 => Register::vr14_16_3,
        15 => Register::vr15_16_3,
        16 => Register::vr16_16_3,
        17 => Register::vr17_16_3,
        18 => Register::vr18_16_3,
        19 => Register::vr19_16_3,
        20 => Register::vr20_16_3,
        21 => Register::vr21_16_3,
        22 => Register::vr22_16_3,
        23 => Register::vr23_16_3,
        24 => Register::vr24_16_3,
        25 => Register::vr25_16_3,
        26 => Register::vr26_16_3,
        27 => Register::vr27_16_3,
        28 => Register::vr28_16_3,
        29 => Register::vr29_16_3,
        30 => Register::vr30_16_3,
        31 => Register::vr31_16_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_21_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_21_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_22_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_4,
        1 => Register::vr1_16_4,
        2 => Register::vr2_16_4,
        3 => Register::vr3_16_4,
        4 => Register::vr4_16_4,
        5 => Register::vr5_16_4,
        6 => Register::vr6_16_4,
        7 => Register::vr7_16_4,
        8 => Register::vr8_16_4,
        9 => Register::vr9_16_4,
        10 => Register::vr10_16_4,
        11 => Register::vr11_16_4,
        12 => Register::vr12_16_4,
        13 => Register::vr13_16_4,
        14 => Register::vr14_16_4,
        15 => Register::vr15_16_4,
        16 => Register::vr16_16_4,
        17 => Register::vr17_16_4,
        18 => Register::vr18_16_4,
        19 => Register::vr19_16_4,
        20 => Register::vr20_16_4,
        21 => Register::vr21_16_4,
        22 => Register::vr22_16_4,
        23 => Register::vr23_16_4,
        24 => Register::vr24_16_4,
        25 => Register::vr25_16_4,
        26 => Register::vr26_16_4,
        27 => Register::vr27_16_4,
        28 => Register::vr28_16_4,
        29 => Register::vr29_16_4,
        30 => Register::vr30_16_4,
        31 => Register::vr31_16_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_22_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_22_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_23_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_5,
        1 => Register::vr1_16_5,
        2 => Register::vr2_16_5,
        3 => Register::vr3_16_5,
        4 => Register::vr4_16_5,
        5 => Register::vr5_16_5,
        6 => Register::vr6_16_5,
        7 => Register::vr7_16_5,
        8 => Register::vr8_16_5,
        9 => Register::vr9_16_5,
        10 => Register::vr10_16_5,
        11 => Register::vr11_16_5,
        12 => Register::vr12_16_5,
        13 => Register::vr13_16_5,
        14 => Register::vr14_16_5,
        15 => Register::vr15_16_5,
        16 => Register::vr16_16_5,
        17 => Register::vr17_16_5,
        18 => Register::vr18_16_5,
        19 => Register::vr19_16_5,
        20 => Register::vr20_16_5,
        21 => Register::vr21_16_5,
        22 => Register::vr22_16_5,
        23 => Register::vr23_16_5,
        24 => Register::vr24_16_5,
        25 => Register::vr25_16_5,
        26 => Register::vr26_16_5,
        27 => Register::vr27_16_5,
        28 => Register::vr28_16_5,
        29 => Register::vr29_16_5,
        30 => Register::vr30_16_5,
        31 => Register::vr31_16_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_23_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_23_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_24_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_6,
        1 => Register::vr1_16_6,
        2 => Register::vr2_16_6,
        3 => Register::vr3_16_6,
        4 => Register::vr4_16_6,
        5 => Register::vr5_16_6,
        6 => Register::vr6_16_6,
        7 => Register::vr7_16_6,
        8 => Register::vr8_16_6,
        9 => Register::vr9_16_6,
        10 => Register::vr10_16_6,
        11 => Register::vr11_16_6,
        12 => Register::vr12_16_6,
        13 => Register::vr13_16_6,
        14 => Register::vr14_16_6,
        15 => Register::vr15_16_6,
        16 => Register::vr16_16_6,
        17 => Register::vr17_16_6,
        18 => Register::vr18_16_6,
        19 => Register::vr19_16_6,
        20 => Register::vr20_16_6,
        21 => Register::vr21_16_6,
        22 => Register::vr22_16_6,
        23 => Register::vr23_16_6,
        24 => Register::vr24_16_6,
        25 => Register::vr25_16_6,
        26 => Register::vr26_16_6,
        27 => Register::vr27_16_6,
        28 => Register::vr28_16_6,
        29 => Register::vr29_16_6,
        30 => Register::vr30_16_6,
        31 => Register::vr31_16_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_24_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_24_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_25_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_7,
        1 => Register::vr1_16_7,
        2 => Register::vr2_16_7,
        3 => Register::vr3_16_7,
        4 => Register::vr4_16_7,
        5 => Register::vr5_16_7,
        6 => Register::vr6_16_7,
        7 => Register::vr7_16_7,
        8 => Register::vr8_16_7,
        9 => Register::vr9_16_7,
        10 => Register::vr10_16_7,
        11 => Register::vr11_16_7,
        12 => Register::vr12_16_7,
        13 => Register::vr13_16_7,
        14 => Register::vr14_16_7,
        15 => Register::vr15_16_7,
        16 => Register::vr16_16_7,
        17 => Register::vr17_16_7,
        18 => Register::vr18_16_7,
        19 => Register::vr19_16_7,
        20 => Register::vr20_16_7,
        21 => Register::vr21_16_7,
        22 => Register::vr22_16_7,
        23 => Register::vr23_16_7,
        24 => Register::vr24_16_7,
        25 => Register::vr25_16_7,
        26 => Register::vr26_16_7,
        27 => Register::vr27_16_7,
        28 => Register::vr28_16_7,
        29 => Register::vr29_16_7,
        30 => Register::vr30_16_7,
        31 => Register::vr31_16_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_25_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_25_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_26_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_0,
        1 => Register::vr1_8_0,
        2 => Register::vr2_8_0,
        3 => Register::vr3_8_0,
        4 => Register::vr4_8_0,
        5 => Register::vr5_8_0,
        6 => Register::vr6_8_0,
        7 => Register::vr7_8_0,
        8 => Register::vr8_8_0,
        9 => Register::vr9_8_0,
        10 => Register::vr10_8_0,
        11 => Register::vr11_8_0,
        12 => Register::vr12_8_0,
        13 => Register::vr13_8_0,
        14 => Register::vr14_8_0,
        15 => Register::vr15_8_0,
        16 => Register::vr16_8_0,
        17 => Register::vr17_8_0,
        18 => Register::vr18_8_0,
        19 => Register::vr19_8_0,
        20 => Register::vr20_8_0,
        21 => Register::vr21_8_0,
        22 => Register::vr22_8_0,
        23 => Register::vr23_8_0,
        24 => Register::vr24_8_0,
        25 => Register::vr25_8_0,
        26 => Register::vr26_8_0,
        27 => Register::vr27_8_0,
        28 => Register::vr28_8_0,
        29 => Register::vr29_8_0,
        30 => Register::vr30_8_0,
        31 => Register::vr31_8_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_26_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_26_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_27_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_1,
        1 => Register::vr1_8_1,
        2 => Register::vr2_8_1,
        3 => Register::vr3_8_1,
        4 => Register::vr4_8_1,
        5 => Register::vr5_8_1,
        6 => Register::vr6_8_1,
        7 => Register::vr7_8_1,
        8 => Register::vr8_8_1,
        9 => Register::vr9_8_1,
        10 => Register::vr10_8_1,
        11 => Register::vr11_8_1,
        12 => Register::vr12_8_1,
        13 => Register::vr13_8_1,
        14 => Register::vr14_8_1,
        15 => Register::vr15_8_1,
        16 => Register::vr16_8_1,
        17 => Register::vr17_8_1,
        18 => Register::vr18_8_1,
        19 => Register::vr19_8_1,
        20 => Register::vr20_8_1,
        21 => Register::vr21_8_1,
        22 => Register::vr22_8_1,
        23 => Register::vr23_8_1,
        24 => Register::vr24_8_1,
        25 => Register::vr25_8_1,
        26 => Register::vr26_8_1,
        27 => Register::vr27_8_1,
        28 => Register::vr28_8_1,
        29 => Register::vr29_8_1,
        30 => Register::vr30_8_1,
        31 => Register::vr31_8_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_27_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_27_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_28_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_2,
        1 => Register::vr1_8_2,
        2 => Register::vr2_8_2,
        3 => Register::vr3_8_2,
        4 => Register::vr4_8_2,
        5 => Register::vr5_8_2,
        6 => Register::vr6_8_2,
        7 => Register::vr7_8_2,
        8 => Register::vr8_8_2,
        9 => Register::vr9_8_2,
        10 => Register::vr10_8_2,
        11 => Register::vr11_8_2,
        12 => Register::vr12_8_2,
        13 => Register::vr13_8_2,
        14 => Register::vr14_8_2,
        15 => Register::vr15_8_2,
        16 => Register::vr16_8_2,
        17 => Register::vr17_8_2,
        18 => Register::vr18_8_2,
        19 => Register::vr19_8_2,
        20 => Register::vr20_8_2,
        21 => Register::vr21_8_2,
        22 => Register::vr22_8_2,
        23 => Register::vr23_8_2,
        24 => Register::vr24_8_2,
        25 => Register::vr25_8_2,
        26 => Register::vr26_8_2,
        27 => Register::vr27_8_2,
        28 => Register::vr28_8_2,
        29 => Register::vr29_8_2,
        30 => Register::vr30_8_2,
        31 => Register::vr31_8_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_28_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_28_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_29_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_3,
        1 => Register::vr1_8_3,
        2 => Register::vr2_8_3,
        3 => Register::vr3_8_3,
        4 => Register::vr4_8_3,
        5 => Register::vr5_8_3,
        6 => Register::vr6_8_3,
        7 => Register::vr7_8_3,
        8 => Register::vr8_8_3,
        9 => Register::vr9_8_3,
        10 => Register::vr10_8_3,
        11 => Register::vr11_8_3,
        12 => Register::vr12_8_3,
        13 => Register::vr13_8_3,
        14 => Register::vr14_8_3,
        15 => Register::vr15_8_3,
        16 => Register::vr16_8_3,
        17 => Register::vr17_8_3,
        18 => Register::vr18_8_3,
        19 => Register::vr19_8_3,
        20 => Register::vr20_8_3,
        21 => Register::vr21_8_3,
        22 => Register::vr22_8_3,
        23 => Register::vr23_8_3,
        24 => Register::vr24_8_3,
        25 => Register::vr25_8_3,
        26 => Register::vr26_8_3,
        27 => Register::vr27_8_3,
        28 => Register::vr28_8_3,
        29 => Register::vr29_8_3,
        30 => Register::vr30_8_3,
        31 => Register::vr31_8_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_29_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_29_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_30_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_4,
        1 => Register::vr1_8_4,
        2 => Register::vr2_8_4,
        3 => Register::vr3_8_4,
        4 => Register::vr4_8_4,
        5 => Register::vr5_8_4,
        6 => Register::vr6_8_4,
        7 => Register::vr7_8_4,
        8 => Register::vr8_8_4,
        9 => Register::vr9_8_4,
        10 => Register::vr10_8_4,
        11 => Register::vr11_8_4,
        12 => Register::vr12_8_4,
        13 => Register::vr13_8_4,
        14 => Register::vr14_8_4,
        15 => Register::vr15_8_4,
        16 => Register::vr16_8_4,
        17 => Register::vr17_8_4,
        18 => Register::vr18_8_4,
        19 => Register::vr19_8_4,
        20 => Register::vr20_8_4,
        21 => Register::vr21_8_4,
        22 => Register::vr22_8_4,
        23 => Register::vr23_8_4,
        24 => Register::vr24_8_4,
        25 => Register::vr25_8_4,
        26 => Register::vr26_8_4,
        27 => Register::vr27_8_4,
        28 => Register::vr28_8_4,
        29 => Register::vr29_8_4,
        30 => Register::vr30_8_4,
        31 => Register::vr31_8_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_30_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_30_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_31_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_5,
        1 => Register::vr1_8_5,
        2 => Register::vr2_8_5,
        3 => Register::vr3_8_5,
        4 => Register::vr4_8_5,
        5 => Register::vr5_8_5,
        6 => Register::vr6_8_5,
        7 => Register::vr7_8_5,
        8 => Register::vr8_8_5,
        9 => Register::vr9_8_5,
        10 => Register::vr10_8_5,
        11 => Register::vr11_8_5,
        12 => Register::vr12_8_5,
        13 => Register::vr13_8_5,
        14 => Register::vr14_8_5,
        15 => Register::vr15_8_5,
        16 => Register::vr16_8_5,
        17 => Register::vr17_8_5,
        18 => Register::vr18_8_5,
        19 => Register::vr19_8_5,
        20 => Register::vr20_8_5,
        21 => Register::vr21_8_5,
        22 => Register::vr22_8_5,
        23 => Register::vr23_8_5,
        24 => Register::vr24_8_5,
        25 => Register::vr25_8_5,
        26 => Register::vr26_8_5,
        27 => Register::vr27_8_5,
        28 => Register::vr28_8_5,
        29 => Register::vr29_8_5,
        30 => Register::vr30_8_5,
        31 => Register::vr31_8_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_31_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_31_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_32_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_6,
        1 => Register::vr1_8_6,
        2 => Register::vr2_8_6,
        3 => Register::vr3_8_6,
        4 => Register::vr4_8_6,
        5 => Register::vr5_8_6,
        6 => Register::vr6_8_6,
        7 => Register::vr7_8_6,
        8 => Register::vr8_8_6,
        9 => Register::vr9_8_6,
        10 => Register::vr10_8_6,
        11 => Register::vr11_8_6,
        12 => Register::vr12_8_6,
        13 => Register::vr13_8_6,
        14 => Register::vr14_8_6,
        15 => Register::vr15_8_6,
        16 => Register::vr16_8_6,
        17 => Register::vr17_8_6,
        18 => Register::vr18_8_6,
        19 => Register::vr19_8_6,
        20 => Register::vr20_8_6,
        21 => Register::vr21_8_6,
        22 => Register::vr22_8_6,
        23 => Register::vr23_8_6,
        24 => Register::vr24_8_6,
        25 => Register::vr25_8_6,
        26 => Register::vr26_8_6,
        27 => Register::vr27_8_6,
        28 => Register::vr28_8_6,
        29 => Register::vr29_8_6,
        30 => Register::vr30_8_6,
        31 => Register::vr31_8_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_32_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_32_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_33_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_7,
        1 => Register::vr1_8_7,
        2 => Register::vr2_8_7,
        3 => Register::vr3_8_7,
        4 => Register::vr4_8_7,
        5 => Register::vr5_8_7,
        6 => Register::vr6_8_7,
        7 => Register::vr7_8_7,
        8 => Register::vr8_8_7,
        9 => Register::vr9_8_7,
        10 => Register::vr10_8_7,
        11 => Register::vr11_8_7,
        12 => Register::vr12_8_7,
        13 => Register::vr13_8_7,
        14 => Register::vr14_8_7,
        15 => Register::vr15_8_7,
        16 => Register::vr16_8_7,
        17 => Register::vr17_8_7,
        18 => Register::vr18_8_7,
        19 => Register::vr19_8_7,
        20 => Register::vr20_8_7,
        21 => Register::vr21_8_7,
        22 => Register::vr22_8_7,
        23 => Register::vr23_8_7,
        24 => Register::vr24_8_7,
        25 => Register::vr25_8_7,
        26 => Register::vr26_8_7,
        27 => Register::vr27_8_7,
        28 => Register::vr28_8_7,
        29 => Register::vr29_8_7,
        30 => Register::vr30_8_7,
        31 => Register::vr31_8_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_33_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_33_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_34_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_8,
        1 => Register::vr1_8_8,
        2 => Register::vr2_8_8,
        3 => Register::vr3_8_8,
        4 => Register::vr4_8_8,
        5 => Register::vr5_8_8,
        6 => Register::vr6_8_8,
        7 => Register::vr7_8_8,
        8 => Register::vr8_8_8,
        9 => Register::vr9_8_8,
        10 => Register::vr10_8_8,
        11 => Register::vr11_8_8,
        12 => Register::vr12_8_8,
        13 => Register::vr13_8_8,
        14 => Register::vr14_8_8,
        15 => Register::vr15_8_8,
        16 => Register::vr16_8_8,
        17 => Register::vr17_8_8,
        18 => Register::vr18_8_8,
        19 => Register::vr19_8_8,
        20 => Register::vr20_8_8,
        21 => Register::vr21_8_8,
        22 => Register::vr22_8_8,
        23 => Register::vr23_8_8,
        24 => Register::vr24_8_8,
        25 => Register::vr25_8_8,
        26 => Register::vr26_8_8,
        27 => Register::vr27_8_8,
        28 => Register::vr28_8_8,
        29 => Register::vr29_8_8,
        30 => Register::vr30_8_8,
        31 => Register::vr31_8_8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_34_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_34_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_35_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_9,
        1 => Register::vr1_8_9,
        2 => Register::vr2_8_9,
        3 => Register::vr3_8_9,
        4 => Register::vr4_8_9,
        5 => Register::vr5_8_9,
        6 => Register::vr6_8_9,
        7 => Register::vr7_8_9,
        8 => Register::vr8_8_9,
        9 => Register::vr9_8_9,
        10 => Register::vr10_8_9,
        11 => Register::vr11_8_9,
        12 => Register::vr12_8_9,
        13 => Register::vr13_8_9,
        14 => Register::vr14_8_9,
        15 => Register::vr15_8_9,
        16 => Register::vr16_8_9,
        17 => Register::vr17_8_9,
        18 => Register::vr18_8_9,
        19 => Register::vr19_8_9,
        20 => Register::vr20_8_9,
        21 => Register::vr21_8_9,
        22 => Register::vr22_8_9,
        23 => Register::vr23_8_9,
        24 => Register::vr24_8_9,
        25 => Register::vr25_8_9,
        26 => Register::vr26_8_9,
        27 => Register::vr27_8_9,
        28 => Register::vr28_8_9,
        29 => Register::vr29_8_9,
        30 => Register::vr30_8_9,
        31 => Register::vr31_8_9,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_35_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_35_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_36_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_10,
        1 => Register::vr1_8_10,
        2 => Register::vr2_8_10,
        3 => Register::vr3_8_10,
        4 => Register::vr4_8_10,
        5 => Register::vr5_8_10,
        6 => Register::vr6_8_10,
        7 => Register::vr7_8_10,
        8 => Register::vr8_8_10,
        9 => Register::vr9_8_10,
        10 => Register::vr10_8_10,
        11 => Register::vr11_8_10,
        12 => Register::vr12_8_10,
        13 => Register::vr13_8_10,
        14 => Register::vr14_8_10,
        15 => Register::vr15_8_10,
        16 => Register::vr16_8_10,
        17 => Register::vr17_8_10,
        18 => Register::vr18_8_10,
        19 => Register::vr19_8_10,
        20 => Register::vr20_8_10,
        21 => Register::vr21_8_10,
        22 => Register::vr22_8_10,
        23 => Register::vr23_8_10,
        24 => Register::vr24_8_10,
        25 => Register::vr25_8_10,
        26 => Register::vr26_8_10,
        27 => Register::vr27_8_10,
        28 => Register::vr28_8_10,
        29 => Register::vr29_8_10,
        30 => Register::vr30_8_10,
        31 => Register::vr31_8_10,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_36_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_36_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_37_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_11,
        1 => Register::vr1_8_11,
        2 => Register::vr2_8_11,
        3 => Register::vr3_8_11,
        4 => Register::vr4_8_11,
        5 => Register::vr5_8_11,
        6 => Register::vr6_8_11,
        7 => Register::vr7_8_11,
        8 => Register::vr8_8_11,
        9 => Register::vr9_8_11,
        10 => Register::vr10_8_11,
        11 => Register::vr11_8_11,
        12 => Register::vr12_8_11,
        13 => Register::vr13_8_11,
        14 => Register::vr14_8_11,
        15 => Register::vr15_8_11,
        16 => Register::vr16_8_11,
        17 => Register::vr17_8_11,
        18 => Register::vr18_8_11,
        19 => Register::vr19_8_11,
        20 => Register::vr20_8_11,
        21 => Register::vr21_8_11,
        22 => Register::vr22_8_11,
        23 => Register::vr23_8_11,
        24 => Register::vr24_8_11,
        25 => Register::vr25_8_11,
        26 => Register::vr26_8_11,
        27 => Register::vr27_8_11,
        28 => Register::vr28_8_11,
        29 => Register::vr29_8_11,
        30 => Register::vr30_8_11,
        31 => Register::vr31_8_11,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_37_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_37_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_38_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_12,
        1 => Register::vr1_8_12,
        2 => Register::vr2_8_12,
        3 => Register::vr3_8_12,
        4 => Register::vr4_8_12,
        5 => Register::vr5_8_12,
        6 => Register::vr6_8_12,
        7 => Register::vr7_8_12,
        8 => Register::vr8_8_12,
        9 => Register::vr9_8_12,
        10 => Register::vr10_8_12,
        11 => Register::vr11_8_12,
        12 => Register::vr12_8_12,
        13 => Register::vr13_8_12,
        14 => Register::vr14_8_12,
        15 => Register::vr15_8_12,
        16 => Register::vr16_8_12,
        17 => Register::vr17_8_12,
        18 => Register::vr18_8_12,
        19 => Register::vr19_8_12,
        20 => Register::vr20_8_12,
        21 => Register::vr21_8_12,
        22 => Register::vr22_8_12,
        23 => Register::vr23_8_12,
        24 => Register::vr24_8_12,
        25 => Register::vr25_8_12,
        26 => Register::vr26_8_12,
        27 => Register::vr27_8_12,
        28 => Register::vr28_8_12,
        29 => Register::vr29_8_12,
        30 => Register::vr30_8_12,
        31 => Register::vr31_8_12,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_38_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_38_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_39_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_13,
        1 => Register::vr1_8_13,
        2 => Register::vr2_8_13,
        3 => Register::vr3_8_13,
        4 => Register::vr4_8_13,
        5 => Register::vr5_8_13,
        6 => Register::vr6_8_13,
        7 => Register::vr7_8_13,
        8 => Register::vr8_8_13,
        9 => Register::vr9_8_13,
        10 => Register::vr10_8_13,
        11 => Register::vr11_8_13,
        12 => Register::vr12_8_13,
        13 => Register::vr13_8_13,
        14 => Register::vr14_8_13,
        15 => Register::vr15_8_13,
        16 => Register::vr16_8_13,
        17 => Register::vr17_8_13,
        18 => Register::vr18_8_13,
        19 => Register::vr19_8_13,
        20 => Register::vr20_8_13,
        21 => Register::vr21_8_13,
        22 => Register::vr22_8_13,
        23 => Register::vr23_8_13,
        24 => Register::vr24_8_13,
        25 => Register::vr25_8_13,
        26 => Register::vr26_8_13,
        27 => Register::vr27_8_13,
        28 => Register::vr28_8_13,
        29 => Register::vr29_8_13,
        30 => Register::vr30_8_13,
        31 => Register::vr31_8_13,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_39_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_39_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_40_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_14,
        1 => Register::vr1_8_14,
        2 => Register::vr2_8_14,
        3 => Register::vr3_8_14,
        4 => Register::vr4_8_14,
        5 => Register::vr5_8_14,
        6 => Register::vr6_8_14,
        7 => Register::vr7_8_14,
        8 => Register::vr8_8_14,
        9 => Register::vr9_8_14,
        10 => Register::vr10_8_14,
        11 => Register::vr11_8_14,
        12 => Register::vr12_8_14,
        13 => Register::vr13_8_14,
        14 => Register::vr14_8_14,
        15 => Register::vr15_8_14,
        16 => Register::vr16_8_14,
        17 => Register::vr17_8_14,
        18 => Register::vr18_8_14,
        19 => Register::vr19_8_14,
        20 => Register::vr20_8_14,
        21 => Register::vr21_8_14,
        22 => Register::vr22_8_14,
        23 => Register::vr23_8_14,
        24 => Register::vr24_8_14,
        25 => Register::vr25_8_14,
        26 => Register::vr26_8_14,
        27 => Register::vr27_8_14,
        28 => Register::vr28_8_14,
        29 => Register::vr29_8_14,
        30 => Register::vr30_8_14,
        31 => Register::vr31_8_14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_40_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_40_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_41_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_15,
        1 => Register::vr1_8_15,
        2 => Register::vr2_8_15,
        3 => Register::vr3_8_15,
        4 => Register::vr4_8_15,
        5 => Register::vr5_8_15,
        6 => Register::vr6_8_15,
        7 => Register::vr7_8_15,
        8 => Register::vr8_8_15,
        9 => Register::vr9_8_15,
        10 => Register::vr10_8_15,
        11 => Register::vr11_8_15,
        12 => Register::vr12_8_15,
        13 => Register::vr13_8_15,
        14 => Register::vr14_8_15,
        15 => Register::vr15_8_15,
        16 => Register::vr16_8_15,
        17 => Register::vr17_8_15,
        18 => Register::vr18_8_15,
        19 => Register::vr19_8_15,
        20 => Register::vr20_8_15,
        21 => Register::vr21_8_15,
        22 => Register::vr22_8_15,
        23 => Register::vr23_8_15,
        24 => Register::vr24_8_15,
        25 => Register::vr25_8_15,
        26 => Register::vr26_8_15,
        27 => Register::vr27_8_15,
        28 => Register::vr28_8_15,
        29 => Register::vr29_8_15,
        30 => Register::vr30_8_15,
        31 => Register::vr31_8_15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_41_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_41_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_42_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_0,
        1 => Register::vr1_64_0,
        2 => Register::vr2_64_0,
        3 => Register::vr3_64_0,
        4 => Register::vr4_64_0,
        5 => Register::vr5_64_0,
        6 => Register::vr6_64_0,
        7 => Register::vr7_64_0,
        8 => Register::vr8_64_0,
        9 => Register::vr9_64_0,
        10 => Register::vr10_64_0,
        11 => Register::vr11_64_0,
        12 => Register::vr12_64_0,
        13 => Register::vr13_64_0,
        14 => Register::vr14_64_0,
        15 => Register::vr15_64_0,
        16 => Register::vr16_64_0,
        17 => Register::vr17_64_0,
        18 => Register::vr18_64_0,
        19 => Register::vr19_64_0,
        20 => Register::vr20_64_0,
        21 => Register::vr21_64_0,
        22 => Register::vr22_64_0,
        23 => Register::vr23_64_0,
        24 => Register::vr24_64_0,
        25 => Register::vr25_64_0,
        26 => Register::vr26_64_0,
        27 => Register::vr27_64_0,
        28 => Register::vr28_64_0,
        29 => Register::vr29_64_0,
        30 => Register::vr30_64_0,
        31 => Register::vr31_64_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_42_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_42_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_43_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_1,
        1 => Register::vr1_64_1,
        2 => Register::vr2_64_1,
        3 => Register::vr3_64_1,
        4 => Register::vr4_64_1,
        5 => Register::vr5_64_1,
        6 => Register::vr6_64_1,
        7 => Register::vr7_64_1,
        8 => Register::vr8_64_1,
        9 => Register::vr9_64_1,
        10 => Register::vr10_64_1,
        11 => Register::vr11_64_1,
        12 => Register::vr12_64_1,
        13 => Register::vr13_64_1,
        14 => Register::vr14_64_1,
        15 => Register::vr15_64_1,
        16 => Register::vr16_64_1,
        17 => Register::vr17_64_1,
        18 => Register::vr18_64_1,
        19 => Register::vr19_64_1,
        20 => Register::vr20_64_1,
        21 => Register::vr21_64_1,
        22 => Register::vr22_64_1,
        23 => Register::vr23_64_1,
        24 => Register::vr24_64_1,
        25 => Register::vr25_64_1,
        26 => Register::vr26_64_1,
        27 => Register::vr27_64_1,
        28 => Register::vr28_64_1,
        29 => Register::vr29_64_1,
        30 => Register::vr30_64_1,
        31 => Register::vr31_64_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_43_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_43_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_44_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_0,
        1 => Register::vr1_32_0,
        2 => Register::vr2_32_0,
        3 => Register::vr3_32_0,
        4 => Register::vr4_32_0,
        5 => Register::vr5_32_0,
        6 => Register::vr6_32_0,
        7 => Register::vr7_32_0,
        8 => Register::vr8_32_0,
        9 => Register::vr9_32_0,
        10 => Register::vr10_32_0,
        11 => Register::vr11_32_0,
        12 => Register::vr12_32_0,
        13 => Register::vr13_32_0,
        14 => Register::vr14_32_0,
        15 => Register::vr15_32_0,
        16 => Register::vr16_32_0,
        17 => Register::vr17_32_0,
        18 => Register::vr18_32_0,
        19 => Register::vr19_32_0,
        20 => Register::vr20_32_0,
        21 => Register::vr21_32_0,
        22 => Register::vr22_32_0,
        23 => Register::vr23_32_0,
        24 => Register::vr24_32_0,
        25 => Register::vr25_32_0,
        26 => Register::vr26_32_0,
        27 => Register::vr27_32_0,
        28 => Register::vr28_32_0,
        29 => Register::vr29_32_0,
        30 => Register::vr30_32_0,
        31 => Register::vr31_32_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_44_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_44_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_45_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_1,
        1 => Register::vr1_32_1,
        2 => Register::vr2_32_1,
        3 => Register::vr3_32_1,
        4 => Register::vr4_32_1,
        5 => Register::vr5_32_1,
        6 => Register::vr6_32_1,
        7 => Register::vr7_32_1,
        8 => Register::vr8_32_1,
        9 => Register::vr9_32_1,
        10 => Register::vr10_32_1,
        11 => Register::vr11_32_1,
        12 => Register::vr12_32_1,
        13 => Register::vr13_32_1,
        14 => Register::vr14_32_1,
        15 => Register::vr15_32_1,
        16 => Register::vr16_32_1,
        17 => Register::vr17_32_1,
        18 => Register::vr18_32_1,
        19 => Register::vr19_32_1,
        20 => Register::vr20_32_1,
        21 => Register::vr21_32_1,
        22 => Register::vr22_32_1,
        23 => Register::vr23_32_1,
        24 => Register::vr24_32_1,
        25 => Register::vr25_32_1,
        26 => Register::vr26_32_1,
        27 => Register::vr27_32_1,
        28 => Register::vr28_32_1,
        29 => Register::vr29_32_1,
        30 => Register::vr30_32_1,
        31 => Register::vr31_32_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_45_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_45_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_46_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_2,
        1 => Register::vr1_32_2,
        2 => Register::vr2_32_2,
        3 => Register::vr3_32_2,
        4 => Register::vr4_32_2,
        5 => Register::vr5_32_2,
        6 => Register::vr6_32_2,
        7 => Register::vr7_32_2,
        8 => Register::vr8_32_2,
        9 => Register::vr9_32_2,
        10 => Register::vr10_32_2,
        11 => Register::vr11_32_2,
        12 => Register::vr12_32_2,
        13 => Register::vr13_32_2,
        14 => Register::vr14_32_2,
        15 => Register::vr15_32_2,
        16 => Register::vr16_32_2,
        17 => Register::vr17_32_2,
        18 => Register::vr18_32_2,
        19 => Register::vr19_32_2,
        20 => Register::vr20_32_2,
        21 => Register::vr21_32_2,
        22 => Register::vr22_32_2,
        23 => Register::vr23_32_2,
        24 => Register::vr24_32_2,
        25 => Register::vr25_32_2,
        26 => Register::vr26_32_2,
        27 => Register::vr27_32_2,
        28 => Register::vr28_32_2,
        29 => Register::vr29_32_2,
        30 => Register::vr30_32_2,
        31 => Register::vr31_32_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_46_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_46_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_47_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_3,
        1 => Register::vr1_32_3,
        2 => Register::vr2_32_3,
        3 => Register::vr3_32_3,
        4 => Register::vr4_32_3,
        5 => Register::vr5_32_3,
        6 => Register::vr6_32_3,
        7 => Register::vr7_32_3,
        8 => Register::vr8_32_3,
        9 => Register::vr9_32_3,
        10 => Register::vr10_32_3,
        11 => Register::vr11_32_3,
        12 => Register::vr12_32_3,
        13 => Register::vr13_32_3,
        14 => Register::vr14_32_3,
        15 => Register::vr15_32_3,
        16 => Register::vr16_32_3,
        17 => Register::vr17_32_3,
        18 => Register::vr18_32_3,
        19 => Register::vr19_32_3,
        20 => Register::vr20_32_3,
        21 => Register::vr21_32_3,
        22 => Register::vr22_32_3,
        23 => Register::vr23_32_3,
        24 => Register::vr24_32_3,
        25 => Register::vr25_32_3,
        26 => Register::vr26_32_3,
        27 => Register::vr27_32_3,
        28 => Register::vr28_32_3,
        29 => Register::vr29_32_3,
        30 => Register::vr30_32_3,
        31 => Register::vr31_32_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_47_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_47_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_48_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_0,
        1 => Register::vr1_16_0,
        2 => Register::vr2_16_0,
        3 => Register::vr3_16_0,
        4 => Register::vr4_16_0,
        5 => Register::vr5_16_0,
        6 => Register::vr6_16_0,
        7 => Register::vr7_16_0,
        8 => Register::vr8_16_0,
        9 => Register::vr9_16_0,
        10 => Register::vr10_16_0,
        11 => Register::vr11_16_0,
        12 => Register::vr12_16_0,
        13 => Register::vr13_16_0,
        14 => Register::vr14_16_0,
        15 => Register::vr15_16_0,
        16 => Register::vr16_16_0,
        17 => Register::vr17_16_0,
        18 => Register::vr18_16_0,
        19 => Register::vr19_16_0,
        20 => Register::vr20_16_0,
        21 => Register::vr21_16_0,
        22 => Register::vr22_16_0,
        23 => Register::vr23_16_0,
        24 => Register::vr24_16_0,
        25 => Register::vr25_16_0,
        26 => Register::vr26_16_0,
        27 => Register::vr27_16_0,
        28 => Register::vr28_16_0,
        29 => Register::vr29_16_0,
        30 => Register::vr30_16_0,
        31 => Register::vr31_16_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_48_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_48_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_49_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_1,
        1 => Register::vr1_16_1,
        2 => Register::vr2_16_1,
        3 => Register::vr3_16_1,
        4 => Register::vr4_16_1,
        5 => Register::vr5_16_1,
        6 => Register::vr6_16_1,
        7 => Register::vr7_16_1,
        8 => Register::vr8_16_1,
        9 => Register::vr9_16_1,
        10 => Register::vr10_16_1,
        11 => Register::vr11_16_1,
        12 => Register::vr12_16_1,
        13 => Register::vr13_16_1,
        14 => Register::vr14_16_1,
        15 => Register::vr15_16_1,
        16 => Register::vr16_16_1,
        17 => Register::vr17_16_1,
        18 => Register::vr18_16_1,
        19 => Register::vr19_16_1,
        20 => Register::vr20_16_1,
        21 => Register::vr21_16_1,
        22 => Register::vr22_16_1,
        23 => Register::vr23_16_1,
        24 => Register::vr24_16_1,
        25 => Register::vr25_16_1,
        26 => Register::vr26_16_1,
        27 => Register::vr27_16_1,
        28 => Register::vr28_16_1,
        29 => Register::vr29_16_1,
        30 => Register::vr30_16_1,
        31 => Register::vr31_16_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_49_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_49_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_50_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_2,
        1 => Register::vr1_16_2,
        2 => Register::vr2_16_2,
        3 => Register::vr3_16_2,
        4 => Register::vr4_16_2,
        5 => Register::vr5_16_2,
        6 => Register::vr6_16_2,
        7 => Register::vr7_16_2,
        8 => Register::vr8_16_2,
        9 => Register::vr9_16_2,
        10 => Register::vr10_16_2,
        11 => Register::vr11_16_2,
        12 => Register::vr12_16_2,
        13 => Register::vr13_16_2,
        14 => Register::vr14_16_2,
        15 => Register::vr15_16_2,
        16 => Register::vr16_16_2,
        17 => Register::vr17_16_2,
        18 => Register::vr18_16_2,
        19 => Register::vr19_16_2,
        20 => Register::vr20_16_2,
        21 => Register::vr21_16_2,
        22 => Register::vr22_16_2,
        23 => Register::vr23_16_2,
        24 => Register::vr24_16_2,
        25 => Register::vr25_16_2,
        26 => Register::vr26_16_2,
        27 => Register::vr27_16_2,
        28 => Register::vr28_16_2,
        29 => Register::vr29_16_2,
        30 => Register::vr30_16_2,
        31 => Register::vr31_16_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_50_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_50_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_51_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_3,
        1 => Register::vr1_16_3,
        2 => Register::vr2_16_3,
        3 => Register::vr3_16_3,
        4 => Register::vr4_16_3,
        5 => Register::vr5_16_3,
        6 => Register::vr6_16_3,
        7 => Register::vr7_16_3,
        8 => Register::vr8_16_3,
        9 => Register::vr9_16_3,
        10 => Register::vr10_16_3,
        11 => Register::vr11_16_3,
        12 => Register::vr12_16_3,
        13 => Register::vr13_16_3,
        14 => Register::vr14_16_3,
        15 => Register::vr15_16_3,
        16 => Register::vr16_16_3,
        17 => Register::vr17_16_3,
        18 => Register::vr18_16_3,
        19 => Register::vr19_16_3,
        20 => Register::vr20_16_3,
        21 => Register::vr21_16_3,
        22 => Register::vr22_16_3,
        23 => Register::vr23_16_3,
        24 => Register::vr24_16_3,
        25 => Register::vr25_16_3,
        26 => Register::vr26_16_3,
        27 => Register::vr27_16_3,
        28 => Register::vr28_16_3,
        29 => Register::vr29_16_3,
        30 => Register::vr30_16_3,
        31 => Register::vr31_16_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_51_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_51_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_52_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_4,
        1 => Register::vr1_16_4,
        2 => Register::vr2_16_4,
        3 => Register::vr3_16_4,
        4 => Register::vr4_16_4,
        5 => Register::vr5_16_4,
        6 => Register::vr6_16_4,
        7 => Register::vr7_16_4,
        8 => Register::vr8_16_4,
        9 => Register::vr9_16_4,
        10 => Register::vr10_16_4,
        11 => Register::vr11_16_4,
        12 => Register::vr12_16_4,
        13 => Register::vr13_16_4,
        14 => Register::vr14_16_4,
        15 => Register::vr15_16_4,
        16 => Register::vr16_16_4,
        17 => Register::vr17_16_4,
        18 => Register::vr18_16_4,
        19 => Register::vr19_16_4,
        20 => Register::vr20_16_4,
        21 => Register::vr21_16_4,
        22 => Register::vr22_16_4,
        23 => Register::vr23_16_4,
        24 => Register::vr24_16_4,
        25 => Register::vr25_16_4,
        26 => Register::vr26_16_4,
        27 => Register::vr27_16_4,
        28 => Register::vr28_16_4,
        29 => Register::vr29_16_4,
        30 => Register::vr30_16_4,
        31 => Register::vr31_16_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_52_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_52_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_53_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_5,
        1 => Register::vr1_16_5,
        2 => Register::vr2_16_5,
        3 => Register::vr3_16_5,
        4 => Register::vr4_16_5,
        5 => Register::vr5_16_5,
        6 => Register::vr6_16_5,
        7 => Register::vr7_16_5,
        8 => Register::vr8_16_5,
        9 => Register::vr9_16_5,
        10 => Register::vr10_16_5,
        11 => Register::vr11_16_5,
        12 => Register::vr12_16_5,
        13 => Register::vr13_16_5,
        14 => Register::vr14_16_5,
        15 => Register::vr15_16_5,
        16 => Register::vr16_16_5,
        17 => Register::vr17_16_5,
        18 => Register::vr18_16_5,
        19 => Register::vr19_16_5,
        20 => Register::vr20_16_5,
        21 => Register::vr21_16_5,
        22 => Register::vr22_16_5,
        23 => Register::vr23_16_5,
        24 => Register::vr24_16_5,
        25 => Register::vr25_16_5,
        26 => Register::vr26_16_5,
        27 => Register::vr27_16_5,
        28 => Register::vr28_16_5,
        29 => Register::vr29_16_5,
        30 => Register::vr30_16_5,
        31 => Register::vr31_16_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_53_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_53_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_54_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_6,
        1 => Register::vr1_16_6,
        2 => Register::vr2_16_6,
        3 => Register::vr3_16_6,
        4 => Register::vr4_16_6,
        5 => Register::vr5_16_6,
        6 => Register::vr6_16_6,
        7 => Register::vr7_16_6,
        8 => Register::vr8_16_6,
        9 => Register::vr9_16_6,
        10 => Register::vr10_16_6,
        11 => Register::vr11_16_6,
        12 => Register::vr12_16_6,
        13 => Register::vr13_16_6,
        14 => Register::vr14_16_6,
        15 => Register::vr15_16_6,
        16 => Register::vr16_16_6,
        17 => Register::vr17_16_6,
        18 => Register::vr18_16_6,
        19 => Register::vr19_16_6,
        20 => Register::vr20_16_6,
        21 => Register::vr21_16_6,
        22 => Register::vr22_16_6,
        23 => Register::vr23_16_6,
        24 => Register::vr24_16_6,
        25 => Register::vr25_16_6,
        26 => Register::vr26_16_6,
        27 => Register::vr27_16_6,
        28 => Register::vr28_16_6,
        29 => Register::vr29_16_6,
        30 => Register::vr30_16_6,
        31 => Register::vr31_16_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_54_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_54_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_55_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_7,
        1 => Register::vr1_16_7,
        2 => Register::vr2_16_7,
        3 => Register::vr3_16_7,
        4 => Register::vr4_16_7,
        5 => Register::vr5_16_7,
        6 => Register::vr6_16_7,
        7 => Register::vr7_16_7,
        8 => Register::vr8_16_7,
        9 => Register::vr9_16_7,
        10 => Register::vr10_16_7,
        11 => Register::vr11_16_7,
        12 => Register::vr12_16_7,
        13 => Register::vr13_16_7,
        14 => Register::vr14_16_7,
        15 => Register::vr15_16_7,
        16 => Register::vr16_16_7,
        17 => Register::vr17_16_7,
        18 => Register::vr18_16_7,
        19 => Register::vr19_16_7,
        20 => Register::vr20_16_7,
        21 => Register::vr21_16_7,
        22 => Register::vr22_16_7,
        23 => Register::vr23_16_7,
        24 => Register::vr24_16_7,
        25 => Register::vr25_16_7,
        26 => Register::vr26_16_7,
        27 => Register::vr27_16_7,
        28 => Register::vr28_16_7,
        29 => Register::vr29_16_7,
        30 => Register::vr30_16_7,
        31 => Register::vr31_16_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_55_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_55_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_56_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_0,
        1 => Register::vr1_8_0,
        2 => Register::vr2_8_0,
        3 => Register::vr3_8_0,
        4 => Register::vr4_8_0,
        5 => Register::vr5_8_0,
        6 => Register::vr6_8_0,
        7 => Register::vr7_8_0,
        8 => Register::vr8_8_0,
        9 => Register::vr9_8_0,
        10 => Register::vr10_8_0,
        11 => Register::vr11_8_0,
        12 => Register::vr12_8_0,
        13 => Register::vr13_8_0,
        14 => Register::vr14_8_0,
        15 => Register::vr15_8_0,
        16 => Register::vr16_8_0,
        17 => Register::vr17_8_0,
        18 => Register::vr18_8_0,
        19 => Register::vr19_8_0,
        20 => Register::vr20_8_0,
        21 => Register::vr21_8_0,
        22 => Register::vr22_8_0,
        23 => Register::vr23_8_0,
        24 => Register::vr24_8_0,
        25 => Register::vr25_8_0,
        26 => Register::vr26_8_0,
        27 => Register::vr27_8_0,
        28 => Register::vr28_8_0,
        29 => Register::vr29_8_0,
        30 => Register::vr30_8_0,
        31 => Register::vr31_8_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_56_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_56_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_57_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_1,
        1 => Register::vr1_8_1,
        2 => Register::vr2_8_1,
        3 => Register::vr3_8_1,
        4 => Register::vr4_8_1,
        5 => Register::vr5_8_1,
        6 => Register::vr6_8_1,
        7 => Register::vr7_8_1,
        8 => Register::vr8_8_1,
        9 => Register::vr9_8_1,
        10 => Register::vr10_8_1,
        11 => Register::vr11_8_1,
        12 => Register::vr12_8_1,
        13 => Register::vr13_8_1,
        14 => Register::vr14_8_1,
        15 => Register::vr15_8_1,
        16 => Register::vr16_8_1,
        17 => Register::vr17_8_1,
        18 => Register::vr18_8_1,
        19 => Register::vr19_8_1,
        20 => Register::vr20_8_1,
        21 => Register::vr21_8_1,
        22 => Register::vr22_8_1,
        23 => Register::vr23_8_1,
        24 => Register::vr24_8_1,
        25 => Register::vr25_8_1,
        26 => Register::vr26_8_1,
        27 => Register::vr27_8_1,
        28 => Register::vr28_8_1,
        29 => Register::vr29_8_1,
        30 => Register::vr30_8_1,
        31 => Register::vr31_8_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_57_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_57_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_58_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_2,
        1 => Register::vr1_8_2,
        2 => Register::vr2_8_2,
        3 => Register::vr3_8_2,
        4 => Register::vr4_8_2,
        5 => Register::vr5_8_2,
        6 => Register::vr6_8_2,
        7 => Register::vr7_8_2,
        8 => Register::vr8_8_2,
        9 => Register::vr9_8_2,
        10 => Register::vr10_8_2,
        11 => Register::vr11_8_2,
        12 => Register::vr12_8_2,
        13 => Register::vr13_8_2,
        14 => Register::vr14_8_2,
        15 => Register::vr15_8_2,
        16 => Register::vr16_8_2,
        17 => Register::vr17_8_2,
        18 => Register::vr18_8_2,
        19 => Register::vr19_8_2,
        20 => Register::vr20_8_2,
        21 => Register::vr21_8_2,
        22 => Register::vr22_8_2,
        23 => Register::vr23_8_2,
        24 => Register::vr24_8_2,
        25 => Register::vr25_8_2,
        26 => Register::vr26_8_2,
        27 => Register::vr27_8_2,
        28 => Register::vr28_8_2,
        29 => Register::vr29_8_2,
        30 => Register::vr30_8_2,
        31 => Register::vr31_8_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_58_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_58_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_59_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_3,
        1 => Register::vr1_8_3,
        2 => Register::vr2_8_3,
        3 => Register::vr3_8_3,
        4 => Register::vr4_8_3,
        5 => Register::vr5_8_3,
        6 => Register::vr6_8_3,
        7 => Register::vr7_8_3,
        8 => Register::vr8_8_3,
        9 => Register::vr9_8_3,
        10 => Register::vr10_8_3,
        11 => Register::vr11_8_3,
        12 => Register::vr12_8_3,
        13 => Register::vr13_8_3,
        14 => Register::vr14_8_3,
        15 => Register::vr15_8_3,
        16 => Register::vr16_8_3,
        17 => Register::vr17_8_3,
        18 => Register::vr18_8_3,
        19 => Register::vr19_8_3,
        20 => Register::vr20_8_3,
        21 => Register::vr21_8_3,
        22 => Register::vr22_8_3,
        23 => Register::vr23_8_3,
        24 => Register::vr24_8_3,
        25 => Register::vr25_8_3,
        26 => Register::vr26_8_3,
        27 => Register::vr27_8_3,
        28 => Register::vr28_8_3,
        29 => Register::vr29_8_3,
        30 => Register::vr30_8_3,
        31 => Register::vr31_8_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_59_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_59_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_60_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_4,
        1 => Register::vr1_8_4,
        2 => Register::vr2_8_4,
        3 => Register::vr3_8_4,
        4 => Register::vr4_8_4,
        5 => Register::vr5_8_4,
        6 => Register::vr6_8_4,
        7 => Register::vr7_8_4,
        8 => Register::vr8_8_4,
        9 => Register::vr9_8_4,
        10 => Register::vr10_8_4,
        11 => Register::vr11_8_4,
        12 => Register::vr12_8_4,
        13 => Register::vr13_8_4,
        14 => Register::vr14_8_4,
        15 => Register::vr15_8_4,
        16 => Register::vr16_8_4,
        17 => Register::vr17_8_4,
        18 => Register::vr18_8_4,
        19 => Register::vr19_8_4,
        20 => Register::vr20_8_4,
        21 => Register::vr21_8_4,
        22 => Register::vr22_8_4,
        23 => Register::vr23_8_4,
        24 => Register::vr24_8_4,
        25 => Register::vr25_8_4,
        26 => Register::vr26_8_4,
        27 => Register::vr27_8_4,
        28 => Register::vr28_8_4,
        29 => Register::vr29_8_4,
        30 => Register::vr30_8_4,
        31 => Register::vr31_8_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_60_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_60_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_61_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_5,
        1 => Register::vr1_8_5,
        2 => Register::vr2_8_5,
        3 => Register::vr3_8_5,
        4 => Register::vr4_8_5,
        5 => Register::vr5_8_5,
        6 => Register::vr6_8_5,
        7 => Register::vr7_8_5,
        8 => Register::vr8_8_5,
        9 => Register::vr9_8_5,
        10 => Register::vr10_8_5,
        11 => Register::vr11_8_5,
        12 => Register::vr12_8_5,
        13 => Register::vr13_8_5,
        14 => Register::vr14_8_5,
        15 => Register::vr15_8_5,
        16 => Register::vr16_8_5,
        17 => Register::vr17_8_5,
        18 => Register::vr18_8_5,
        19 => Register::vr19_8_5,
        20 => Register::vr20_8_5,
        21 => Register::vr21_8_5,
        22 => Register::vr22_8_5,
        23 => Register::vr23_8_5,
        24 => Register::vr24_8_5,
        25 => Register::vr25_8_5,
        26 => Register::vr26_8_5,
        27 => Register::vr27_8_5,
        28 => Register::vr28_8_5,
        29 => Register::vr29_8_5,
        30 => Register::vr30_8_5,
        31 => Register::vr31_8_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_61_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_61_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_62_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_6,
        1 => Register::vr1_8_6,
        2 => Register::vr2_8_6,
        3 => Register::vr3_8_6,
        4 => Register::vr4_8_6,
        5 => Register::vr5_8_6,
        6 => Register::vr6_8_6,
        7 => Register::vr7_8_6,
        8 => Register::vr8_8_6,
        9 => Register::vr9_8_6,
        10 => Register::vr10_8_6,
        11 => Register::vr11_8_6,
        12 => Register::vr12_8_6,
        13 => Register::vr13_8_6,
        14 => Register::vr14_8_6,
        15 => Register::vr15_8_6,
        16 => Register::vr16_8_6,
        17 => Register::vr17_8_6,
        18 => Register::vr18_8_6,
        19 => Register::vr19_8_6,
        20 => Register::vr20_8_6,
        21 => Register::vr21_8_6,
        22 => Register::vr22_8_6,
        23 => Register::vr23_8_6,
        24 => Register::vr24_8_6,
        25 => Register::vr25_8_6,
        26 => Register::vr26_8_6,
        27 => Register::vr27_8_6,
        28 => Register::vr28_8_6,
        29 => Register::vr29_8_6,
        30 => Register::vr30_8_6,
        31 => Register::vr31_8_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_62_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_62_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_63_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_7,
        1 => Register::vr1_8_7,
        2 => Register::vr2_8_7,
        3 => Register::vr3_8_7,
        4 => Register::vr4_8_7,
        5 => Register::vr5_8_7,
        6 => Register::vr6_8_7,
        7 => Register::vr7_8_7,
        8 => Register::vr8_8_7,
        9 => Register::vr9_8_7,
        10 => Register::vr10_8_7,
        11 => Register::vr11_8_7,
        12 => Register::vr12_8_7,
        13 => Register::vr13_8_7,
        14 => Register::vr14_8_7,
        15 => Register::vr15_8_7,
        16 => Register::vr16_8_7,
        17 => Register::vr17_8_7,
        18 => Register::vr18_8_7,
        19 => Register::vr19_8_7,
        20 => Register::vr20_8_7,
        21 => Register::vr21_8_7,
        22 => Register::vr22_8_7,
        23 => Register::vr23_8_7,
        24 => Register::vr24_8_7,
        25 => Register::vr25_8_7,
        26 => Register::vr26_8_7,
        27 => Register::vr27_8_7,
        28 => Register::vr28_8_7,
        29 => Register::vr29_8_7,
        30 => Register::vr30_8_7,
        31 => Register::vr31_8_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_63_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_63_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_64_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_8,
        1 => Register::vr1_8_8,
        2 => Register::vr2_8_8,
        3 => Register::vr3_8_8,
        4 => Register::vr4_8_8,
        5 => Register::vr5_8_8,
        6 => Register::vr6_8_8,
        7 => Register::vr7_8_8,
        8 => Register::vr8_8_8,
        9 => Register::vr9_8_8,
        10 => Register::vr10_8_8,
        11 => Register::vr11_8_8,
        12 => Register::vr12_8_8,
        13 => Register::vr13_8_8,
        14 => Register::vr14_8_8,
        15 => Register::vr15_8_8,
        16 => Register::vr16_8_8,
        17 => Register::vr17_8_8,
        18 => Register::vr18_8_8,
        19 => Register::vr19_8_8,
        20 => Register::vr20_8_8,
        21 => Register::vr21_8_8,
        22 => Register::vr22_8_8,
        23 => Register::vr23_8_8,
        24 => Register::vr24_8_8,
        25 => Register::vr25_8_8,
        26 => Register::vr26_8_8,
        27 => Register::vr27_8_8,
        28 => Register::vr28_8_8,
        29 => Register::vr29_8_8,
        30 => Register::vr30_8_8,
        31 => Register::vr31_8_8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_64_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_64_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_65_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_9,
        1 => Register::vr1_8_9,
        2 => Register::vr2_8_9,
        3 => Register::vr3_8_9,
        4 => Register::vr4_8_9,
        5 => Register::vr5_8_9,
        6 => Register::vr6_8_9,
        7 => Register::vr7_8_9,
        8 => Register::vr8_8_9,
        9 => Register::vr9_8_9,
        10 => Register::vr10_8_9,
        11 => Register::vr11_8_9,
        12 => Register::vr12_8_9,
        13 => Register::vr13_8_9,
        14 => Register::vr14_8_9,
        15 => Register::vr15_8_9,
        16 => Register::vr16_8_9,
        17 => Register::vr17_8_9,
        18 => Register::vr18_8_9,
        19 => Register::vr19_8_9,
        20 => Register::vr20_8_9,
        21 => Register::vr21_8_9,
        22 => Register::vr22_8_9,
        23 => Register::vr23_8_9,
        24 => Register::vr24_8_9,
        25 => Register::vr25_8_9,
        26 => Register::vr26_8_9,
        27 => Register::vr27_8_9,
        28 => Register::vr28_8_9,
        29 => Register::vr29_8_9,
        30 => Register::vr30_8_9,
        31 => Register::vr31_8_9,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_65_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_65_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_66_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_10,
        1 => Register::vr1_8_10,
        2 => Register::vr2_8_10,
        3 => Register::vr3_8_10,
        4 => Register::vr4_8_10,
        5 => Register::vr5_8_10,
        6 => Register::vr6_8_10,
        7 => Register::vr7_8_10,
        8 => Register::vr8_8_10,
        9 => Register::vr9_8_10,
        10 => Register::vr10_8_10,
        11 => Register::vr11_8_10,
        12 => Register::vr12_8_10,
        13 => Register::vr13_8_10,
        14 => Register::vr14_8_10,
        15 => Register::vr15_8_10,
        16 => Register::vr16_8_10,
        17 => Register::vr17_8_10,
        18 => Register::vr18_8_10,
        19 => Register::vr19_8_10,
        20 => Register::vr20_8_10,
        21 => Register::vr21_8_10,
        22 => Register::vr22_8_10,
        23 => Register::vr23_8_10,
        24 => Register::vr24_8_10,
        25 => Register::vr25_8_10,
        26 => Register::vr26_8_10,
        27 => Register::vr27_8_10,
        28 => Register::vr28_8_10,
        29 => Register::vr29_8_10,
        30 => Register::vr30_8_10,
        31 => Register::vr31_8_10,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_66_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_66_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_67_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_11,
        1 => Register::vr1_8_11,
        2 => Register::vr2_8_11,
        3 => Register::vr3_8_11,
        4 => Register::vr4_8_11,
        5 => Register::vr5_8_11,
        6 => Register::vr6_8_11,
        7 => Register::vr7_8_11,
        8 => Register::vr8_8_11,
        9 => Register::vr9_8_11,
        10 => Register::vr10_8_11,
        11 => Register::vr11_8_11,
        12 => Register::vr12_8_11,
        13 => Register::vr13_8_11,
        14 => Register::vr14_8_11,
        15 => Register::vr15_8_11,
        16 => Register::vr16_8_11,
        17 => Register::vr17_8_11,
        18 => Register::vr18_8_11,
        19 => Register::vr19_8_11,
        20 => Register::vr20_8_11,
        21 => Register::vr21_8_11,
        22 => Register::vr22_8_11,
        23 => Register::vr23_8_11,
        24 => Register::vr24_8_11,
        25 => Register::vr25_8_11,
        26 => Register::vr26_8_11,
        27 => Register::vr27_8_11,
        28 => Register::vr28_8_11,
        29 => Register::vr29_8_11,
        30 => Register::vr30_8_11,
        31 => Register::vr31_8_11,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_67_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_67_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_68_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_12,
        1 => Register::vr1_8_12,
        2 => Register::vr2_8_12,
        3 => Register::vr3_8_12,
        4 => Register::vr4_8_12,
        5 => Register::vr5_8_12,
        6 => Register::vr6_8_12,
        7 => Register::vr7_8_12,
        8 => Register::vr8_8_12,
        9 => Register::vr9_8_12,
        10 => Register::vr10_8_12,
        11 => Register::vr11_8_12,
        12 => Register::vr12_8_12,
        13 => Register::vr13_8_12,
        14 => Register::vr14_8_12,
        15 => Register::vr15_8_12,
        16 => Register::vr16_8_12,
        17 => Register::vr17_8_12,
        18 => Register::vr18_8_12,
        19 => Register::vr19_8_12,
        20 => Register::vr20_8_12,
        21 => Register::vr21_8_12,
        22 => Register::vr22_8_12,
        23 => Register::vr23_8_12,
        24 => Register::vr24_8_12,
        25 => Register::vr25_8_12,
        26 => Register::vr26_8_12,
        27 => Register::vr27_8_12,
        28 => Register::vr28_8_12,
        29 => Register::vr29_8_12,
        30 => Register::vr30_8_12,
        31 => Register::vr31_8_12,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_68_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_68_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_69_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_13,
        1 => Register::vr1_8_13,
        2 => Register::vr2_8_13,
        3 => Register::vr3_8_13,
        4 => Register::vr4_8_13,
        5 => Register::vr5_8_13,
        6 => Register::vr6_8_13,
        7 => Register::vr7_8_13,
        8 => Register::vr8_8_13,
        9 => Register::vr9_8_13,
        10 => Register::vr10_8_13,
        11 => Register::vr11_8_13,
        12 => Register::vr12_8_13,
        13 => Register::vr13_8_13,
        14 => Register::vr14_8_13,
        15 => Register::vr15_8_13,
        16 => Register::vr16_8_13,
        17 => Register::vr17_8_13,
        18 => Register::vr18_8_13,
        19 => Register::vr19_8_13,
        20 => Register::vr20_8_13,
        21 => Register::vr21_8_13,
        22 => Register::vr22_8_13,
        23 => Register::vr23_8_13,
        24 => Register::vr24_8_13,
        25 => Register::vr25_8_13,
        26 => Register::vr26_8_13,
        27 => Register::vr27_8_13,
        28 => Register::vr28_8_13,
        29 => Register::vr29_8_13,
        30 => Register::vr30_8_13,
        31 => Register::vr31_8_13,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_69_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_69_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_70_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_14,
        1 => Register::vr1_8_14,
        2 => Register::vr2_8_14,
        3 => Register::vr3_8_14,
        4 => Register::vr4_8_14,
        5 => Register::vr5_8_14,
        6 => Register::vr6_8_14,
        7 => Register::vr7_8_14,
        8 => Register::vr8_8_14,
        9 => Register::vr9_8_14,
        10 => Register::vr10_8_14,
        11 => Register::vr11_8_14,
        12 => Register::vr12_8_14,
        13 => Register::vr13_8_14,
        14 => Register::vr14_8_14,
        15 => Register::vr15_8_14,
        16 => Register::vr16_8_14,
        17 => Register::vr17_8_14,
        18 => Register::vr18_8_14,
        19 => Register::vr19_8_14,
        20 => Register::vr20_8_14,
        21 => Register::vr21_8_14,
        22 => Register::vr22_8_14,
        23 => Register::vr23_8_14,
        24 => Register::vr24_8_14,
        25 => Register::vr25_8_14,
        26 => Register::vr26_8_14,
        27 => Register::vr27_8_14,
        28 => Register::vr28_8_14,
        29 => Register::vr29_8_14,
        30 => Register::vr30_8_14,
        31 => Register::vr31_8_14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_70_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_70_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_71_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_15,
        1 => Register::vr1_8_15,
        2 => Register::vr2_8_15,
        3 => Register::vr3_8_15,
        4 => Register::vr4_8_15,
        5 => Register::vr5_8_15,
        6 => Register::vr6_8_15,
        7 => Register::vr7_8_15,
        8 => Register::vr8_8_15,
        9 => Register::vr9_8_15,
        10 => Register::vr10_8_15,
        11 => Register::vr11_8_15,
        12 => Register::vr12_8_15,
        13 => Register::vr13_8_15,
        14 => Register::vr14_8_15,
        15 => Register::vr15_8_15,
        16 => Register::vr16_8_15,
        17 => Register::vr17_8_15,
        18 => Register::vr18_8_15,
        19 => Register::vr19_8_15,
        20 => Register::vr20_8_15,
        21 => Register::vr21_8_15,
        22 => Register::vr22_8_15,
        23 => Register::vr23_8_15,
        24 => Register::vr24_8_15,
        25 => Register::vr25_8_15,
        26 => Register::vr26_8_15,
        27 => Register::vr27_8_15,
        28 => Register::vr28_8_15,
        29 => Register::vr29_8_15,
        30 => Register::vr30_8_15,
        31 => Register::vr31_8_15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_71_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_71_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_72_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_0,
        1 => Register::vr1_64_0,
        2 => Register::vr2_64_0,
        3 => Register::vr3_64_0,
        4 => Register::vr4_64_0,
        5 => Register::vr5_64_0,
        6 => Register::vr6_64_0,
        7 => Register::vr7_64_0,
        8 => Register::vr8_64_0,
        9 => Register::vr9_64_0,
        10 => Register::vr10_64_0,
        11 => Register::vr11_64_0,
        12 => Register::vr12_64_0,
        13 => Register::vr13_64_0,
        14 => Register::vr14_64_0,
        15 => Register::vr15_64_0,
        16 => Register::vr16_64_0,
        17 => Register::vr17_64_0,
        18 => Register::vr18_64_0,
        19 => Register::vr19_64_0,
        20 => Register::vr20_64_0,
        21 => Register::vr21_64_0,
        22 => Register::vr22_64_0,
        23 => Register::vr23_64_0,
        24 => Register::vr24_64_0,
        25 => Register::vr25_64_0,
        26 => Register::vr26_64_0,
        27 => Register::vr27_64_0,
        28 => Register::vr28_64_0,
        29 => Register::vr29_64_0,
        30 => Register::vr30_64_0,
        31 => Register::vr31_64_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_72_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_72_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_73_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_1,
        1 => Register::vr1_64_1,
        2 => Register::vr2_64_1,
        3 => Register::vr3_64_1,
        4 => Register::vr4_64_1,
        5 => Register::vr5_64_1,
        6 => Register::vr6_64_1,
        7 => Register::vr7_64_1,
        8 => Register::vr8_64_1,
        9 => Register::vr9_64_1,
        10 => Register::vr10_64_1,
        11 => Register::vr11_64_1,
        12 => Register::vr12_64_1,
        13 => Register::vr13_64_1,
        14 => Register::vr14_64_1,
        15 => Register::vr15_64_1,
        16 => Register::vr16_64_1,
        17 => Register::vr17_64_1,
        18 => Register::vr18_64_1,
        19 => Register::vr19_64_1,
        20 => Register::vr20_64_1,
        21 => Register::vr21_64_1,
        22 => Register::vr22_64_1,
        23 => Register::vr23_64_1,
        24 => Register::vr24_64_1,
        25 => Register::vr25_64_1,
        26 => Register::vr26_64_1,
        27 => Register::vr27_64_1,
        28 => Register::vr28_64_1,
        29 => Register::vr29_64_1,
        30 => Register::vr30_64_1,
        31 => Register::vr31_64_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_73_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_73_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_74_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_0,
        1 => Register::vr1_32_0,
        2 => Register::vr2_32_0,
        3 => Register::vr3_32_0,
        4 => Register::vr4_32_0,
        5 => Register::vr5_32_0,
        6 => Register::vr6_32_0,
        7 => Register::vr7_32_0,
        8 => Register::vr8_32_0,
        9 => Register::vr9_32_0,
        10 => Register::vr10_32_0,
        11 => Register::vr11_32_0,
        12 => Register::vr12_32_0,
        13 => Register::vr13_32_0,
        14 => Register::vr14_32_0,
        15 => Register::vr15_32_0,
        16 => Register::vr16_32_0,
        17 => Register::vr17_32_0,
        18 => Register::vr18_32_0,
        19 => Register::vr19_32_0,
        20 => Register::vr20_32_0,
        21 => Register::vr21_32_0,
        22 => Register::vr22_32_0,
        23 => Register::vr23_32_0,
        24 => Register::vr24_32_0,
        25 => Register::vr25_32_0,
        26 => Register::vr26_32_0,
        27 => Register::vr27_32_0,
        28 => Register::vr28_32_0,
        29 => Register::vr29_32_0,
        30 => Register::vr30_32_0,
        31 => Register::vr31_32_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_74_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_74_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_75_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_1,
        1 => Register::vr1_32_1,
        2 => Register::vr2_32_1,
        3 => Register::vr3_32_1,
        4 => Register::vr4_32_1,
        5 => Register::vr5_32_1,
        6 => Register::vr6_32_1,
        7 => Register::vr7_32_1,
        8 => Register::vr8_32_1,
        9 => Register::vr9_32_1,
        10 => Register::vr10_32_1,
        11 => Register::vr11_32_1,
        12 => Register::vr12_32_1,
        13 => Register::vr13_32_1,
        14 => Register::vr14_32_1,
        15 => Register::vr15_32_1,
        16 => Register::vr16_32_1,
        17 => Register::vr17_32_1,
        18 => Register::vr18_32_1,
        19 => Register::vr19_32_1,
        20 => Register::vr20_32_1,
        21 => Register::vr21_32_1,
        22 => Register::vr22_32_1,
        23 => Register::vr23_32_1,
        24 => Register::vr24_32_1,
        25 => Register::vr25_32_1,
        26 => Register::vr26_32_1,
        27 => Register::vr27_32_1,
        28 => Register::vr28_32_1,
        29 => Register::vr29_32_1,
        30 => Register::vr30_32_1,
        31 => Register::vr31_32_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_75_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_75_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_76_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_2,
        1 => Register::vr1_32_2,
        2 => Register::vr2_32_2,
        3 => Register::vr3_32_2,
        4 => Register::vr4_32_2,
        5 => Register::vr5_32_2,
        6 => Register::vr6_32_2,
        7 => Register::vr7_32_2,
        8 => Register::vr8_32_2,
        9 => Register::vr9_32_2,
        10 => Register::vr10_32_2,
        11 => Register::vr11_32_2,
        12 => Register::vr12_32_2,
        13 => Register::vr13_32_2,
        14 => Register::vr14_32_2,
        15 => Register::vr15_32_2,
        16 => Register::vr16_32_2,
        17 => Register::vr17_32_2,
        18 => Register::vr18_32_2,
        19 => Register::vr19_32_2,
        20 => Register::vr20_32_2,
        21 => Register::vr21_32_2,
        22 => Register::vr22_32_2,
        23 => Register::vr23_32_2,
        24 => Register::vr24_32_2,
        25 => Register::vr25_32_2,
        26 => Register::vr26_32_2,
        27 => Register::vr27_32_2,
        28 => Register::vr28_32_2,
        29 => Register::vr29_32_2,
        30 => Register::vr30_32_2,
        31 => Register::vr31_32_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_76_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_76_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_77_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_3,
        1 => Register::vr1_32_3,
        2 => Register::vr2_32_3,
        3 => Register::vr3_32_3,
        4 => Register::vr4_32_3,
        5 => Register::vr5_32_3,
        6 => Register::vr6_32_3,
        7 => Register::vr7_32_3,
        8 => Register::vr8_32_3,
        9 => Register::vr9_32_3,
        10 => Register::vr10_32_3,
        11 => Register::vr11_32_3,
        12 => Register::vr12_32_3,
        13 => Register::vr13_32_3,
        14 => Register::vr14_32_3,
        15 => Register::vr15_32_3,
        16 => Register::vr16_32_3,
        17 => Register::vr17_32_3,
        18 => Register::vr18_32_3,
        19 => Register::vr19_32_3,
        20 => Register::vr20_32_3,
        21 => Register::vr21_32_3,
        22 => Register::vr22_32_3,
        23 => Register::vr23_32_3,
        24 => Register::vr24_32_3,
        25 => Register::vr25_32_3,
        26 => Register::vr26_32_3,
        27 => Register::vr27_32_3,
        28 => Register::vr28_32_3,
        29 => Register::vr29_32_3,
        30 => Register::vr30_32_3,
        31 => Register::vr31_32_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_77_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_77_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_78_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_0,
        1 => Register::vr1_16_0,
        2 => Register::vr2_16_0,
        3 => Register::vr3_16_0,
        4 => Register::vr4_16_0,
        5 => Register::vr5_16_0,
        6 => Register::vr6_16_0,
        7 => Register::vr7_16_0,
        8 => Register::vr8_16_0,
        9 => Register::vr9_16_0,
        10 => Register::vr10_16_0,
        11 => Register::vr11_16_0,
        12 => Register::vr12_16_0,
        13 => Register::vr13_16_0,
        14 => Register::vr14_16_0,
        15 => Register::vr15_16_0,
        16 => Register::vr16_16_0,
        17 => Register::vr17_16_0,
        18 => Register::vr18_16_0,
        19 => Register::vr19_16_0,
        20 => Register::vr20_16_0,
        21 => Register::vr21_16_0,
        22 => Register::vr22_16_0,
        23 => Register::vr23_16_0,
        24 => Register::vr24_16_0,
        25 => Register::vr25_16_0,
        26 => Register::vr26_16_0,
        27 => Register::vr27_16_0,
        28 => Register::vr28_16_0,
        29 => Register::vr29_16_0,
        30 => Register::vr30_16_0,
        31 => Register::vr31_16_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_78_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_78_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_79_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_1,
        1 => Register::vr1_16_1,
        2 => Register::vr2_16_1,
        3 => Register::vr3_16_1,
        4 => Register::vr4_16_1,
        5 => Register::vr5_16_1,
        6 => Register::vr6_16_1,
        7 => Register::vr7_16_1,
        8 => Register::vr8_16_1,
        9 => Register::vr9_16_1,
        10 => Register::vr10_16_1,
        11 => Register::vr11_16_1,
        12 => Register::vr12_16_1,
        13 => Register::vr13_16_1,
        14 => Register::vr14_16_1,
        15 => Register::vr15_16_1,
        16 => Register::vr16_16_1,
        17 => Register::vr17_16_1,
        18 => Register::vr18_16_1,
        19 => Register::vr19_16_1,
        20 => Register::vr20_16_1,
        21 => Register::vr21_16_1,
        22 => Register::vr22_16_1,
        23 => Register::vr23_16_1,
        24 => Register::vr24_16_1,
        25 => Register::vr25_16_1,
        26 => Register::vr26_16_1,
        27 => Register::vr27_16_1,
        28 => Register::vr28_16_1,
        29 => Register::vr29_16_1,
        30 => Register::vr30_16_1,
        31 => Register::vr31_16_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_79_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_79_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_80_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_2,
        1 => Register::vr1_16_2,
        2 => Register::vr2_16_2,
        3 => Register::vr3_16_2,
        4 => Register::vr4_16_2,
        5 => Register::vr5_16_2,
        6 => Register::vr6_16_2,
        7 => Register::vr7_16_2,
        8 => Register::vr8_16_2,
        9 => Register::vr9_16_2,
        10 => Register::vr10_16_2,
        11 => Register::vr11_16_2,
        12 => Register::vr12_16_2,
        13 => Register::vr13_16_2,
        14 => Register::vr14_16_2,
        15 => Register::vr15_16_2,
        16 => Register::vr16_16_2,
        17 => Register::vr17_16_2,
        18 => Register::vr18_16_2,
        19 => Register::vr19_16_2,
        20 => Register::vr20_16_2,
        21 => Register::vr21_16_2,
        22 => Register::vr22_16_2,
        23 => Register::vr23_16_2,
        24 => Register::vr24_16_2,
        25 => Register::vr25_16_2,
        26 => Register::vr26_16_2,
        27 => Register::vr27_16_2,
        28 => Register::vr28_16_2,
        29 => Register::vr29_16_2,
        30 => Register::vr30_16_2,
        31 => Register::vr31_16_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_80_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_80_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_81_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_3,
        1 => Register::vr1_16_3,
        2 => Register::vr2_16_3,
        3 => Register::vr3_16_3,
        4 => Register::vr4_16_3,
        5 => Register::vr5_16_3,
        6 => Register::vr6_16_3,
        7 => Register::vr7_16_3,
        8 => Register::vr8_16_3,
        9 => Register::vr9_16_3,
        10 => Register::vr10_16_3,
        11 => Register::vr11_16_3,
        12 => Register::vr12_16_3,
        13 => Register::vr13_16_3,
        14 => Register::vr14_16_3,
        15 => Register::vr15_16_3,
        16 => Register::vr16_16_3,
        17 => Register::vr17_16_3,
        18 => Register::vr18_16_3,
        19 => Register::vr19_16_3,
        20 => Register::vr20_16_3,
        21 => Register::vr21_16_3,
        22 => Register::vr22_16_3,
        23 => Register::vr23_16_3,
        24 => Register::vr24_16_3,
        25 => Register::vr25_16_3,
        26 => Register::vr26_16_3,
        27 => Register::vr27_16_3,
        28 => Register::vr28_16_3,
        29 => Register::vr29_16_3,
        30 => Register::vr30_16_3,
        31 => Register::vr31_16_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_81_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_81_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_82_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_4,
        1 => Register::vr1_16_4,
        2 => Register::vr2_16_4,
        3 => Register::vr3_16_4,
        4 => Register::vr4_16_4,
        5 => Register::vr5_16_4,
        6 => Register::vr6_16_4,
        7 => Register::vr7_16_4,
        8 => Register::vr8_16_4,
        9 => Register::vr9_16_4,
        10 => Register::vr10_16_4,
        11 => Register::vr11_16_4,
        12 => Register::vr12_16_4,
        13 => Register::vr13_16_4,
        14 => Register::vr14_16_4,
        15 => Register::vr15_16_4,
        16 => Register::vr16_16_4,
        17 => Register::vr17_16_4,
        18 => Register::vr18_16_4,
        19 => Register::vr19_16_4,
        20 => Register::vr20_16_4,
        21 => Register::vr21_16_4,
        22 => Register::vr22_16_4,
        23 => Register::vr23_16_4,
        24 => Register::vr24_16_4,
        25 => Register::vr25_16_4,
        26 => Register::vr26_16_4,
        27 => Register::vr27_16_4,
        28 => Register::vr28_16_4,
        29 => Register::vr29_16_4,
        30 => Register::vr30_16_4,
        31 => Register::vr31_16_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_82_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_82_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_83_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_5,
        1 => Register::vr1_16_5,
        2 => Register::vr2_16_5,
        3 => Register::vr3_16_5,
        4 => Register::vr4_16_5,
        5 => Register::vr5_16_5,
        6 => Register::vr6_16_5,
        7 => Register::vr7_16_5,
        8 => Register::vr8_16_5,
        9 => Register::vr9_16_5,
        10 => Register::vr10_16_5,
        11 => Register::vr11_16_5,
        12 => Register::vr12_16_5,
        13 => Register::vr13_16_5,
        14 => Register::vr14_16_5,
        15 => Register::vr15_16_5,
        16 => Register::vr16_16_5,
        17 => Register::vr17_16_5,
        18 => Register::vr18_16_5,
        19 => Register::vr19_16_5,
        20 => Register::vr20_16_5,
        21 => Register::vr21_16_5,
        22 => Register::vr22_16_5,
        23 => Register::vr23_16_5,
        24 => Register::vr24_16_5,
        25 => Register::vr25_16_5,
        26 => Register::vr26_16_5,
        27 => Register::vr27_16_5,
        28 => Register::vr28_16_5,
        29 => Register::vr29_16_5,
        30 => Register::vr30_16_5,
        31 => Register::vr31_16_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_83_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_83_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_84_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_6,
        1 => Register::vr1_16_6,
        2 => Register::vr2_16_6,
        3 => Register::vr3_16_6,
        4 => Register::vr4_16_6,
        5 => Register::vr5_16_6,
        6 => Register::vr6_16_6,
        7 => Register::vr7_16_6,
        8 => Register::vr8_16_6,
        9 => Register::vr9_16_6,
        10 => Register::vr10_16_6,
        11 => Register::vr11_16_6,
        12 => Register::vr12_16_6,
        13 => Register::vr13_16_6,
        14 => Register::vr14_16_6,
        15 => Register::vr15_16_6,
        16 => Register::vr16_16_6,
        17 => Register::vr17_16_6,
        18 => Register::vr18_16_6,
        19 => Register::vr19_16_6,
        20 => Register::vr20_16_6,
        21 => Register::vr21_16_6,
        22 => Register::vr22_16_6,
        23 => Register::vr23_16_6,
        24 => Register::vr24_16_6,
        25 => Register::vr25_16_6,
        26 => Register::vr26_16_6,
        27 => Register::vr27_16_6,
        28 => Register::vr28_16_6,
        29 => Register::vr29_16_6,
        30 => Register::vr30_16_6,
        31 => Register::vr31_16_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_84_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_84_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_85_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_7,
        1 => Register::vr1_16_7,
        2 => Register::vr2_16_7,
        3 => Register::vr3_16_7,
        4 => Register::vr4_16_7,
        5 => Register::vr5_16_7,
        6 => Register::vr6_16_7,
        7 => Register::vr7_16_7,
        8 => Register::vr8_16_7,
        9 => Register::vr9_16_7,
        10 => Register::vr10_16_7,
        11 => Register::vr11_16_7,
        12 => Register::vr12_16_7,
        13 => Register::vr13_16_7,
        14 => Register::vr14_16_7,
        15 => Register::vr15_16_7,
        16 => Register::vr16_16_7,
        17 => Register::vr17_16_7,
        18 => Register::vr18_16_7,
        19 => Register::vr19_16_7,
        20 => Register::vr20_16_7,
        21 => Register::vr21_16_7,
        22 => Register::vr22_16_7,
        23 => Register::vr23_16_7,
        24 => Register::vr24_16_7,
        25 => Register::vr25_16_7,
        26 => Register::vr26_16_7,
        27 => Register::vr27_16_7,
        28 => Register::vr28_16_7,
        29 => Register::vr29_16_7,
        30 => Register::vr30_16_7,
        31 => Register::vr31_16_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_85_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_85_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_86_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_0,
        1 => Register::vr1_8_0,
        2 => Register::vr2_8_0,
        3 => Register::vr3_8_0,
        4 => Register::vr4_8_0,
        5 => Register::vr5_8_0,
        6 => Register::vr6_8_0,
        7 => Register::vr7_8_0,
        8 => Register::vr8_8_0,
        9 => Register::vr9_8_0,
        10 => Register::vr10_8_0,
        11 => Register::vr11_8_0,
        12 => Register::vr12_8_0,
        13 => Register::vr13_8_0,
        14 => Register::vr14_8_0,
        15 => Register::vr15_8_0,
        16 => Register::vr16_8_0,
        17 => Register::vr17_8_0,
        18 => Register::vr18_8_0,
        19 => Register::vr19_8_0,
        20 => Register::vr20_8_0,
        21 => Register::vr21_8_0,
        22 => Register::vr22_8_0,
        23 => Register::vr23_8_0,
        24 => Register::vr24_8_0,
        25 => Register::vr25_8_0,
        26 => Register::vr26_8_0,
        27 => Register::vr27_8_0,
        28 => Register::vr28_8_0,
        29 => Register::vr29_8_0,
        30 => Register::vr30_8_0,
        31 => Register::vr31_8_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_86_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_86_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_87_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_1,
        1 => Register::vr1_8_1,
        2 => Register::vr2_8_1,
        3 => Register::vr3_8_1,
        4 => Register::vr4_8_1,
        5 => Register::vr5_8_1,
        6 => Register::vr6_8_1,
        7 => Register::vr7_8_1,
        8 => Register::vr8_8_1,
        9 => Register::vr9_8_1,
        10 => Register::vr10_8_1,
        11 => Register::vr11_8_1,
        12 => Register::vr12_8_1,
        13 => Register::vr13_8_1,
        14 => Register::vr14_8_1,
        15 => Register::vr15_8_1,
        16 => Register::vr16_8_1,
        17 => Register::vr17_8_1,
        18 => Register::vr18_8_1,
        19 => Register::vr19_8_1,
        20 => Register::vr20_8_1,
        21 => Register::vr21_8_1,
        22 => Register::vr22_8_1,
        23 => Register::vr23_8_1,
        24 => Register::vr24_8_1,
        25 => Register::vr25_8_1,
        26 => Register::vr26_8_1,
        27 => Register::vr27_8_1,
        28 => Register::vr28_8_1,
        29 => Register::vr29_8_1,
        30 => Register::vr30_8_1,
        31 => Register::vr31_8_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_87_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_87_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_88_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_2,
        1 => Register::vr1_8_2,
        2 => Register::vr2_8_2,
        3 => Register::vr3_8_2,
        4 => Register::vr4_8_2,
        5 => Register::vr5_8_2,
        6 => Register::vr6_8_2,
        7 => Register::vr7_8_2,
        8 => Register::vr8_8_2,
        9 => Register::vr9_8_2,
        10 => Register::vr10_8_2,
        11 => Register::vr11_8_2,
        12 => Register::vr12_8_2,
        13 => Register::vr13_8_2,
        14 => Register::vr14_8_2,
        15 => Register::vr15_8_2,
        16 => Register::vr16_8_2,
        17 => Register::vr17_8_2,
        18 => Register::vr18_8_2,
        19 => Register::vr19_8_2,
        20 => Register::vr20_8_2,
        21 => Register::vr21_8_2,
        22 => Register::vr22_8_2,
        23 => Register::vr23_8_2,
        24 => Register::vr24_8_2,
        25 => Register::vr25_8_2,
        26 => Register::vr26_8_2,
        27 => Register::vr27_8_2,
        28 => Register::vr28_8_2,
        29 => Register::vr29_8_2,
        30 => Register::vr30_8_2,
        31 => Register::vr31_8_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_88_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_88_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_89_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_3,
        1 => Register::vr1_8_3,
        2 => Register::vr2_8_3,
        3 => Register::vr3_8_3,
        4 => Register::vr4_8_3,
        5 => Register::vr5_8_3,
        6 => Register::vr6_8_3,
        7 => Register::vr7_8_3,
        8 => Register::vr8_8_3,
        9 => Register::vr9_8_3,
        10 => Register::vr10_8_3,
        11 => Register::vr11_8_3,
        12 => Register::vr12_8_3,
        13 => Register::vr13_8_3,
        14 => Register::vr14_8_3,
        15 => Register::vr15_8_3,
        16 => Register::vr16_8_3,
        17 => Register::vr17_8_3,
        18 => Register::vr18_8_3,
        19 => Register::vr19_8_3,
        20 => Register::vr20_8_3,
        21 => Register::vr21_8_3,
        22 => Register::vr22_8_3,
        23 => Register::vr23_8_3,
        24 => Register::vr24_8_3,
        25 => Register::vr25_8_3,
        26 => Register::vr26_8_3,
        27 => Register::vr27_8_3,
        28 => Register::vr28_8_3,
        29 => Register::vr29_8_3,
        30 => Register::vr30_8_3,
        31 => Register::vr31_8_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_89_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_89_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_90_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_4,
        1 => Register::vr1_8_4,
        2 => Register::vr2_8_4,
        3 => Register::vr3_8_4,
        4 => Register::vr4_8_4,
        5 => Register::vr5_8_4,
        6 => Register::vr6_8_4,
        7 => Register::vr7_8_4,
        8 => Register::vr8_8_4,
        9 => Register::vr9_8_4,
        10 => Register::vr10_8_4,
        11 => Register::vr11_8_4,
        12 => Register::vr12_8_4,
        13 => Register::vr13_8_4,
        14 => Register::vr14_8_4,
        15 => Register::vr15_8_4,
        16 => Register::vr16_8_4,
        17 => Register::vr17_8_4,
        18 => Register::vr18_8_4,
        19 => Register::vr19_8_4,
        20 => Register::vr20_8_4,
        21 => Register::vr21_8_4,
        22 => Register::vr22_8_4,
        23 => Register::vr23_8_4,
        24 => Register::vr24_8_4,
        25 => Register::vr25_8_4,
        26 => Register::vr26_8_4,
        27 => Register::vr27_8_4,
        28 => Register::vr28_8_4,
        29 => Register::vr29_8_4,
        30 => Register::vr30_8_4,
        31 => Register::vr31_8_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_90_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_90_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_91_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_5,
        1 => Register::vr1_8_5,
        2 => Register::vr2_8_5,
        3 => Register::vr3_8_5,
        4 => Register::vr4_8_5,
        5 => Register::vr5_8_5,
        6 => Register::vr6_8_5,
        7 => Register::vr7_8_5,
        8 => Register::vr8_8_5,
        9 => Register::vr9_8_5,
        10 => Register::vr10_8_5,
        11 => Register::vr11_8_5,
        12 => Register::vr12_8_5,
        13 => Register::vr13_8_5,
        14 => Register::vr14_8_5,
        15 => Register::vr15_8_5,
        16 => Register::vr16_8_5,
        17 => Register::vr17_8_5,
        18 => Register::vr18_8_5,
        19 => Register::vr19_8_5,
        20 => Register::vr20_8_5,
        21 => Register::vr21_8_5,
        22 => Register::vr22_8_5,
        23 => Register::vr23_8_5,
        24 => Register::vr24_8_5,
        25 => Register::vr25_8_5,
        26 => Register::vr26_8_5,
        27 => Register::vr27_8_5,
        28 => Register::vr28_8_5,
        29 => Register::vr29_8_5,
        30 => Register::vr30_8_5,
        31 => Register::vr31_8_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_91_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_91_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_92_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_6,
        1 => Register::vr1_8_6,
        2 => Register::vr2_8_6,
        3 => Register::vr3_8_6,
        4 => Register::vr4_8_6,
        5 => Register::vr5_8_6,
        6 => Register::vr6_8_6,
        7 => Register::vr7_8_6,
        8 => Register::vr8_8_6,
        9 => Register::vr9_8_6,
        10 => Register::vr10_8_6,
        11 => Register::vr11_8_6,
        12 => Register::vr12_8_6,
        13 => Register::vr13_8_6,
        14 => Register::vr14_8_6,
        15 => Register::vr15_8_6,
        16 => Register::vr16_8_6,
        17 => Register::vr17_8_6,
        18 => Register::vr18_8_6,
        19 => Register::vr19_8_6,
        20 => Register::vr20_8_6,
        21 => Register::vr21_8_6,
        22 => Register::vr22_8_6,
        23 => Register::vr23_8_6,
        24 => Register::vr24_8_6,
        25 => Register::vr25_8_6,
        26 => Register::vr26_8_6,
        27 => Register::vr27_8_6,
        28 => Register::vr28_8_6,
        29 => Register::vr29_8_6,
        30 => Register::vr30_8_6,
        31 => Register::vr31_8_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_92_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_92_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_93_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_7,
        1 => Register::vr1_8_7,
        2 => Register::vr2_8_7,
        3 => Register::vr3_8_7,
        4 => Register::vr4_8_7,
        5 => Register::vr5_8_7,
        6 => Register::vr6_8_7,
        7 => Register::vr7_8_7,
        8 => Register::vr8_8_7,
        9 => Register::vr9_8_7,
        10 => Register::vr10_8_7,
        11 => Register::vr11_8_7,
        12 => Register::vr12_8_7,
        13 => Register::vr13_8_7,
        14 => Register::vr14_8_7,
        15 => Register::vr15_8_7,
        16 => Register::vr16_8_7,
        17 => Register::vr17_8_7,
        18 => Register::vr18_8_7,
        19 => Register::vr19_8_7,
        20 => Register::vr20_8_7,
        21 => Register::vr21_8_7,
        22 => Register::vr22_8_7,
        23 => Register::vr23_8_7,
        24 => Register::vr24_8_7,
        25 => Register::vr25_8_7,
        26 => Register::vr26_8_7,
        27 => Register::vr27_8_7,
        28 => Register::vr28_8_7,
        29 => Register::vr29_8_7,
        30 => Register::vr30_8_7,
        31 => Register::vr31_8_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_93_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_93_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_94_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_8,
        1 => Register::vr1_8_8,
        2 => Register::vr2_8_8,
        3 => Register::vr3_8_8,
        4 => Register::vr4_8_8,
        5 => Register::vr5_8_8,
        6 => Register::vr6_8_8,
        7 => Register::vr7_8_8,
        8 => Register::vr8_8_8,
        9 => Register::vr9_8_8,
        10 => Register::vr10_8_8,
        11 => Register::vr11_8_8,
        12 => Register::vr12_8_8,
        13 => Register::vr13_8_8,
        14 => Register::vr14_8_8,
        15 => Register::vr15_8_8,
        16 => Register::vr16_8_8,
        17 => Register::vr17_8_8,
        18 => Register::vr18_8_8,
        19 => Register::vr19_8_8,
        20 => Register::vr20_8_8,
        21 => Register::vr21_8_8,
        22 => Register::vr22_8_8,
        23 => Register::vr23_8_8,
        24 => Register::vr24_8_8,
        25 => Register::vr25_8_8,
        26 => Register::vr26_8_8,
        27 => Register::vr27_8_8,
        28 => Register::vr28_8_8,
        29 => Register::vr29_8_8,
        30 => Register::vr30_8_8,
        31 => Register::vr31_8_8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_94_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_94_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_95_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_9,
        1 => Register::vr1_8_9,
        2 => Register::vr2_8_9,
        3 => Register::vr3_8_9,
        4 => Register::vr4_8_9,
        5 => Register::vr5_8_9,
        6 => Register::vr6_8_9,
        7 => Register::vr7_8_9,
        8 => Register::vr8_8_9,
        9 => Register::vr9_8_9,
        10 => Register::vr10_8_9,
        11 => Register::vr11_8_9,
        12 => Register::vr12_8_9,
        13 => Register::vr13_8_9,
        14 => Register::vr14_8_9,
        15 => Register::vr15_8_9,
        16 => Register::vr16_8_9,
        17 => Register::vr17_8_9,
        18 => Register::vr18_8_9,
        19 => Register::vr19_8_9,
        20 => Register::vr20_8_9,
        21 => Register::vr21_8_9,
        22 => Register::vr22_8_9,
        23 => Register::vr23_8_9,
        24 => Register::vr24_8_9,
        25 => Register::vr25_8_9,
        26 => Register::vr26_8_9,
        27 => Register::vr27_8_9,
        28 => Register::vr28_8_9,
        29 => Register::vr29_8_9,
        30 => Register::vr30_8_9,
        31 => Register::vr31_8_9,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_95_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_95_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_96_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_10,
        1 => Register::vr1_8_10,
        2 => Register::vr2_8_10,
        3 => Register::vr3_8_10,
        4 => Register::vr4_8_10,
        5 => Register::vr5_8_10,
        6 => Register::vr6_8_10,
        7 => Register::vr7_8_10,
        8 => Register::vr8_8_10,
        9 => Register::vr9_8_10,
        10 => Register::vr10_8_10,
        11 => Register::vr11_8_10,
        12 => Register::vr12_8_10,
        13 => Register::vr13_8_10,
        14 => Register::vr14_8_10,
        15 => Register::vr15_8_10,
        16 => Register::vr16_8_10,
        17 => Register::vr17_8_10,
        18 => Register::vr18_8_10,
        19 => Register::vr19_8_10,
        20 => Register::vr20_8_10,
        21 => Register::vr21_8_10,
        22 => Register::vr22_8_10,
        23 => Register::vr23_8_10,
        24 => Register::vr24_8_10,
        25 => Register::vr25_8_10,
        26 => Register::vr26_8_10,
        27 => Register::vr27_8_10,
        28 => Register::vr28_8_10,
        29 => Register::vr29_8_10,
        30 => Register::vr30_8_10,
        31 => Register::vr31_8_10,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_96_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_96_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_97_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_11,
        1 => Register::vr1_8_11,
        2 => Register::vr2_8_11,
        3 => Register::vr3_8_11,
        4 => Register::vr4_8_11,
        5 => Register::vr5_8_11,
        6 => Register::vr6_8_11,
        7 => Register::vr7_8_11,
        8 => Register::vr8_8_11,
        9 => Register::vr9_8_11,
        10 => Register::vr10_8_11,
        11 => Register::vr11_8_11,
        12 => Register::vr12_8_11,
        13 => Register::vr13_8_11,
        14 => Register::vr14_8_11,
        15 => Register::vr15_8_11,
        16 => Register::vr16_8_11,
        17 => Register::vr17_8_11,
        18 => Register::vr18_8_11,
        19 => Register::vr19_8_11,
        20 => Register::vr20_8_11,
        21 => Register::vr21_8_11,
        22 => Register::vr22_8_11,
        23 => Register::vr23_8_11,
        24 => Register::vr24_8_11,
        25 => Register::vr25_8_11,
        26 => Register::vr26_8_11,
        27 => Register::vr27_8_11,
        28 => Register::vr28_8_11,
        29 => Register::vr29_8_11,
        30 => Register::vr30_8_11,
        31 => Register::vr31_8_11,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_97_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_97_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_98_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_12,
        1 => Register::vr1_8_12,
        2 => Register::vr2_8_12,
        3 => Register::vr3_8_12,
        4 => Register::vr4_8_12,
        5 => Register::vr5_8_12,
        6 => Register::vr6_8_12,
        7 => Register::vr7_8_12,
        8 => Register::vr8_8_12,
        9 => Register::vr9_8_12,
        10 => Register::vr10_8_12,
        11 => Register::vr11_8_12,
        12 => Register::vr12_8_12,
        13 => Register::vr13_8_12,
        14 => Register::vr14_8_12,
        15 => Register::vr15_8_12,
        16 => Register::vr16_8_12,
        17 => Register::vr17_8_12,
        18 => Register::vr18_8_12,
        19 => Register::vr19_8_12,
        20 => Register::vr20_8_12,
        21 => Register::vr21_8_12,
        22 => Register::vr22_8_12,
        23 => Register::vr23_8_12,
        24 => Register::vr24_8_12,
        25 => Register::vr25_8_12,
        26 => Register::vr26_8_12,
        27 => Register::vr27_8_12,
        28 => Register::vr28_8_12,
        29 => Register::vr29_8_12,
        30 => Register::vr30_8_12,
        31 => Register::vr31_8_12,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_98_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_98_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_99_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_13,
        1 => Register::vr1_8_13,
        2 => Register::vr2_8_13,
        3 => Register::vr3_8_13,
        4 => Register::vr4_8_13,
        5 => Register::vr5_8_13,
        6 => Register::vr6_8_13,
        7 => Register::vr7_8_13,
        8 => Register::vr8_8_13,
        9 => Register::vr9_8_13,
        10 => Register::vr10_8_13,
        11 => Register::vr11_8_13,
        12 => Register::vr12_8_13,
        13 => Register::vr13_8_13,
        14 => Register::vr14_8_13,
        15 => Register::vr15_8_13,
        16 => Register::vr16_8_13,
        17 => Register::vr17_8_13,
        18 => Register::vr18_8_13,
        19 => Register::vr19_8_13,
        20 => Register::vr20_8_13,
        21 => Register::vr21_8_13,
        22 => Register::vr22_8_13,
        23 => Register::vr23_8_13,
        24 => Register::vr24_8_13,
        25 => Register::vr25_8_13,
        26 => Register::vr26_8_13,
        27 => Register::vr27_8_13,
        28 => Register::vr28_8_13,
        29 => Register::vr29_8_13,
        30 => Register::vr30_8_13,
        31 => Register::vr31_8_13,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_99_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_99_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_100_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_14,
        1 => Register::vr1_8_14,
        2 => Register::vr2_8_14,
        3 => Register::vr3_8_14,
        4 => Register::vr4_8_14,
        5 => Register::vr5_8_14,
        6 => Register::vr6_8_14,
        7 => Register::vr7_8_14,
        8 => Register::vr8_8_14,
        9 => Register::vr9_8_14,
        10 => Register::vr10_8_14,
        11 => Register::vr11_8_14,
        12 => Register::vr12_8_14,
        13 => Register::vr13_8_14,
        14 => Register::vr14_8_14,
        15 => Register::vr15_8_14,
        16 => Register::vr16_8_14,
        17 => Register::vr17_8_14,
        18 => Register::vr18_8_14,
        19 => Register::vr19_8_14,
        20 => Register::vr20_8_14,
        21 => Register::vr21_8_14,
        22 => Register::vr22_8_14,
        23 => Register::vr23_8_14,
        24 => Register::vr24_8_14,
        25 => Register::vr25_8_14,
        26 => Register::vr26_8_14,
        27 => Register::vr27_8_14,
        28 => Register::vr28_8_14,
        29 => Register::vr29_8_14,
        30 => Register::vr30_8_14,
        31 => Register::vr31_8_14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_100_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_100_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_101_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_15,
        1 => Register::vr1_8_15,
        2 => Register::vr2_8_15,
        3 => Register::vr3_8_15,
        4 => Register::vr4_8_15,
        5 => Register::vr5_8_15,
        6 => Register::vr6_8_15,
        7 => Register::vr7_8_15,
        8 => Register::vr8_8_15,
        9 => Register::vr9_8_15,
        10 => Register::vr10_8_15,
        11 => Register::vr11_8_15,
        12 => Register::vr12_8_15,
        13 => Register::vr13_8_15,
        14 => Register::vr14_8_15,
        15 => Register::vr15_8_15,
        16 => Register::vr16_8_15,
        17 => Register::vr17_8_15,
        18 => Register::vr18_8_15,
        19 => Register::vr19_8_15,
        20 => Register::vr20_8_15,
        21 => Register::vr21_8_15,
        22 => Register::vr22_8_15,
        23 => Register::vr23_8_15,
        24 => Register::vr24_8_15,
        25 => Register::vr25_8_15,
        26 => Register::vr26_8_15,
        27 => Register::vr27_8_15,
        28 => Register::vr28_8_15,
        29 => Register::vr29_8_15,
        30 => Register::vr30_8_15,
        31 => Register::vr31_8_15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_101_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_101_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_102_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_0,
        1 => Register::vr1_64_0,
        2 => Register::vr2_64_0,
        3 => Register::vr3_64_0,
        4 => Register::vr4_64_0,
        5 => Register::vr5_64_0,
        6 => Register::vr6_64_0,
        7 => Register::vr7_64_0,
        8 => Register::vr8_64_0,
        9 => Register::vr9_64_0,
        10 => Register::vr10_64_0,
        11 => Register::vr11_64_0,
        12 => Register::vr12_64_0,
        13 => Register::vr13_64_0,
        14 => Register::vr14_64_0,
        15 => Register::vr15_64_0,
        16 => Register::vr16_64_0,
        17 => Register::vr17_64_0,
        18 => Register::vr18_64_0,
        19 => Register::vr19_64_0,
        20 => Register::vr20_64_0,
        21 => Register::vr21_64_0,
        22 => Register::vr22_64_0,
        23 => Register::vr23_64_0,
        24 => Register::vr24_64_0,
        25 => Register::vr25_64_0,
        26 => Register::vr26_64_0,
        27 => Register::vr27_64_0,
        28 => Register::vr28_64_0,
        29 => Register::vr29_64_0,
        30 => Register::vr30_64_0,
        31 => Register::vr31_64_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_102_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_102_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_103_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_1,
        1 => Register::vr1_64_1,
        2 => Register::vr2_64_1,
        3 => Register::vr3_64_1,
        4 => Register::vr4_64_1,
        5 => Register::vr5_64_1,
        6 => Register::vr6_64_1,
        7 => Register::vr7_64_1,
        8 => Register::vr8_64_1,
        9 => Register::vr9_64_1,
        10 => Register::vr10_64_1,
        11 => Register::vr11_64_1,
        12 => Register::vr12_64_1,
        13 => Register::vr13_64_1,
        14 => Register::vr14_64_1,
        15 => Register::vr15_64_1,
        16 => Register::vr16_64_1,
        17 => Register::vr17_64_1,
        18 => Register::vr18_64_1,
        19 => Register::vr19_64_1,
        20 => Register::vr20_64_1,
        21 => Register::vr21_64_1,
        22 => Register::vr22_64_1,
        23 => Register::vr23_64_1,
        24 => Register::vr24_64_1,
        25 => Register::vr25_64_1,
        26 => Register::vr26_64_1,
        27 => Register::vr27_64_1,
        28 => Register::vr28_64_1,
        29 => Register::vr29_64_1,
        30 => Register::vr30_64_1,
        31 => Register::vr31_64_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_103_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_103_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_104_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_0,
        1 => Register::vr1_32_0,
        2 => Register::vr2_32_0,
        3 => Register::vr3_32_0,
        4 => Register::vr4_32_0,
        5 => Register::vr5_32_0,
        6 => Register::vr6_32_0,
        7 => Register::vr7_32_0,
        8 => Register::vr8_32_0,
        9 => Register::vr9_32_0,
        10 => Register::vr10_32_0,
        11 => Register::vr11_32_0,
        12 => Register::vr12_32_0,
        13 => Register::vr13_32_0,
        14 => Register::vr14_32_0,
        15 => Register::vr15_32_0,
        16 => Register::vr16_32_0,
        17 => Register::vr17_32_0,
        18 => Register::vr18_32_0,
        19 => Register::vr19_32_0,
        20 => Register::vr20_32_0,
        21 => Register::vr21_32_0,
        22 => Register::vr22_32_0,
        23 => Register::vr23_32_0,
        24 => Register::vr24_32_0,
        25 => Register::vr25_32_0,
        26 => Register::vr26_32_0,
        27 => Register::vr27_32_0,
        28 => Register::vr28_32_0,
        29 => Register::vr29_32_0,
        30 => Register::vr30_32_0,
        31 => Register::vr31_32_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_104_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_104_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_105_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_1,
        1 => Register::vr1_32_1,
        2 => Register::vr2_32_1,
        3 => Register::vr3_32_1,
        4 => Register::vr4_32_1,
        5 => Register::vr5_32_1,
        6 => Register::vr6_32_1,
        7 => Register::vr7_32_1,
        8 => Register::vr8_32_1,
        9 => Register::vr9_32_1,
        10 => Register::vr10_32_1,
        11 => Register::vr11_32_1,
        12 => Register::vr12_32_1,
        13 => Register::vr13_32_1,
        14 => Register::vr14_32_1,
        15 => Register::vr15_32_1,
        16 => Register::vr16_32_1,
        17 => Register::vr17_32_1,
        18 => Register::vr18_32_1,
        19 => Register::vr19_32_1,
        20 => Register::vr20_32_1,
        21 => Register::vr21_32_1,
        22 => Register::vr22_32_1,
        23 => Register::vr23_32_1,
        24 => Register::vr24_32_1,
        25 => Register::vr25_32_1,
        26 => Register::vr26_32_1,
        27 => Register::vr27_32_1,
        28 => Register::vr28_32_1,
        29 => Register::vr29_32_1,
        30 => Register::vr30_32_1,
        31 => Register::vr31_32_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_105_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_105_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_106_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_2,
        1 => Register::vr1_32_2,
        2 => Register::vr2_32_2,
        3 => Register::vr3_32_2,
        4 => Register::vr4_32_2,
        5 => Register::vr5_32_2,
        6 => Register::vr6_32_2,
        7 => Register::vr7_32_2,
        8 => Register::vr8_32_2,
        9 => Register::vr9_32_2,
        10 => Register::vr10_32_2,
        11 => Register::vr11_32_2,
        12 => Register::vr12_32_2,
        13 => Register::vr13_32_2,
        14 => Register::vr14_32_2,
        15 => Register::vr15_32_2,
        16 => Register::vr16_32_2,
        17 => Register::vr17_32_2,
        18 => Register::vr18_32_2,
        19 => Register::vr19_32_2,
        20 => Register::vr20_32_2,
        21 => Register::vr21_32_2,
        22 => Register::vr22_32_2,
        23 => Register::vr23_32_2,
        24 => Register::vr24_32_2,
        25 => Register::vr25_32_2,
        26 => Register::vr26_32_2,
        27 => Register::vr27_32_2,
        28 => Register::vr28_32_2,
        29 => Register::vr29_32_2,
        30 => Register::vr30_32_2,
        31 => Register::vr31_32_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_106_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_106_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_107_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_3,
        1 => Register::vr1_32_3,
        2 => Register::vr2_32_3,
        3 => Register::vr3_32_3,
        4 => Register::vr4_32_3,
        5 => Register::vr5_32_3,
        6 => Register::vr6_32_3,
        7 => Register::vr7_32_3,
        8 => Register::vr8_32_3,
        9 => Register::vr9_32_3,
        10 => Register::vr10_32_3,
        11 => Register::vr11_32_3,
        12 => Register::vr12_32_3,
        13 => Register::vr13_32_3,
        14 => Register::vr14_32_3,
        15 => Register::vr15_32_3,
        16 => Register::vr16_32_3,
        17 => Register::vr17_32_3,
        18 => Register::vr18_32_3,
        19 => Register::vr19_32_3,
        20 => Register::vr20_32_3,
        21 => Register::vr21_32_3,
        22 => Register::vr22_32_3,
        23 => Register::vr23_32_3,
        24 => Register::vr24_32_3,
        25 => Register::vr25_32_3,
        26 => Register::vr26_32_3,
        27 => Register::vr27_32_3,
        28 => Register::vr28_32_3,
        29 => Register::vr29_32_3,
        30 => Register::vr30_32_3,
        31 => Register::vr31_32_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_107_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_107_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_108_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_0,
        1 => Register::vr1_16_0,
        2 => Register::vr2_16_0,
        3 => Register::vr3_16_0,
        4 => Register::vr4_16_0,
        5 => Register::vr5_16_0,
        6 => Register::vr6_16_0,
        7 => Register::vr7_16_0,
        8 => Register::vr8_16_0,
        9 => Register::vr9_16_0,
        10 => Register::vr10_16_0,
        11 => Register::vr11_16_0,
        12 => Register::vr12_16_0,
        13 => Register::vr13_16_0,
        14 => Register::vr14_16_0,
        15 => Register::vr15_16_0,
        16 => Register::vr16_16_0,
        17 => Register::vr17_16_0,
        18 => Register::vr18_16_0,
        19 => Register::vr19_16_0,
        20 => Register::vr20_16_0,
        21 => Register::vr21_16_0,
        22 => Register::vr22_16_0,
        23 => Register::vr23_16_0,
        24 => Register::vr24_16_0,
        25 => Register::vr25_16_0,
        26 => Register::vr26_16_0,
        27 => Register::vr27_16_0,
        28 => Register::vr28_16_0,
        29 => Register::vr29_16_0,
        30 => Register::vr30_16_0,
        31 => Register::vr31_16_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_108_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_108_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_109_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_1,
        1 => Register::vr1_16_1,
        2 => Register::vr2_16_1,
        3 => Register::vr3_16_1,
        4 => Register::vr4_16_1,
        5 => Register::vr5_16_1,
        6 => Register::vr6_16_1,
        7 => Register::vr7_16_1,
        8 => Register::vr8_16_1,
        9 => Register::vr9_16_1,
        10 => Register::vr10_16_1,
        11 => Register::vr11_16_1,
        12 => Register::vr12_16_1,
        13 => Register::vr13_16_1,
        14 => Register::vr14_16_1,
        15 => Register::vr15_16_1,
        16 => Register::vr16_16_1,
        17 => Register::vr17_16_1,
        18 => Register::vr18_16_1,
        19 => Register::vr19_16_1,
        20 => Register::vr20_16_1,
        21 => Register::vr21_16_1,
        22 => Register::vr22_16_1,
        23 => Register::vr23_16_1,
        24 => Register::vr24_16_1,
        25 => Register::vr25_16_1,
        26 => Register::vr26_16_1,
        27 => Register::vr27_16_1,
        28 => Register::vr28_16_1,
        29 => Register::vr29_16_1,
        30 => Register::vr30_16_1,
        31 => Register::vr31_16_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_109_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_109_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_110_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_2,
        1 => Register::vr1_16_2,
        2 => Register::vr2_16_2,
        3 => Register::vr3_16_2,
        4 => Register::vr4_16_2,
        5 => Register::vr5_16_2,
        6 => Register::vr6_16_2,
        7 => Register::vr7_16_2,
        8 => Register::vr8_16_2,
        9 => Register::vr9_16_2,
        10 => Register::vr10_16_2,
        11 => Register::vr11_16_2,
        12 => Register::vr12_16_2,
        13 => Register::vr13_16_2,
        14 => Register::vr14_16_2,
        15 => Register::vr15_16_2,
        16 => Register::vr16_16_2,
        17 => Register::vr17_16_2,
        18 => Register::vr18_16_2,
        19 => Register::vr19_16_2,
        20 => Register::vr20_16_2,
        21 => Register::vr21_16_2,
        22 => Register::vr22_16_2,
        23 => Register::vr23_16_2,
        24 => Register::vr24_16_2,
        25 => Register::vr25_16_2,
        26 => Register::vr26_16_2,
        27 => Register::vr27_16_2,
        28 => Register::vr28_16_2,
        29 => Register::vr29_16_2,
        30 => Register::vr30_16_2,
        31 => Register::vr31_16_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_110_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_110_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_111_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_3,
        1 => Register::vr1_16_3,
        2 => Register::vr2_16_3,
        3 => Register::vr3_16_3,
        4 => Register::vr4_16_3,
        5 => Register::vr5_16_3,
        6 => Register::vr6_16_3,
        7 => Register::vr7_16_3,
        8 => Register::vr8_16_3,
        9 => Register::vr9_16_3,
        10 => Register::vr10_16_3,
        11 => Register::vr11_16_3,
        12 => Register::vr12_16_3,
        13 => Register::vr13_16_3,
        14 => Register::vr14_16_3,
        15 => Register::vr15_16_3,
        16 => Register::vr16_16_3,
        17 => Register::vr17_16_3,
        18 => Register::vr18_16_3,
        19 => Register::vr19_16_3,
        20 => Register::vr20_16_3,
        21 => Register::vr21_16_3,
        22 => Register::vr22_16_3,
        23 => Register::vr23_16_3,
        24 => Register::vr24_16_3,
        25 => Register::vr25_16_3,
        26 => Register::vr26_16_3,
        27 => Register::vr27_16_3,
        28 => Register::vr28_16_3,
        29 => Register::vr29_16_3,
        30 => Register::vr30_16_3,
        31 => Register::vr31_16_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_111_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_111_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_112_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_4,
        1 => Register::vr1_16_4,
        2 => Register::vr2_16_4,
        3 => Register::vr3_16_4,
        4 => Register::vr4_16_4,
        5 => Register::vr5_16_4,
        6 => Register::vr6_16_4,
        7 => Register::vr7_16_4,
        8 => Register::vr8_16_4,
        9 => Register::vr9_16_4,
        10 => Register::vr10_16_4,
        11 => Register::vr11_16_4,
        12 => Register::vr12_16_4,
        13 => Register::vr13_16_4,
        14 => Register::vr14_16_4,
        15 => Register::vr15_16_4,
        16 => Register::vr16_16_4,
        17 => Register::vr17_16_4,
        18 => Register::vr18_16_4,
        19 => Register::vr19_16_4,
        20 => Register::vr20_16_4,
        21 => Register::vr21_16_4,
        22 => Register::vr22_16_4,
        23 => Register::vr23_16_4,
        24 => Register::vr24_16_4,
        25 => Register::vr25_16_4,
        26 => Register::vr26_16_4,
        27 => Register::vr27_16_4,
        28 => Register::vr28_16_4,
        29 => Register::vr29_16_4,
        30 => Register::vr30_16_4,
        31 => Register::vr31_16_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_112_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_112_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_113_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_5,
        1 => Register::vr1_16_5,
        2 => Register::vr2_16_5,
        3 => Register::vr3_16_5,
        4 => Register::vr4_16_5,
        5 => Register::vr5_16_5,
        6 => Register::vr6_16_5,
        7 => Register::vr7_16_5,
        8 => Register::vr8_16_5,
        9 => Register::vr9_16_5,
        10 => Register::vr10_16_5,
        11 => Register::vr11_16_5,
        12 => Register::vr12_16_5,
        13 => Register::vr13_16_5,
        14 => Register::vr14_16_5,
        15 => Register::vr15_16_5,
        16 => Register::vr16_16_5,
        17 => Register::vr17_16_5,
        18 => Register::vr18_16_5,
        19 => Register::vr19_16_5,
        20 => Register::vr20_16_5,
        21 => Register::vr21_16_5,
        22 => Register::vr22_16_5,
        23 => Register::vr23_16_5,
        24 => Register::vr24_16_5,
        25 => Register::vr25_16_5,
        26 => Register::vr26_16_5,
        27 => Register::vr27_16_5,
        28 => Register::vr28_16_5,
        29 => Register::vr29_16_5,
        30 => Register::vr30_16_5,
        31 => Register::vr31_16_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_113_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_113_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_114_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_6,
        1 => Register::vr1_16_6,
        2 => Register::vr2_16_6,
        3 => Register::vr3_16_6,
        4 => Register::vr4_16_6,
        5 => Register::vr5_16_6,
        6 => Register::vr6_16_6,
        7 => Register::vr7_16_6,
        8 => Register::vr8_16_6,
        9 => Register::vr9_16_6,
        10 => Register::vr10_16_6,
        11 => Register::vr11_16_6,
        12 => Register::vr12_16_6,
        13 => Register::vr13_16_6,
        14 => Register::vr14_16_6,
        15 => Register::vr15_16_6,
        16 => Register::vr16_16_6,
        17 => Register::vr17_16_6,
        18 => Register::vr18_16_6,
        19 => Register::vr19_16_6,
        20 => Register::vr20_16_6,
        21 => Register::vr21_16_6,
        22 => Register::vr22_16_6,
        23 => Register::vr23_16_6,
        24 => Register::vr24_16_6,
        25 => Register::vr25_16_6,
        26 => Register::vr26_16_6,
        27 => Register::vr27_16_6,
        28 => Register::vr28_16_6,
        29 => Register::vr29_16_6,
        30 => Register::vr30_16_6,
        31 => Register::vr31_16_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_114_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_114_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_115_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_7,
        1 => Register::vr1_16_7,
        2 => Register::vr2_16_7,
        3 => Register::vr3_16_7,
        4 => Register::vr4_16_7,
        5 => Register::vr5_16_7,
        6 => Register::vr6_16_7,
        7 => Register::vr7_16_7,
        8 => Register::vr8_16_7,
        9 => Register::vr9_16_7,
        10 => Register::vr10_16_7,
        11 => Register::vr11_16_7,
        12 => Register::vr12_16_7,
        13 => Register::vr13_16_7,
        14 => Register::vr14_16_7,
        15 => Register::vr15_16_7,
        16 => Register::vr16_16_7,
        17 => Register::vr17_16_7,
        18 => Register::vr18_16_7,
        19 => Register::vr19_16_7,
        20 => Register::vr20_16_7,
        21 => Register::vr21_16_7,
        22 => Register::vr22_16_7,
        23 => Register::vr23_16_7,
        24 => Register::vr24_16_7,
        25 => Register::vr25_16_7,
        26 => Register::vr26_16_7,
        27 => Register::vr27_16_7,
        28 => Register::vr28_16_7,
        29 => Register::vr29_16_7,
        30 => Register::vr30_16_7,
        31 => Register::vr31_16_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_115_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_115_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_116_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_0,
        1 => Register::vr1_8_0,
        2 => Register::vr2_8_0,
        3 => Register::vr3_8_0,
        4 => Register::vr4_8_0,
        5 => Register::vr5_8_0,
        6 => Register::vr6_8_0,
        7 => Register::vr7_8_0,
        8 => Register::vr8_8_0,
        9 => Register::vr9_8_0,
        10 => Register::vr10_8_0,
        11 => Register::vr11_8_0,
        12 => Register::vr12_8_0,
        13 => Register::vr13_8_0,
        14 => Register::vr14_8_0,
        15 => Register::vr15_8_0,
        16 => Register::vr16_8_0,
        17 => Register::vr17_8_0,
        18 => Register::vr18_8_0,
        19 => Register::vr19_8_0,
        20 => Register::vr20_8_0,
        21 => Register::vr21_8_0,
        22 => Register::vr22_8_0,
        23 => Register::vr23_8_0,
        24 => Register::vr24_8_0,
        25 => Register::vr25_8_0,
        26 => Register::vr26_8_0,
        27 => Register::vr27_8_0,
        28 => Register::vr28_8_0,
        29 => Register::vr29_8_0,
        30 => Register::vr30_8_0,
        31 => Register::vr31_8_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_116_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_116_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_117_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_1,
        1 => Register::vr1_8_1,
        2 => Register::vr2_8_1,
        3 => Register::vr3_8_1,
        4 => Register::vr4_8_1,
        5 => Register::vr5_8_1,
        6 => Register::vr6_8_1,
        7 => Register::vr7_8_1,
        8 => Register::vr8_8_1,
        9 => Register::vr9_8_1,
        10 => Register::vr10_8_1,
        11 => Register::vr11_8_1,
        12 => Register::vr12_8_1,
        13 => Register::vr13_8_1,
        14 => Register::vr14_8_1,
        15 => Register::vr15_8_1,
        16 => Register::vr16_8_1,
        17 => Register::vr17_8_1,
        18 => Register::vr18_8_1,
        19 => Register::vr19_8_1,
        20 => Register::vr20_8_1,
        21 => Register::vr21_8_1,
        22 => Register::vr22_8_1,
        23 => Register::vr23_8_1,
        24 => Register::vr24_8_1,
        25 => Register::vr25_8_1,
        26 => Register::vr26_8_1,
        27 => Register::vr27_8_1,
        28 => Register::vr28_8_1,
        29 => Register::vr29_8_1,
        30 => Register::vr30_8_1,
        31 => Register::vr31_8_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_117_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_117_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_118_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_2,
        1 => Register::vr1_8_2,
        2 => Register::vr2_8_2,
        3 => Register::vr3_8_2,
        4 => Register::vr4_8_2,
        5 => Register::vr5_8_2,
        6 => Register::vr6_8_2,
        7 => Register::vr7_8_2,
        8 => Register::vr8_8_2,
        9 => Register::vr9_8_2,
        10 => Register::vr10_8_2,
        11 => Register::vr11_8_2,
        12 => Register::vr12_8_2,
        13 => Register::vr13_8_2,
        14 => Register::vr14_8_2,
        15 => Register::vr15_8_2,
        16 => Register::vr16_8_2,
        17 => Register::vr17_8_2,
        18 => Register::vr18_8_2,
        19 => Register::vr19_8_2,
        20 => Register::vr20_8_2,
        21 => Register::vr21_8_2,
        22 => Register::vr22_8_2,
        23 => Register::vr23_8_2,
        24 => Register::vr24_8_2,
        25 => Register::vr25_8_2,
        26 => Register::vr26_8_2,
        27 => Register::vr27_8_2,
        28 => Register::vr28_8_2,
        29 => Register::vr29_8_2,
        30 => Register::vr30_8_2,
        31 => Register::vr31_8_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_118_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_118_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_119_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_3,
        1 => Register::vr1_8_3,
        2 => Register::vr2_8_3,
        3 => Register::vr3_8_3,
        4 => Register::vr4_8_3,
        5 => Register::vr5_8_3,
        6 => Register::vr6_8_3,
        7 => Register::vr7_8_3,
        8 => Register::vr8_8_3,
        9 => Register::vr9_8_3,
        10 => Register::vr10_8_3,
        11 => Register::vr11_8_3,
        12 => Register::vr12_8_3,
        13 => Register::vr13_8_3,
        14 => Register::vr14_8_3,
        15 => Register::vr15_8_3,
        16 => Register::vr16_8_3,
        17 => Register::vr17_8_3,
        18 => Register::vr18_8_3,
        19 => Register::vr19_8_3,
        20 => Register::vr20_8_3,
        21 => Register::vr21_8_3,
        22 => Register::vr22_8_3,
        23 => Register::vr23_8_3,
        24 => Register::vr24_8_3,
        25 => Register::vr25_8_3,
        26 => Register::vr26_8_3,
        27 => Register::vr27_8_3,
        28 => Register::vr28_8_3,
        29 => Register::vr29_8_3,
        30 => Register::vr30_8_3,
        31 => Register::vr31_8_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_119_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_119_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_120_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_4,
        1 => Register::vr1_8_4,
        2 => Register::vr2_8_4,
        3 => Register::vr3_8_4,
        4 => Register::vr4_8_4,
        5 => Register::vr5_8_4,
        6 => Register::vr6_8_4,
        7 => Register::vr7_8_4,
        8 => Register::vr8_8_4,
        9 => Register::vr9_8_4,
        10 => Register::vr10_8_4,
        11 => Register::vr11_8_4,
        12 => Register::vr12_8_4,
        13 => Register::vr13_8_4,
        14 => Register::vr14_8_4,
        15 => Register::vr15_8_4,
        16 => Register::vr16_8_4,
        17 => Register::vr17_8_4,
        18 => Register::vr18_8_4,
        19 => Register::vr19_8_4,
        20 => Register::vr20_8_4,
        21 => Register::vr21_8_4,
        22 => Register::vr22_8_4,
        23 => Register::vr23_8_4,
        24 => Register::vr24_8_4,
        25 => Register::vr25_8_4,
        26 => Register::vr26_8_4,
        27 => Register::vr27_8_4,
        28 => Register::vr28_8_4,
        29 => Register::vr29_8_4,
        30 => Register::vr30_8_4,
        31 => Register::vr31_8_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_120_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_120_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_121_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_5,
        1 => Register::vr1_8_5,
        2 => Register::vr2_8_5,
        3 => Register::vr3_8_5,
        4 => Register::vr4_8_5,
        5 => Register::vr5_8_5,
        6 => Register::vr6_8_5,
        7 => Register::vr7_8_5,
        8 => Register::vr8_8_5,
        9 => Register::vr9_8_5,
        10 => Register::vr10_8_5,
        11 => Register::vr11_8_5,
        12 => Register::vr12_8_5,
        13 => Register::vr13_8_5,
        14 => Register::vr14_8_5,
        15 => Register::vr15_8_5,
        16 => Register::vr16_8_5,
        17 => Register::vr17_8_5,
        18 => Register::vr18_8_5,
        19 => Register::vr19_8_5,
        20 => Register::vr20_8_5,
        21 => Register::vr21_8_5,
        22 => Register::vr22_8_5,
        23 => Register::vr23_8_5,
        24 => Register::vr24_8_5,
        25 => Register::vr25_8_5,
        26 => Register::vr26_8_5,
        27 => Register::vr27_8_5,
        28 => Register::vr28_8_5,
        29 => Register::vr29_8_5,
        30 => Register::vr30_8_5,
        31 => Register::vr31_8_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_121_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_121_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_122_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_6,
        1 => Register::vr1_8_6,
        2 => Register::vr2_8_6,
        3 => Register::vr3_8_6,
        4 => Register::vr4_8_6,
        5 => Register::vr5_8_6,
        6 => Register::vr6_8_6,
        7 => Register::vr7_8_6,
        8 => Register::vr8_8_6,
        9 => Register::vr9_8_6,
        10 => Register::vr10_8_6,
        11 => Register::vr11_8_6,
        12 => Register::vr12_8_6,
        13 => Register::vr13_8_6,
        14 => Register::vr14_8_6,
        15 => Register::vr15_8_6,
        16 => Register::vr16_8_6,
        17 => Register::vr17_8_6,
        18 => Register::vr18_8_6,
        19 => Register::vr19_8_6,
        20 => Register::vr20_8_6,
        21 => Register::vr21_8_6,
        22 => Register::vr22_8_6,
        23 => Register::vr23_8_6,
        24 => Register::vr24_8_6,
        25 => Register::vr25_8_6,
        26 => Register::vr26_8_6,
        27 => Register::vr27_8_6,
        28 => Register::vr28_8_6,
        29 => Register::vr29_8_6,
        30 => Register::vr30_8_6,
        31 => Register::vr31_8_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_122_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_122_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_123_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_7,
        1 => Register::vr1_8_7,
        2 => Register::vr2_8_7,
        3 => Register::vr3_8_7,
        4 => Register::vr4_8_7,
        5 => Register::vr5_8_7,
        6 => Register::vr6_8_7,
        7 => Register::vr7_8_7,
        8 => Register::vr8_8_7,
        9 => Register::vr9_8_7,
        10 => Register::vr10_8_7,
        11 => Register::vr11_8_7,
        12 => Register::vr12_8_7,
        13 => Register::vr13_8_7,
        14 => Register::vr14_8_7,
        15 => Register::vr15_8_7,
        16 => Register::vr16_8_7,
        17 => Register::vr17_8_7,
        18 => Register::vr18_8_7,
        19 => Register::vr19_8_7,
        20 => Register::vr20_8_7,
        21 => Register::vr21_8_7,
        22 => Register::vr22_8_7,
        23 => Register::vr23_8_7,
        24 => Register::vr24_8_7,
        25 => Register::vr25_8_7,
        26 => Register::vr26_8_7,
        27 => Register::vr27_8_7,
        28 => Register::vr28_8_7,
        29 => Register::vr29_8_7,
        30 => Register::vr30_8_7,
        31 => Register::vr31_8_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_123_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_123_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_124_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_8,
        1 => Register::vr1_8_8,
        2 => Register::vr2_8_8,
        3 => Register::vr3_8_8,
        4 => Register::vr4_8_8,
        5 => Register::vr5_8_8,
        6 => Register::vr6_8_8,
        7 => Register::vr7_8_8,
        8 => Register::vr8_8_8,
        9 => Register::vr9_8_8,
        10 => Register::vr10_8_8,
        11 => Register::vr11_8_8,
        12 => Register::vr12_8_8,
        13 => Register::vr13_8_8,
        14 => Register::vr14_8_8,
        15 => Register::vr15_8_8,
        16 => Register::vr16_8_8,
        17 => Register::vr17_8_8,
        18 => Register::vr18_8_8,
        19 => Register::vr19_8_8,
        20 => Register::vr20_8_8,
        21 => Register::vr21_8_8,
        22 => Register::vr22_8_8,
        23 => Register::vr23_8_8,
        24 => Register::vr24_8_8,
        25 => Register::vr25_8_8,
        26 => Register::vr26_8_8,
        27 => Register::vr27_8_8,
        28 => Register::vr28_8_8,
        29 => Register::vr29_8_8,
        30 => Register::vr30_8_8,
        31 => Register::vr31_8_8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_124_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_124_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_125_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_9,
        1 => Register::vr1_8_9,
        2 => Register::vr2_8_9,
        3 => Register::vr3_8_9,
        4 => Register::vr4_8_9,
        5 => Register::vr5_8_9,
        6 => Register::vr6_8_9,
        7 => Register::vr7_8_9,
        8 => Register::vr8_8_9,
        9 => Register::vr9_8_9,
        10 => Register::vr10_8_9,
        11 => Register::vr11_8_9,
        12 => Register::vr12_8_9,
        13 => Register::vr13_8_9,
        14 => Register::vr14_8_9,
        15 => Register::vr15_8_9,
        16 => Register::vr16_8_9,
        17 => Register::vr17_8_9,
        18 => Register::vr18_8_9,
        19 => Register::vr19_8_9,
        20 => Register::vr20_8_9,
        21 => Register::vr21_8_9,
        22 => Register::vr22_8_9,
        23 => Register::vr23_8_9,
        24 => Register::vr24_8_9,
        25 => Register::vr25_8_9,
        26 => Register::vr26_8_9,
        27 => Register::vr27_8_9,
        28 => Register::vr28_8_9,
        29 => Register::vr29_8_9,
        30 => Register::vr30_8_9,
        31 => Register::vr31_8_9,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_125_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_125_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_126_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_10,
        1 => Register::vr1_8_10,
        2 => Register::vr2_8_10,
        3 => Register::vr3_8_10,
        4 => Register::vr4_8_10,
        5 => Register::vr5_8_10,
        6 => Register::vr6_8_10,
        7 => Register::vr7_8_10,
        8 => Register::vr8_8_10,
        9 => Register::vr9_8_10,
        10 => Register::vr10_8_10,
        11 => Register::vr11_8_10,
        12 => Register::vr12_8_10,
        13 => Register::vr13_8_10,
        14 => Register::vr14_8_10,
        15 => Register::vr15_8_10,
        16 => Register::vr16_8_10,
        17 => Register::vr17_8_10,
        18 => Register::vr18_8_10,
        19 => Register::vr19_8_10,
        20 => Register::vr20_8_10,
        21 => Register::vr21_8_10,
        22 => Register::vr22_8_10,
        23 => Register::vr23_8_10,
        24 => Register::vr24_8_10,
        25 => Register::vr25_8_10,
        26 => Register::vr26_8_10,
        27 => Register::vr27_8_10,
        28 => Register::vr28_8_10,
        29 => Register::vr29_8_10,
        30 => Register::vr30_8_10,
        31 => Register::vr31_8_10,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_126_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_126_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_127_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_11,
        1 => Register::vr1_8_11,
        2 => Register::vr2_8_11,
        3 => Register::vr3_8_11,
        4 => Register::vr4_8_11,
        5 => Register::vr5_8_11,
        6 => Register::vr6_8_11,
        7 => Register::vr7_8_11,
        8 => Register::vr8_8_11,
        9 => Register::vr9_8_11,
        10 => Register::vr10_8_11,
        11 => Register::vr11_8_11,
        12 => Register::vr12_8_11,
        13 => Register::vr13_8_11,
        14 => Register::vr14_8_11,
        15 => Register::vr15_8_11,
        16 => Register::vr16_8_11,
        17 => Register::vr17_8_11,
        18 => Register::vr18_8_11,
        19 => Register::vr19_8_11,
        20 => Register::vr20_8_11,
        21 => Register::vr21_8_11,
        22 => Register::vr22_8_11,
        23 => Register::vr23_8_11,
        24 => Register::vr24_8_11,
        25 => Register::vr25_8_11,
        26 => Register::vr26_8_11,
        27 => Register::vr27_8_11,
        28 => Register::vr28_8_11,
        29 => Register::vr29_8_11,
        30 => Register::vr30_8_11,
        31 => Register::vr31_8_11,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_127_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_127_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_128_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_12,
        1 => Register::vr1_8_12,
        2 => Register::vr2_8_12,
        3 => Register::vr3_8_12,
        4 => Register::vr4_8_12,
        5 => Register::vr5_8_12,
        6 => Register::vr6_8_12,
        7 => Register::vr7_8_12,
        8 => Register::vr8_8_12,
        9 => Register::vr9_8_12,
        10 => Register::vr10_8_12,
        11 => Register::vr11_8_12,
        12 => Register::vr12_8_12,
        13 => Register::vr13_8_12,
        14 => Register::vr14_8_12,
        15 => Register::vr15_8_12,
        16 => Register::vr16_8_12,
        17 => Register::vr17_8_12,
        18 => Register::vr18_8_12,
        19 => Register::vr19_8_12,
        20 => Register::vr20_8_12,
        21 => Register::vr21_8_12,
        22 => Register::vr22_8_12,
        23 => Register::vr23_8_12,
        24 => Register::vr24_8_12,
        25 => Register::vr25_8_12,
        26 => Register::vr26_8_12,
        27 => Register::vr27_8_12,
        28 => Register::vr28_8_12,
        29 => Register::vr29_8_12,
        30 => Register::vr30_8_12,
        31 => Register::vr31_8_12,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_128_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_128_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_129_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_13,
        1 => Register::vr1_8_13,
        2 => Register::vr2_8_13,
        3 => Register::vr3_8_13,
        4 => Register::vr4_8_13,
        5 => Register::vr5_8_13,
        6 => Register::vr6_8_13,
        7 => Register::vr7_8_13,
        8 => Register::vr8_8_13,
        9 => Register::vr9_8_13,
        10 => Register::vr10_8_13,
        11 => Register::vr11_8_13,
        12 => Register::vr12_8_13,
        13 => Register::vr13_8_13,
        14 => Register::vr14_8_13,
        15 => Register::vr15_8_13,
        16 => Register::vr16_8_13,
        17 => Register::vr17_8_13,
        18 => Register::vr18_8_13,
        19 => Register::vr19_8_13,
        20 => Register::vr20_8_13,
        21 => Register::vr21_8_13,
        22 => Register::vr22_8_13,
        23 => Register::vr23_8_13,
        24 => Register::vr24_8_13,
        25 => Register::vr25_8_13,
        26 => Register::vr26_8_13,
        27 => Register::vr27_8_13,
        28 => Register::vr28_8_13,
        29 => Register::vr29_8_13,
        30 => Register::vr30_8_13,
        31 => Register::vr31_8_13,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_129_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_129_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_130_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_14,
        1 => Register::vr1_8_14,
        2 => Register::vr2_8_14,
        3 => Register::vr3_8_14,
        4 => Register::vr4_8_14,
        5 => Register::vr5_8_14,
        6 => Register::vr6_8_14,
        7 => Register::vr7_8_14,
        8 => Register::vr8_8_14,
        9 => Register::vr9_8_14,
        10 => Register::vr10_8_14,
        11 => Register::vr11_8_14,
        12 => Register::vr12_8_14,
        13 => Register::vr13_8_14,
        14 => Register::vr14_8_14,
        15 => Register::vr15_8_14,
        16 => Register::vr16_8_14,
        17 => Register::vr17_8_14,
        18 => Register::vr18_8_14,
        19 => Register::vr19_8_14,
        20 => Register::vr20_8_14,
        21 => Register::vr21_8_14,
        22 => Register::vr22_8_14,
        23 => Register::vr23_8_14,
        24 => Register::vr24_8_14,
        25 => Register::vr25_8_14,
        26 => Register::vr26_8_14,
        27 => Register::vr27_8_14,
        28 => Register::vr28_8_14,
        29 => Register::vr29_8_14,
        30 => Register::vr30_8_14,
        31 => Register::vr31_8_14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_130_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_130_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_131_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_15,
        1 => Register::vr1_8_15,
        2 => Register::vr2_8_15,
        3 => Register::vr3_8_15,
        4 => Register::vr4_8_15,
        5 => Register::vr5_8_15,
        6 => Register::vr6_8_15,
        7 => Register::vr7_8_15,
        8 => Register::vr8_8_15,
        9 => Register::vr9_8_15,
        10 => Register::vr10_8_15,
        11 => Register::vr11_8_15,
        12 => Register::vr12_8_15,
        13 => Register::vr13_8_15,
        14 => Register::vr14_8_15,
        15 => Register::vr15_8_15,
        16 => Register::vr16_8_15,
        17 => Register::vr17_8_15,
        18 => Register::vr18_8_15,
        19 => Register::vr19_8_15,
        20 => Register::vr20_8_15,
        21 => Register::vr21_8_15,
        22 => Register::vr22_8_15,
        23 => Register::vr23_8_15,
        24 => Register::vr24_8_15,
        25 => Register::vr25_8_15,
        26 => Register::vr26_8_15,
        27 => Register::vr27_8_15,
        28 => Register::vr28_8_15,
        29 => Register::vr29_8_15,
        30 => Register::vr30_8_15,
        31 => Register::vr31_8_15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_131_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_131_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_132_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_0,
        1 => Register::vr1_64_0,
        2 => Register::vr2_64_0,
        3 => Register::vr3_64_0,
        4 => Register::vr4_64_0,
        5 => Register::vr5_64_0,
        6 => Register::vr6_64_0,
        7 => Register::vr7_64_0,
        8 => Register::vr8_64_0,
        9 => Register::vr9_64_0,
        10 => Register::vr10_64_0,
        11 => Register::vr11_64_0,
        12 => Register::vr12_64_0,
        13 => Register::vr13_64_0,
        14 => Register::vr14_64_0,
        15 => Register::vr15_64_0,
        16 => Register::vr16_64_0,
        17 => Register::vr17_64_0,
        18 => Register::vr18_64_0,
        19 => Register::vr19_64_0,
        20 => Register::vr20_64_0,
        21 => Register::vr21_64_0,
        22 => Register::vr22_64_0,
        23 => Register::vr23_64_0,
        24 => Register::vr24_64_0,
        25 => Register::vr25_64_0,
        26 => Register::vr26_64_0,
        27 => Register::vr27_64_0,
        28 => Register::vr28_64_0,
        29 => Register::vr29_64_0,
        30 => Register::vr30_64_0,
        31 => Register::vr31_64_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_132_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_132_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_133_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_64_1,
        1 => Register::vr1_64_1,
        2 => Register::vr2_64_1,
        3 => Register::vr3_64_1,
        4 => Register::vr4_64_1,
        5 => Register::vr5_64_1,
        6 => Register::vr6_64_1,
        7 => Register::vr7_64_1,
        8 => Register::vr8_64_1,
        9 => Register::vr9_64_1,
        10 => Register::vr10_64_1,
        11 => Register::vr11_64_1,
        12 => Register::vr12_64_1,
        13 => Register::vr13_64_1,
        14 => Register::vr14_64_1,
        15 => Register::vr15_64_1,
        16 => Register::vr16_64_1,
        17 => Register::vr17_64_1,
        18 => Register::vr18_64_1,
        19 => Register::vr19_64_1,
        20 => Register::vr20_64_1,
        21 => Register::vr21_64_1,
        22 => Register::vr22_64_1,
        23 => Register::vr23_64_1,
        24 => Register::vr24_64_1,
        25 => Register::vr25_64_1,
        26 => Register::vr26_64_1,
        27 => Register::vr27_64_1,
        28 => Register::vr28_64_1,
        29 => Register::vr29_64_1,
        30 => Register::vr30_64_1,
        31 => Register::vr31_64_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_133_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_133_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_134_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_0,
        1 => Register::vr1_32_0,
        2 => Register::vr2_32_0,
        3 => Register::vr3_32_0,
        4 => Register::vr4_32_0,
        5 => Register::vr5_32_0,
        6 => Register::vr6_32_0,
        7 => Register::vr7_32_0,
        8 => Register::vr8_32_0,
        9 => Register::vr9_32_0,
        10 => Register::vr10_32_0,
        11 => Register::vr11_32_0,
        12 => Register::vr12_32_0,
        13 => Register::vr13_32_0,
        14 => Register::vr14_32_0,
        15 => Register::vr15_32_0,
        16 => Register::vr16_32_0,
        17 => Register::vr17_32_0,
        18 => Register::vr18_32_0,
        19 => Register::vr19_32_0,
        20 => Register::vr20_32_0,
        21 => Register::vr21_32_0,
        22 => Register::vr22_32_0,
        23 => Register::vr23_32_0,
        24 => Register::vr24_32_0,
        25 => Register::vr25_32_0,
        26 => Register::vr26_32_0,
        27 => Register::vr27_32_0,
        28 => Register::vr28_32_0,
        29 => Register::vr29_32_0,
        30 => Register::vr30_32_0,
        31 => Register::vr31_32_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_134_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_134_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_135_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_1,
        1 => Register::vr1_32_1,
        2 => Register::vr2_32_1,
        3 => Register::vr3_32_1,
        4 => Register::vr4_32_1,
        5 => Register::vr5_32_1,
        6 => Register::vr6_32_1,
        7 => Register::vr7_32_1,
        8 => Register::vr8_32_1,
        9 => Register::vr9_32_1,
        10 => Register::vr10_32_1,
        11 => Register::vr11_32_1,
        12 => Register::vr12_32_1,
        13 => Register::vr13_32_1,
        14 => Register::vr14_32_1,
        15 => Register::vr15_32_1,
        16 => Register::vr16_32_1,
        17 => Register::vr17_32_1,
        18 => Register::vr18_32_1,
        19 => Register::vr19_32_1,
        20 => Register::vr20_32_1,
        21 => Register::vr21_32_1,
        22 => Register::vr22_32_1,
        23 => Register::vr23_32_1,
        24 => Register::vr24_32_1,
        25 => Register::vr25_32_1,
        26 => Register::vr26_32_1,
        27 => Register::vr27_32_1,
        28 => Register::vr28_32_1,
        29 => Register::vr29_32_1,
        30 => Register::vr30_32_1,
        31 => Register::vr31_32_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_135_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_135_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_136_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_2,
        1 => Register::vr1_32_2,
        2 => Register::vr2_32_2,
        3 => Register::vr3_32_2,
        4 => Register::vr4_32_2,
        5 => Register::vr5_32_2,
        6 => Register::vr6_32_2,
        7 => Register::vr7_32_2,
        8 => Register::vr8_32_2,
        9 => Register::vr9_32_2,
        10 => Register::vr10_32_2,
        11 => Register::vr11_32_2,
        12 => Register::vr12_32_2,
        13 => Register::vr13_32_2,
        14 => Register::vr14_32_2,
        15 => Register::vr15_32_2,
        16 => Register::vr16_32_2,
        17 => Register::vr17_32_2,
        18 => Register::vr18_32_2,
        19 => Register::vr19_32_2,
        20 => Register::vr20_32_2,
        21 => Register::vr21_32_2,
        22 => Register::vr22_32_2,
        23 => Register::vr23_32_2,
        24 => Register::vr24_32_2,
        25 => Register::vr25_32_2,
        26 => Register::vr26_32_2,
        27 => Register::vr27_32_2,
        28 => Register::vr28_32_2,
        29 => Register::vr29_32_2,
        30 => Register::vr30_32_2,
        31 => Register::vr31_32_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_136_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_136_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_137_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_32_3,
        1 => Register::vr1_32_3,
        2 => Register::vr2_32_3,
        3 => Register::vr3_32_3,
        4 => Register::vr4_32_3,
        5 => Register::vr5_32_3,
        6 => Register::vr6_32_3,
        7 => Register::vr7_32_3,
        8 => Register::vr8_32_3,
        9 => Register::vr9_32_3,
        10 => Register::vr10_32_3,
        11 => Register::vr11_32_3,
        12 => Register::vr12_32_3,
        13 => Register::vr13_32_3,
        14 => Register::vr14_32_3,
        15 => Register::vr15_32_3,
        16 => Register::vr16_32_3,
        17 => Register::vr17_32_3,
        18 => Register::vr18_32_3,
        19 => Register::vr19_32_3,
        20 => Register::vr20_32_3,
        21 => Register::vr21_32_3,
        22 => Register::vr22_32_3,
        23 => Register::vr23_32_3,
        24 => Register::vr24_32_3,
        25 => Register::vr25_32_3,
        26 => Register::vr26_32_3,
        27 => Register::vr27_32_3,
        28 => Register::vr28_32_3,
        29 => Register::vr29_32_3,
        30 => Register::vr30_32_3,
        31 => Register::vr31_32_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_137_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_137_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_138_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_0,
        1 => Register::vr1_16_0,
        2 => Register::vr2_16_0,
        3 => Register::vr3_16_0,
        4 => Register::vr4_16_0,
        5 => Register::vr5_16_0,
        6 => Register::vr6_16_0,
        7 => Register::vr7_16_0,
        8 => Register::vr8_16_0,
        9 => Register::vr9_16_0,
        10 => Register::vr10_16_0,
        11 => Register::vr11_16_0,
        12 => Register::vr12_16_0,
        13 => Register::vr13_16_0,
        14 => Register::vr14_16_0,
        15 => Register::vr15_16_0,
        16 => Register::vr16_16_0,
        17 => Register::vr17_16_0,
        18 => Register::vr18_16_0,
        19 => Register::vr19_16_0,
        20 => Register::vr20_16_0,
        21 => Register::vr21_16_0,
        22 => Register::vr22_16_0,
        23 => Register::vr23_16_0,
        24 => Register::vr24_16_0,
        25 => Register::vr25_16_0,
        26 => Register::vr26_16_0,
        27 => Register::vr27_16_0,
        28 => Register::vr28_16_0,
        29 => Register::vr29_16_0,
        30 => Register::vr30_16_0,
        31 => Register::vr31_16_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_138_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_138_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_139_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_1,
        1 => Register::vr1_16_1,
        2 => Register::vr2_16_1,
        3 => Register::vr3_16_1,
        4 => Register::vr4_16_1,
        5 => Register::vr5_16_1,
        6 => Register::vr6_16_1,
        7 => Register::vr7_16_1,
        8 => Register::vr8_16_1,
        9 => Register::vr9_16_1,
        10 => Register::vr10_16_1,
        11 => Register::vr11_16_1,
        12 => Register::vr12_16_1,
        13 => Register::vr13_16_1,
        14 => Register::vr14_16_1,
        15 => Register::vr15_16_1,
        16 => Register::vr16_16_1,
        17 => Register::vr17_16_1,
        18 => Register::vr18_16_1,
        19 => Register::vr19_16_1,
        20 => Register::vr20_16_1,
        21 => Register::vr21_16_1,
        22 => Register::vr22_16_1,
        23 => Register::vr23_16_1,
        24 => Register::vr24_16_1,
        25 => Register::vr25_16_1,
        26 => Register::vr26_16_1,
        27 => Register::vr27_16_1,
        28 => Register::vr28_16_1,
        29 => Register::vr29_16_1,
        30 => Register::vr30_16_1,
        31 => Register::vr31_16_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_139_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_139_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_140_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_2,
        1 => Register::vr1_16_2,
        2 => Register::vr2_16_2,
        3 => Register::vr3_16_2,
        4 => Register::vr4_16_2,
        5 => Register::vr5_16_2,
        6 => Register::vr6_16_2,
        7 => Register::vr7_16_2,
        8 => Register::vr8_16_2,
        9 => Register::vr9_16_2,
        10 => Register::vr10_16_2,
        11 => Register::vr11_16_2,
        12 => Register::vr12_16_2,
        13 => Register::vr13_16_2,
        14 => Register::vr14_16_2,
        15 => Register::vr15_16_2,
        16 => Register::vr16_16_2,
        17 => Register::vr17_16_2,
        18 => Register::vr18_16_2,
        19 => Register::vr19_16_2,
        20 => Register::vr20_16_2,
        21 => Register::vr21_16_2,
        22 => Register::vr22_16_2,
        23 => Register::vr23_16_2,
        24 => Register::vr24_16_2,
        25 => Register::vr25_16_2,
        26 => Register::vr26_16_2,
        27 => Register::vr27_16_2,
        28 => Register::vr28_16_2,
        29 => Register::vr29_16_2,
        30 => Register::vr30_16_2,
        31 => Register::vr31_16_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_140_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_140_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_141_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_3,
        1 => Register::vr1_16_3,
        2 => Register::vr2_16_3,
        3 => Register::vr3_16_3,
        4 => Register::vr4_16_3,
        5 => Register::vr5_16_3,
        6 => Register::vr6_16_3,
        7 => Register::vr7_16_3,
        8 => Register::vr8_16_3,
        9 => Register::vr9_16_3,
        10 => Register::vr10_16_3,
        11 => Register::vr11_16_3,
        12 => Register::vr12_16_3,
        13 => Register::vr13_16_3,
        14 => Register::vr14_16_3,
        15 => Register::vr15_16_3,
        16 => Register::vr16_16_3,
        17 => Register::vr17_16_3,
        18 => Register::vr18_16_3,
        19 => Register::vr19_16_3,
        20 => Register::vr20_16_3,
        21 => Register::vr21_16_3,
        22 => Register::vr22_16_3,
        23 => Register::vr23_16_3,
        24 => Register::vr24_16_3,
        25 => Register::vr25_16_3,
        26 => Register::vr26_16_3,
        27 => Register::vr27_16_3,
        28 => Register::vr28_16_3,
        29 => Register::vr29_16_3,
        30 => Register::vr30_16_3,
        31 => Register::vr31_16_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_141_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_141_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_142_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_4,
        1 => Register::vr1_16_4,
        2 => Register::vr2_16_4,
        3 => Register::vr3_16_4,
        4 => Register::vr4_16_4,
        5 => Register::vr5_16_4,
        6 => Register::vr6_16_4,
        7 => Register::vr7_16_4,
        8 => Register::vr8_16_4,
        9 => Register::vr9_16_4,
        10 => Register::vr10_16_4,
        11 => Register::vr11_16_4,
        12 => Register::vr12_16_4,
        13 => Register::vr13_16_4,
        14 => Register::vr14_16_4,
        15 => Register::vr15_16_4,
        16 => Register::vr16_16_4,
        17 => Register::vr17_16_4,
        18 => Register::vr18_16_4,
        19 => Register::vr19_16_4,
        20 => Register::vr20_16_4,
        21 => Register::vr21_16_4,
        22 => Register::vr22_16_4,
        23 => Register::vr23_16_4,
        24 => Register::vr24_16_4,
        25 => Register::vr25_16_4,
        26 => Register::vr26_16_4,
        27 => Register::vr27_16_4,
        28 => Register::vr28_16_4,
        29 => Register::vr29_16_4,
        30 => Register::vr30_16_4,
        31 => Register::vr31_16_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_142_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_142_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_143_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_5,
        1 => Register::vr1_16_5,
        2 => Register::vr2_16_5,
        3 => Register::vr3_16_5,
        4 => Register::vr4_16_5,
        5 => Register::vr5_16_5,
        6 => Register::vr6_16_5,
        7 => Register::vr7_16_5,
        8 => Register::vr8_16_5,
        9 => Register::vr9_16_5,
        10 => Register::vr10_16_5,
        11 => Register::vr11_16_5,
        12 => Register::vr12_16_5,
        13 => Register::vr13_16_5,
        14 => Register::vr14_16_5,
        15 => Register::vr15_16_5,
        16 => Register::vr16_16_5,
        17 => Register::vr17_16_5,
        18 => Register::vr18_16_5,
        19 => Register::vr19_16_5,
        20 => Register::vr20_16_5,
        21 => Register::vr21_16_5,
        22 => Register::vr22_16_5,
        23 => Register::vr23_16_5,
        24 => Register::vr24_16_5,
        25 => Register::vr25_16_5,
        26 => Register::vr26_16_5,
        27 => Register::vr27_16_5,
        28 => Register::vr28_16_5,
        29 => Register::vr29_16_5,
        30 => Register::vr30_16_5,
        31 => Register::vr31_16_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_143_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_143_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_144_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_6,
        1 => Register::vr1_16_6,
        2 => Register::vr2_16_6,
        3 => Register::vr3_16_6,
        4 => Register::vr4_16_6,
        5 => Register::vr5_16_6,
        6 => Register::vr6_16_6,
        7 => Register::vr7_16_6,
        8 => Register::vr8_16_6,
        9 => Register::vr9_16_6,
        10 => Register::vr10_16_6,
        11 => Register::vr11_16_6,
        12 => Register::vr12_16_6,
        13 => Register::vr13_16_6,
        14 => Register::vr14_16_6,
        15 => Register::vr15_16_6,
        16 => Register::vr16_16_6,
        17 => Register::vr17_16_6,
        18 => Register::vr18_16_6,
        19 => Register::vr19_16_6,
        20 => Register::vr20_16_6,
        21 => Register::vr21_16_6,
        22 => Register::vr22_16_6,
        23 => Register::vr23_16_6,
        24 => Register::vr24_16_6,
        25 => Register::vr25_16_6,
        26 => Register::vr26_16_6,
        27 => Register::vr27_16_6,
        28 => Register::vr28_16_6,
        29 => Register::vr29_16_6,
        30 => Register::vr30_16_6,
        31 => Register::vr31_16_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_144_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_144_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_145_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_16_7,
        1 => Register::vr1_16_7,
        2 => Register::vr2_16_7,
        3 => Register::vr3_16_7,
        4 => Register::vr4_16_7,
        5 => Register::vr5_16_7,
        6 => Register::vr6_16_7,
        7 => Register::vr7_16_7,
        8 => Register::vr8_16_7,
        9 => Register::vr9_16_7,
        10 => Register::vr10_16_7,
        11 => Register::vr11_16_7,
        12 => Register::vr12_16_7,
        13 => Register::vr13_16_7,
        14 => Register::vr14_16_7,
        15 => Register::vr15_16_7,
        16 => Register::vr16_16_7,
        17 => Register::vr17_16_7,
        18 => Register::vr18_16_7,
        19 => Register::vr19_16_7,
        20 => Register::vr20_16_7,
        21 => Register::vr21_16_7,
        22 => Register::vr22_16_7,
        23 => Register::vr23_16_7,
        24 => Register::vr24_16_7,
        25 => Register::vr25_16_7,
        26 => Register::vr26_16_7,
        27 => Register::vr27_16_7,
        28 => Register::vr28_16_7,
        29 => Register::vr29_16_7,
        30 => Register::vr30_16_7,
        31 => Register::vr31_16_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_145_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_145_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_146_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_0,
        1 => Register::vr1_8_0,
        2 => Register::vr2_8_0,
        3 => Register::vr3_8_0,
        4 => Register::vr4_8_0,
        5 => Register::vr5_8_0,
        6 => Register::vr6_8_0,
        7 => Register::vr7_8_0,
        8 => Register::vr8_8_0,
        9 => Register::vr9_8_0,
        10 => Register::vr10_8_0,
        11 => Register::vr11_8_0,
        12 => Register::vr12_8_0,
        13 => Register::vr13_8_0,
        14 => Register::vr14_8_0,
        15 => Register::vr15_8_0,
        16 => Register::vr16_8_0,
        17 => Register::vr17_8_0,
        18 => Register::vr18_8_0,
        19 => Register::vr19_8_0,
        20 => Register::vr20_8_0,
        21 => Register::vr21_8_0,
        22 => Register::vr22_8_0,
        23 => Register::vr23_8_0,
        24 => Register::vr24_8_0,
        25 => Register::vr25_8_0,
        26 => Register::vr26_8_0,
        27 => Register::vr27_8_0,
        28 => Register::vr28_8_0,
        29 => Register::vr29_8_0,
        30 => Register::vr30_8_0,
        31 => Register::vr31_8_0,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_146_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_146_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_147_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_1,
        1 => Register::vr1_8_1,
        2 => Register::vr2_8_1,
        3 => Register::vr3_8_1,
        4 => Register::vr4_8_1,
        5 => Register::vr5_8_1,
        6 => Register::vr6_8_1,
        7 => Register::vr7_8_1,
        8 => Register::vr8_8_1,
        9 => Register::vr9_8_1,
        10 => Register::vr10_8_1,
        11 => Register::vr11_8_1,
        12 => Register::vr12_8_1,
        13 => Register::vr13_8_1,
        14 => Register::vr14_8_1,
        15 => Register::vr15_8_1,
        16 => Register::vr16_8_1,
        17 => Register::vr17_8_1,
        18 => Register::vr18_8_1,
        19 => Register::vr19_8_1,
        20 => Register::vr20_8_1,
        21 => Register::vr21_8_1,
        22 => Register::vr22_8_1,
        23 => Register::vr23_8_1,
        24 => Register::vr24_8_1,
        25 => Register::vr25_8_1,
        26 => Register::vr26_8_1,
        27 => Register::vr27_8_1,
        28 => Register::vr28_8_1,
        29 => Register::vr29_8_1,
        30 => Register::vr30_8_1,
        31 => Register::vr31_8_1,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_147_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_147_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_148_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_2,
        1 => Register::vr1_8_2,
        2 => Register::vr2_8_2,
        3 => Register::vr3_8_2,
        4 => Register::vr4_8_2,
        5 => Register::vr5_8_2,
        6 => Register::vr6_8_2,
        7 => Register::vr7_8_2,
        8 => Register::vr8_8_2,
        9 => Register::vr9_8_2,
        10 => Register::vr10_8_2,
        11 => Register::vr11_8_2,
        12 => Register::vr12_8_2,
        13 => Register::vr13_8_2,
        14 => Register::vr14_8_2,
        15 => Register::vr15_8_2,
        16 => Register::vr16_8_2,
        17 => Register::vr17_8_2,
        18 => Register::vr18_8_2,
        19 => Register::vr19_8_2,
        20 => Register::vr20_8_2,
        21 => Register::vr21_8_2,
        22 => Register::vr22_8_2,
        23 => Register::vr23_8_2,
        24 => Register::vr24_8_2,
        25 => Register::vr25_8_2,
        26 => Register::vr26_8_2,
        27 => Register::vr27_8_2,
        28 => Register::vr28_8_2,
        29 => Register::vr29_8_2,
        30 => Register::vr30_8_2,
        31 => Register::vr31_8_2,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_148_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_148_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_149_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_3,
        1 => Register::vr1_8_3,
        2 => Register::vr2_8_3,
        3 => Register::vr3_8_3,
        4 => Register::vr4_8_3,
        5 => Register::vr5_8_3,
        6 => Register::vr6_8_3,
        7 => Register::vr7_8_3,
        8 => Register::vr8_8_3,
        9 => Register::vr9_8_3,
        10 => Register::vr10_8_3,
        11 => Register::vr11_8_3,
        12 => Register::vr12_8_3,
        13 => Register::vr13_8_3,
        14 => Register::vr14_8_3,
        15 => Register::vr15_8_3,
        16 => Register::vr16_8_3,
        17 => Register::vr17_8_3,
        18 => Register::vr18_8_3,
        19 => Register::vr19_8_3,
        20 => Register::vr20_8_3,
        21 => Register::vr21_8_3,
        22 => Register::vr22_8_3,
        23 => Register::vr23_8_3,
        24 => Register::vr24_8_3,
        25 => Register::vr25_8_3,
        26 => Register::vr26_8_3,
        27 => Register::vr27_8_3,
        28 => Register::vr28_8_3,
        29 => Register::vr29_8_3,
        30 => Register::vr30_8_3,
        31 => Register::vr31_8_3,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_149_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_149_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_150_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_4,
        1 => Register::vr1_8_4,
        2 => Register::vr2_8_4,
        3 => Register::vr3_8_4,
        4 => Register::vr4_8_4,
        5 => Register::vr5_8_4,
        6 => Register::vr6_8_4,
        7 => Register::vr7_8_4,
        8 => Register::vr8_8_4,
        9 => Register::vr9_8_4,
        10 => Register::vr10_8_4,
        11 => Register::vr11_8_4,
        12 => Register::vr12_8_4,
        13 => Register::vr13_8_4,
        14 => Register::vr14_8_4,
        15 => Register::vr15_8_4,
        16 => Register::vr16_8_4,
        17 => Register::vr17_8_4,
        18 => Register::vr18_8_4,
        19 => Register::vr19_8_4,
        20 => Register::vr20_8_4,
        21 => Register::vr21_8_4,
        22 => Register::vr22_8_4,
        23 => Register::vr23_8_4,
        24 => Register::vr24_8_4,
        25 => Register::vr25_8_4,
        26 => Register::vr26_8_4,
        27 => Register::vr27_8_4,
        28 => Register::vr28_8_4,
        29 => Register::vr29_8_4,
        30 => Register::vr30_8_4,
        31 => Register::vr31_8_4,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_150_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_150_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_151_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_5,
        1 => Register::vr1_8_5,
        2 => Register::vr2_8_5,
        3 => Register::vr3_8_5,
        4 => Register::vr4_8_5,
        5 => Register::vr5_8_5,
        6 => Register::vr6_8_5,
        7 => Register::vr7_8_5,
        8 => Register::vr8_8_5,
        9 => Register::vr9_8_5,
        10 => Register::vr10_8_5,
        11 => Register::vr11_8_5,
        12 => Register::vr12_8_5,
        13 => Register::vr13_8_5,
        14 => Register::vr14_8_5,
        15 => Register::vr15_8_5,
        16 => Register::vr16_8_5,
        17 => Register::vr17_8_5,
        18 => Register::vr18_8_5,
        19 => Register::vr19_8_5,
        20 => Register::vr20_8_5,
        21 => Register::vr21_8_5,
        22 => Register::vr22_8_5,
        23 => Register::vr23_8_5,
        24 => Register::vr24_8_5,
        25 => Register::vr25_8_5,
        26 => Register::vr26_8_5,
        27 => Register::vr27_8_5,
        28 => Register::vr28_8_5,
        29 => Register::vr29_8_5,
        30 => Register::vr30_8_5,
        31 => Register::vr31_8_5,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_151_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_151_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_152_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_6,
        1 => Register::vr1_8_6,
        2 => Register::vr2_8_6,
        3 => Register::vr3_8_6,
        4 => Register::vr4_8_6,
        5 => Register::vr5_8_6,
        6 => Register::vr6_8_6,
        7 => Register::vr7_8_6,
        8 => Register::vr8_8_6,
        9 => Register::vr9_8_6,
        10 => Register::vr10_8_6,
        11 => Register::vr11_8_6,
        12 => Register::vr12_8_6,
        13 => Register::vr13_8_6,
        14 => Register::vr14_8_6,
        15 => Register::vr15_8_6,
        16 => Register::vr16_8_6,
        17 => Register::vr17_8_6,
        18 => Register::vr18_8_6,
        19 => Register::vr19_8_6,
        20 => Register::vr20_8_6,
        21 => Register::vr21_8_6,
        22 => Register::vr22_8_6,
        23 => Register::vr23_8_6,
        24 => Register::vr24_8_6,
        25 => Register::vr25_8_6,
        26 => Register::vr26_8_6,
        27 => Register::vr27_8_6,
        28 => Register::vr28_8_6,
        29 => Register::vr29_8_6,
        30 => Register::vr30_8_6,
        31 => Register::vr31_8_6,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_152_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_152_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_153_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_7,
        1 => Register::vr1_8_7,
        2 => Register::vr2_8_7,
        3 => Register::vr3_8_7,
        4 => Register::vr4_8_7,
        5 => Register::vr5_8_7,
        6 => Register::vr6_8_7,
        7 => Register::vr7_8_7,
        8 => Register::vr8_8_7,
        9 => Register::vr9_8_7,
        10 => Register::vr10_8_7,
        11 => Register::vr11_8_7,
        12 => Register::vr12_8_7,
        13 => Register::vr13_8_7,
        14 => Register::vr14_8_7,
        15 => Register::vr15_8_7,
        16 => Register::vr16_8_7,
        17 => Register::vr17_8_7,
        18 => Register::vr18_8_7,
        19 => Register::vr19_8_7,
        20 => Register::vr20_8_7,
        21 => Register::vr21_8_7,
        22 => Register::vr22_8_7,
        23 => Register::vr23_8_7,
        24 => Register::vr24_8_7,
        25 => Register::vr25_8_7,
        26 => Register::vr26_8_7,
        27 => Register::vr27_8_7,
        28 => Register::vr28_8_7,
        29 => Register::vr29_8_7,
        30 => Register::vr30_8_7,
        31 => Register::vr31_8_7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_153_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_153_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_154_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_8,
        1 => Register::vr1_8_8,
        2 => Register::vr2_8_8,
        3 => Register::vr3_8_8,
        4 => Register::vr4_8_8,
        5 => Register::vr5_8_8,
        6 => Register::vr6_8_8,
        7 => Register::vr7_8_8,
        8 => Register::vr8_8_8,
        9 => Register::vr9_8_8,
        10 => Register::vr10_8_8,
        11 => Register::vr11_8_8,
        12 => Register::vr12_8_8,
        13 => Register::vr13_8_8,
        14 => Register::vr14_8_8,
        15 => Register::vr15_8_8,
        16 => Register::vr16_8_8,
        17 => Register::vr17_8_8,
        18 => Register::vr18_8_8,
        19 => Register::vr19_8_8,
        20 => Register::vr20_8_8,
        21 => Register::vr21_8_8,
        22 => Register::vr22_8_8,
        23 => Register::vr23_8_8,
        24 => Register::vr24_8_8,
        25 => Register::vr25_8_8,
        26 => Register::vr26_8_8,
        27 => Register::vr27_8_8,
        28 => Register::vr28_8_8,
        29 => Register::vr29_8_8,
        30 => Register::vr30_8_8,
        31 => Register::vr31_8_8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_154_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_154_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_155_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_9,
        1 => Register::vr1_8_9,
        2 => Register::vr2_8_9,
        3 => Register::vr3_8_9,
        4 => Register::vr4_8_9,
        5 => Register::vr5_8_9,
        6 => Register::vr6_8_9,
        7 => Register::vr7_8_9,
        8 => Register::vr8_8_9,
        9 => Register::vr9_8_9,
        10 => Register::vr10_8_9,
        11 => Register::vr11_8_9,
        12 => Register::vr12_8_9,
        13 => Register::vr13_8_9,
        14 => Register::vr14_8_9,
        15 => Register::vr15_8_9,
        16 => Register::vr16_8_9,
        17 => Register::vr17_8_9,
        18 => Register::vr18_8_9,
        19 => Register::vr19_8_9,
        20 => Register::vr20_8_9,
        21 => Register::vr21_8_9,
        22 => Register::vr22_8_9,
        23 => Register::vr23_8_9,
        24 => Register::vr24_8_9,
        25 => Register::vr25_8_9,
        26 => Register::vr26_8_9,
        27 => Register::vr27_8_9,
        28 => Register::vr28_8_9,
        29 => Register::vr29_8_9,
        30 => Register::vr30_8_9,
        31 => Register::vr31_8_9,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_155_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_155_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_156_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_10,
        1 => Register::vr1_8_10,
        2 => Register::vr2_8_10,
        3 => Register::vr3_8_10,
        4 => Register::vr4_8_10,
        5 => Register::vr5_8_10,
        6 => Register::vr6_8_10,
        7 => Register::vr7_8_10,
        8 => Register::vr8_8_10,
        9 => Register::vr9_8_10,
        10 => Register::vr10_8_10,
        11 => Register::vr11_8_10,
        12 => Register::vr12_8_10,
        13 => Register::vr13_8_10,
        14 => Register::vr14_8_10,
        15 => Register::vr15_8_10,
        16 => Register::vr16_8_10,
        17 => Register::vr17_8_10,
        18 => Register::vr18_8_10,
        19 => Register::vr19_8_10,
        20 => Register::vr20_8_10,
        21 => Register::vr21_8_10,
        22 => Register::vr22_8_10,
        23 => Register::vr23_8_10,
        24 => Register::vr24_8_10,
        25 => Register::vr25_8_10,
        26 => Register::vr26_8_10,
        27 => Register::vr27_8_10,
        28 => Register::vr28_8_10,
        29 => Register::vr29_8_10,
        30 => Register::vr30_8_10,
        31 => Register::vr31_8_10,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_156_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_156_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_157_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_11,
        1 => Register::vr1_8_11,
        2 => Register::vr2_8_11,
        3 => Register::vr3_8_11,
        4 => Register::vr4_8_11,
        5 => Register::vr5_8_11,
        6 => Register::vr6_8_11,
        7 => Register::vr7_8_11,
        8 => Register::vr8_8_11,
        9 => Register::vr9_8_11,
        10 => Register::vr10_8_11,
        11 => Register::vr11_8_11,
        12 => Register::vr12_8_11,
        13 => Register::vr13_8_11,
        14 => Register::vr14_8_11,
        15 => Register::vr15_8_11,
        16 => Register::vr16_8_11,
        17 => Register::vr17_8_11,
        18 => Register::vr18_8_11,
        19 => Register::vr19_8_11,
        20 => Register::vr20_8_11,
        21 => Register::vr21_8_11,
        22 => Register::vr22_8_11,
        23 => Register::vr23_8_11,
        24 => Register::vr24_8_11,
        25 => Register::vr25_8_11,
        26 => Register::vr26_8_11,
        27 => Register::vr27_8_11,
        28 => Register::vr28_8_11,
        29 => Register::vr29_8_11,
        30 => Register::vr30_8_11,
        31 => Register::vr31_8_11,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_157_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_157_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_158_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_12,
        1 => Register::vr1_8_12,
        2 => Register::vr2_8_12,
        3 => Register::vr3_8_12,
        4 => Register::vr4_8_12,
        5 => Register::vr5_8_12,
        6 => Register::vr6_8_12,
        7 => Register::vr7_8_12,
        8 => Register::vr8_8_12,
        9 => Register::vr9_8_12,
        10 => Register::vr10_8_12,
        11 => Register::vr11_8_12,
        12 => Register::vr12_8_12,
        13 => Register::vr13_8_12,
        14 => Register::vr14_8_12,
        15 => Register::vr15_8_12,
        16 => Register::vr16_8_12,
        17 => Register::vr17_8_12,
        18 => Register::vr18_8_12,
        19 => Register::vr19_8_12,
        20 => Register::vr20_8_12,
        21 => Register::vr21_8_12,
        22 => Register::vr22_8_12,
        23 => Register::vr23_8_12,
        24 => Register::vr24_8_12,
        25 => Register::vr25_8_12,
        26 => Register::vr26_8_12,
        27 => Register::vr27_8_12,
        28 => Register::vr28_8_12,
        29 => Register::vr29_8_12,
        30 => Register::vr30_8_12,
        31 => Register::vr31_8_12,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_158_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_158_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_159_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_13,
        1 => Register::vr1_8_13,
        2 => Register::vr2_8_13,
        3 => Register::vr3_8_13,
        4 => Register::vr4_8_13,
        5 => Register::vr5_8_13,
        6 => Register::vr6_8_13,
        7 => Register::vr7_8_13,
        8 => Register::vr8_8_13,
        9 => Register::vr9_8_13,
        10 => Register::vr10_8_13,
        11 => Register::vr11_8_13,
        12 => Register::vr12_8_13,
        13 => Register::vr13_8_13,
        14 => Register::vr14_8_13,
        15 => Register::vr15_8_13,
        16 => Register::vr16_8_13,
        17 => Register::vr17_8_13,
        18 => Register::vr18_8_13,
        19 => Register::vr19_8_13,
        20 => Register::vr20_8_13,
        21 => Register::vr21_8_13,
        22 => Register::vr22_8_13,
        23 => Register::vr23_8_13,
        24 => Register::vr24_8_13,
        25 => Register::vr25_8_13,
        26 => Register::vr26_8_13,
        27 => Register::vr27_8_13,
        28 => Register::vr28_8_13,
        29 => Register::vr29_8_13,
        30 => Register::vr30_8_13,
        31 => Register::vr31_8_13,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_159_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_159_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_160_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_14,
        1 => Register::vr1_8_14,
        2 => Register::vr2_8_14,
        3 => Register::vr3_8_14,
        4 => Register::vr4_8_14,
        5 => Register::vr5_8_14,
        6 => Register::vr6_8_14,
        7 => Register::vr7_8_14,
        8 => Register::vr8_8_14,
        9 => Register::vr9_8_14,
        10 => Register::vr10_8_14,
        11 => Register::vr11_8_14,
        12 => Register::vr12_8_14,
        13 => Register::vr13_8_14,
        14 => Register::vr14_8_14,
        15 => Register::vr15_8_14,
        16 => Register::vr16_8_14,
        17 => Register::vr17_8_14,
        18 => Register::vr18_8_14,
        19 => Register::vr19_8_14,
        20 => Register::vr20_8_14,
        21 => Register::vr21_8_14,
        22 => Register::vr22_8_14,
        23 => Register::vr23_8_14,
        24 => Register::vr24_8_14,
        25 => Register::vr25_8_14,
        26 => Register::vr26_8_14,
        27 => Register::vr27_8_14,
        28 => Register::vr28_8_14,
        29 => Register::vr29_8_14,
        30 => Register::vr30_8_14,
        31 => Register::vr31_8_14,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_160_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_160_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_161_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::vr0_8_15,
        1 => Register::vr1_8_15,
        2 => Register::vr2_8_15,
        3 => Register::vr3_8_15,
        4 => Register::vr4_8_15,
        5 => Register::vr5_8_15,
        6 => Register::vr6_8_15,
        7 => Register::vr7_8_15,
        8 => Register::vr8_8_15,
        9 => Register::vr9_8_15,
        10 => Register::vr10_8_15,
        11 => Register::vr11_8_15,
        12 => Register::vr12_8_15,
        13 => Register::vr13_8_15,
        14 => Register::vr14_8_15,
        15 => Register::vr15_8_15,
        16 => Register::vr16_8_15,
        17 => Register::vr17_8_15,
        18 => Register::vr18_8_15,
        19 => Register::vr19_8_15,
        20 => Register::vr20_8_15,
        21 => Register::vr21_8_15,
        22 => Register::vr22_8_15,
        23 => Register::vr23_8_15,
        24 => Register::vr24_8_15,
        25 => Register::vr25_8_15,
        26 => Register::vr26_8_15,
        27 => Register::vr27_8_15,
        28 => Register::vr28_8_15,
        29 => Register::vr29_8_15,
        30 => Register::vr30_8_15,
        31 => Register::vr31_8_15,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_161_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_161_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_162_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => <DisplayElement>::Literal("v0"),
        1 => <DisplayElement>::Literal("v1"),
        2 => <DisplayElement>::Literal("v2"),
        3 => <DisplayElement>::Literal("v3"),
        4 => <DisplayElement>::Literal("v4"),
        5 => <DisplayElement>::Literal("v5"),
        6 => <DisplayElement>::Literal("v6"),
        7 => <DisplayElement>::Literal("v7"),
        8 => <DisplayElement>::Literal("v8"),
        9 => <DisplayElement>::Literal("v9"),
        10 => <DisplayElement>::Literal("v10"),
        11 => <DisplayElement>::Literal("v11"),
        12 => <DisplayElement>::Literal("v12"),
        13 => <DisplayElement>::Literal("v13"),
        14 => <DisplayElement>::Literal("v14"),
        15 => <DisplayElement>::Literal("v15"),
        16 => <DisplayElement>::Literal("v16"),
        17 => <DisplayElement>::Literal("v17"),
        18 => <DisplayElement>::Literal("v18"),
        19 => <DisplayElement>::Literal("v19"),
        20 => <DisplayElement>::Literal("v20"),
        21 => <DisplayElement>::Literal("v21"),
        22 => <DisplayElement>::Literal("v22"),
        23 => <DisplayElement>::Literal("v23"),
        24 => <DisplayElement>::Literal("v24"),
        25 => <DisplayElement>::Literal("v25"),
        26 => <DisplayElement>::Literal("v26"),
        27 => <DisplayElement>::Literal("v27"),
        28 => <DisplayElement>::Literal("v28"),
        29 => <DisplayElement>::Literal("v29"),
        30 => <DisplayElement>::Literal("v30"),
        31 => <DisplayElement>::Literal("v31"),
        _ => unreachable!("Invalid Attach Value"),
    }
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, bool, u64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(true, false, value) => {
                write!(f, "0x{:x}", value)
            }
            Self::Number(true, true, value) => {
                write!(f, "-0x{:x}", value)
            }
            Self::Number(false, false, value) => value.fmt(f),
            Self::Number(false, true, value) => {
                write!(f, "-{:x}", value)
            }
        }
    }
}
#[doc = "Create token_fields: CX SX3 TX3"]
fn token_72(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 1) as u8)
}
#[doc = "Create token_fields: OP5_VLE"]
fn token_103(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 11) & 31) as u8)
}
#[doc = "Create token_fields: A A_BITS A_BITSS BI_BITS BITS_16_20 D1 DX fA BU_UIMM BU_SIMM RA UI_11_s8 vrAR vrAD vrA_64_0 vrA_64_1 vrA_32_0 vrA_32_1 vrA_32_2 vrA_32_3 vrA_16_0 vrA_16_1 vrA_16_2 vrA_16_3 vrA_16_4 vrA_16_5 vrA_16_6 vrA_16_7 vrA_8_0 vrA_8_1 vrA_8_2 vrA_8_3 vrA_8_4 vrA_8_5 vrA_8_6 vrA_8_7 vrA_8_8 vrA_8_9 vrA_8_10 vrA_8_11 vrA_8_12 vrA_8_13 vrA_8_14 vrA_8_15 Avsa Avsb IMM_16_20_VLE"]
fn token_1(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 31) as u8)
}
#[doc = "Create token_fields: CRM7"]
fn token_68(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 1) as u8)
}
#[doc = "Create token_fields: XORR_VLE BI16_VLE BITS_8_9"]
fn token_110(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 3) as u8)
}
#[doc = "Create token_fields: BF2 BITS_23_25 CR_D crfD CRFD"]
fn token_9(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 7) as u8)
}
#[doc = "Create token_fields: BIT_16 CRM3 MSR_L R16"]
fn token_19(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 1) as u8)
}
#[doc = "Create token_fields: BIT_L BIT_R FM3 L2"]
fn token_15(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 1) as u8)
}
#[doc = "Create token_fields: BITS_1_10 XOP_1_10"]
fn token_29(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 1023) as u16)
}
#[doc = "Create token_fields: BIT_0 D2 EX LK Rc R0 SX TX"]
fn token_16(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 1) as u8)
}
#[doc = "Create token_fields: BITS_21_28"]
fn token_52(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 255) as u8)
}
#[doc = "Create token_fields: BITS_3_7"]
fn token_60(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 31) as u8)
}
#[doc = "Create token_fields: BITS_21_25 BO BO_BITS CRBD CT D Dp DUI fD fS fT MO RS RT S T TOA TH TMP_6_10 TO vrDR vrDD vrD_64_0 vrD_64_1 vrD_32_0 vrD_32_1 vrD_32_2 vrD_32_3 vrD_16_0 vrD_16_1 vrD_16_2 vrD_16_3 vrD_16_4 vrD_16_5 vrD_16_6 vrD_16_7 vrD_8_0 vrD_8_1 vrD_8_2 vrD_8_3 vrD_8_4 vrD_8_5 vrD_8_6 vrD_8_7 vrD_8_8 vrD_8_9 vrD_8_10 vrD_8_11 vrD_8_12 vrD_8_13 vrD_8_14 vrD_8_15 vrSR vrSD vrS_64_0 vrS_64_1 vrS_32_0 vrS_32_1 vrS_32_2 vrS_32_3 vrS_16_0 vrS_16_1 vrS_16_2 vrS_16_3 vrS_16_4 vrS_16_5 vrS_16_6 vrS_16_7 vrS_8_0 vrS_8_1 vrS_8_2 vrS_8_3 vrS_8_4 vrS_8_5 vrS_8_6 vrS_8_7 vrS_8_8 vrS_8_9 vrS_8_10 vrS_8_11 vrS_8_12 vrS_8_13 vrS_8_14 vrS_8_15 Svsa Svsb Svsbx Tvsa Tvsb Tvsbx IMM_21_25_VLE SIMM_21_25_VLE"]
fn token_51(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 31) as u8)
}
#[doc = "Create token_fields: BO_2 FM1"]
fn token_64(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 1) as u8)
}
#[doc = "Create token_fields: BITS_2_4 XOP_2_4"]
fn token_58(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 7) as u8)
}
#[doc = "Create token_fields: ME XOP_1_5"]
fn token_79(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 31) as u8)
}
#[doc = "Create token_fields: CRM0 FM5"]
fn token_65(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 19) & 1) as u8)
}
#[doc = "Create token_fields: BITS_0_3"]
fn token_28(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 15) as u8)
}
#[doc = "Create token_fields: UIMT"]
fn token_87(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 63) as u8)
}
#[doc = "Create token_fields: BITS_11_22"]
fn token_32(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 4095) as u16)
}
#[doc = "Create token_fields: OP"]
fn token_80(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 26) & 63) as u8)
}
#[doc = "Create token_fields: BITS_16_22 DCMX"]
fn token_42(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 127) as u8)
}
#[doc = "Create token_fields: ARY_VLE RY_VLE RZ_VLE"]
fn token_113(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 15) as u8)
}
#[doc = "Create token_fields: BIT8_VLE LK8_VLE"]
fn token_116(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 1) as u8)
}
#[doc = "Create token_fields: DCM DGM SH16"]
fn token_74(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 63) as u8)
}
#[doc = "Create token_fields: BD15_VLE"]
fn token_98(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 32767) as u16)
}
#[doc = "Create token_fields: BH_RBE BITS_11_20 DCRN DUIS SPRVAL TBR"]
fn token_11(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 1023) as u16)
}
#[doc = "Create token_fields: OP6_VLE"]
fn token_104(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 63) as u8)
}
#[doc = "Create token_fields: D0"]
fn token_73(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 1023) as u16)
}
#[doc = "Create token_fields: SIMM UI_16_s16 UIMM"]
fn token_84(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 65535) as u16)
}
#[doc = "Create token_fields: CRM6"]
fn token_67(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 1) as u8)
}
#[doc = "Create token_fields: BF BITS_17_24 FM"]
fn token_6(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 255) as u8)
}
#[doc = "Create token_fields: BFA2 BI_CR BITS_18_20 CR_A CRFS"]
fn token_8(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 7) as u8)
}
#[doc = "Create token_fields: DM SHW SCL_VLE"]
fn token_75(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 3) as u8)
}
#[doc = "Create token_fields: BIT_A BIT_25 BO_0"]
fn token_14(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 25) & 1) as u8)
}
#[doc = "Create token_fields: BITS_19_20 SP"]
fn token_47(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 19) & 3) as u8)
}
#[doc = "Create token_fields: BFA BITS_0_2"]
fn token_7(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 7) as u8)
}
#[doc = "Create token_fields: LEV"]
fn token_77(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 127) as u8)
}
#[doc = "Create token_fields: BITS_22_24"]
fn token_53(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 22) & 7) as u8)
}
#[doc = "Create token_fields: OP16_VLE"]
fn token_106(tokens: &[u8]) -> u16 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 65535) as u16)
}
#[doc = "Create token_fields: BITS_16_19 SR UIMB"]
fn token_41(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 15) as u8)
}
#[doc = "Create token_fields: UIMM8"]
fn token_86(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 255) as u8)
}
#[doc = "Create token_fields: BITS_24_25"]
fn token_59(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 24) & 3) as u8)
}
#[doc = "Create token_fields: BD DS DSs SIMM_DS"]
fn token_5(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 16383) as u16)
}
#[doc = "Create token_fields: BIT_9 O PS"]
fn token_24(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 1) as u8)
}
#[doc = "Create token_fields: BITS_16_25"]
fn token_43(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 1023) as u16)
}
#[doc = "Create token_fields: BITS_16_18 UIMH"]
fn token_40(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 7) as u8)
}
#[doc = "Create token_fields: OIM5_VLE UI5_VLE"]
fn token_107(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 31) as u8)
}
#[doc = "Create token_fields: B B_BITS BITS_11_15 fB FNC IMM EVUIMM EVUIMM_8 EVUIMM_4 EVUIMM_2 NB RB SHL S5IMM UI UI_16_s8 vrBR vrBD vrB_64_0 vrB_64_1 vrB_32_0 vrB_32_1 vrB_32_2 vrB_32_3 vrB_16_0 vrB_16_1 vrB_16_2 vrB_16_3 vrB_16_4 vrB_16_5 vrB_16_6 vrB_16_7 vrB_8_0 vrB_8_1 vrB_8_2 vrB_8_3 vrB_8_4 vrB_8_5 vrB_8_6 vrB_8_7 vrB_8_8 vrB_8_9 vrB_8_10 vrB_8_11 vrB_8_12 vrB_8_13 vrB_8_14 vrB_8_15 Bvsa Bvsb LEV_VLE XOP_11_VLE"]
fn token_4(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 31) as u8)
}
#[doc = "Create token_fields: XOP_1_8"]
fn token_93(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 255) as u8)
}
#[doc = "Create token_fields: LK0_VLE"]
fn token_118(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 1) as u8)
}
#[doc = "Create token_fields: BIT_20 BITS_20_20 FM4"]
fn token_22(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 1) as u8)
}
#[doc = "Create token_fields: CR_X_CC"]
fn token_70(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 3) as u8)
}
#[doc = "Create token_fields: AX DM2"]
fn token_3(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 1) as u8)
}
#[doc = "Create token_fields: BIT_17 CRM2 FM7"]
fn token_20(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 1) as u8)
}
#[doc = "Create token_fields: BITS_21_23"]
fn token_49(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 7) as u8)
}
#[doc = "Create token_fields: OIM7_VLE UI7_VLE"]
fn token_108(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 127) as u8)
}
#[doc = "Create token_fields: XOP_0_5"]
fn token_89(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 63) as u8)
}
#[doc = "Create token_fields: BITS_6_10 C CRBR fC MBL vrCR vrCD vrC_64_0 vrC_64_1 vrC_32_0 vrC_32_1 vrC_32_2 vrC_32_3 vrC_16_0 vrC_16_1 vrC_16_2 vrC_16_3 vrC_16_4 vrC_16_5 vrC_16_6 vrC_16_7 vrC_8_0 vrC_8_1 vrC_8_2 vrC_8_3 vrC_8_4 vrC_8_5 vrC_8_6 vrC_8_7 vrC_8_8 vrC_8_9 vrC_8_10 vrC_8_11 vrC_8_12 vrC_8_13 vrC_8_14 vrC_8_15 Cvsa Cvsb"]
fn token_62(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 31) as u8)
}
#[doc = "Create token_fields: OP15_VLE"]
fn token_105(tokens: &[u8]) -> u16 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 1) & 32767) as u16)
}
#[doc = "Create token_fields: BI_CC CR_A_CC L16 UIM UIMW BI_CC_VLE"]
fn token_13(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 3) as u8)
}
#[doc = "Create token_fields: BITS_12_25"]
fn token_37(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 16383) as u16)
}
#[doc = "Create token_fields: OP4_VLE"]
fn token_102(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 15) as u8)
}
#[doc = "Create token_fields: BO16_VLE"]
fn token_114(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 1) as u8)
}
#[doc = "Create token_fields: S8IMM IMM8"]
fn token_83(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: BIT_15 CRM4 SIMM_SIGN ST"]
fn token_18(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 15) & 1) as u8)
}
#[doc = "Create token_fields: XOP_0_9"]
fn token_91(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 1023) as u16)
}
#[doc = "Create token_fields: BITS_11_17"]
fn token_31(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 127) as u8)
}
#[doc = "Create token_fields: BIT_22 BO_3 FM2"]
fn token_23(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 22) & 1) as u8)
}
#[doc = "Create token_fields: BITS_23_24"]
fn token_57(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 23) & 3) as u8)
}
#[doc = "Create token_fields: BO_VLE"]
fn token_100(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 20) & 3) as u8)
}
#[doc = "Create token_fields: BITS_11_13"]
fn token_30(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 7) as u8)
}
#[doc = "Create token_fields: BIT_18 CRM1 FM6"]
fn token_21(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 1) as u8)
}
#[doc = "Create token_fields: SD4_VLE"]
fn token_109(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 15) as u8)
}
#[doc = "Create token_fields: BITS_0_17"]
fn token_27(tokens: &[u8]) -> u32 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 262143) as u32)
}
#[doc = "Create token_fields: RMC"]
fn token_81(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 9) & 3) as u8)
}
#[doc = "Create token_fields: BIT_6 DC6"]
fn token_25(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 1) as u8)
}
#[doc = "Create token_fields: BITS_17_20"]
fn token_44(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 17) & 15) as u8)
}
#[doc = "Create token_fields: BITS_21_24 XOP_7_10"]
fn token_50(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 7) & 15) as u8)
}
#[doc = "Create token_fields: XOP_1_4"]
fn token_92(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 15) as u8)
}
#[doc = "Create token_fields: BITS_12_19 CRM"]
fn token_36(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 255) as u8)
}
#[doc = "Create token_fields: XOR_VLE"]
fn token_111(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 63) as u8)
}
#[doc = "Create token_fields: CT2"]
fn token_71(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 15) as u8)
}
#[doc = "Create token_fields: BITS_14_15"]
fn token_39(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 14) & 3) as u8)
}
#[doc = "Create token_fields: BITS_12_15 BITS_16_17 XOP_12_VLE"]
fn token_35(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 12) & 15) as u8)
}
#[doc = "Create token_fields: BITS_11_24"]
fn token_33(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 16383) as u16)
}
#[doc = "Create token_fields: BITS_2_25 LI"]
fn token_56(tokens: &[u8]) -> u32 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 16777215) as u32)
}
#[doc = "Create token_fields: CRM5"]
fn token_66(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 14) & 1) as u8)
}
#[doc = "Create token_fields: XOP_2_10"]
fn token_94(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 2) & 511) as u16)
}
#[doc = "Create token_fields: XOP_3_9"]
fn token_97(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 127) as u8)
}
#[doc = "Create token_fields: XOP_8_VLE"]
fn token_101(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 255) as u8)
}
#[doc = "Create token_fields: XOP_3_5"]
fn token_95(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 7) as u8)
}
#[doc = "Create token_fields: XOP_3_10"]
fn token_96(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 3) & 255) as u8)
}
#[doc = "Create token_fields: BITS_4_5"]
fn token_61(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 3) as u8)
}
#[doc = "Create token_fields: ARX_VLE RX_VLE"]
fn token_112(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 15) as u8)
}
#[doc = "Create token_fields: BIT_10 OE Rc2"]
fn token_17(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 10) & 1) as u8)
}
#[doc = "Create token_fields: BD24_VLE"]
fn token_99(tokens: &[u8]) -> u32 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 16777215) as u32)
}
#[doc = "Create token_fields: BITS_22_26"]
fn token_55(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 22) & 31) as u8)
}
#[doc = "Create token_fields: BITS_1_9 XOP_1_9"]
fn token_46(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 511) as u16)
}
#[doc = "Create token_fields: AA BIT_1 BX SHH"]
fn token_2(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 1) & 1) as u8)
}
#[doc = "Create token_fields: MBH"]
fn token_78(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 5) & 1) as u8)
}
#[doc = "Create token_fields: BITS_0_1"]
fn token_26(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 3) as u8)
}
#[doc = "Create token_fields: BITS_13_15 CR_B"]
fn token_38(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 13) & 7) as u8)
}
#[doc = "Create token_fields: BO_1 FM0"]
fn token_63(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 24) & 1) as u8)
}
#[doc = "Create token_fields: BITS_22_25 COND_BRANCH_CTRL XOP_VLE"]
fn token_54(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 22) & 15) as u8)
}
#[doc = "Create token_fields: BITS_18_19 BI_CR_VLE"]
fn token_45(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 18) & 3) as u8)
}
#[doc = "Create token_fields: DQ DQs"]
fn token_76(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 4) & 4095) as u16)
}
#[doc = "Create token_fields: BH BH_BITS CR_B_CC"]
fn token_10(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 3) as u8)
}
#[doc = "Create token_fields: XOP_0_8"]
fn token_90(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 511) as u16)
}
#[doc = "Create token_fields: BD8_VLE"]
fn token_117(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: BITS_11_25"]
fn token_34(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 32767) as u16)
}
#[doc = "Create token_fields: BITS_21_22 CR_D_CC L STRM WC BF_VLE"]
fn token_48(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 21) & 3) as u8)
}
#[doc = "Create token_fields: CR_X"]
fn token_69(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 8) & 7) as u8)
}
#[doc = "Create token_fields: BH_RET BIT_11 SBE"]
fn token_12(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 1) as u8)
}
#[doc = "Create token_fields: SHB"]
fn token_82(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 6) & 15) as u8)
}
#[doc = "Create token_fields: SIX IMM_11_15_VLE SIMM_11_14_VLE"]
fn token_85(tokens: &[u8]) -> u8 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 11) & 15) as u8)
}
#[doc = "Create token_fields: XOP_0_10 IMM_0_10_VLE"]
fn token_88(tokens: &[u8]) -> u16 {
    (((u32::from_le_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 2047) as u16)
}
#[doc = "Create token_fields: BIT9_VLE"]
fn token_115(tokens: &[u8]) -> u8 {
    (((u16::from_le_bytes(tokens[0..2].try_into().unwrap()) >> 9) & 1) as u8)
}
#[derive(Clone, Copy, Default)]
pub struct ContextMemory(pub u16);
impl ContextMemory {
    pub fn read_linkreg(&self) -> u8 {
        (((self.0.reverse_bits() >> 14) & 3) as u8)
    }
    pub fn write_linkreg(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(3 << 14)) | ((value as u16 & 3) << 14)).reverse_bits();
    }
    pub fn read_vle(&self) -> u8 {
        (((self.0.reverse_bits() >> 13) & 1) as u8)
    }
    pub fn write_vle(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 13)) | ((value as u16 & 1) << 13)).reverse_bits();
    }
    pub fn read_lsmul(&self) -> u8 {
        (((self.0.reverse_bits() >> 8) & 31) as u8)
    }
    pub fn write_lsmul(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(31 << 8)) | ((value as u16 & 31) << 8)).reverse_bits();
    }
    pub fn read_regp(&self) -> u8 {
        (((self.0.reverse_bits() >> 3) & 31) as u8)
    }
    pub fn write_regp(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(31 << 3)) | ((value as u16 & 31) << 3)).reverse_bits();
    }
    pub fn read_regpset(&self) -> u8 {
        (((self.0.reverse_bits() >> 3) & 31) as u8)
    }
    pub fn write_regpset(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(31 << 3)) | ((value as u16 & 31) << 3)).reverse_bits();
    }
}
#[derive(Clone)]
pub struct GlobalSet {
    default: ContextMemory,
    branches: std::collections::HashMap<AddrType, ContextMemory>,
}
impl GlobalSet {
    pub fn new(default: ContextMemory) -> Self {
        Self {
            default,
            branches: std::collections::HashMap::new(),
        }
    }
    pub fn set(&mut self, address: Option<AddrType>, set: impl FnOnce(&mut ContextMemory)) {
        let Some (address) = address else { return } ;
        let entry = self
            .branches
            .entry(address)
            .or_insert_with(|| self.default.clone());
        set(entry);
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:332:1, end:332:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar0 {
    REL_ABS: TableREL_ABS,
    addressLI: TableaddressLI,
}
impl bl_instructionVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressLI
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressLI = if let Some((len, table)) =
            TableaddressLI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REL_ABS, addressLI }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:466:1, end:466:2))"]
#[derive(Clone, Debug)]
struct bctr_instructionVar1 {}
impl bctr_instructionVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bctr"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3528:1, end:3528:2))"]
#[derive(Clone, Debug)]
struct rfid_instructionVar2 {}
impl rfid_instructionVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rfid"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3726:1, end:3726:2))"]
#[derive(Clone, Debug)]
struct slbia_instructionVar3 {}
impl slbia_instructionVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slbia"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3975:1, end:3975:2))"]
#[derive(Clone, Debug)]
struct std_instructionVar4 {
    dsPlusRaOrZeroAddress: TabledsPlusRaOrZeroAddress,
}
impl std_instructionVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("std"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::r2),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dsPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dsPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledsPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dsPlusRaOrZeroAddress,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4436:1, end:4436:2))"]
#[derive(Clone, Debug)]
struct tlbia_instructionVar5 {}
impl tlbia_instructionVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbia"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4466:1, end:4466:2))"]
#[derive(Clone, Debug)]
struct trap_instructionVar6 {}
impl trap_instructionVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trap"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:74:1, end:74:2))"]
#[derive(Clone, Debug)]
struct isync_instructionVar7 {}
impl isync_instructionVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("isync"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:159:1, end:159:2))"]
#[derive(Clone, Debug)]
struct rfci_instructionVar8 {}
impl rfci_instructionVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rfci"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:168:1, end:168:2))"]
#[derive(Clone, Debug)]
struct rfi_instructionVar9 {}
impl rfi_instructionVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rfi"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:161:1, end:161:2))"]
#[derive(Clone, Debug)]
struct dss_instructionVar10 {
    STRM: u8,
}
impl dss_instructionVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dss"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.STRM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let STRM = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STRM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:167:1, end:167:2))"]
#[derive(Clone, Debug)]
struct dssall_instructionVar11 {
    STRM: u8,
}
impl dssall_instructionVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dssall"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.STRM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let STRM = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STRM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:495:1, end:495:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar12 {
    CC: TableCC,
}
impl b_instructionVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ctr")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:500:1, end:500:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar13 {
    BH: u8,
    CC: TableCC,
}
impl b_instructionVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("ctr"),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_10(tokens_current) == 0 {
            return None;
        }
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:507:1, end:507:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar14 {
    CC: TableCC,
}
impl b_instructionVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ctrl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:514:1, end:514:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar15 {
    BH: u8,
    CC: TableCC,
}
impl b_instructionVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("ctrl"),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_10(tokens_current) == 0 {
            return None;
        }
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:585:1, end:585:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar16 {
    CC: TableCC,
}
impl b_instructionVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lr")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:591:1, end:591:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar17 {
    BH: u8,
    CC: TableCC,
}
impl b_instructionVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("lr"),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_10(tokens_current) == 0 {
            return None;
        }
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:599:1, end:599:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar18 {
    CC: TableCC,
}
impl b_instructionVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lrl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:607:1, end:607:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar19 {
    BH: u8,
    CC: TableCC,
}
impl b_instructionVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("lrl"),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_10(tokens_current) == 0 {
            return None;
        }
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:461:1, end:461:2))"]
#[derive(Clone, Debug)]
struct bctr_instructionVar20 {}
impl bctr_instructionVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bctr"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:481:1, end:481:2))"]
#[derive(Clone, Debug)]
struct bctrl_instructionVar21 {}
impl bctrl_instructionVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bctrl"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:523:1, end:523:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar22 {
    BI_CR: u8,
    CC: TableCC,
}
impl b_instructionVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("ctr"),
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.BI_CR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:537:1, end:537:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar23 {
    BI_CR: u8,
    CC: TableCC,
}
impl b_instructionVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("ctrl"),
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.BI_CR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:559:1, end:559:2))"]
#[derive(Clone, Debug)]
struct blr_instructionVar24 {}
impl blr_instructionVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blr"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:569:1, end:569:2))"]
#[derive(Clone, Debug)]
struct blrl_instructionVar25 {}
impl blrl_instructionVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("blrl"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:617:1, end:617:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar26 {
    BI_CR: u8,
    CC: TableCC,
}
impl b_instructionVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("lr"),
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.BI_CR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:625:1, end:625:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar27 {
    BI_CR: u8,
    BH: u8,
    CC: TableCC,
}
impl b_instructionVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("lr"),
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.BI_CR),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        if token_10(tokens_current) == 0 {
            return None;
        }
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BI_CR = token_8(tokens_current);
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR, BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:633:1, end:633:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar28 {
    BI_CR: u8,
    CC: TableCC,
}
impl b_instructionVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("lrl"),
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.BI_CR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:655:1, end:655:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar29 {
    CTR_DEC: TableCTR_DEC,
}
impl bd_instructionVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lr")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CTR_DEC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:669:1, end:669:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar30 {
    CTR_DEC: TableCTR_DEC,
}
impl bd_instructionVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lrl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CTR_DEC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:688:1, end:688:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar31 {
    CTR_DEC: TableCTR_DEC,
    CC_TF: TableCC_TF,
    CC_OP: TableCC_OP,
}
impl bd_instructionVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.CC_TF
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("lr"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CTR_DEC,
                CC_TF,
                CC_OP,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:706:1, end:706:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar32 {
    CTR_DEC: TableCTR_DEC,
    CC_TF: TableCC_TF,
    CC_OP: TableCC_OP,
}
impl bd_instructionVar32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.CC_TF
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("lrl"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CTR_DEC,
                CC_TF,
                CC_OP,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:153:1, end:153:2))"]
#[derive(Clone, Debug)]
struct mtspr_instructionVar33 {
    SPRVAL: u16,
    S: u8,
}
impl mtspr_instructionVar33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("mtspr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_9_display(self.SPRVAL),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let S = token_51(tokens_current);
        let SPRVAL = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPRVAL, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1095:1, end:1095:2))"]
#[derive(Clone, Debug)]
struct eieio_instructionVar34 {}
impl eieio_instructionVar34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eieio"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2956:1, end:2956:2))"]
#[derive(Clone, Debug)]
struct mcrf_instructionVar35 {
    CRFD: u8,
    CRFS: u8,
}
impl mcrf_instructionVar35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcrf"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.CRFD),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.CRFS),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRFD = token_9(tokens_current);
        let CRFS = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRFD, CRFS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2962:1, end:2962:2))"]
#[derive(Clone, Debug)]
struct mcrfs_instructionVar36 {
    CRFD: u8,
    CRFS: u8,
    FPSCR_CRFS: TableFPSCR_CRFS,
}
impl mcrfs_instructionVar36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcrfs"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.CRFD),
            <DisplayElement>::Literal(","),
            meaning_4_display(self.CRFS),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FPSCR_CRFS = if let Some((len, table)) =
            TableFPSCR_CRFS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRFD = token_9(tokens_current);
        let CRFS = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FPSCR_CRFS,
                CRFD,
                CRFS,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4442:1, end:4442:2))"]
#[derive(Clone, Debug)]
struct tlbsync_instructionVar37 {}
impl tlbsync_instructionVar37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbsync"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:147:1, end:147:2))"]
#[derive(Clone, Debug)]
struct mtspr_instructionVar38 {
    SPRVAL: u16,
    S: u8,
}
impl mtspr_instructionVar38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_next), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("mtspr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_9_display(self.SPRVAL),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(1i128 & 3).unwrap());
        let SPRVAL = token_11(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPRVAL, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2968:1, end:2968:2))"]
#[derive(Clone, Debug)]
struct mcrxr_instructionVar39 {
    CRFD: u8,
}
impl mcrxr_instructionVar39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mcrxr"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_4_display(self.CRFD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRFD = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRFD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3005:1, end:3005:2))"]
#[derive(Clone, Debug)]
struct mffs_instructionVar40 {
    fD: u8,
}
impl mffs_instructionVar40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mffs"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_6_display(self.fD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3013:1, end:3013:2))"]
#[derive(Clone, Debug)]
struct mffs__instructionVar41 {
    fD: u8,
}
impl mffs__instructionVar41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mffs."));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_6_display(self.fD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3071:1, end:3071:2))"]
#[derive(Clone, Debug)]
struct mtfsb0_instructionVar42 {
    CRBD: u8,
}
impl mtfsb0_instructionVar42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtfsb0"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_7_display(self.CRBD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRBD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRBD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3076:1, end:3076:2))"]
#[derive(Clone, Debug)]
struct mtfsb0__instructionVar43 {
    CRBD: u8,
}
impl mtfsb0__instructionVar43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtfsb0."));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_7_display(self.CRBD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRBD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRBD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3082:1, end:3082:2))"]
#[derive(Clone, Debug)]
struct mtfsb1_instructionVar44 {
    CRBD: u8,
}
impl mtfsb1_instructionVar44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtfsb1"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_7_display(self.CRBD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRBD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRBD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3087:1, end:3087:2))"]
#[derive(Clone, Debug)]
struct mtfsb1__instructionVar45 {
    CRBD: u8,
}
impl mtfsb1__instructionVar45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtfsb1."));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_7_display(self.CRBD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRBD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRBD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3168:1, end:3168:2))"]
#[derive(Clone, Debug)]
struct mtmsrd_instructionVar46 {
    S: u8,
}
impl mtmsrd_instructionVar46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtmsrd"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(",0"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3190:1, end:3190:2))"]
#[derive(Clone, Debug)]
struct mtmsrd_instructionVar47 {
    S: u8,
}
impl mtmsrd_instructionVar47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtmsrd"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(",1"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4399:1, end:4399:2))"]
#[derive(Clone, Debug)]
struct sync_instructionVar48 {
    L: u8,
}
impl sync_instructionVar48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sync"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.L as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let L = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { L }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:98:1, end:98:2))"]
#[derive(Clone, Debug)]
struct mftb_instructionVar49 {
    D: u8,
}
impl mftb_instructionVar49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mftb"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::TBLr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:103:1, end:103:2))"]
#[derive(Clone, Debug)]
struct mftb_instructionVar50 {
    D: u8,
}
impl mftb_instructionVar50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mftb"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::TBUr),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2977:1, end:2977:2))"]
#[derive(Clone, Debug)]
struct mfcr_instructionVar51 {
    D: u8,
}
impl mfcr_instructionVar51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfcr"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_3_display(self.D)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3023:1, end:3023:2))"]
#[derive(Clone, Debug)]
struct mfsr_instructionVar52 {
    D: u8,
    B: u8,
}
impl mfsr_instructionVar52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfsr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let SR = token_41(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3228:1, end:3228:2))"]
#[derive(Clone, Debug)]
struct mtsr_instructionVar53 {
    SR: u8,
    S: u8,
}
impl mtsr_instructionVar53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtsr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.SR),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let SR = token_41(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3238:1, end:3238:2))"]
#[derive(Clone, Debug)]
struct mtsrd_instructionVar54 {
    SR: u8,
    S: u8,
}
impl mtsrd_instructionVar54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtsrd"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.SR),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SR = token_41(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SR, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3462:1, end:3462:2))"]
#[derive(Clone, Debug)]
struct nego_instructionVar55 {
    D: u8,
    A: u8,
}
impl nego_instructionVar55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nego"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:86:1, end:86:2))"]
#[derive(Clone, Debug)]
struct mfmsr_instructionVar56 {
    D: u8,
}
impl mfmsr_instructionVar56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfmsr"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_3_display(self.D)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:116:1, end:116:2))"]
#[derive(Clone, Debug)]
struct mtmsr_instructionVar57 {
    S: u8,
}
impl mtmsr_instructionVar57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtmsr"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(",0"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:134:1, end:134:2))"]
#[derive(Clone, Debug)]
struct mtmsr_instructionVar58 {
    S: u8,
}
impl mtmsr_instructionVar58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtmsr"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(",1"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:249:1, end:249:2))"]
#[derive(Clone, Debug)]
struct mfvscr_instructionVar59 {
    vrD: TablevrD,
}
impl mfvscr_instructionVar59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfvscr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:181:1, end:181:2))"]
#[derive(Clone, Debug)]
struct addme_instructionVar60 {
    D: u8,
    A: u8,
}
impl addme_instructionVar60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addme"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:190:1, end:190:2))"]
#[derive(Clone, Debug)]
struct addme__instructionVar61 {
    D: u8,
    A: u8,
}
impl addme__instructionVar61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addme."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:200:1, end:200:2))"]
#[derive(Clone, Debug)]
struct addmeo_instructionVar62 {
    D: u8,
    A: u8,
}
impl addmeo_instructionVar62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addmeo"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:210:1, end:210:2))"]
#[derive(Clone, Debug)]
struct addmeo__instructionVar63 {
    D: u8,
    A: u8,
}
impl addmeo__instructionVar63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addmeo."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:221:1, end:221:2))"]
#[derive(Clone, Debug)]
struct addze_instructionVar64 {
    D: u8,
    A: u8,
}
impl addze_instructionVar64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addze"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:229:1, end:229:2))"]
#[derive(Clone, Debug)]
struct addze__instructionVar65 {
    D: u8,
    A: u8,
}
impl addze__instructionVar65 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addze."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:238:1, end:238:2))"]
#[derive(Clone, Debug)]
struct addzeo_instructionVar66 {
    D: u8,
    A: u8,
}
impl addzeo_instructionVar66 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addzeo"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:247:1, end:247:2))"]
#[derive(Clone, Debug)]
struct addzeo__instructionVar67 {
    D: u8,
    A: u8,
}
impl addzeo__instructionVar67 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addzeo."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:475:1, end:475:2))"]
#[derive(Clone, Debug)]
struct bctr_instructionVar68 {
    BH: u8,
}
impl bctr_instructionVar68 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bctr"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:487:1, end:487:2))"]
#[derive(Clone, Debug)]
struct bctrl_instructionVar69 {
    BH: u8,
}
impl bctrl_instructionVar69 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bctrl"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:530:1, end:530:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar70 {
    BI_CR: u8,
    BH: u8,
    CC: TableCC,
}
impl b_instructionVar70 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("ctr"),
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.BI_CR),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR, BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:546:1, end:546:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar71 {
    BI_CR: u8,
    BH: u8,
    CC: TableCC,
}
impl b_instructionVar71 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("ctrl"),
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.BI_CR),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BI_CR = token_8(tokens_current);
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR, BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:563:1, end:563:2))"]
#[derive(Clone, Debug)]
struct blr_instructionVar72 {
    BH: u8,
}
impl blr_instructionVar72 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("blr"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:576:1, end:576:2))"]
#[derive(Clone, Debug)]
struct blrl_instructionVar73 {
    BH: u8,
}
impl blrl_instructionVar73 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("blrl"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:643:1, end:643:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar74 {
    BI_CR: u8,
    BH: u8,
    CC: TableCC,
}
impl b_instructionVar74 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("lrl"),
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.BI_CR),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BI_CR = token_8(tokens_current);
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CC, BI_CR, BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:661:1, end:661:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar75 {
    BH: u8,
    CTR_DEC: TableCTR_DEC,
}
impl bd_instructionVar75 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("lr"),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CTR_DEC, BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:677:1, end:677:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar76 {
    BH: u8,
    CTR_DEC: TableCTR_DEC,
}
impl bd_instructionVar76 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("lrl"),
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CTR_DEC, BH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:697:1, end:697:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar77 {
    BH: u8,
    CC_OP: TableCC_OP,
    CC_TF: TableCC_TF,
    CTR_DEC: TableCTR_DEC,
}
impl bd_instructionVar77 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.CC_TF
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("lr"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_OP,
                CC_TF,
                CTR_DEC,
                BH,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:717:1, end:717:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar78 {
    BH: u8,
    CTR_DEC: TableCTR_DEC,
    CC_TF: TableCC_TF,
    CC_OP: TableCC_OP,
}
impl bd_instructionVar78 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.CC_TF
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("lrl"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.BH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CTR_DEC,
                CC_TF,
                CC_OP,
                BH,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4428:1, end:4428:2))"]
#[derive(Clone, Debug)]
struct tlbiel_instructionVar79 {
    RB_OR_ZERO: TableRB_OR_ZERO,
}
impl tlbiel_instructionVar79 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbiel"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RB_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RB_OR_ZERO = if let Some((len, table)) =
            TableRB_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RB_OR_ZERO }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/g2.sinc, start:5:1, end:5:2))"]
#[derive(Clone, Debug)]
struct tlbld_instructionVar80 {
    B: u8,
}
impl tlbld_instructionVar80 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbld"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/g2.sinc, start:10:1, end:10:2))"]
#[derive(Clone, Debug)]
struct tlbli_instructionVar81 {
    B: u8,
}
impl tlbli_instructionVar81 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbli"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:254:1, end:254:2))"]
#[derive(Clone, Debug)]
struct mtvscr_instructionVar82 {
    vrB: TablevrB,
}
impl mtvscr_instructionVar82 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtvscr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:903:1, end:903:2))"]
#[derive(Clone, Debug)]
struct dccci_instructionVar83 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dccci_instructionVar83 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dccci"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2049:1, end:2049:2))"]
#[derive(Clone, Debug)]
struct iccci_instructionVar84 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl iccci_instructionVar84 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("iccci"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2057:1, end:2057:2))"]
#[derive(Clone, Debug)]
struct icread_instructionVar85 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl icread_instructionVar85 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("icread"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:4:1, end:4:2))"]
#[derive(Clone, Debug)]
struct dcba_instructionVar86 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dcba_instructionVar86 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dcba"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:11:1, end:11:2))"]
#[derive(Clone, Debug)]
struct dcbf_instructionVar87 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dcbf_instructionVar87 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dcbf"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:18:1, end:18:2))"]
#[derive(Clone, Debug)]
struct dcbi_instructionVar88 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dcbi_instructionVar88 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dcbi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:25:1, end:25:2))"]
#[derive(Clone, Debug)]
struct dcbst_instructionVar89 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dcbst_instructionVar89 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dcbst"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:32:1, end:32:2))"]
#[derive(Clone, Debug)]
struct dcbt_instructionVar90 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dcbt_instructionVar90 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dcbt"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:39:1, end:39:2))"]
#[derive(Clone, Debug)]
struct dcbtst_instructionVar91 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dcbtst_instructionVar91 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dcbtst"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:46:1, end:46:2))"]
#[derive(Clone, Debug)]
struct dcbz_instructionVar92 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dcbz_instructionVar92 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dcbz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:60:1, end:60:2))"]
#[derive(Clone, Debug)]
struct icbi_instructionVar93 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl icbi_instructionVar93 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("icbi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:733:1, end:733:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar94 {
    A: u8,
    B: u8,
    DSIZE: TableDSIZE,
    REG_A: TableREG_A,
    REG_B: TableREG_B,
}
impl cmp_instructionVar94 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.DSIZE
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REG_A = if let Some((len, table)) =
            TableREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REG_B = if let Some((len, table)) =
            TableREG_B::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                REG_A,
                REG_B,
                A,
                B,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:773:1, end:773:2))"]
#[derive(Clone, Debug)]
struct cmpl_instructionVar95 {
    A: u8,
    B: u8,
    DSIZE: TableDSIZE,
    UREG_A: TableUREG_A,
    UREG_B: TableUREG_B,
}
impl cmpl_instructionVar95 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpl"));
        self.DSIZE
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UREG_A = if let Some((len, table)) =
            TableUREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UREG_B = if let Some((len, table)) =
            TableUREG_B::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                UREG_A,
                UREG_B,
                A,
                B,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3138:1, end:3138:2))"]
#[derive(Clone, Debug)]
struct mtfsfi_instructionVar96 {
    crfD: u8,
    IMM: u8,
}
impl mtfsfi_instructionVar96 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtfsfi"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.crfD as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.IMM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let crfD = token_9(tokens_current);
        let IMM = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { crfD, IMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3150:1, end:3150:2))"]
#[derive(Clone, Debug)]
struct mtfsfi__instructionVar97 {
    crfD: u8,
    IMM: u8,
}
impl mtfsfi__instructionVar97 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtfsfi."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.crfD as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.IMM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let IMM = token_4(tokens_current);
        let crfD = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { crfD, IMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1241:1, end:1241:2))"]
#[derive(Clone, Debug)]
struct fcmpo_instructionVar98 {
    CRFD: u8,
    fA: u8,
    fB: u8,
}
impl fcmpo_instructionVar98 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmpo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.CRFD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        let CRFD = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRFD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1250:1, end:1250:2))"]
#[derive(Clone, Debug)]
struct fcmpu_instructionVar99 {
    CRFD: u8,
    fA: u8,
    fB: u8,
}
impl fcmpu_instructionVar99 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmpu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.CRFD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRFD = token_9(tokens_current);
        let fB = token_4(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRFD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:743:1, end:743:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar100 {
    CRFD: u8,
    A: u8,
    B: u8,
    REG_A: TableREG_A,
    DSIZE: TableDSIZE,
    REG_B: TableREG_B,
}
impl cmp_instructionVar100 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.DSIZE
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.CRFD),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REG_A = if let Some((len, table)) =
            TableREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REG_B = if let Some((len, table)) =
            TableREG_B::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRFD = token_9(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                REG_A,
                DSIZE,
                REG_B,
                CRFD,
                A,
                B,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:783:1, end:783:2))"]
#[derive(Clone, Debug)]
struct cmpl_instructionVar101 {
    CRFD: u8,
    A: u8,
    B: u8,
    UREG_B: TableUREG_B,
    DSIZE: TableDSIZE,
    UREG_A: TableUREG_A,
}
impl cmpl_instructionVar101 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpl"));
        self.DSIZE
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.CRFD),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UREG_A = if let Some((len, table)) =
            TableUREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UREG_B = if let Some((len, table)) =
            TableUREG_B::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CRFD = token_9(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                UREG_B,
                DSIZE,
                UREG_A,
                CRFD,
                A,
                B,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:815:1, end:815:2))"]
#[derive(Clone, Debug)]
struct cntlzd_instructionVar102 {
    A: u8,
    S: u8,
}
impl cntlzd_instructionVar102 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cntlzd"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:821:1, end:821:2))"]
#[derive(Clone, Debug)]
struct cntlzd__instructionVar103 {
    A: u8,
    S: u8,
}
impl cntlzd__instructionVar103 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cntlzd."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:829:1, end:829:2))"]
#[derive(Clone, Debug)]
struct cntlzw_instructionVar104 {
    A: u8,
    S: u8,
}
impl cntlzw_instructionVar104 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cntlzw"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:835:1, end:835:2))"]
#[derive(Clone, Debug)]
struct cntlzw__instructionVar105 {
    A: u8,
    S: u8,
}
impl cntlzw__instructionVar105 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cntlzw."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1164:1, end:1164:2))"]
#[derive(Clone, Debug)]
struct fabs_instructionVar106 {
    fD: u8,
    fB: u8,
}
impl fabs_instructionVar106 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fabs"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1170:1, end:1170:2))"]
#[derive(Clone, Debug)]
struct fabs__instructionVar107 {
    fD: u8,
    fB: u8,
}
impl fabs__instructionVar107 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fabs."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1220:1, end:1220:2))"]
#[derive(Clone, Debug)]
struct fcfid_instructionVar108 {
    fD: u8,
    fB: u8,
}
impl fcfid_instructionVar108 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcfid"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1226:1, end:1226:2))"]
#[derive(Clone, Debug)]
struct fcfid__instructionVar109 {
    fD: u8,
    fB: u8,
}
impl fcfid__instructionVar109 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcfid."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1260:1, end:1260:2))"]
#[derive(Clone, Debug)]
struct fctid_instructionVar110 {
    fD: u8,
    fB: u8,
}
impl fctid_instructionVar110 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fctid"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1270:1, end:1270:2))"]
#[derive(Clone, Debug)]
struct fctid__instructionVar111 {
    fD: u8,
    fB: u8,
}
impl fctid__instructionVar111 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fctid."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1282:1, end:1282:2))"]
#[derive(Clone, Debug)]
struct fctidz_instructionVar112 {
    fD: u8,
    fB: u8,
}
impl fctidz_instructionVar112 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fctidz"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1292:1, end:1292:2))"]
#[derive(Clone, Debug)]
struct fctidz__instructionVar113 {
    fD: u8,
    fB: u8,
}
impl fctidz__instructionVar113 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fctidz."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1305:1, end:1305:2))"]
#[derive(Clone, Debug)]
struct fctiw_instructionVar114 {
    fD: u8,
    fB: u8,
}
impl fctiw_instructionVar114 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fctiw"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1317:1, end:1317:2))"]
#[derive(Clone, Debug)]
struct fctiw__instructionVar115 {
    fD: u8,
    fB: u8,
}
impl fctiw__instructionVar115 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fctiw."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1331:1, end:1331:2))"]
#[derive(Clone, Debug)]
struct fctiwz_instructionVar116 {
    fD: u8,
    fB: u8,
}
impl fctiwz_instructionVar116 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fctiwz"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1343:1, end:1343:2))"]
#[derive(Clone, Debug)]
struct fctiwz__instructionVar117 {
    fD: u8,
    fB: u8,
}
impl fctiwz__instructionVar117 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fctiwz."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1480:1, end:1480:2))"]
#[derive(Clone, Debug)]
struct fmr_instructionVar118 {
    fD: u8,
    fB: u8,
}
impl fmr_instructionVar118 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1485:1, end:1485:2))"]
#[derive(Clone, Debug)]
struct fmr__instructionVar119 {
    fD: u8,
    fB: u8,
}
impl fmr__instructionVar119 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmr."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1615:1, end:1615:2))"]
#[derive(Clone, Debug)]
struct fnabs_instructionVar120 {
    fD: u8,
    fB: u8,
}
impl fnabs_instructionVar120 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnabs"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1621:1, end:1621:2))"]
#[derive(Clone, Debug)]
struct fnabs__instructionVar121 {
    fD: u8,
    fB: u8,
}
impl fnabs__instructionVar121 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnabs."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1628:1, end:1628:2))"]
#[derive(Clone, Debug)]
struct fneg_instructionVar122 {
    fD: u8,
    fB: u8,
}
impl fneg_instructionVar122 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fneg"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1634:1, end:1634:2))"]
#[derive(Clone, Debug)]
struct fneg__instructionVar123 {
    fD: u8,
    fB: u8,
}
impl fneg__instructionVar123 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fneg."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1847:1, end:1847:2))"]
#[derive(Clone, Debug)]
struct frsp_instructionVar124 {
    fD: u8,
    fB: u8,
}
impl frsp_instructionVar124 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("frsp"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1865:1, end:1865:2))"]
#[derive(Clone, Debug)]
struct frsp__instructionVar125 {
    fD: u8,
    fB: u8,
}
impl frsp__instructionVar125 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("frsp."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1946:1, end:1946:2))"]
#[derive(Clone, Debug)]
struct fsqrt_instructionVar126 {
    fD: u8,
    fB: u8,
}
impl fsqrt_instructionVar126 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrt"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1960:1, end:1960:2))"]
#[derive(Clone, Debug)]
struct fsqrt__instructionVar127 {
    fD: u8,
    fB: u8,
}
impl fsqrt__instructionVar127 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrt."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1975:1, end:1975:2))"]
#[derive(Clone, Debug)]
struct fsqrts_instructionVar128 {
    fD: u8,
    fB: u8,
}
impl fsqrts_instructionVar128 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrts"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1990:1, end:1990:2))"]
#[derive(Clone, Debug)]
struct fsqrts__instructionVar129 {
    fD: u8,
    fB: u8,
}
impl fsqrts__instructionVar129 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrts."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3032:1, end:3032:2))"]
#[derive(Clone, Debug)]
struct mfsrin_instructionVar130 {
    D: u8,
    B: u8,
}
impl mfsrin_instructionVar130 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfsrin"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3093:1, end:3093:2))"]
#[derive(Clone, Debug)]
struct mtfsf_instructionVar131 {
    FM: u8,
    fB: u8,
}
impl mtfsf_instructionVar131 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtfsf"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.FM as u64),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FM = token_6(tokens_current);
        let FM2 = token_23(tokens_current);
        let FM7 = token_20(tokens_current);
        let FM1 = token_64(tokens_current);
        let FM4 = token_22(tokens_current);
        let FM0 = token_63(tokens_current);
        let FM5 = token_65(tokens_current);
        let FM6 = token_21(tokens_current);
        let FM3 = token_15(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FM, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3115:1, end:3115:2))"]
#[derive(Clone, Debug)]
struct mtfsf__instructionVar132 {
    FM: u8,
    fB: u8,
}
impl mtfsf__instructionVar132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtfsf."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.FM as u64),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let FM6 = token_21(tokens_current);
        let FM3 = token_15(tokens_current);
        let fB = token_4(tokens_current);
        let FM5 = token_65(tokens_current);
        let FM4 = token_22(tokens_current);
        let FM7 = token_20(tokens_current);
        let FM = token_6(tokens_current);
        let FM2 = token_23(tokens_current);
        let FM0 = token_63(tokens_current);
        let FM1 = token_64(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FM, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3244:1, end:3244:2))"]
#[derive(Clone, Debug)]
struct mtsrdin_instructionVar133 {
    S: u8,
    B: u8,
}
impl mtsrdin_instructionVar133 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtsrdin"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3252:1, end:3252:2))"]
#[derive(Clone, Debug)]
struct mtsrin_instructionVar134 {
    S: u8,
    B: u8,
}
impl mtsrin_instructionVar134 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtsrin"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3732:1, end:3732:2))"]
#[derive(Clone, Debug)]
struct slbie_instructionVar135 {
    B: u8,
}
impl slbie_instructionVar135 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slbie"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3738:1, end:3738:2))"]
#[derive(Clone, Debug)]
struct slbmfee_instructionVar136 {
    D: u8,
    B: u8,
}
impl slbmfee_instructionVar136 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slbmfee"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3744:1, end:3744:2))"]
#[derive(Clone, Debug)]
struct slbmfev_instructionVar137 {
    D: u8,
    B: u8,
}
impl slbmfev_instructionVar137 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slbmfev"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3750:1, end:3750:2))"]
#[derive(Clone, Debug)]
struct slbmte_instructionVar138 {
    S: u8,
    B: u8,
}
impl slbmte_instructionVar138 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slbmte"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4423:1, end:4423:2))"]
#[derive(Clone, Debug)]
struct tlbie_instructionVar139 {
    RS_OR_ZERO: TableRS_OR_ZERO,
    RB_OR_ZERO: TableRB_OR_ZERO,
}
impl tlbie_instructionVar139 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbie"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.RB_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RS_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RS_OR_ZERO = if let Some((len, table)) =
            TableRS_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RB_OR_ZERO = if let Some((len, table)) =
            TableRB_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RS_OR_ZERO,
                RB_OR_ZERO,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:172:1, end:172:2))"]
#[derive(Clone, Debug)]
struct dst_instructionVar140 {
    A: u8,
    B: u8,
    STRM: u8,
}
impl dst_instructionVar140 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dst"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.STRM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let STRM = token_48(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, B, STRM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:177:1, end:177:2))"]
#[derive(Clone, Debug)]
struct dstt_instructionVar141 {
    A: u8,
    B: u8,
    STRM: u8,
}
impl dstt_instructionVar141 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dstt"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.STRM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let STRM = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, B, STRM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:182:1, end:182:2))"]
#[derive(Clone, Debug)]
struct dstst_instructionVar142 {
    A: u8,
    B: u8,
    STRM: u8,
}
impl dstst_instructionVar142 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dstst"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.STRM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let STRM = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, B, STRM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:187:1, end:187:2))"]
#[derive(Clone, Debug)]
struct dststt_instructionVar143 {
    A: u8,
    B: u8,
    STRM: u8,
}
impl dststt_instructionVar143 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("dststt"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.STRM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let STRM = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, B, STRM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:845:1, end:845:2))"]
#[derive(Clone, Debug)]
struct crand_instructionVar144 {
    CC_B_OP: TableCC_B_OP,
    CC_OP: TableCC_OP,
    CC_D_OP: TableCC_D_OP,
}
impl crand_instructionVar144 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("crand"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_D_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC_D_OP = if let Some((len, table)) =
            TableCC_D_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) =
            TableCC_B_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CR_D = token_9(tokens_current);
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_B_OP,
                CC_OP,
                CC_D_OP,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:852:1, end:852:2))"]
#[derive(Clone, Debug)]
struct crandc_instructionVar145 {
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
}
impl crandc_instructionVar145 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("crandc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_D_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC_D_OP = if let Some((len, table)) =
            TableCC_D_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) =
            TableCC_B_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CR_D = token_9(tokens_current);
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_OP,
                CC_B_OP,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:860:1, end:860:2))"]
#[derive(Clone, Debug)]
struct creqv_instructionVar146 {
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
}
impl creqv_instructionVar146 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("creqv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_D_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC_D_OP = if let Some((len, table)) =
            TableCC_D_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) =
            TableCC_B_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CR_D = token_9(tokens_current);
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_OP,
                CC_B_OP,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:867:1, end:867:2))"]
#[derive(Clone, Debug)]
struct crnand_instructionVar147 {
    CC_B_OP: TableCC_B_OP,
    CC_OP: TableCC_OP,
    CC_D_OP: TableCC_D_OP,
}
impl crnand_instructionVar147 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("crnand"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_D_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC_D_OP = if let Some((len, table)) =
            TableCC_D_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) =
            TableCC_B_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CR_D_CC = token_48(tokens_current);
        let CR_D = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_B_OP,
                CC_OP,
                CC_D_OP,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:874:1, end:874:2))"]
#[derive(Clone, Debug)]
struct crnor_instructionVar148 {
    CC_B_OP: TableCC_B_OP,
    CC_OP: TableCC_OP,
    CC_D_OP: TableCC_D_OP,
}
impl crnor_instructionVar148 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("crnor"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_D_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC_D_OP = if let Some((len, table)) =
            TableCC_D_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) =
            TableCC_B_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CR_D_CC = token_48(tokens_current);
        let CR_D = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_B_OP,
                CC_OP,
                CC_D_OP,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:881:1, end:881:2))"]
#[derive(Clone, Debug)]
struct cror_instructionVar149 {
    CC_B_OP: TableCC_B_OP,
    CC_D_OP: TableCC_D_OP,
    CC_OP: TableCC_OP,
}
impl cror_instructionVar149 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cror"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_D_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC_D_OP = if let Some((len, table)) =
            TableCC_D_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) =
            TableCC_B_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CR_D = token_9(tokens_current);
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_B_OP,
                CC_D_OP,
                CC_OP,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:888:1, end:888:2))"]
#[derive(Clone, Debug)]
struct crorc_instructionVar150 {
    CC_OP: TableCC_OP,
    CC_B_OP: TableCC_B_OP,
    CC_D_OP: TableCC_D_OP,
}
impl crorc_instructionVar150 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("crorc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_D_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC_D_OP = if let Some((len, table)) =
            TableCC_D_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) =
            TableCC_B_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CR_D_CC = token_48(tokens_current);
        let CR_D = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_OP,
                CC_B_OP,
                CC_D_OP,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:895:1, end:895:2))"]
#[derive(Clone, Debug)]
struct crxor_instructionVar151 {
    CC_D_OP: TableCC_D_OP,
    CC_B_OP: TableCC_B_OP,
    CC_OP: TableCC_OP,
}
impl crxor_instructionVar151 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("crxor"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_D_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.CC_B_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC_D_OP = if let Some((len, table)) =
            TableCC_D_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_B_OP = if let Some((len, table)) =
            TableCC_B_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CR_D_CC = token_48(tokens_current);
        let CR_D = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CC_D_OP,
                CC_B_OP,
                CC_OP,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1077:1, end:1077:2))"]
#[derive(Clone, Debug)]
struct eciwx_instructionVar152 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl eciwx_instructionVar152 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eciwx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1084:1, end:1084:2))"]
#[derive(Clone, Debug)]
struct ecowx_instructionVar153 {
    S: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl ecowx_instructionVar153 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ecowx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1117:1, end:1117:2))"]
#[derive(Clone, Debug)]
struct extsb_instructionVar154 {
    A: u8,
    S: u8,
}
impl extsb_instructionVar154 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extsb"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1123:1, end:1123:2))"]
#[derive(Clone, Debug)]
struct extsb__instructionVar155 {
    A: u8,
    S: u8,
}
impl extsb__instructionVar155 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extsb."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1133:1, end:1133:2))"]
#[derive(Clone, Debug)]
struct extsh_instructionVar156 {
    A: u8,
    S: u8,
}
impl extsh_instructionVar156 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extsh"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1139:1, end:1139:2))"]
#[derive(Clone, Debug)]
struct extsh__instructionVar157 {
    A: u8,
    S: u8,
}
impl extsh__instructionVar157 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extsh."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1147:1, end:1147:2))"]
#[derive(Clone, Debug)]
struct extsw_instructionVar158 {
    A: u8,
    S: u8,
}
impl extsw_instructionVar158 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extsw"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1153:1, end:1153:2))"]
#[derive(Clone, Debug)]
struct extsw__instructionVar159 {
    A: u8,
    S: u8,
}
impl extsw__instructionVar159 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extsw."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1176:1, end:1176:2))"]
#[derive(Clone, Debug)]
struct fadd_instructionVar160 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fadd_instructionVar160 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fadd"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1185:1, end:1185:2))"]
#[derive(Clone, Debug)]
struct fadd__instructionVar161 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fadd__instructionVar161 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fadd."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1195:1, end:1195:2))"]
#[derive(Clone, Debug)]
struct fadds_instructionVar162 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fadds_instructionVar162 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fadds"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1206:1, end:1206:2))"]
#[derive(Clone, Debug)]
struct fadds__instructionVar163 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fadds__instructionVar163 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fadds."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1358:1, end:1358:2))"]
#[derive(Clone, Debug)]
struct fdiv_instructionVar164 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fdiv_instructionVar164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdiv"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1366:1, end:1366:2))"]
#[derive(Clone, Debug)]
struct fdiv__instructionVar165 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fdiv__instructionVar165 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdiv."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1376:1, end:1376:2))"]
#[derive(Clone, Debug)]
struct fdivs_instructionVar166 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fdivs_instructionVar166 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdivs"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1385:1, end:1385:2))"]
#[derive(Clone, Debug)]
struct fdivs__instructionVar167 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fdivs__instructionVar167 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdivs."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fA = token_1(tokens_current);
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1810:1, end:1810:2))"]
#[derive(Clone, Debug)]
struct fres_instructionVar168 {
    fD: u8,
    fB: u8,
}
impl fres_instructionVar168 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fres"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        let BITS_16_20 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1828:1, end:1828:2))"]
#[derive(Clone, Debug)]
struct fres__instructionVar169 {
    fD: u8,
    fB: u8,
}
impl fres__instructionVar169 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fres."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let BITS_16_20 = token_1(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1884:1, end:1884:2))"]
#[derive(Clone, Debug)]
struct frsqrte_instructionVar170 {
    fD: u8,
    fB: u8,
}
impl frsqrte_instructionVar170 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("frsqrte"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let BITS_16_20 = token_1(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1902:1, end:1902:2))"]
#[derive(Clone, Debug)]
struct frsqrte__instructionVar171 {
    fD: u8,
    fB: u8,
}
impl frsqrte__instructionVar171 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("frsqrte."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let BITS_16_20 = token_1(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2006:1, end:2006:2))"]
#[derive(Clone, Debug)]
struct fsub_instructionVar172 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fsub_instructionVar172 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsub"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fA = token_1(tokens_current);
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2015:1, end:2015:2))"]
#[derive(Clone, Debug)]
struct fsub__instructionVar173 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fsub__instructionVar173 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsub."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2025:1, end:2025:2))"]
#[derive(Clone, Debug)]
struct fsubs_instructionVar174 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fsubs_instructionVar174 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsubs"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2036:1, end:2036:2))"]
#[derive(Clone, Debug)]
struct fsubs__instructionVar175 {
    fD: u8,
    fA: u8,
    fB: u8,
}
impl fsubs__instructionVar175 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsubs."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2150:1, end:2150:2))"]
#[derive(Clone, Debug)]
struct lfdux_instructionVar176 {
    fD: u8,
    A: u8,
    B: u8,
}
impl lfdux_instructionVar176 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lfdux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2157:1, end:2157:2))"]
#[derive(Clone, Debug)]
struct lfdx_instructionVar177 {
    fD: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lfdx_instructionVar177 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lfdx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fD = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, fD, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2176:1, end:2176:2))"]
#[derive(Clone, Debug)]
struct lfsux_instructionVar178 {
    fD: u8,
    A: u8,
    B: u8,
}
impl lfsux_instructionVar178 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lfsux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let fD = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2183:1, end:2183:2))"]
#[derive(Clone, Debug)]
struct lfsx_instructionVar179 {
    fD: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lfsx_instructionVar179 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lfsx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fD = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, fD, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:12:1, end:12:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar180 {
    D: u8,
    NB: u8,
    DYN_D6: TableDYN_D6,
    DYN_D7: TableDYN_D7,
    DYN_D3: TableDYN_D3,
    DYN_D5: TableDYN_D5,
    DYN_D1: TableDYN_D1,
    DYN_D4: TableDYN_D4,
    DYN_D2: TableDYN_D2,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lswi_instructionVar180 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) =
            TableDYN_D3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) =
            TableDYN_D4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) =
            TableDYN_D5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D6 = if let Some((len, table)) =
            TableDYN_D6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D7 = if let Some((len, table)) =
            TableDYN_D7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D6,
                DYN_D7,
                DYN_D3,
                DYN_D5,
                DYN_D1,
                DYN_D4,
                DYN_D2,
                RA_OR_ZERO,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:33:1, end:33:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar181 {
    D: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lswi_instructionVar181 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, NB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:49:1, end:49:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar182 {
    D: u8,
    NB: u8,
    DYN_D1: TableDYN_D1,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lswi_instructionVar182 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D1,
                RA_OR_ZERO,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:67:1, end:67:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar183 {
    D: u8,
    NB: u8,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lswi_instructionVar183 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D1,
                DYN_D2,
                RA_OR_ZERO,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:87:1, end:87:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar184 {
    D: u8,
    NB: u8,
    DYN_D1: TableDYN_D1,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D3: TableDYN_D3,
    DYN_D2: TableDYN_D2,
}
impl lswi_instructionVar184 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) =
            TableDYN_D3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D1,
                RA_OR_ZERO,
                DYN_D3,
                DYN_D2,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:109:1, end:109:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar185 {
    D: u8,
    NB: u8,
    DYN_D2: TableDYN_D2,
    DYN_D1: TableDYN_D1,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D3: TableDYN_D3,
    DYN_D4: TableDYN_D4,
}
impl lswi_instructionVar185 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) =
            TableDYN_D3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) =
            TableDYN_D4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D2,
                DYN_D1,
                RA_OR_ZERO,
                DYN_D3,
                DYN_D4,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:133:1, end:133:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar186 {
    D: u8,
    NB: u8,
    DYN_D5: TableDYN_D5,
    DYN_D4: TableDYN_D4,
    DYN_D2: TableDYN_D2,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D3: TableDYN_D3,
    DYN_D1: TableDYN_D1,
}
impl lswi_instructionVar186 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) =
            TableDYN_D3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) =
            TableDYN_D4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) =
            TableDYN_D5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D5,
                DYN_D4,
                DYN_D2,
                RA_OR_ZERO,
                DYN_D3,
                DYN_D1,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:159:1, end:159:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar187 {
    D: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D2: TableDYN_D2,
    DYN_D6: TableDYN_D6,
    DYN_D4: TableDYN_D4,
    DYN_D1: TableDYN_D1,
    DYN_D3: TableDYN_D3,
    DYN_D5: TableDYN_D5,
}
impl lswi_instructionVar187 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) =
            TableDYN_D3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) =
            TableDYN_D4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) =
            TableDYN_D5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D6 = if let Some((len, table)) =
            TableDYN_D6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D2,
                DYN_D6,
                DYN_D4,
                DYN_D1,
                DYN_D3,
                DYN_D5,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3449:1, end:3449:2))"]
#[derive(Clone, Debug)]
struct neg_instructionVar188 {
    D: u8,
    A: u8,
}
impl neg_instructionVar188 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3455:1, end:3455:2))"]
#[derive(Clone, Debug)]
struct neg__instructionVar189 {
    D: u8,
    A: u8,
}
impl neg__instructionVar189 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3469:1, end:3469:2))"]
#[derive(Clone, Debug)]
struct nego__instructionVar190 {
    D: u8,
    A: u8,
}
impl nego__instructionVar190 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nego."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:13:1, end:13:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar191 {
    S: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S3: TableDYN_S3,
    DYN_S1: TableDYN_S1,
    DYN_S7: TableDYN_S7,
    DYN_S6: TableDYN_S6,
    DYN_S4: TableDYN_S4,
    DYN_S5: TableDYN_S5,
    DYN_S2: TableDYN_S2,
}
impl stswi_instructionVar191 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) =
            TableDYN_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) =
            TableDYN_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) =
            TableDYN_S5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S6 = if let Some((len, table)) =
            TableDYN_S6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S7 = if let Some((len, table)) =
            TableDYN_S7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S3,
                DYN_S1,
                DYN_S7,
                DYN_S6,
                DYN_S4,
                DYN_S5,
                DYN_S2,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:34:1, end:34:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar192 {
    S: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stswi_instructionVar192 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, NB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:50:1, end:50:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar193 {
    S: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
}
impl stswi_instructionVar193 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:68:1, end:68:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar194 {
    S: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
}
impl stswi_instructionVar194 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:88:1, end:88:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar195 {
    S: u8,
    NB: u8,
    DYN_S1: TableDYN_S1,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
}
impl stswi_instructionVar195 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) =
            TableDYN_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_S1,
                RA_OR_ZERO,
                DYN_S2,
                DYN_S3,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:110:1, end:110:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar196 {
    S: u8,
    NB: u8,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S4: TableDYN_S4,
}
impl stswi_instructionVar196 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) =
            TableDYN_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) =
            TableDYN_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_S1,
                DYN_S2,
                DYN_S3,
                RA_OR_ZERO,
                DYN_S4,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:134:1, end:134:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar197 {
    S: u8,
    NB: u8,
    DYN_S4: TableDYN_S4,
    DYN_S2: TableDYN_S2,
    DYN_S1: TableDYN_S1,
    DYN_S3: TableDYN_S3,
    DYN_S5: TableDYN_S5,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stswi_instructionVar197 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) =
            TableDYN_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) =
            TableDYN_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) =
            TableDYN_S5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_S4,
                DYN_S2,
                DYN_S1,
                DYN_S3,
                DYN_S5,
                RA_OR_ZERO,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:160:1, end:160:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar198 {
    S: u8,
    NB: u8,
    DYN_S4: TableDYN_S4,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S3: TableDYN_S3,
    DYN_S5: TableDYN_S5,
    DYN_S6: TableDYN_S6,
    DYN_S2: TableDYN_S2,
    DYN_S1: TableDYN_S1,
}
impl stswi_instructionVar198 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) =
            TableDYN_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) =
            TableDYN_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) =
            TableDYN_S5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S6 = if let Some((len, table)) =
            TableDYN_S6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_S4,
                RA_OR_ZERO,
                DYN_S3,
                DYN_S5,
                DYN_S6,
                DYN_S2,
                DYN_S1,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4320:1, end:4320:2))"]
#[derive(Clone, Debug)]
struct subfme_instructionVar199 {
    D: u8,
    A: u8,
}
impl subfme_instructionVar199 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfme"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4329:1, end:4329:2))"]
#[derive(Clone, Debug)]
struct subfme__instructionVar200 {
    D: u8,
    A: u8,
}
impl subfme__instructionVar200 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfme."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4338:1, end:4338:2))"]
#[derive(Clone, Debug)]
struct subfmeo_instructionVar201 {
    D: u8,
    A: u8,
}
impl subfmeo_instructionVar201 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfmeo"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4348:1, end:4348:2))"]
#[derive(Clone, Debug)]
struct subfmeo__instructionVar202 {
    D: u8,
    A: u8,
}
impl subfmeo__instructionVar202 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfmeo."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4359:1, end:4359:2))"]
#[derive(Clone, Debug)]
struct subfze_instructionVar203 {
    D: u8,
    A: u8,
}
impl subfze_instructionVar203 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfze"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4368:1, end:4368:2))"]
#[derive(Clone, Debug)]
struct subfze__instructionVar204 {
    D: u8,
    A: u8,
}
impl subfze__instructionVar204 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfze."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4378:1, end:4378:2))"]
#[derive(Clone, Debug)]
struct subfzeo_instructionVar205 {
    D: u8,
    A: u8,
}
impl subfzeo_instructionVar205 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfzeo"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4388:1, end:4388:2))"]
#[derive(Clone, Debug)]
struct subfzeo__instructionVar206 {
    D: u8,
    A: u8,
}
impl subfzeo__instructionVar206 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfzeo."));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:977:1, end:977:2))"]
#[derive(Clone, Debug)]
struct vspltisb_instructionVar207 {
    A_BITSS: u8,
    vrD: TablevrD,
}
impl vspltisb_instructionVar207 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vspltisb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.A_BITSS & 16 != 0 { -1 & !15 } else { 0 } | self.A_BITSS as i8)
                    .is_negative(),
                (if self.A_BITSS & 16 != 0 { -1 & !15 } else { 0 } | self.A_BITSS as i8).abs()
                    as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A_BITSS = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, A_BITSS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:982:1, end:982:2))"]
#[derive(Clone, Debug)]
struct vspltish_instructionVar208 {
    A_BITSS: u8,
    vrD: TablevrD,
}
impl vspltish_instructionVar208 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vspltish"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.A_BITSS & 16 != 0 { -1 & !15 } else { 0 } | self.A_BITSS as i8)
                    .is_negative(),
                (if self.A_BITSS & 16 != 0 { -1 & !15 } else { 0 } | self.A_BITSS as i8).abs()
                    as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A_BITSS = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, A_BITSS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:987:1, end:987:2))"]
#[derive(Clone, Debug)]
struct vspltisw_instructionVar209 {
    A_BITSS: u8,
    vrD: TablevrD,
}
impl vspltisw_instructionVar209 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vspltisw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.A_BITSS & 16 != 0 { -1 & !15 } else { 0 } | self.A_BITSS as i8)
                    .is_negative(),
                (if self.A_BITSS & 16 != 0 { -1 & !15 } else { 0 } | self.A_BITSS as i8).abs()
                    as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A_BITSS = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, A_BITSS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1511:1, end:1511:2))"]
#[derive(Clone, Debug)]
struct vsbox_instructionVar210 {
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsbox_instructionVar210 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsbox"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1790:1, end:1790:2))"]
#[derive(Clone, Debug)]
struct vmul10cuq_instructionVar211 {
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vmul10cuq_instructionVar211 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmul10cuq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1802:1, end:1802:2))"]
#[derive(Clone, Debug)]
struct vmul10uq_instructionVar212 {
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vmul10uq_instructionVar212 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmul10uq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:26:1, end:26:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar213 {
    D: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lswi_instructionVar213 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let NB = token_4(tokens_current);
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, NB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:39:1, end:39:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar214 {
    D: u8,
    NB: u8,
    DYN_D1: TableDYN_D1,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lswi_instructionVar214 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let NB = token_4(tokens_current);
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D1,
                RA_OR_ZERO,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:57:1, end:57:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar215 {
    D: u8,
    NB: u8,
    DYN_D2: TableDYN_D2,
    DYN_D1: TableDYN_D1,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lswi_instructionVar215 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let NB = token_4(tokens_current);
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D2,
                DYN_D1,
                RA_OR_ZERO,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:76:1, end:76:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar216 {
    D: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D3: TableDYN_D3,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
}
impl lswi_instructionVar216 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) =
            TableDYN_D3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        let NB = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D3,
                DYN_D1,
                DYN_D2,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:97:1, end:97:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar217 {
    D: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    DYN_D4: TableDYN_D4,
}
impl lswi_instructionVar217 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) =
            TableDYN_D3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) =
            TableDYN_D4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let BH = token_10(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_D1,
                DYN_D2,
                DYN_D3,
                DYN_D4,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:120:1, end:120:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar218 {
    D: u8,
    NB: u8,
    DYN_D5: TableDYN_D5,
    DYN_D2: TableDYN_D2,
    DYN_D1: TableDYN_D1,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D4: TableDYN_D4,
    DYN_D3: TableDYN_D3,
}
impl lswi_instructionVar218 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) =
            TableDYN_D3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) =
            TableDYN_D4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) =
            TableDYN_D5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        let D = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D5,
                DYN_D2,
                DYN_D1,
                RA_OR_ZERO,
                DYN_D4,
                DYN_D3,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:145:1, end:145:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar219 {
    D: u8,
    NB: u8,
    DYN_D1: TableDYN_D1,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D5: TableDYN_D5,
    DYN_D6: TableDYN_D6,
    DYN_D4: TableDYN_D4,
}
impl lswi_instructionVar219 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) =
            TableDYN_D3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) =
            TableDYN_D4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) =
            TableDYN_D5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D6 = if let Some((len, table)) =
            TableDYN_D6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let BH = token_10(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D1,
                DYN_D2,
                DYN_D3,
                RA_OR_ZERO,
                DYN_D5,
                DYN_D6,
                DYN_D4,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:172:1, end:172:2))"]
#[derive(Clone, Debug)]
struct lswi_instructionVar220 {
    D: u8,
    NB: u8,
    DYN_D2: TableDYN_D2,
    DYN_D3: TableDYN_D3,
    DYN_D6: TableDYN_D6,
    DYN_D7: TableDYN_D7,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_D4: TableDYN_D4,
    DYN_D5: TableDYN_D5,
    DYN_D1: TableDYN_D1,
}
impl lswi_instructionVar220 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D1 = if let Some((len, table)) =
            TableDYN_D1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D2 = if let Some((len, table)) =
            TableDYN_D2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D3 = if let Some((len, table)) =
            TableDYN_D3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D4 = if let Some((len, table)) =
            TableDYN_D4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D5 = if let Some((len, table)) =
            TableDYN_D5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D6 = if let Some((len, table)) =
            TableDYN_D6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_D7 = if let Some((len, table)) =
            TableDYN_D7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let BH = token_10(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_D2,
                DYN_D3,
                DYN_D6,
                DYN_D7,
                RA_OR_ZERO,
                DYN_D4,
                DYN_D5,
                DYN_D1,
                D,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3043:1, end:3043:2))"]
#[derive(Clone, Debug)]
struct mtcrf_instructionVar221 {
    CRM: u8,
    S: u8,
}
impl mtcrf_instructionVar221 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtcrf"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.CRM as u64),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRM0 = token_65(tokens_current);
        let CRM7 = token_68(tokens_current);
        let CRM = token_36(tokens_current);
        let CRM4 = token_18(tokens_current);
        let S = token_51(tokens_current);
        let CRM1 = token_21(tokens_current);
        let CRM2 = token_20(tokens_current);
        let CRM3 = token_19(tokens_current);
        let CRM5 = token_66(tokens_current);
        let CRM6 = token_67(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRM, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3199:1, end:3199:2))"]
#[derive(Clone, Debug)]
struct mtocrf_instructionVar222 {
    S: u8,
    CRM_val: TableCRM_val,
}
impl mtocrf_instructionVar222 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtocrf"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CRM_val
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.S)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRM_val = if let Some((len, table)) =
            TableCRM_val::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let CRM1 = token_21(tokens_current);
        let CRM0 = token_65(tokens_current);
        let CRM3 = token_19(tokens_current);
        let CRM6 = token_67(tokens_current);
        let CRM7 = token_68(tokens_current);
        let CRM5 = token_66(tokens_current);
        let CRM2 = token_20(tokens_current);
        let CRM4 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRM_val, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:604:1, end:604:2))"]
#[derive(Clone, Debug)]
struct vexptefp_instructionVar223 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vexptefp_instructionVar223 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vexptefp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:609:1, end:609:2))"]
#[derive(Clone, Debug)]
struct vlogefp_instructionVar224 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vlogefp_instructionVar224 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vlogefp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:882:1, end:882:2))"]
#[derive(Clone, Debug)]
struct vrefp_instructionVar225 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vrefp_instructionVar225 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrefp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:887:1, end:887:2))"]
#[derive(Clone, Debug)]
struct vrfim_instructionVar226 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vrfim_instructionVar226 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrfim"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:892:1, end:892:2))"]
#[derive(Clone, Debug)]
struct vrfin_instructionVar227 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vrfin_instructionVar227 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrfin"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:897:1, end:897:2))"]
#[derive(Clone, Debug)]
struct vrfip_instructionVar228 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vrfip_instructionVar228 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrfip"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:902:1, end:902:2))"]
#[derive(Clone, Debug)]
struct vrfiz_instructionVar229 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vrfiz_instructionVar229 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrfiz"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:922:1, end:922:2))"]
#[derive(Clone, Debug)]
struct vrsqrtefp_instructionVar230 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vrsqrtefp_instructionVar230 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrsqrtefp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1134:1, end:1134:2))"]
#[derive(Clone, Debug)]
struct vupkhpx_instructionVar231 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vupkhpx_instructionVar231 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vupkhpx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1139:1, end:1139:2))"]
#[derive(Clone, Debug)]
struct vupkhsb_instructionVar232 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vupkhsb_instructionVar232 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vupkhsb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1144:1, end:1144:2))"]
#[derive(Clone, Debug)]
struct vupkhsh_instructionVar233 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vupkhsh_instructionVar233 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vupkhsh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1149:1, end:1149:2))"]
#[derive(Clone, Debug)]
struct vupklpx_instructionVar234 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vupklpx_instructionVar234 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vupklpx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1154:1, end:1154:2))"]
#[derive(Clone, Debug)]
struct vupklsb_instructionVar235 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vupklsb_instructionVar235 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vupklsb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1159:1, end:1159:2))"]
#[derive(Clone, Debug)]
struct vupklsh_instructionVar236 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vupklsh_instructionVar236 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vupklsh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1347:1, end:1347:2))"]
#[derive(Clone, Debug)]
struct vclzb_instructionVar237 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vclzb_instructionVar237 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vclzb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1351:1, end:1351:2))"]
#[derive(Clone, Debug)]
struct vclzd_instructionVar238 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vclzd_instructionVar238 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vclzd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1355:1, end:1355:2))"]
#[derive(Clone, Debug)]
struct vclzh_instructionVar239 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vclzh_instructionVar239 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vclzh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1359:1, end:1359:2))"]
#[derive(Clone, Debug)]
struct vclzw_instructionVar240 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vclzw_instructionVar240 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vclzw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1391:1, end:1391:2))"]
#[derive(Clone, Debug)]
struct vgbbd_instructionVar241 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vgbbd_instructionVar241 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vgbbd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1491:1, end:1491:2))"]
#[derive(Clone, Debug)]
struct vpopcntb_instructionVar242 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vpopcntb_instructionVar242 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpopcntb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1495:1, end:1495:2))"]
#[derive(Clone, Debug)]
struct vpopcntd_instructionVar243 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vpopcntd_instructionVar243 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpopcntd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1499:1, end:1499:2))"]
#[derive(Clone, Debug)]
struct vpopcnth_instructionVar244 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vpopcnth_instructionVar244 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpopcnth"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1503:1, end:1503:2))"]
#[derive(Clone, Debug)]
struct vpopcntw_instructionVar245 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vpopcntw_instructionVar245 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpopcntw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1555:1, end:1555:2))"]
#[derive(Clone, Debug)]
struct vupkhsw_instructionVar246 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vupkhsw_instructionVar246 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vupkhsw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1559:1, end:1559:2))"]
#[derive(Clone, Debug)]
struct vupklsw_instructionVar247 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vupklsw_instructionVar247 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vupklsw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1582:1, end:1582:2))"]
#[derive(Clone, Debug)]
struct bcdctn__instructionVar248 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl bcdctn__instructionVar248 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdctn."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1586:1, end:1586:2))"]
#[derive(Clone, Debug)]
struct bcdctsq__instructionVar249 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl bcdctsq__instructionVar249 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdctsq."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1634:1, end:1634:2))"]
#[derive(Clone, Debug)]
struct vclzlsbb_instructionVar250 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vclzlsbb_instructionVar250 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vclzlsbb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1686:1, end:1686:2))"]
#[derive(Clone, Debug)]
struct vctzb_instructionVar251 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vctzb_instructionVar251 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vctzb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1690:1, end:1690:2))"]
#[derive(Clone, Debug)]
struct vctzh_instructionVar252 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vctzh_instructionVar252 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vctzh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1694:1, end:1694:2))"]
#[derive(Clone, Debug)]
struct vctzd_instructionVar253 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vctzd_instructionVar253 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vctzd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1698:1, end:1698:2))"]
#[derive(Clone, Debug)]
struct vctzlsbb_instructionVar254 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vctzlsbb_instructionVar254 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vctzlsbb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1702:1, end:1702:2))"]
#[derive(Clone, Debug)]
struct vctzw_instructionVar255 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vctzw_instructionVar255 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vctzw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1726:1, end:1726:2))"]
#[derive(Clone, Debug)]
struct vextsb2d_instructionVar256 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vextsb2d_instructionVar256 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextsb2d"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1730:1, end:1730:2))"]
#[derive(Clone, Debug)]
struct vextsb2w_instructionVar257 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vextsb2w_instructionVar257 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextsb2w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1734:1, end:1734:2))"]
#[derive(Clone, Debug)]
struct vextsh2d_instructionVar258 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vextsh2d_instructionVar258 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextsh2d"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1738:1, end:1738:2))"]
#[derive(Clone, Debug)]
struct vextsh2w_instructionVar259 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vextsh2w_instructionVar259 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextsh2w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1742:1, end:1742:2))"]
#[derive(Clone, Debug)]
struct vextsw2d_instructionVar260 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vextsw2d_instructionVar260 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextsw2d"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1806:1, end:1806:2))"]
#[derive(Clone, Debug)]
struct vnegd_instructionVar261 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vnegd_instructionVar261 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vnegd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1810:1, end:1810:2))"]
#[derive(Clone, Debug)]
struct vnegw_instructionVar262 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vnegw_instructionVar262 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vnegw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1818:1, end:1818:2))"]
#[derive(Clone, Debug)]
struct vprtybd_instructionVar263 {
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vprtybd_instructionVar263 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vprtybd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1822:1, end:1822:2))"]
#[derive(Clone, Debug)]
struct vprtybq_instructionVar264 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vprtybq_instructionVar264 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vprtybq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1826:1, end:1826:2))"]
#[derive(Clone, Debug)]
struct vprtybw_instructionVar265 {
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vprtybw_instructionVar265 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vprtybw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:997:1, end:997:2))"]
#[derive(Clone, Debug)]
struct vspltw_instructionVar266 {
    UIMW: u8,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vspltw_instructionVar266 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vspltw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMW as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMW = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, UIMW }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:972:1, end:972:2))"]
#[derive(Clone, Debug)]
struct vsplth_instructionVar267 {
    UIMH: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vsplth_instructionVar267 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsplth"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMH as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMH = token_40(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, UIMH }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2995:1, end:2995:2))"]
#[derive(Clone, Debug)]
struct mfocrf_instructionVar268 {
    D: u8,
    CRM_CR: TableCRM_CR,
}
impl mfocrf_instructionVar268 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfocrf"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.CRM_CR
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CRM_CR = if let Some((len, table)) =
            TableCRM_CR::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let BIT_11 = token_12(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRM_CR, D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4033:1, end:4033:2))"]
#[derive(Clone, Debug)]
struct stfdux_instructionVar269 {
    fS: u8,
    A: u8,
    B: u8,
}
impl stfdux_instructionVar269 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stfdux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fS),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let fS = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fS, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4041:1, end:4041:2))"]
#[derive(Clone, Debug)]
struct stfdx_instructionVar270 {
    fS: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stfdx_instructionVar270 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stfdx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fS),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fS = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, fS, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4048:1, end:4048:2))"]
#[derive(Clone, Debug)]
struct stfiwx_instructionVar271 {
    fS: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stfiwx_instructionVar271 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stfiwx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fS),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fS = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, fS, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4072:1, end:4072:2))"]
#[derive(Clone, Debug)]
struct stfsux_instructionVar272 {
    fS: u8,
    A: u8,
    B: u8,
}
impl stfsux_instructionVar272 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stfsux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fS),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let fS = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fS, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4081:1, end:4081:2))"]
#[derive(Clone, Debug)]
struct stfsx_instructionVar273 {
    fS: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stfsx_instructionVar273 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stfsx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fS),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let fS = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, fS, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:27:1, end:27:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar274 {
    S: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stswi_instructionVar274 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let NB = token_4(tokens_current);
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, NB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:40:1, end:40:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar275 {
    S: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
}
impl stswi_instructionVar275 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let S = token_51(tokens_current);
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:58:1, end:58:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar276 {
    S: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
}
impl stswi_instructionVar276 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let BH = token_10(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S1,
                DYN_S2,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:77:1, end:77:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar277 {
    S: u8,
    NB: u8,
    DYN_S3: TableDYN_S3,
    DYN_S1: TableDYN_S1,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S2: TableDYN_S2,
}
impl stswi_instructionVar277 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) =
            TableDYN_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let BH = token_10(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_S3,
                DYN_S1,
                RA_OR_ZERO,
                DYN_S2,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:98:1, end:98:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar278 {
    S: u8,
    NB: u8,
    DYN_S3: TableDYN_S3,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S4: TableDYN_S4,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stswi_instructionVar278 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) =
            TableDYN_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) =
            TableDYN_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let NB = token_4(tokens_current);
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_S3,
                DYN_S1,
                DYN_S2,
                DYN_S4,
                RA_OR_ZERO,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:121:1, end:121:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar279 {
    S: u8,
    NB: u8,
    DYN_S2: TableDYN_S2,
    DYN_S4: TableDYN_S4,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S3: TableDYN_S3,
    DYN_S1: TableDYN_S1,
    DYN_S5: TableDYN_S5,
}
impl stswi_instructionVar279 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) =
            TableDYN_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) =
            TableDYN_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) =
            TableDYN_S5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let S = token_51(tokens_current);
        let BH = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_S2,
                DYN_S4,
                RA_OR_ZERO,
                DYN_S3,
                DYN_S1,
                DYN_S5,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:146:1, end:146:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar280 {
    S: u8,
    NB: u8,
    DYN_S5: TableDYN_S5,
    DYN_S6: TableDYN_S6,
    DYN_S2: TableDYN_S2,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S3: TableDYN_S3,
    DYN_S4: TableDYN_S4,
    DYN_S1: TableDYN_S1,
}
impl stswi_instructionVar280 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) =
            TableDYN_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) =
            TableDYN_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) =
            TableDYN_S5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S6 = if let Some((len, table)) =
            TableDYN_S6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let BH = token_10(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DYN_S5,
                DYN_S6,
                DYN_S2,
                RA_OR_ZERO,
                DYN_S3,
                DYN_S4,
                DYN_S1,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:173:1, end:173:2))"]
#[derive(Clone, Debug)]
struct stswi_instructionVar281 {
    S: u8,
    NB: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    DYN_S6: TableDYN_S6,
    DYN_S7: TableDYN_S7,
    DYN_S4: TableDYN_S4,
    DYN_S5: TableDYN_S5,
    DYN_S1: TableDYN_S1,
    DYN_S2: TableDYN_S2,
    DYN_S3: TableDYN_S3,
}
impl stswi_instructionVar281 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswi"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.NB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S1 = if let Some((len, table)) =
            TableDYN_S1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S2 = if let Some((len, table)) =
            TableDYN_S2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S3 = if let Some((len, table)) =
            TableDYN_S3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S4 = if let Some((len, table)) =
            TableDYN_S4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S5 = if let Some((len, table)) =
            TableDYN_S5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S6 = if let Some((len, table)) =
            TableDYN_S6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let DYN_S7 = if let Some((len, table)) =
            TableDYN_S7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BH = token_10(tokens_current);
        let S = token_51(tokens_current);
        let NB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                DYN_S6,
                DYN_S7,
                DYN_S4,
                DYN_S5,
                DYN_S1,
                DYN_S2,
                DYN_S3,
                S,
                NB,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4519:1, end:4519:2))"]
#[derive(Clone, Debug)]
struct xor__instructionVar282 {
    A: u8,
    S: u8,
    B: u8,
}
impl xor__instructionVar282 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xor."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:67:1, end:67:2))"]
#[derive(Clone, Debug)]
struct icbt_instructionVar283 {
    BITS_21_24: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl icbt_instructionVar283 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("icbt"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BITS_21_24 as u64),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let BITS_21_24 = token_50(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                BITS_21_24,
                B,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:190:1, end:190:2))"]
#[derive(Clone, Debug)]
struct tlbsx__instructionVar284 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl tlbsx__instructionVar284 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbsx."));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:964:1, end:964:2))"]
#[derive(Clone, Debug)]
struct vspltb_instructionVar285 {
    UIMB: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vspltb_instructionVar285 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vspltb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMB = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, UIMB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1706:1, end:1706:2))"]
#[derive(Clone, Debug)]
struct vextractd_instructionVar286 {
    UIMB: u8,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vextractd_instructionVar286 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextractd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMB = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, UIMB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1711:1, end:1711:2))"]
#[derive(Clone, Debug)]
struct vextractub_instructionVar287 {
    UIMB: u8,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vextractub_instructionVar287 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextractub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMB = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, UIMB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1716:1, end:1716:2))"]
#[derive(Clone, Debug)]
struct vextractuh_instructionVar288 {
    UIMB: u8,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vextractuh_instructionVar288 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextractuh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMB = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, UIMB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1721:1, end:1721:2))"]
#[derive(Clone, Debug)]
struct vextractuw_instructionVar289 {
    UIMB: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vextractuw_instructionVar289 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextractuw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMB = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, UIMB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1774:1, end:1774:2))"]
#[derive(Clone, Debug)]
struct vinsertb_instructionVar290 {
    UIMB: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vinsertb_instructionVar290 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vinsertb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMB = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, UIMB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1778:1, end:1778:2))"]
#[derive(Clone, Debug)]
struct vinsertd_instructionVar291 {
    UIMB: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vinsertd_instructionVar291 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vinsertd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMB = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, UIMB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1782:1, end:1782:2))"]
#[derive(Clone, Debug)]
struct vinserth_instructionVar292 {
    UIMB: u8,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vinserth_instructionVar292 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vinserth"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMB = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, UIMB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1786:1, end:1786:2))"]
#[derive(Clone, Debug)]
struct vinsertw_instructionVar293 {
    UIMB: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vinsertw_instructionVar293 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vinsertw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UIMB = token_41(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, UIMB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:6:1, end:6:2))"]
#[derive(Clone, Debug)]
struct add_instructionVar294 {
    D: u8,
    A: u8,
    B: u8,
}
impl add_instructionVar294 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:12:1, end:12:2))"]
#[derive(Clone, Debug)]
struct add__instructionVar295 {
    D: u8,
    A: u8,
    B: u8,
}
impl add__instructionVar295 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:19:1, end:19:2))"]
#[derive(Clone, Debug)]
struct addo_instructionVar296 {
    D: u8,
    A: u8,
    B: u8,
}
impl addo_instructionVar296 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:26:1, end:26:2))"]
#[derive(Clone, Debug)]
struct addo__instructionVar297 {
    D: u8,
    A: u8,
    B: u8,
}
impl addo__instructionVar297 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:34:1, end:34:2))"]
#[derive(Clone, Debug)]
struct addc_instructionVar298 {
    D: u8,
    A: u8,
    B: u8,
}
impl addc_instructionVar298 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addc"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:41:1, end:41:2))"]
#[derive(Clone, Debug)]
struct addc__instructionVar299 {
    D: u8,
    A: u8,
    B: u8,
}
impl addc__instructionVar299 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addc."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:49:1, end:49:2))"]
#[derive(Clone, Debug)]
struct addco_instructionVar300 {
    D: u8,
    A: u8,
    B: u8,
}
impl addco_instructionVar300 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addco"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:57:1, end:57:2))"]
#[derive(Clone, Debug)]
struct addco__instructionVar301 {
    D: u8,
    A: u8,
    B: u8,
}
impl addco__instructionVar301 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addco."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:66:1, end:66:2))"]
#[derive(Clone, Debug)]
struct adde_instructionVar302 {
    D: u8,
    A: u8,
    B: u8,
}
impl adde_instructionVar302 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adde"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:74:1, end:74:2))"]
#[derive(Clone, Debug)]
struct adde__instructionVar303 {
    D: u8,
    A: u8,
    B: u8,
}
impl adde__instructionVar303 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adde."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:83:1, end:83:2))"]
#[derive(Clone, Debug)]
struct addeo_instructionVar304 {
    D: u8,
    A: u8,
    B: u8,
}
impl addeo_instructionVar304 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addeo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:92:1, end:92:2))"]
#[derive(Clone, Debug)]
struct addeo__instructionVar305 {
    D: u8,
    A: u8,
    B: u8,
}
impl addeo__instructionVar305 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addeo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3720:1, end:3720:2))"]
#[derive(Clone, Debug)]
struct sc_instructionVar306 {
    LEV: u8,
}
impl sc_instructionVar306 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sc"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.LEV as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let LEV = token_77(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LEV }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:109:1, end:109:2))"]
#[derive(Clone, Debug)]
struct li_instructionVar307 {
    D: u8,
    SIMM: u16,
}
impl li_instructionVar307 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("li"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let SIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:115:1, end:115:2))"]
#[derive(Clone, Debug)]
struct li_instructionVar308 {
    D: u8,
    SIMM: u16,
}
impl li_instructionVar308 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("li"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SIMM = token_84(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:163:1, end:163:2))"]
#[derive(Clone, Debug)]
struct lis_instructionVar309 {
    D: u8,
    SIMM: u16,
}
impl lis_instructionVar309 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lis"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SIMM = token_84(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:169:1, end:169:2))"]
#[derive(Clone, Debug)]
struct lis_instructionVar310 {
    D: u8,
    SIMM: u16,
}
impl lis_instructionVar310 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lis"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SIMM = token_84(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:370:1, end:370:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar311 {
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl bl_instructionVar311 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addressBD, REL_ABS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1576:1, end:1576:2))"]
#[derive(Clone, Debug)]
struct fmul_instructionVar312 {
    fD: u8,
    fA: u8,
    fC: u8,
}
impl fmul_instructionVar312 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fC = token_62(tokens_current);
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1584:1, end:1584:2))"]
#[derive(Clone, Debug)]
struct fmul__instructionVar313 {
    fD: u8,
    fA: u8,
    fC: u8,
}
impl fmul__instructionVar313 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fC = token_62(tokens_current);
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1594:1, end:1594:2))"]
#[derive(Clone, Debug)]
struct fmuls_instructionVar314 {
    fD: u8,
    fA: u8,
    fC: u8,
}
impl fmuls_instructionVar314 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmuls"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fC = token_62(tokens_current);
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1604:1, end:1604:2))"]
#[derive(Clone, Debug)]
struct fmuls__instructionVar315 {
    fD: u8,
    fA: u8,
    fC: u8,
}
impl fmuls__instructionVar315 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmuls."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        let fC = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:103:1, end:103:2))"]
#[derive(Clone, Debug)]
struct addi_instructionVar316 {
    D: u8,
    A: u8,
    SIMM: u16,
}
impl addi_instructionVar316 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addi"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let SIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:121:1, end:121:2))"]
#[derive(Clone, Debug)]
struct subi_instructionVar317 {
    D: u8,
    A: u8,
    SIMM: u16,
}
impl subi_instructionVar317 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_tmp: i128 = 0;
        calc_tmp = (-i128::try_from(
            (if self.SIMM & 32768 != 0 {
                -1 & !32767
            } else {
                0
            } | self.SIMM as i16),
        )
        .unwrap());
        display.push(DisplayElement::Literal("subi"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Number(true, calc_tmp.is_negative(), calc_tmp.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_tmp: i128 = 0;
        let mut block_0_len = 4;
        calc_tmp = (-i128::try_from(token_84(tokens_current)).unwrap());
        let SIMM = token_84(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:127:1, end:127:2))"]
#[derive(Clone, Debug)]
struct addic_instructionVar318 {
    D: u8,
    A: u8,
    SIMM: u16,
}
impl addic_instructionVar318 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addic"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let SIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:134:1, end:134:2))"]
#[derive(Clone, Debug)]
struct subic_instructionVar319 {
    D: u8,
    A: u8,
    SIMM: u16,
}
impl subic_instructionVar319 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_tmp: i128 = 0;
        calc_tmp = (-i128::try_from(
            (if self.SIMM & 32768 != 0 {
                -1 & !32767
            } else {
                0
            } | self.SIMM as i16),
        )
        .unwrap());
        display.push(DisplayElement::Literal("subic"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Number(true, calc_tmp.is_negative(), calc_tmp.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_tmp: i128 = 0;
        let mut block_0_len = 4;
        calc_tmp = (-i128::try_from(token_84(tokens_current)).unwrap());
        let A = token_1(tokens_current);
        let SIMM = token_84(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:141:1, end:141:2))"]
#[derive(Clone, Debug)]
struct addic__instructionVar320 {
    D: u8,
    A: u8,
    SIMM: u16,
}
impl addic__instructionVar320 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addic."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let SIMM = token_84(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:149:1, end:149:2))"]
#[derive(Clone, Debug)]
struct subic__instructionVar321 {
    D: u8,
    A: u8,
    SIMM: u16,
}
impl subic__instructionVar321 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_tmp: i128 = 0;
        calc_tmp = (-i128::try_from(
            (if self.SIMM & 32768 != 0 {
                -1 & !32767
            } else {
                0
            } | self.SIMM as i16),
        )
        .unwrap());
        display.push(DisplayElement::Literal("subic."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Number(true, calc_tmp.is_negative(), calc_tmp.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_tmp: i128 = 0;
        let mut block_0_len = 4;
        calc_tmp = (-i128::try_from(token_84(tokens_current)).unwrap());
        let D = token_51(tokens_current);
        let SIMM = token_84(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:157:1, end:157:2))"]
#[derive(Clone, Debug)]
struct addis_instructionVar322 {
    D: u8,
    A: u8,
    SIMM: u16,
}
impl addis_instructionVar322 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addis"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let SIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:175:1, end:175:2))"]
#[derive(Clone, Debug)]
struct subis_instructionVar323 {
    D: u8,
    A: u8,
    SIMM: u16,
}
impl subis_instructionVar323 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_tmp: i128 = 0;
        calc_tmp = (-i128::try_from(
            (if self.SIMM & 32768 != 0 {
                -1 & !32767
            } else {
                0
            } | self.SIMM as i16),
        )
        .unwrap());
        display.push(DisplayElement::Literal("subis"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Number(true, calc_tmp.is_negative(), calc_tmp.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_tmp: i128 = 0;
        let mut block_0_len = 4;
        calc_tmp = (-i128::try_from(token_84(tokens_current)).unwrap());
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let SIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:261:1, end:261:2))"]
#[derive(Clone, Debug)]
struct and_instructionVar324 {
    A: u8,
    S: u8,
    B: u8,
}
impl and_instructionVar324 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:267:1, end:267:2))"]
#[derive(Clone, Debug)]
struct and__instructionVar325 {
    A: u8,
    S: u8,
    B: u8,
}
impl and__instructionVar325 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:274:1, end:274:2))"]
#[derive(Clone, Debug)]
struct andc_instructionVar326 {
    A: u8,
    S: u8,
    B: u8,
}
impl andc_instructionVar326 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andc"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:280:1, end:280:2))"]
#[derive(Clone, Debug)]
struct andc__instructionVar327 {
    A: u8,
    S: u8,
    B: u8,
}
impl andc__instructionVar327 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andc."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:379:1, end:379:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar328 {
    REL_ABS: TableREL_ABS,
    CC: TableCC,
    addressBD: TableaddressBD,
}
impl b_instructionVar328 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                REL_ABS,
                CC,
                addressBD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:394:1, end:394:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar329 {
    REL_ABS: TableREL_ABS,
    CC: TableCC,
    addressBD: TableaddressBD,
}
impl b_instructionVar329 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                REL_ABS,
                CC,
                addressBD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:345:1, end:345:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar330 {
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl b_instructionVar330 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addressBD, REL_ABS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:361:1, end:361:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar331 {
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
}
impl bl_instructionVar331 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bl"));
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addressBD, REL_ABS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:404:1, end:404:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar332 {
    BI_CR: u8,
    REL_ABS: TableREL_ABS,
    addressBD: TableaddressBD,
    CC: TableCC,
}
impl b_instructionVar332 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.BI_CR),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                REL_ABS,
                addressBD,
                CC,
                BI_CR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:412:1, end:412:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar333 {
    BI_CR: u8,
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
    CC: TableCC,
}
impl b_instructionVar333 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.BI_CR),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addressBD,
                REL_ABS,
                CC,
                BI_CR,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:422:1, end:422:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar334 {
    CTR_DEC: TableCTR_DEC,
    REL_ABS: TableREL_ABS,
    addressBD: TableaddressBD,
}
impl bd_instructionVar334 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CTR_DEC,
                REL_ABS,
                addressBD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:429:1, end:429:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar335 {
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
    CTR_DEC: TableCTR_DEC,
}
impl bd_instructionVar335 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addressBD,
                REL_ABS,
                CTR_DEC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:439:1, end:439:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar336 {
    CTR_DEC: TableCTR_DEC,
    CC_TF: TableCC_TF,
    REL_ABS: TableREL_ABS,
    CC_OP: TableCC_OP,
    addressBD: TableaddressBD,
}
impl bd_instructionVar336 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.CC_TF
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CTR_DEC,
                CC_TF,
                REL_ABS,
                CC_OP,
                addressBD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:446:1, end:446:2))"]
#[derive(Clone, Debug)]
struct bd_instructionVar337 {
    CTR_DEC: TableCTR_DEC,
    CC_TF: TableCC_TF,
    CC_OP: TableCC_OP,
    REL_ABS: TableREL_ABS,
    addressBD: TableaddressBD,
}
impl bd_instructionVar337 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bd"));
        self.CTR_DEC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.CC_TF
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.CC_OP
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC_TF = if let Some((len, table)) =
            TableCC_TF::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CTR_DEC = if let Some((len, table)) =
            TableCTR_DEC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let CC_OP = if let Some((len, table)) =
            TableCC_OP::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                CTR_DEC,
                CC_TF,
                CC_OP,
                REL_ABS,
                addressBD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1396:1, end:1396:2))"]
#[derive(Clone, Debug)]
struct fmadd_instructionVar338 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fmadd_instructionVar338 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmadd"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        let fC = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1416:1, end:1416:2))"]
#[derive(Clone, Debug)]
struct fmadd__instructionVar339 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fmadd__instructionVar339 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmadd."));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        let fC = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1437:1, end:1437:2))"]
#[derive(Clone, Debug)]
struct fmadds_instructionVar340 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fmadds_instructionVar340 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmadds"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        let fC = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1458:1, end:1458:2))"]
#[derive(Clone, Debug)]
struct fmadds__instructionVar341 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fmadds__instructionVar341 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmadds."));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fC = token_62(tokens_current);
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1491:1, end:1491:2))"]
#[derive(Clone, Debug)]
struct fmsub_instructionVar342 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fmsub_instructionVar342 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmsub"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fC = token_62(tokens_current);
        let fA = token_1(tokens_current);
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1511:1, end:1511:2))"]
#[derive(Clone, Debug)]
struct fmsub__instructionVar343 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fmsub__instructionVar343 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmsub."));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fC = token_62(tokens_current);
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1533:1, end:1533:2))"]
#[derive(Clone, Debug)]
struct fmsubs_instructionVar344 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fmsubs_instructionVar344 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmsubs"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fA = token_1(tokens_current);
        let fC = token_62(tokens_current);
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1554:1, end:1554:2))"]
#[derive(Clone, Debug)]
struct fmsubs__instructionVar345 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fmsubs__instructionVar345 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmsubs."));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        let fC = token_62(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1641:1, end:1641:2))"]
#[derive(Clone, Debug)]
struct fnmadd_instructionVar346 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fnmadd_instructionVar346 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnmadd"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fC = token_62(tokens_current);
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1661:1, end:1661:2))"]
#[derive(Clone, Debug)]
struct fnmadd__instructionVar347 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fnmadd__instructionVar347 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnmadd."));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fC = token_62(tokens_current);
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1682:1, end:1682:2))"]
#[derive(Clone, Debug)]
struct fnmadds_instructionVar348 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fnmadds_instructionVar348 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnmadds"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fA = token_1(tokens_current);
        let fD = token_51(tokens_current);
        let fC = token_62(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1703:1, end:1703:2))"]
#[derive(Clone, Debug)]
struct fnmadds__instructionVar349 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fnmadds__instructionVar349 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnmadds."));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fC = token_62(tokens_current);
        let fA = token_1(tokens_current);
        let fB = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1725:1, end:1725:2))"]
#[derive(Clone, Debug)]
struct fnmsub_instructionVar350 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fnmsub_instructionVar350 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnmsub"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fC = token_62(tokens_current);
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1745:1, end:1745:2))"]
#[derive(Clone, Debug)]
struct fnmsub__instructionVar351 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fnmsub__instructionVar351 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnmsub."));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fC = token_62(tokens_current);
        let fD = token_51(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1767:1, end:1767:2))"]
#[derive(Clone, Debug)]
struct fnmsubs_instructionVar352 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fnmsubs_instructionVar352 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnmsubs"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fB = token_4(tokens_current);
        let fA = token_1(tokens_current);
        let fC = token_62(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1788:1, end:1788:2))"]
#[derive(Clone, Debug)]
struct fnmsubs__instructionVar353 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fnmsubs__instructionVar353 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnmsubs."));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fC = token_62(tokens_current);
        let fB = token_4(tokens_current);
        let fA = token_1(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1922:1, end:1922:2))"]
#[derive(Clone, Debug)]
struct fsel_instructionVar354 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fsel_instructionVar354 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsel"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fC = token_62(tokens_current);
        let fB = token_4(tokens_current);
        let fA = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1933:1, end:1933:2))"]
#[derive(Clone, Debug)]
struct fsel__instructionVar355 {
    fD: u8,
    fA: u8,
    fC: u8,
    fB: u8,
}
impl fsel__instructionVar355 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsel."));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fA),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fC),
            <DisplayElement>::Literal(","),
            meaning_6_display(self.fB),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let fD = token_51(tokens_current);
        let fB = token_4(tokens_current);
        let fA = token_1(tokens_current);
        let fC = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fD, fA, fC, fB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3537:1, end:3537:2))"]
#[derive(Clone, Debug)]
struct rldcl_instructionVar356 {
    A: u8,
    S: u8,
    B: u8,
    MB: TableMB,
}
impl rldcl_instructionVar356 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldcl"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { MB, A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3544:1, end:3544:2))"]
#[derive(Clone, Debug)]
struct rldcl__instructionVar357 {
    A: u8,
    S: u8,
    B: u8,
    MB: TableMB,
}
impl rldcl__instructionVar357 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldcl."));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { MB, A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3552:1, end:3552:2))"]
#[derive(Clone, Debug)]
struct rldcr_instructionVar358 {
    A: u8,
    S: u8,
    B: u8,
    MB: TableMB,
    rotmask_Z: Tablerotmask_Z,
}
impl rldcr_instructionVar358 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldcr"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rotmask_Z = if let Some((len, table)) =
            Tablerotmask_Z::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                MB,
                rotmask_Z,
                A,
                S,
                B,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3559:1, end:3559:2))"]
#[derive(Clone, Debug)]
struct rldcr__instructionVar359 {
    A: u8,
    S: u8,
    B: u8,
    MB: TableMB,
    rotmask_Z: Tablerotmask_Z,
}
impl rldcr__instructionVar359 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldcr."));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rotmask_Z = if let Some((len, table)) =
            Tablerotmask_Z::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                MB,
                rotmask_Z,
                A,
                S,
                B,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2096:1, end:2096:2))"]
#[derive(Clone, Debug)]
struct ld_instructionVar360 {
    D: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl ld_instructionVar360 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ld"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                D,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2111:1, end:2111:2))"]
#[derive(Clone, Debug)]
struct ldu_instructionVar361 {
    D: u8,
    dsPlusRaAddress: TabledsPlusRaAddress,
}
impl ldu_instructionVar361 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dsPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dsPlusRaAddress = if let Some((len, table)) =
            TabledsPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dsPlusRaAddress, D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2265:1, end:2265:2))"]
#[derive(Clone, Debug)]
struct lwa_instructionVar362 {
    D: u8,
    dsPlusRaOrZeroAddress: TabledsPlusRaOrZeroAddress,
}
impl lwa_instructionVar362 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwa"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dsPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dsPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledsPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dsPlusRaOrZeroAddress,
                D,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3568:1, end:3568:2))"]
#[derive(Clone, Debug)]
struct rldic_instructionVar363 {
    A: u8,
    S: u8,
    MB: TableMB,
    rotmask_SH: Tablerotmask_SH,
    SH: TableSH,
}
impl rldic_instructionVar363 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldic"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SH
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SH = if let Some((len, table)) =
            TableSH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rotmask_SH = if let Some((len, table)) =
            Tablerotmask_SH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                MB,
                rotmask_SH,
                SH,
                A,
                S,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3575:1, end:3575:2))"]
#[derive(Clone, Debug)]
struct rldic__instructionVar364 {
    A: u8,
    S: u8,
    SH: TableSH,
    MB: TableMB,
    rotmask_SH: Tablerotmask_SH,
}
impl rldic__instructionVar364 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldic."));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SH
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SH = if let Some((len, table)) =
            TableSH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rotmask_SH = if let Some((len, table)) =
            Tablerotmask_SH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SH,
                MB,
                rotmask_SH,
                A,
                S,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3584:1, end:3584:2))"]
#[derive(Clone, Debug)]
struct rldicl_instructionVar365 {
    A: u8,
    S: u8,
    SH: TableSH,
    MB: TableMB,
}
impl rldicl_instructionVar365 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldicl"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SH
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SH = if let Some((len, table)) =
            TableSH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SH, MB, A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3591:1, end:3591:2))"]
#[derive(Clone, Debug)]
struct rldicl__instructionVar366 {
    A: u8,
    S: u8,
    SH: TableSH,
    MB: TableMB,
}
impl rldicl__instructionVar366 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldicl."));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SH
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SH = if let Some((len, table)) =
            TableSH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SH, MB, A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3599:1, end:3599:2))"]
#[derive(Clone, Debug)]
struct rldicr_instructionVar367 {
    A: u8,
    S: u8,
    MB: TableMB,
    SH: TableSH,
}
impl rldicr_instructionVar367 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldicr"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SH
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SH = if let Some((len, table)) =
            TableSH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { MB, SH, A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3606:1, end:3606:2))"]
#[derive(Clone, Debug)]
struct rldicr__instructionVar368 {
    A: u8,
    S: u8,
    MB: TableMB,
    SH: TableSH,
}
impl rldicr__instructionVar368 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldicr."));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SH
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SH = if let Some((len, table)) =
            TableSH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { MB, SH, A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3614:1, end:3614:2))"]
#[derive(Clone, Debug)]
struct rldimi_instructionVar369 {
    A: u8,
    S: u8,
    MB: TableMB,
    SH: TableSH,
    rotmask_SH: Tablerotmask_SH,
}
impl rldimi_instructionVar369 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldimi"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SH
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SH = if let Some((len, table)) =
            TableSH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rotmask_SH = if let Some((len, table)) =
            Tablerotmask_SH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                MB,
                SH,
                rotmask_SH,
                A,
                S,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3621:1, end:3621:2))"]
#[derive(Clone, Debug)]
struct rldimi__instructionVar370 {
    A: u8,
    S: u8,
    SH: TableSH,
    rotmask_SH: Tablerotmask_SH,
    MB: TableMB,
}
impl rldimi__instructionVar370 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rldimi."));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SH
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.MB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SH = if let Some((len, table)) =
            TableSH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MB = if let Some((len, table)) =
            TableMB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let rotmask_SH = if let Some((len, table)) =
            Tablerotmask_SH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                SH,
                rotmask_SH,
                MB,
                A,
                S,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3968:1, end:3968:2))"]
#[derive(Clone, Debug)]
struct std_instructionVar371 {
    S: u8,
    dsPlusRaOrZeroAddress: TabledsPlusRaOrZeroAddress,
}
impl std_instructionVar371 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("std"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dsPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dsPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledsPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dsPlusRaOrZeroAddress,
                S,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3993:1, end:3993:2))"]
#[derive(Clone, Debug)]
struct stdu_instructionVar372 {
    S: u8,
    dsPlusRaAddress: TabledsPlusRaAddress,
}
impl stdu_instructionVar372 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stdu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dsPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dsPlusRaAddress = if let Some((len, table)) =
            TabledsPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dsPlusRaAddress, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:306:1, end:306:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar373 {
    addressLI: TableaddressLI,
    REL_ABS: TableREL_ABS,
}
impl b_instructionVar373 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressLI
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressLI = if let Some((len, table)) =
            TableaddressLI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addressLI, REL_ABS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:322:1, end:322:2))"]
#[derive(Clone, Debug)]
struct bl_instructionVar374 {
    addressLI: TableaddressLI,
    REL_ABS: TableREL_ABS,
}
impl bl_instructionVar374 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("bl"));
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressLI
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressLI = if let Some((len, table)) =
            TableaddressLI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addressLI, REL_ABS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:753:1, end:753:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar375 {
    A: u8,
    SIMM: u16,
    REG_A: TableREG_A,
    DSIZE: TableDSIZE,
}
impl cmp_instructionVar375 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.DSIZE
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("i"),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REG_A = if let Some((len, table)) =
            TableREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let SIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                REG_A,
                DSIZE,
                A,
                SIMM,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:793:1, end:793:2))"]
#[derive(Clone, Debug)]
struct cmpl_instructionVar376 {
    A: u8,
    UIMM: u16,
    UREG_A: TableUREG_A,
    DSIZE: TableDSIZE,
}
impl cmpl_instructionVar376 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpl"));
        self.DSIZE
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("i"),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UREG_A = if let Some((len, table)) =
            TableUREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let UIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                UREG_A,
                DSIZE,
                A,
                UIMM,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:763:1, end:763:2))"]
#[derive(Clone, Debug)]
struct cmp_instructionVar377 {
    CRFD: u8,
    A: u8,
    SIMM: u16,
    DSIZE: TableDSIZE,
    REG_A: TableREG_A,
}
impl cmp_instructionVar377 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp"));
        self.DSIZE
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal("i"),
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.CRFD),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REG_A = if let Some((len, table)) =
            TableREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SIMM = token_84(tokens_current);
        let A = token_1(tokens_current);
        let CRFD = token_9(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                DSIZE,
                REG_A,
                CRFD,
                A,
                SIMM,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:803:1, end:803:2))"]
#[derive(Clone, Debug)]
struct cmpl_instructionVar378 {
    CRFD: u8,
    A: u8,
    UIMM: u16,
    UREG_A: TableUREG_A,
    DSIZE: TableDSIZE,
}
impl cmpl_instructionVar378 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpl"));
        self.DSIZE
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal("i"),
            <DisplayElement>::Literal(" "),
            meaning_4_display(self.CRFD),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let DSIZE = if let Some((len, table)) =
            TableDSIZE::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UREG_A = if let Some((len, table)) =
            TableUREG_A::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let UIMM = token_84(tokens_current);
        let CRFD = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                UREG_A,
                DSIZE,
                CRFD,
                A,
                UIMM,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3633:1, end:3633:2))"]
#[derive(Clone, Debug)]
struct rlwimi_instructionVar379 {
    A: u8,
    S: u8,
    SHL: u8,
    MBL: u8,
    ME: u8,
    rotmask: Tablerotmask,
}
impl rlwimi_instructionVar379 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rlwimi"));
        let extend: [DisplayElement; 10usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.SHL as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.MBL as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.ME as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rotmask = if let Some((len, table)) =
            Tablerotmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SHL = token_4(tokens_current);
        let MBL = token_62(tokens_current);
        let ME = token_79(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                A,
                S,
                SHL,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3647:1, end:3647:2))"]
#[derive(Clone, Debug)]
struct rlwimi__instructionVar380 {
    A: u8,
    S: u8,
    SHL: u8,
    MBL: u8,
    ME: u8,
    rotmask: Tablerotmask,
}
impl rlwimi__instructionVar380 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rlwimi."));
        let extend: [DisplayElement; 10usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.SHL as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.MBL as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.ME as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rotmask = if let Some((len, table)) =
            Tablerotmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MBL = token_62(tokens_current);
        let ME = token_79(tokens_current);
        let A = token_1(tokens_current);
        let SHL = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                A,
                S,
                SHL,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3662:1, end:3662:2))"]
#[derive(Clone, Debug)]
struct rlwinm_instructionVar381 {
    A: u8,
    S: u8,
    SHL: u8,
    MBL: u8,
    ME: u8,
    rotmask: Tablerotmask,
}
impl rlwinm_instructionVar381 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rlwinm"));
        let extend: [DisplayElement; 10usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.SHL as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.MBL as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.ME as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rotmask = if let Some((len, table)) =
            Tablerotmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SHL = token_4(tokens_current);
        let S = token_51(tokens_current);
        let MBL = token_62(tokens_current);
        let ME = token_79(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                A,
                S,
                SHL,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3676:1, end:3676:2))"]
#[derive(Clone, Debug)]
struct rlwinm__instructionVar382 {
    A: u8,
    S: u8,
    SHL: u8,
    MBL: u8,
    ME: u8,
    rotmask: Tablerotmask,
}
impl rlwinm__instructionVar382 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rlwinm."));
        let extend: [DisplayElement; 10usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.SHL as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.MBL as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.ME as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rotmask = if let Some((len, table)) =
            Tablerotmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let MBL = token_62(tokens_current);
        let A = token_1(tokens_current);
        let SHL = token_4(tokens_current);
        let ME = token_79(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                A,
                S,
                SHL,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3691:1, end:3691:2))"]
#[derive(Clone, Debug)]
struct rlwnm_instructionVar383 {
    A: u8,
    S: u8,
    B: u8,
    MBL: u8,
    ME: u8,
    rotmask: Tablerotmask,
}
impl rlwnm_instructionVar383 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rlwnm"));
        let extend: [DisplayElement; 10usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.MBL as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.ME as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rotmask = if let Some((len, table)) =
            Tablerotmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ME = token_79(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        let MBL = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                A,
                S,
                B,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3705:1, end:3705:2))"]
#[derive(Clone, Debug)]
struct rlwnm__instructionVar384 {
    A: u8,
    S: u8,
    B: u8,
    MBL: u8,
    ME: u8,
    rotmask: Tablerotmask,
}
impl rlwnm__instructionVar384 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rlwnm."));
        let extend: [DisplayElement; 10usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.MBL as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.ME as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let rotmask = if let Some((len, table)) =
            Tablerotmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let MBL = token_62(tokens_current);
        let ME = token_79(tokens_current);
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rotmask,
                A,
                S,
                B,
                MBL,
                ME,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:287:1, end:287:2))"]
#[derive(Clone, Debug)]
struct andi__instructionVar385 {
    A: u8,
    S: u8,
    UIMM: u16,
}
impl andi__instructionVar385 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andi."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        let UIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, UIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:294:1, end:294:2))"]
#[derive(Clone, Debug)]
struct andis__instructionVar386 {
    A: u8,
    S: u8,
    UIMM: u16,
}
impl andis__instructionVar386 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andis."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let UIMM = token_84(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, UIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:386:1, end:386:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar387 {
    addressBD: TableaddressBD,
    REL_ABS: TableREL_ABS,
    CC: TableCC,
}
impl b_instructionVar387 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.CC
            .display_extend(display, context, inst_start, inst_next, global_set);
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let CC = if let Some((len, table)) =
            TableCC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                addressBD,
                REL_ABS,
                CC,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:350:1, end:350:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar388 {
    REL_ABS: TableREL_ABS,
    addressBD: TableaddressBD,
}
impl b_instructionVar388 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressBD
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let addressBD = if let Some((len, table)) =
            TableaddressBD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REL_ABS, addressBD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:311:1, end:311:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar389 {
    REL_ABS: TableREL_ABS,
    addressLI: TableaddressLI,
}
impl b_instructionVar389 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        global_set.set(Some(inst_start), |context| {
            context.write_linkreg(
                u8::try_from(i128::try_from(context.read_linkreg()).unwrap() & 3).unwrap(),
            )
        });
        display.push(DisplayElement::Literal("b"));
        self.REL_ABS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addressLI
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_linkreg(u8::try_from(0i128 & 3).unwrap());
        let REL_ABS = if let Some((len, table)) =
            TableREL_ABS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addressLI = if let Some((len, table)) =
            TableaddressLI::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { REL_ABS, addressLI }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:916:1, end:916:2))"]
#[derive(Clone, Debug)]
struct divd_instructionVar390 {
    D: u8,
    A: u8,
    B: u8,
}
impl divd_instructionVar390 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divd"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:922:1, end:922:2))"]
#[derive(Clone, Debug)]
struct divd__instructionVar391 {
    D: u8,
    A: u8,
    B: u8,
}
impl divd__instructionVar391 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divd."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:929:1, end:929:2))"]
#[derive(Clone, Debug)]
struct divdo_instructionVar392 {
    D: u8,
    A: u8,
    B: u8,
}
impl divdo_instructionVar392 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divdo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:936:1, end:936:2))"]
#[derive(Clone, Debug)]
struct divdo__instructionVar393 {
    D: u8,
    A: u8,
    B: u8,
}
impl divdo__instructionVar393 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divdo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:945:1, end:945:2))"]
#[derive(Clone, Debug)]
struct divdu_instructionVar394 {
    D: u8,
    A: u8,
    B: u8,
}
impl divdu_instructionVar394 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divdu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:951:1, end:951:2))"]
#[derive(Clone, Debug)]
struct divdu__instructionVar395 {
    D: u8,
    A: u8,
    B: u8,
}
impl divdu__instructionVar395 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divdu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:958:1, end:958:2))"]
#[derive(Clone, Debug)]
struct divduo_instructionVar396 {
    D: u8,
    A: u8,
    B: u8,
}
impl divduo_instructionVar396 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divduo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:965:1, end:965:2))"]
#[derive(Clone, Debug)]
struct divduo__instructionVar397 {
    D: u8,
    A: u8,
    B: u8,
}
impl divduo__instructionVar397 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divduo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:975:1, end:975:2))"]
#[derive(Clone, Debug)]
struct divw_instructionVar398 {
    D: u8,
    A: u8,
    B: u8,
}
impl divw_instructionVar398 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:985:1, end:985:2))"]
#[derive(Clone, Debug)]
struct divw__instructionVar399 {
    D: u8,
    A: u8,
    B: u8,
}
impl divw__instructionVar399 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:999:1, end:999:2))"]
#[derive(Clone, Debug)]
struct divwo_instructionVar400 {
    D: u8,
    A: u8,
    B: u8,
}
impl divwo_instructionVar400 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divwo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1011:1, end:1011:2))"]
#[derive(Clone, Debug)]
struct divwo__instructionVar401 {
    D: u8,
    A: u8,
    B: u8,
}
impl divwo__instructionVar401 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divwo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1026:1, end:1026:2))"]
#[derive(Clone, Debug)]
struct divwu_instructionVar402 {
    D: u8,
    A: u8,
    B: u8,
}
impl divwu_instructionVar402 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divwu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1036:1, end:1036:2))"]
#[derive(Clone, Debug)]
struct divwu__instructionVar403 {
    D: u8,
    A: u8,
    B: u8,
}
impl divwu__instructionVar403 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divwu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1048:1, end:1048:2))"]
#[derive(Clone, Debug)]
struct divwuo_instructionVar404 {
    D: u8,
    A: u8,
    B: u8,
}
impl divwuo_instructionVar404 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divwuo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1060:1, end:1060:2))"]
#[derive(Clone, Debug)]
struct divwuo__instructionVar405 {
    D: u8,
    A: u8,
    B: u8,
}
impl divwuo__instructionVar405 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divwuo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1101:1, end:1101:2))"]
#[derive(Clone, Debug)]
struct eqv_instructionVar406 {
    A: u8,
    S: u8,
    B: u8,
}
impl eqv_instructionVar406 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eqv"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:1107:1, end:1107:2))"]
#[derive(Clone, Debug)]
struct eqv__instructionVar407 {
    A: u8,
    S: u8,
    B: u8,
}
impl eqv__instructionVar407 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eqv."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2065:1, end:2065:2))"]
#[derive(Clone, Debug)]
struct lbz_instructionVar408 {
    D: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl lbz_instructionVar408 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbz"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                D,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2072:1, end:2072:2))"]
#[derive(Clone, Debug)]
struct lbzu_instructionVar409 {
    D: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl lbzu_instructionVar409 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbzu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2080:1, end:2080:2))"]
#[derive(Clone, Debug)]
struct lbzux_instructionVar410 {
    D: u8,
    A: u8,
    B: u8,
}
impl lbzux_instructionVar410 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbzux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2088:1, end:2088:2))"]
#[derive(Clone, Debug)]
struct lbzx_instructionVar411 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lbzx_instructionVar411 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lbzx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2119:1, end:2119:2))"]
#[derive(Clone, Debug)]
struct ldux_instructionVar412 {
    D: u8,
    A: u8,
    B: u8,
}
impl ldux_instructionVar412 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2128:1, end:2128:2))"]
#[derive(Clone, Debug)]
struct ldarx_instructionVar413 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl ldarx_instructionVar413 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ldarx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2137:1, end:2137:2))"]
#[derive(Clone, Debug)]
struct lfd_instructionVar414 {
    fD: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl lfd_instructionVar414 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lfd"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                fD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2143:1, end:2143:2))"]
#[derive(Clone, Debug)]
struct lfdu_instructionVar415 {
    fD: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl lfdu_instructionVar415 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lfdu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, fD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2163:1, end:2163:2))"]
#[derive(Clone, Debug)]
struct lfs_instructionVar416 {
    fD: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl lfs_instructionVar416 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lfs"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fD = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                fD,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2168:1, end:2168:2))"]
#[derive(Clone, Debug)]
struct lfsu_instructionVar417 {
    fD: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl lfsu_instructionVar417 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lfsu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fD),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fD = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, fD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2189:1, end:2189:2))"]
#[derive(Clone, Debug)]
struct lha_instructionVar418 {
    D: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl lha_instructionVar418 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lha"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                D,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2195:1, end:2195:2))"]
#[derive(Clone, Debug)]
struct lhau_instructionVar419 {
    D: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl lhau_instructionVar419 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhau"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2202:1, end:2202:2))"]
#[derive(Clone, Debug)]
struct lhaux_instructionVar420 {
    D: u8,
    A: u8,
    B: u8,
}
impl lhaux_instructionVar420 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhaux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2209:1, end:2209:2))"]
#[derive(Clone, Debug)]
struct lhax_instructionVar421 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lhax_instructionVar421 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhax"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2215:1, end:2215:2))"]
#[derive(Clone, Debug)]
struct lhbrx_instructionVar422 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lhbrx_instructionVar422 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhbrx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2224:1, end:2224:2))"]
#[derive(Clone, Debug)]
struct lhz_instructionVar423 {
    D: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl lhz_instructionVar423 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhz"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                D,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2231:1, end:2231:2))"]
#[derive(Clone, Debug)]
struct lhzu_instructionVar424 {
    D: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl lhzu_instructionVar424 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhzu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2239:1, end:2239:2))"]
#[derive(Clone, Debug)]
struct lhzux_instructionVar425 {
    D: u8,
    A: u8,
    B: u8,
}
impl lhzux_instructionVar425 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhzux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2246:1, end:2246:2))"]
#[derive(Clone, Debug)]
struct lhzx_instructionVar426 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lhzx_instructionVar426 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lhzx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:96:1, end:96:2))"]
#[derive(Clone, Debug)]
struct lmw_instructionVar427 {
    D: u8,
    BITS_21_25: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
    LDMR31: TableLDMR31,
}
impl lmw_instructionVar427 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lmw"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_lsmul(
            u8::try_from(i128::try_from(token_51(tokens_current)).unwrap() & 31).unwrap(),
        );
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let LDMR31 = if let Some((len, table)) =
            TableLDMR31::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BITS_21_25 = token_51(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                LDMR31,
                D,
                BITS_21_25,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2259:1, end:2259:2))"]
#[derive(Clone, Debug)]
struct lswx_instructionVar428 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lswx_instructionVar428 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lswx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let NB = token_4(tokens_current);
        let D = token_51(tokens_current);
        let BITS_21_25 = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2272:1, end:2272:2))"]
#[derive(Clone, Debug)]
struct lwarx_instructionVar429 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lwarx_instructionVar429 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwarx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2286:1, end:2286:2))"]
#[derive(Clone, Debug)]
struct lwaux_instructionVar430 {
    D: u8,
    A: u8,
    B: u8,
}
impl lwaux_instructionVar430 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwaux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2293:1, end:2293:2))"]
#[derive(Clone, Debug)]
struct lwax_instructionVar431 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lwax_instructionVar431 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwax"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2300:1, end:2300:2))"]
#[derive(Clone, Debug)]
struct lwbrx_instructionVar432 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lwbrx_instructionVar432 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwbrx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2310:1, end:2310:2))"]
#[derive(Clone, Debug)]
struct lwz_instructionVar433 {
    D: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl lwz_instructionVar433 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwz"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                D,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2320:1, end:2320:2))"]
#[derive(Clone, Debug)]
struct lwzu_instructionVar434 {
    D: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl lwzu_instructionVar434 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwzu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2332:1, end:2332:2))"]
#[derive(Clone, Debug)]
struct lwzux_instructionVar435 {
    D: u8,
    A: u8,
    B: u8,
}
impl lwzux_instructionVar435 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwzux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2344:1, end:2344:2))"]
#[derive(Clone, Debug)]
struct lwzx_instructionVar436 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lwzx_instructionVar436 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lwzx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2354:1, end:2354:2))"]
#[derive(Clone, Debug)]
struct macchw_instructionVar437 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchw_instructionVar437 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2360:1, end:2360:2))"]
#[derive(Clone, Debug)]
struct macchw__instructionVar438 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchw__instructionVar438 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2367:1, end:2367:2))"]
#[derive(Clone, Debug)]
struct macchwo_instructionVar439 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwo_instructionVar439 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2375:1, end:2375:2))"]
#[derive(Clone, Debug)]
struct macchwo__instructionVar440 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwo__instructionVar440 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2384:1, end:2384:2))"]
#[derive(Clone, Debug)]
struct macchws_instructionVar441 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchws_instructionVar441 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchws"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2390:1, end:2390:2))"]
#[derive(Clone, Debug)]
struct macchws__instructionVar442 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchws__instructionVar442 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchws."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2398:1, end:2398:2))"]
#[derive(Clone, Debug)]
struct macchwso_instructionVar443 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwso_instructionVar443 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwso"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2407:1, end:2407:2))"]
#[derive(Clone, Debug)]
struct macchwso__instructionVar444 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwso__instructionVar444 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwso."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2416:1, end:2416:2))"]
#[derive(Clone, Debug)]
struct macchwsu_instructionVar445 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwsu_instructionVar445 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwsu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2422:1, end:2422:2))"]
#[derive(Clone, Debug)]
struct macchwsu__instructionVar446 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwsu__instructionVar446 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwsu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2429:1, end:2429:2))"]
#[derive(Clone, Debug)]
struct macchwsuo_instructionVar447 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwsuo_instructionVar447 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwsuo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2436:1, end:2436:2))"]
#[derive(Clone, Debug)]
struct macchwsuo__instructionVar448 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwsuo__instructionVar448 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwsuo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2444:1, end:2444:2))"]
#[derive(Clone, Debug)]
struct macchwu_instructionVar449 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwu_instructionVar449 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2450:1, end:2450:2))"]
#[derive(Clone, Debug)]
struct macchwu__instructionVar450 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwu__instructionVar450 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2457:1, end:2457:2))"]
#[derive(Clone, Debug)]
struct macchwuo_instructionVar451 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwuo_instructionVar451 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwuo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2464:1, end:2464:2))"]
#[derive(Clone, Debug)]
struct macchwuo__instructionVar452 {
    D: u8,
    A: u8,
    B: u8,
}
impl macchwuo__instructionVar452 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("macchwuo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2473:1, end:2473:2))"]
#[derive(Clone, Debug)]
struct machhw_instructionVar453 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhw_instructionVar453 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2479:1, end:2479:2))"]
#[derive(Clone, Debug)]
struct machhw__instructionVar454 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhw__instructionVar454 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2487:1, end:2487:2))"]
#[derive(Clone, Debug)]
struct machhwo_instructionVar455 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwo_instructionVar455 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2496:1, end:2496:2))"]
#[derive(Clone, Debug)]
struct machhwo__instructionVar456 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwo__instructionVar456 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2505:1, end:2505:2))"]
#[derive(Clone, Debug)]
struct machhws_instructionVar457 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhws_instructionVar457 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhws"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2511:1, end:2511:2))"]
#[derive(Clone, Debug)]
struct machhws__instructionVar458 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhws__instructionVar458 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhws."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2518:1, end:2518:2))"]
#[derive(Clone, Debug)]
struct machhwso_instructionVar459 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwso_instructionVar459 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwso"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2525:1, end:2525:2))"]
#[derive(Clone, Debug)]
struct machhwso__instructionVar460 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwso__instructionVar460 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwso."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2533:1, end:2533:2))"]
#[derive(Clone, Debug)]
struct machhwsu_instructionVar461 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwsu_instructionVar461 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwsu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2539:1, end:2539:2))"]
#[derive(Clone, Debug)]
struct machhwsu__instructionVar462 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwsu__instructionVar462 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwsu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2546:1, end:2546:2))"]
#[derive(Clone, Debug)]
struct machhwsuo_instructionVar463 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwsuo_instructionVar463 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwsuo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2553:1, end:2553:2))"]
#[derive(Clone, Debug)]
struct machhwsuo__instructionVar464 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwsuo__instructionVar464 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwsuo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2561:1, end:2561:2))"]
#[derive(Clone, Debug)]
struct machhwu_instructionVar465 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwu_instructionVar465 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2567:1, end:2567:2))"]
#[derive(Clone, Debug)]
struct machhwu__instructionVar466 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwu__instructionVar466 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2574:1, end:2574:2))"]
#[derive(Clone, Debug)]
struct machhwuo_instructionVar467 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwuo_instructionVar467 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwuo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2581:1, end:2581:2))"]
#[derive(Clone, Debug)]
struct machhwuo__instructionVar468 {
    D: u8,
    A: u8,
    B: u8,
}
impl machhwuo__instructionVar468 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("machhwuo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2590:1, end:2590:2))"]
#[derive(Clone, Debug)]
struct maclhw_instructionVar469 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhw_instructionVar469 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2596:1, end:2596:2))"]
#[derive(Clone, Debug)]
struct maclhw__instructionVar470 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhw__instructionVar470 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2603:1, end:2603:2))"]
#[derive(Clone, Debug)]
struct maclhwo_instructionVar471 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwo_instructionVar471 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2610:1, end:2610:2))"]
#[derive(Clone, Debug)]
struct maclhwo__instructionVar472 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwo__instructionVar472 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2618:1, end:2618:2))"]
#[derive(Clone, Debug)]
struct maclhws_instructionVar473 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhws_instructionVar473 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhws"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2624:1, end:2624:2))"]
#[derive(Clone, Debug)]
struct maclhws__instructionVar474 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhws__instructionVar474 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhws."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2631:1, end:2631:2))"]
#[derive(Clone, Debug)]
struct maclhwso_instructionVar475 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwso_instructionVar475 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwso"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2638:1, end:2638:2))"]
#[derive(Clone, Debug)]
struct maclhwso__instructionVar476 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwso__instructionVar476 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwso."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2646:1, end:2646:2))"]
#[derive(Clone, Debug)]
struct maclhwsu_instructionVar477 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwsu_instructionVar477 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwsu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2652:1, end:2652:2))"]
#[derive(Clone, Debug)]
struct maclhwsu__instructionVar478 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwsu__instructionVar478 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwsu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2659:1, end:2659:2))"]
#[derive(Clone, Debug)]
struct maclhwsuo_instructionVar479 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwsuo_instructionVar479 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwsuo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2666:1, end:2666:2))"]
#[derive(Clone, Debug)]
struct maclhwsuo__instructionVar480 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwsuo__instructionVar480 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwsuo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2675:1, end:2675:2))"]
#[derive(Clone, Debug)]
struct maclhwu_instructionVar481 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwu_instructionVar481 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2683:1, end:2683:2))"]
#[derive(Clone, Debug)]
struct maclhwu__instructionVar482 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwu__instructionVar482 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2691:1, end:2691:2))"]
#[derive(Clone, Debug)]
struct maclhwuo_instructionVar483 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwuo_instructionVar483 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwuo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2698:1, end:2698:2))"]
#[derive(Clone, Debug)]
struct maclhwuo__instructionVar484 {
    D: u8,
    A: u8,
    B: u8,
}
impl maclhwuo__instructionVar484 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("maclhwuo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2706:1, end:2706:2))"]
#[derive(Clone, Debug)]
struct mulchw_instructionVar485 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulchw_instructionVar485 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulchw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2712:1, end:2712:2))"]
#[derive(Clone, Debug)]
struct mulchw__instructionVar486 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulchw__instructionVar486 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulchw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2719:1, end:2719:2))"]
#[derive(Clone, Debug)]
struct mulchwu_instructionVar487 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulchwu_instructionVar487 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulchwu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2725:1, end:2725:2))"]
#[derive(Clone, Debug)]
struct mulchwu__instructionVar488 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulchwu__instructionVar488 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulchwu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2732:1, end:2732:2))"]
#[derive(Clone, Debug)]
struct mulhhw_instructionVar489 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhhw_instructionVar489 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhhw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2738:1, end:2738:2))"]
#[derive(Clone, Debug)]
struct mulhhw__instructionVar490 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhhw__instructionVar490 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhhw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2745:1, end:2745:2))"]
#[derive(Clone, Debug)]
struct mulhhwu_instructionVar491 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhhwu_instructionVar491 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhhwu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2751:1, end:2751:2))"]
#[derive(Clone, Debug)]
struct mulhhwu__instructionVar492 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhhwu__instructionVar492 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhhwu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2758:1, end:2758:2))"]
#[derive(Clone, Debug)]
struct mullhw_instructionVar493 {
    D: u8,
    A: u8,
    B: u8,
}
impl mullhw_instructionVar493 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mullhw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2764:1, end:2764:2))"]
#[derive(Clone, Debug)]
struct mullhw__instructionVar494 {
    D: u8,
    A: u8,
    B: u8,
}
impl mullhw__instructionVar494 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mullhw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2772:1, end:2772:2))"]
#[derive(Clone, Debug)]
struct mullhwu_instructionVar495 {
    D: u8,
    A: u8,
    B: u8,
}
impl mullhwu_instructionVar495 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mullhwu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2780:1, end:2780:2))"]
#[derive(Clone, Debug)]
struct mullhwu__instructionVar496 {
    D: u8,
    A: u8,
    B: u8,
}
impl mullhwu__instructionVar496 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mullhwu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2788:1, end:2788:2))"]
#[derive(Clone, Debug)]
struct nmacchw_instructionVar497 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmacchw_instructionVar497 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmacchw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2794:1, end:2794:2))"]
#[derive(Clone, Debug)]
struct nmacchw__instructionVar498 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmacchw__instructionVar498 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmacchw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2801:1, end:2801:2))"]
#[derive(Clone, Debug)]
struct nmacchwo_instructionVar499 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmacchwo_instructionVar499 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmacchwo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2808:1, end:2808:2))"]
#[derive(Clone, Debug)]
struct nmacchwo__instructionVar500 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmacchwo__instructionVar500 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmacchwo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2816:1, end:2816:2))"]
#[derive(Clone, Debug)]
struct nmacchws_instructionVar501 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmacchws_instructionVar501 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmacchws"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2822:1, end:2822:2))"]
#[derive(Clone, Debug)]
struct nmacchws__instructionVar502 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmacchws__instructionVar502 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmacchws."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2829:1, end:2829:2))"]
#[derive(Clone, Debug)]
struct nmacchwso_instructionVar503 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmacchwso_instructionVar503 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmacchwso"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2836:1, end:2836:2))"]
#[derive(Clone, Debug)]
struct nmacchwso__instructionVar504 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmacchwso__instructionVar504 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmacchwso."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2844:1, end:2844:2))"]
#[derive(Clone, Debug)]
struct nmachhw_instructionVar505 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmachhw_instructionVar505 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmachhw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2850:1, end:2850:2))"]
#[derive(Clone, Debug)]
struct nmachhw__instructionVar506 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmachhw__instructionVar506 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmachhw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2857:1, end:2857:2))"]
#[derive(Clone, Debug)]
struct nmachhwo_instructionVar507 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmachhwo_instructionVar507 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmachhwo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2864:1, end:2864:2))"]
#[derive(Clone, Debug)]
struct nmachhwo__instructionVar508 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmachhwo__instructionVar508 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmachhwo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2872:1, end:2872:2))"]
#[derive(Clone, Debug)]
struct nmachhws_instructionVar509 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmachhws_instructionVar509 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmachhws"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2878:1, end:2878:2))"]
#[derive(Clone, Debug)]
struct nmachhws__instructionVar510 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmachhws__instructionVar510 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmachhws."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2885:1, end:2885:2))"]
#[derive(Clone, Debug)]
struct nmachhwso_instructionVar511 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmachhwso_instructionVar511 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmachhwso"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2892:1, end:2892:2))"]
#[derive(Clone, Debug)]
struct nmachhwso__instructionVar512 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmachhwso__instructionVar512 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmachhwso."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2900:1, end:2900:2))"]
#[derive(Clone, Debug)]
struct nmaclhw_instructionVar513 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmaclhw_instructionVar513 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmaclhw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2906:1, end:2906:2))"]
#[derive(Clone, Debug)]
struct nmaclhw__instructionVar514 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmaclhw__instructionVar514 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmaclhw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2913:1, end:2913:2))"]
#[derive(Clone, Debug)]
struct nmaclhwo_instructionVar515 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmaclhwo_instructionVar515 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmaclhwo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2920:1, end:2920:2))"]
#[derive(Clone, Debug)]
struct nmaclhwo__instructionVar516 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmaclhwo__instructionVar516 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmaclhwo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2928:1, end:2928:2))"]
#[derive(Clone, Debug)]
struct nmaclhws_instructionVar517 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmaclhws_instructionVar517 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmaclhws"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2934:1, end:2934:2))"]
#[derive(Clone, Debug)]
struct nmaclhws__instructionVar518 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmaclhws__instructionVar518 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmaclhws."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2941:1, end:2941:2))"]
#[derive(Clone, Debug)]
struct nmaclhwso_instructionVar519 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmaclhwso_instructionVar519 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmaclhwso"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:2948:1, end:2948:2))"]
#[derive(Clone, Debug)]
struct nmaclhwso__instructionVar520 {
    D: u8,
    A: u8,
    B: u8,
}
impl nmaclhwso__instructionVar520 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nmaclhwso."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3264:1, end:3264:2))"]
#[derive(Clone, Debug)]
struct mulhd_instructionVar521 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhd_instructionVar521 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhd"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3270:1, end:3270:2))"]
#[derive(Clone, Debug)]
struct mulhd__instructionVar522 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhd__instructionVar522 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhd."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3278:1, end:3278:2))"]
#[derive(Clone, Debug)]
struct mulhdu_instructionVar523 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhdu_instructionVar523 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhdu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3284:1, end:3284:2))"]
#[derive(Clone, Debug)]
struct mulhdu__instructionVar524 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhdu__instructionVar524 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhdu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3294:1, end:3294:2))"]
#[derive(Clone, Debug)]
struct mulhw_instructionVar525 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhw_instructionVar525 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3307:1, end:3307:2))"]
#[derive(Clone, Debug)]
struct mulhw__instructionVar526 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhw__instructionVar526 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3321:1, end:3321:2))"]
#[derive(Clone, Debug)]
struct mulhwu_instructionVar527 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhwu_instructionVar527 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhwu"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3333:1, end:3333:2))"]
#[derive(Clone, Debug)]
struct mulhwu__instructionVar528 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulhwu__instructionVar528 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulhwu."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3348:1, end:3348:2))"]
#[derive(Clone, Debug)]
struct mulld_instructionVar529 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulld_instructionVar529 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulld"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3355:1, end:3355:2))"]
#[derive(Clone, Debug)]
struct mulld__instructionVar530 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulld__instructionVar530 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulld."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3363:1, end:3363:2))"]
#[derive(Clone, Debug)]
struct mulldo_instructionVar531 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulldo_instructionVar531 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulldo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3371:1, end:3371:2))"]
#[derive(Clone, Debug)]
struct mulldo__instructionVar532 {
    D: u8,
    A: u8,
    B: u8,
}
impl mulldo__instructionVar532 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulldo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3382:1, end:3382:2))"]
#[derive(Clone, Debug)]
struct mulli_instructionVar533 {
    D: u8,
    A: u8,
    SIMM: u16,
}
impl mulli_instructionVar533 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulli"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SIMM = token_84(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3388:1, end:3388:2))"]
#[derive(Clone, Debug)]
struct mullw_instructionVar534 {
    D: u8,
    A: u8,
    B: u8,
}
impl mullw_instructionVar534 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mullw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3398:1, end:3398:2))"]
#[derive(Clone, Debug)]
struct mullw__instructionVar535 {
    D: u8,
    A: u8,
    B: u8,
}
impl mullw__instructionVar535 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mullw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3409:1, end:3409:2))"]
#[derive(Clone, Debug)]
struct mullwo_instructionVar536 {
    D: u8,
    A: u8,
    B: u8,
}
impl mullwo_instructionVar536 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mullwo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3422:1, end:3422:2))"]
#[derive(Clone, Debug)]
struct mullwo__instructionVar537 {
    D: u8,
    A: u8,
    B: u8,
}
impl mullwo__instructionVar537 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mullwo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3436:1, end:3436:2))"]
#[derive(Clone, Debug)]
struct nand_instructionVar538 {
    A: u8,
    S: u8,
    B: u8,
}
impl nand_instructionVar538 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nand"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3442:1, end:3442:2))"]
#[derive(Clone, Debug)]
struct nand__instructionVar539 {
    A: u8,
    S: u8,
    B: u8,
}
impl nand__instructionVar539 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nand."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3477:1, end:3477:2))"]
#[derive(Clone, Debug)]
struct nor_instructionVar540 {
    A: u8,
    S: u8,
    B: u8,
}
impl nor_instructionVar540 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nor"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3483:1, end:3483:2))"]
#[derive(Clone, Debug)]
struct nor__instructionVar541 {
    A: u8,
    S: u8,
    B: u8,
}
impl nor__instructionVar541 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nor."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3490:1, end:3490:2))"]
#[derive(Clone, Debug)]
struct or_instructionVar542 {
    A: u8,
    S: u8,
    B: u8,
}
impl or_instructionVar542 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3496:1, end:3496:2))"]
#[derive(Clone, Debug)]
struct or__instructionVar543 {
    A: u8,
    S: u8,
    B: u8,
}
impl or__instructionVar543 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3503:1, end:3503:2))"]
#[derive(Clone, Debug)]
struct orc_instructionVar544 {
    A: u8,
    S: u8,
    B: u8,
}
impl orc_instructionVar544 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orc"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3509:1, end:3509:2))"]
#[derive(Clone, Debug)]
struct orc__instructionVar545 {
    A: u8,
    S: u8,
    B: u8,
}
impl orc__instructionVar545 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("orc."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3516:1, end:3516:2))"]
#[derive(Clone, Debug)]
struct ori_instructionVar546 {
    A: u8,
    S: u8,
    UIMM: u16,
}
impl ori_instructionVar546 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ori"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let UIMM = token_84(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, UIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3522:1, end:3522:2))"]
#[derive(Clone, Debug)]
struct oris_instructionVar547 {
    A: u8,
    S: u8,
    UIMM: u16,
}
impl oris_instructionVar547 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("oris"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let UIMM = token_84(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, UIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3757:1, end:3757:2))"]
#[derive(Clone, Debug)]
struct sld_instructionVar548 {
    A: u8,
    S: u8,
    B: u8,
}
impl sld_instructionVar548 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sld"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3763:1, end:3763:2))"]
#[derive(Clone, Debug)]
struct sld__instructionVar549 {
    A: u8,
    S: u8,
    B: u8,
}
impl sld__instructionVar549 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sld."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3771:1, end:3771:2))"]
#[derive(Clone, Debug)]
struct slw_instructionVar550 {
    A: u8,
    S: u8,
    B: u8,
}
impl slw_instructionVar550 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3785:1, end:3785:2))"]
#[derive(Clone, Debug)]
struct slw__instructionVar551 {
    A: u8,
    S: u8,
    B: u8,
}
impl slw__instructionVar551 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("slw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3800:1, end:3800:2))"]
#[derive(Clone, Debug)]
struct srad_instructionVar552 {
    A: u8,
    S: u8,
    B: u8,
}
impl srad_instructionVar552 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srad"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3808:1, end:3808:2))"]
#[derive(Clone, Debug)]
struct srad__instructionVar553 {
    A: u8,
    S: u8,
    B: u8,
}
impl srad__instructionVar553 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srad."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3834:1, end:3834:2))"]
#[derive(Clone, Debug)]
struct sraw_instructionVar554 {
    A: u8,
    S: u8,
    B: u8,
}
impl sraw_instructionVar554 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sraw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3848:1, end:3848:2))"]
#[derive(Clone, Debug)]
struct sraw__instructionVar555 {
    A: u8,
    S: u8,
    B: u8,
}
impl sraw__instructionVar555 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sraw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3864:1, end:3864:2))"]
#[derive(Clone, Debug)]
struct srawi_instructionVar556 {
    A: u8,
    S: u8,
    SHL: u8,
}
impl srawi_instructionVar556 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srawi"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.SHL as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SHL = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, SHL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3877:1, end:3877:2))"]
#[derive(Clone, Debug)]
struct srawi__instructionVar557 {
    A: u8,
    S: u8,
    SHL: u8,
}
impl srawi__instructionVar557 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srawi."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.SHL as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SHL = token_4(tokens_current);
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, SHL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3893:1, end:3893:2))"]
#[derive(Clone, Debug)]
struct srd_instructionVar558 {
    A: u8,
    S: u8,
    B: u8,
}
impl srd_instructionVar558 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srd"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3899:1, end:3899:2))"]
#[derive(Clone, Debug)]
struct srd__instructionVar559 {
    A: u8,
    S: u8,
    B: u8,
}
impl srd__instructionVar559 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srd."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3907:1, end:3907:2))"]
#[derive(Clone, Debug)]
struct srw_instructionVar560 {
    A: u8,
    S: u8,
    B: u8,
}
impl srw_instructionVar560 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srw"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3921:1, end:3921:2))"]
#[derive(Clone, Debug)]
struct srw__instructionVar561 {
    A: u8,
    S: u8,
    B: u8,
}
impl srw__instructionVar561 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("srw."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3952:1, end:3952:2))"]
#[derive(Clone, Debug)]
struct stbux_instructionVar562 {
    S: u8,
    A: u8,
    B: u8,
}
impl stbux_instructionVar562 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stbux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3960:1, end:3960:2))"]
#[derive(Clone, Debug)]
struct stbx_instructionVar563 {
    S: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stbx_instructionVar563 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stbx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3982:1, end:3982:2))"]
#[derive(Clone, Debug)]
struct stdcx__instructionVar564 {
    S: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stdcx__instructionVar564 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stdcx."));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4000:1, end:4000:2))"]
#[derive(Clone, Debug)]
struct stdux_instructionVar565 {
    S: u8,
    A: u8,
    B: u8,
}
impl stdux_instructionVar565 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stdux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4008:1, end:4008:2))"]
#[derive(Clone, Debug)]
struct stdx_instructionVar566 {
    S: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stdx_instructionVar566 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stdx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4095:1, end:4095:2))"]
#[derive(Clone, Debug)]
struct sthbrx_instructionVar567 {
    S: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl sthbrx_instructionVar567 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sthbrx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4111:1, end:4111:2))"]
#[derive(Clone, Debug)]
struct sthux_instructionVar568 {
    S: u8,
    A: u8,
    B: u8,
}
impl sthux_instructionVar568 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sthux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4119:1, end:4119:2))"]
#[derive(Clone, Debug)]
struct sthx_instructionVar569 {
    S: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl sthx_instructionVar569 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sthx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4139:1, end:4139:2))"]
#[derive(Clone, Debug)]
struct stswx_instructionVar570 {
    S: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stswx_instructionVar570 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stswx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4156:1, end:4156:2))"]
#[derive(Clone, Debug)]
struct stwbrx_instructionVar571 {
    S: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stwbrx_instructionVar571 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stwbrx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4172:1, end:4172:2))"]
#[derive(Clone, Debug)]
struct stwcx__instructionVar572 {
    S: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stwcx__instructionVar572 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stwcx."));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4193:1, end:4193:2))"]
#[derive(Clone, Debug)]
struct stwux_instructionVar573 {
    S: u8,
    A: u8,
    B: u8,
}
impl stwux_instructionVar573 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stwux"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4205:1, end:4205:2))"]
#[derive(Clone, Debug)]
struct stwx_instructionVar574 {
    S: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stwx_instructionVar574 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stwx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4217:1, end:4217:2))"]
#[derive(Clone, Debug)]
struct subf_instructionVar575 {
    D: u8,
    A: u8,
    B: u8,
}
impl subf_instructionVar575 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subf"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4223:1, end:4223:2))"]
#[derive(Clone, Debug)]
struct subf__instructionVar576 {
    D: u8,
    A: u8,
    B: u8,
}
impl subf__instructionVar576 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subf."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4230:1, end:4230:2))"]
#[derive(Clone, Debug)]
struct subfo_instructionVar577 {
    D: u8,
    A: u8,
    B: u8,
}
impl subfo_instructionVar577 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4237:1, end:4237:2))"]
#[derive(Clone, Debug)]
struct subfo__instructionVar578 {
    D: u8,
    A: u8,
    B: u8,
}
impl subfo__instructionVar578 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4245:1, end:4245:2))"]
#[derive(Clone, Debug)]
struct subfc_instructionVar579 {
    D: u8,
    A: u8,
    B: u8,
}
impl subfc_instructionVar579 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfc"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4252:1, end:4252:2))"]
#[derive(Clone, Debug)]
struct subfc__instructionVar580 {
    D: u8,
    A: u8,
    B: u8,
}
impl subfc__instructionVar580 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfc."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4260:1, end:4260:2))"]
#[derive(Clone, Debug)]
struct subfco_instructionVar581 {
    D: u8,
    A: u8,
    B: u8,
}
impl subfco_instructionVar581 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfco"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4268:1, end:4268:2))"]
#[derive(Clone, Debug)]
struct subfco__instructionVar582 {
    D: u8,
    A: u8,
    B: u8,
}
impl subfco__instructionVar582 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfco."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4277:1, end:4277:2))"]
#[derive(Clone, Debug)]
struct subfe_instructionVar583 {
    D: u8,
    A: u8,
    B: u8,
}
impl subfe_instructionVar583 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfe"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4285:1, end:4285:2))"]
#[derive(Clone, Debug)]
struct subfe__instructionVar584 {
    D: u8,
    A: u8,
    B: u8,
}
impl subfe__instructionVar584 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfe."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4294:1, end:4294:2))"]
#[derive(Clone, Debug)]
struct subfeo_instructionVar585 {
    D: u8,
    A: u8,
    B: u8,
}
impl subfeo_instructionVar585 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfeo"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4303:1, end:4303:2))"]
#[derive(Clone, Debug)]
struct subfeo__instructionVar586 {
    D: u8,
    A: u8,
    B: u8,
}
impl subfeo__instructionVar586 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfeo."));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4407:1, end:4407:2))"]
#[derive(Clone, Debug)]
struct td_instructionVar587 {
    A: u8,
    B: u8,
    TOm: TableTOm,
}
impl td_instructionVar587 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("td"));
        self.TOm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let TOm = if let Some((len, table)) =
            TableTOm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let TO = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOm, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4445:1, end:4445:2))"]
#[derive(Clone, Debug)]
struct tw_instructionVar588 {
    A: u8,
    B: u8,
    TOm: TableTOm,
}
impl tw_instructionVar588 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tw"));
        self.TOm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let TOm = if let Some((len, table)) =
            TableTOm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let TO = token_51(tokens_current);
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOm, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4513:1, end:4513:2))"]
#[derive(Clone, Debug)]
struct xor_instructionVar589 {
    A: u8,
    S: u8,
    B: u8,
}
impl xor_instructionVar589 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xor"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        let B = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:80:1, end:80:2))"]
#[derive(Clone, Debug)]
struct mfdcr_instructionVar590 {
    D: u8,
    DCRN: u16,
}
impl mfdcr_instructionVar590 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfdcr"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_10_display(self.DCRN),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let DCRN = token_11(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, DCRN }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:92:1, end:92:2))"]
#[derive(Clone, Debug)]
struct mfspr_instructionVar591 {
    D: u8,
    SPRVAL: u16,
}
impl mfspr_instructionVar591 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mfspr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_9_display(self.SPRVAL),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SPRVAL = token_11(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, SPRVAL }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:109:1, end:109:2))"]
#[derive(Clone, Debug)]
struct mtdcr_instructionVar592 {
    DCRN: u16,
    D: u8,
}
impl mtdcr_instructionVar592 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtdcr"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_10_display(self.DCRN),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let DCRN = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { DCRN, D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:142:1, end:142:2))"]
#[derive(Clone, Debug)]
struct mtspr_instructionVar593 {
    SPRVAL: u16,
    S: u8,
}
impl mtspr_instructionVar593 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mtspr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_9_display(self.SPRVAL),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SPRVAL = token_11(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SPRVAL, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:183:1, end:183:2))"]
#[derive(Clone, Debug)]
struct tlbsx_instructionVar594 {
    D: u8,
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl tlbsx_instructionVar594 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbsx"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, D, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:192:1, end:192:2))"]
#[derive(Clone, Debug)]
struct lvebx_instructionVar595 {
    B: u8,
    vrD: TablevrD,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lvebx_instructionVar595 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lvebx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:207:1, end:207:2))"]
#[derive(Clone, Debug)]
struct lvehx_instructionVar596 {
    A: u8,
    B: u8,
    vrD: TablevrD,
}
impl lvehx_instructionVar596 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lvehx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:212:1, end:212:2))"]
#[derive(Clone, Debug)]
struct lvewx_instructionVar597 {
    A: u8,
    B: u8,
    vrD: TablevrD,
}
impl lvewx_instructionVar597 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lvewx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:217:1, end:217:2))"]
#[derive(Clone, Debug)]
struct lvsl_instructionVar598 {
    A: u8,
    B: u8,
    vrD: TablevrD,
}
impl lvsl_instructionVar598 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lvsl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:222:1, end:222:2))"]
#[derive(Clone, Debug)]
struct lvsr_instructionVar599 {
    B: u8,
    vrD: TablevrD,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lvsr_instructionVar599 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lvsr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:236:1, end:236:2))"]
#[derive(Clone, Debug)]
struct lvx_instructionVar600 {
    B: u8,
    vrD: TablevrD,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl lvx_instructionVar600 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lvx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:244:1, end:244:2))"]
#[derive(Clone, Debug)]
struct lvxl_instructionVar601 {
    A: u8,
    B: u8,
    vrD: TablevrD,
}
impl lvxl_instructionVar601 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lvxl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.B),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, A, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:259:1, end:259:2))"]
#[derive(Clone, Debug)]
struct stvebx_instructionVar602 {
    B: u8,
    vrS: TablevrS,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stvebx_instructionVar602 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stvebx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrS = if let Some((len, table)) =
            TablevrS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrS, RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:265:1, end:265:2))"]
#[derive(Clone, Debug)]
struct stvehx_instructionVar603 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    vrS: TablevrS,
}
impl stvehx_instructionVar603 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stvehx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrS = if let Some((len, table)) =
            TablevrS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, vrS, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:271:1, end:271:2))"]
#[derive(Clone, Debug)]
struct stvewx_instructionVar604 {
    B: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
    vrS: TablevrS,
}
impl stvewx_instructionVar604 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stvewx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrS = if let Some((len, table)) =
            TablevrS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, vrS, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:277:1, end:277:2))"]
#[derive(Clone, Debug)]
struct stvx_instructionVar605 {
    B: u8,
    vrS: TablevrS,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stvx_instructionVar605 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stvx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrS = if let Some((len, table)) =
            TablevrS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrS, RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:283:1, end:283:2))"]
#[derive(Clone, Debug)]
struct stvxl_instructionVar606 {
    B: u8,
    vrS: TablevrS,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl stvxl_instructionVar606 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stvxl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrS
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(","), meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrS = if let Some((len, table)) =
            TablevrS::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrS, RA_OR_ZERO, B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:290:1, end:290:2))"]
#[derive(Clone, Debug)]
struct vaddcuw_instructionVar607 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vaddcuw_instructionVar607 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddcuw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:295:1, end:295:2))"]
#[derive(Clone, Debug)]
struct vaddfp_instructionVar608 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vaddfp_instructionVar608 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddfp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:300:1, end:300:2))"]
#[derive(Clone, Debug)]
struct vaddsbs_instructionVar609 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vaddsbs_instructionVar609 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddsbs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:305:1, end:305:2))"]
#[derive(Clone, Debug)]
struct vaddshs_instructionVar610 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vaddshs_instructionVar610 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddshs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:310:1, end:310:2))"]
#[derive(Clone, Debug)]
struct vaddsws_instructionVar611 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vaddsws_instructionVar611 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddsws"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:344:1, end:344:2))"]
#[derive(Clone, Debug)]
struct vaddubm_instructionVar612 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
    vaddubm_part1: Tablevaddubm_part1,
    vaddubm_part2: Tablevaddubm_part2,
}
impl vaddubm_instructionVar612 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddubm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vaddubm_part1 = if let Some((len, table)) =
            Tablevaddubm_part1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vaddubm_part2 = if let Some((len, table)) =
            Tablevaddubm_part2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                vrA,
                vrD,
                vrB,
                vaddubm_part1,
                vaddubm_part2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:348:1, end:348:2))"]
#[derive(Clone, Debug)]
struct vaddubs_instructionVar613 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vaddubs_instructionVar613 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddubs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:353:1, end:353:2))"]
#[derive(Clone, Debug)]
struct vadduhm_instructionVar614 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vadduhm_instructionVar614 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vadduhm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB_16_6 = token_4(tokens_current);
        let vrD_16_7 = token_51(tokens_current);
        let vrD_16_5 = token_51(tokens_current);
        let vrA_16_0 = token_1(tokens_current);
        let vrD_16_0 = token_51(tokens_current);
        let vrD_16_6 = token_51(tokens_current);
        let vrA_16_5 = token_1(tokens_current);
        let vrD_16_4 = token_51(tokens_current);
        let vrA_16_3 = token_1(tokens_current);
        let vrA_16_7 = token_1(tokens_current);
        let vrB_16_4 = token_4(tokens_current);
        let vrB_16_0 = token_4(tokens_current);
        let vrD_16_1 = token_51(tokens_current);
        let vrA_16_6 = token_1(tokens_current);
        let vrB_16_3 = token_4(tokens_current);
        let vrA_16_2 = token_1(tokens_current);
        let vrB_16_1 = token_4(tokens_current);
        let vrB_16_7 = token_4(tokens_current);
        let vrD_16_2 = token_51(tokens_current);
        let vrB_16_5 = token_4(tokens_current);
        let vrA_16_4 = token_1(tokens_current);
        let vrD_16_3 = token_51(tokens_current);
        let vrB_16_2 = token_4(tokens_current);
        let vrA_16_1 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:368:1, end:368:2))"]
#[derive(Clone, Debug)]
struct vadduhs_instructionVar615 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vadduhs_instructionVar615 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vadduhs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:373:1, end:373:2))"]
#[derive(Clone, Debug)]
struct vadduwm_instructionVar616 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vadduwm_instructionVar616 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vadduwm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB_32_2 = token_4(tokens_current);
        let vrA_32_1 = token_1(tokens_current);
        let vrA_32_0 = token_1(tokens_current);
        let vrB_32_3 = token_4(tokens_current);
        let vrB_32_0 = token_4(tokens_current);
        let vrA_32_3 = token_1(tokens_current);
        let vrD_32_0 = token_51(tokens_current);
        let vrD_32_1 = token_51(tokens_current);
        let vrB_32_1 = token_4(tokens_current);
        let vrD_32_2 = token_51(tokens_current);
        let vrA_32_2 = token_1(tokens_current);
        let vrD_32_3 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:390:1, end:390:2))"]
#[derive(Clone, Debug)]
struct vand_instructionVar617 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vand_instructionVar617 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vand"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:395:1, end:395:2))"]
#[derive(Clone, Debug)]
struct vandc_instructionVar618 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vandc_instructionVar618 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vandc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:400:1, end:400:2))"]
#[derive(Clone, Debug)]
struct vavgsb_instructionVar619 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vavgsb_instructionVar619 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vavgsb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:405:1, end:405:2))"]
#[derive(Clone, Debug)]
struct vavgsh_instructionVar620 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vavgsh_instructionVar620 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vavgsh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:410:1, end:410:2))"]
#[derive(Clone, Debug)]
struct vavgsw_instructionVar621 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vavgsw_instructionVar621 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vavgsw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:415:1, end:415:2))"]
#[derive(Clone, Debug)]
struct vavgub_instructionVar622 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vavgub_instructionVar622 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vavgub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:420:1, end:420:2))"]
#[derive(Clone, Debug)]
struct vavguh_instructionVar623 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vavguh_instructionVar623 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vavguh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:425:1, end:425:2))"]
#[derive(Clone, Debug)]
struct vavguw_instructionVar624 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vavguw_instructionVar624 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vavguw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:430:1, end:430:2))"]
#[derive(Clone, Debug)]
struct vcfsx_instructionVar625 {
    A_BITS: u8,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcfsx_instructionVar625 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcfsx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.A_BITS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A_BITS = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, A_BITS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:435:1, end:435:2))"]
#[derive(Clone, Debug)]
struct vcfux_instructionVar626 {
    A_BITS: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vcfux_instructionVar626 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcfux"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.A_BITS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A_BITS = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, A_BITS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:440:1, end:440:2))"]
#[derive(Clone, Debug)]
struct vcmpbfp_instructionVar627 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vcmpbfp_instructionVar627 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpbfp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:445:1, end:445:2))"]
#[derive(Clone, Debug)]
struct vcmpbfp__instructionVar628 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vcmpbfp__instructionVar628 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpbfp."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:451:1, end:451:2))"]
#[derive(Clone, Debug)]
struct vcmpeqfp_instructionVar629 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vcmpeqfp_instructionVar629 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpeqfp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:457:1, end:457:2))"]
#[derive(Clone, Debug)]
struct vcmpeqfp__instructionVar630 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vcmpeqfp__instructionVar630 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpeqfp."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:462:1, end:462:2))"]
#[derive(Clone, Debug)]
struct vcmpequb_instructionVar631 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpequb_instructionVar631 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpequb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:468:1, end:468:2))"]
#[derive(Clone, Debug)]
struct vcmpequb__instructionVar632 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vcmpequb__instructionVar632 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpequb."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:474:1, end:474:2))"]
#[derive(Clone, Debug)]
struct vcmpequh_instructionVar633 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpequh_instructionVar633 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpequh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:480:1, end:480:2))"]
#[derive(Clone, Debug)]
struct vcmpequh__instructionVar634 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vcmpequh__instructionVar634 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpequh."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:486:1, end:486:2))"]
#[derive(Clone, Debug)]
struct vcmpequw_instructionVar635 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpequw_instructionVar635 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpequw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:492:1, end:492:2))"]
#[derive(Clone, Debug)]
struct vcmpequw__instructionVar636 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vcmpequw__instructionVar636 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpequw."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:498:1, end:498:2))"]
#[derive(Clone, Debug)]
struct vcmpgefp_instructionVar637 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vcmpgefp_instructionVar637 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgefp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:504:1, end:504:2))"]
#[derive(Clone, Debug)]
struct vcmpgefp__instructionVar638 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vcmpgefp__instructionVar638 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgefp."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:510:1, end:510:2))"]
#[derive(Clone, Debug)]
struct vcmpgtfp_instructionVar639 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpgtfp_instructionVar639 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtfp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:516:1, end:516:2))"]
#[derive(Clone, Debug)]
struct vcmpgtfp__instructionVar640 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vcmpgtfp__instructionVar640 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtfp."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:522:1, end:522:2))"]
#[derive(Clone, Debug)]
struct vcmpgtsb_instructionVar641 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpgtsb_instructionVar641 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtsb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:528:1, end:528:2))"]
#[derive(Clone, Debug)]
struct vcmpgtsb__instructionVar642 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vcmpgtsb__instructionVar642 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtsb."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:534:1, end:534:2))"]
#[derive(Clone, Debug)]
struct vcmpgtsh_instructionVar643 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vcmpgtsh_instructionVar643 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtsh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:540:1, end:540:2))"]
#[derive(Clone, Debug)]
struct vcmpgtsh__instructionVar644 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vcmpgtsh__instructionVar644 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtsh."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:546:1, end:546:2))"]
#[derive(Clone, Debug)]
struct vcmpgtsw_instructionVar645 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vcmpgtsw_instructionVar645 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtsw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:552:1, end:552:2))"]
#[derive(Clone, Debug)]
struct vcmpgtsw__instructionVar646 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vcmpgtsw__instructionVar646 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtsw."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:558:1, end:558:2))"]
#[derive(Clone, Debug)]
struct vcmpgtub_instructionVar647 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vcmpgtub_instructionVar647 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:564:1, end:564:2))"]
#[derive(Clone, Debug)]
struct vcmpgtub__instructionVar648 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vcmpgtub__instructionVar648 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtub."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:570:1, end:570:2))"]
#[derive(Clone, Debug)]
struct vcmpgtuh_instructionVar649 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vcmpgtuh_instructionVar649 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtuh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:576:1, end:576:2))"]
#[derive(Clone, Debug)]
struct vcmpgtuh__instructionVar650 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vcmpgtuh__instructionVar650 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtuh."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:582:1, end:582:2))"]
#[derive(Clone, Debug)]
struct vcmpgtuw_instructionVar651 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vcmpgtuw_instructionVar651 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtuw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:588:1, end:588:2))"]
#[derive(Clone, Debug)]
struct vcmpgtuw__instructionVar652 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpgtuw__instructionVar652 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtuw."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:594:1, end:594:2))"]
#[derive(Clone, Debug)]
struct vctsxs_instructionVar653 {
    A_BITS: u8,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vctsxs_instructionVar653 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vctsxs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.A_BITS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A_BITS = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, A_BITS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:599:1, end:599:2))"]
#[derive(Clone, Debug)]
struct vctuxs_instructionVar654 {
    A_BITS: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vctuxs_instructionVar654 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vctuxs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.A_BITS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A_BITS = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, A_BITS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:619:1, end:619:2))"]
#[derive(Clone, Debug)]
struct vmaxfp_instructionVar655 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vmaxfp_instructionVar655 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmaxfp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:624:1, end:624:2))"]
#[derive(Clone, Debug)]
struct vmaxsb_instructionVar656 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vmaxsb_instructionVar656 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmaxsb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:629:1, end:629:2))"]
#[derive(Clone, Debug)]
struct vmaxsh_instructionVar657 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vmaxsh_instructionVar657 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmaxsh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:634:1, end:634:2))"]
#[derive(Clone, Debug)]
struct vmaxsw_instructionVar658 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmaxsw_instructionVar658 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmaxsw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:639:1, end:639:2))"]
#[derive(Clone, Debug)]
struct vmaxub_instructionVar659 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmaxub_instructionVar659 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmaxub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:644:1, end:644:2))"]
#[derive(Clone, Debug)]
struct vmaxuh_instructionVar660 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmaxuh_instructionVar660 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmaxuh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:649:1, end:649:2))"]
#[derive(Clone, Debug)]
struct vmaxuw_instructionVar661 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vmaxuw_instructionVar661 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmaxuw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:664:1, end:664:2))"]
#[derive(Clone, Debug)]
struct vminfp_instructionVar662 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vminfp_instructionVar662 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vminfp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:669:1, end:669:2))"]
#[derive(Clone, Debug)]
struct vminsb_instructionVar663 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vminsb_instructionVar663 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vminsb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:674:1, end:674:2))"]
#[derive(Clone, Debug)]
struct vminsh_instructionVar664 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vminsh_instructionVar664 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vminsh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:679:1, end:679:2))"]
#[derive(Clone, Debug)]
struct vminsw_instructionVar665 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vminsw_instructionVar665 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vminsw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:684:1, end:684:2))"]
#[derive(Clone, Debug)]
struct vminub_instructionVar666 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vminub_instructionVar666 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vminub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:689:1, end:689:2))"]
#[derive(Clone, Debug)]
struct vminuh_instructionVar667 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vminuh_instructionVar667 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vminuh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:694:1, end:694:2))"]
#[derive(Clone, Debug)]
struct vminuw_instructionVar668 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vminuw_instructionVar668 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vminuw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:704:1, end:704:2))"]
#[derive(Clone, Debug)]
struct vmrghb_instructionVar669 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vmrghb_instructionVar669 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmrghb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:709:1, end:709:2))"]
#[derive(Clone, Debug)]
struct vmrghh_instructionVar670 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vmrghh_instructionVar670 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmrghh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:714:1, end:714:2))"]
#[derive(Clone, Debug)]
struct vmrghw_instructionVar671 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vmrghw_instructionVar671 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmrghw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:719:1, end:719:2))"]
#[derive(Clone, Debug)]
struct vmrglb_instructionVar672 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmrglb_instructionVar672 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmrglb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:724:1, end:724:2))"]
#[derive(Clone, Debug)]
struct vmrglh_instructionVar673 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vmrglh_instructionVar673 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmrglh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:729:1, end:729:2))"]
#[derive(Clone, Debug)]
struct vmrglw_instructionVar674 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmrglw_instructionVar674 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmrglw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:764:1, end:764:2))"]
#[derive(Clone, Debug)]
struct vmulesb_instructionVar675 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmulesb_instructionVar675 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmulesb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:769:1, end:769:2))"]
#[derive(Clone, Debug)]
struct vmulesh_instructionVar676 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vmulesh_instructionVar676 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmulesh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:774:1, end:774:2))"]
#[derive(Clone, Debug)]
struct vmuleub_instructionVar677 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmuleub_instructionVar677 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmuleub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:779:1, end:779:2))"]
#[derive(Clone, Debug)]
struct vmuleuh_instructionVar678 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmuleuh_instructionVar678 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmuleuh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:784:1, end:784:2))"]
#[derive(Clone, Debug)]
struct vmulosb_instructionVar679 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vmulosb_instructionVar679 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmulosb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:789:1, end:789:2))"]
#[derive(Clone, Debug)]
struct vmulosh_instructionVar680 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmulosh_instructionVar680 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmulosh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:794:1, end:794:2))"]
#[derive(Clone, Debug)]
struct vmuloub_instructionVar681 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vmuloub_instructionVar681 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmuloub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:799:1, end:799:2))"]
#[derive(Clone, Debug)]
struct vmulouh_instructionVar682 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vmulouh_instructionVar682 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmulouh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:809:1, end:809:2))"]
#[derive(Clone, Debug)]
struct vnor_instructionVar683 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vnor_instructionVar683 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vnor"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:814:1, end:814:2))"]
#[derive(Clone, Debug)]
struct vor_instructionVar684 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vor_instructionVar684 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vor"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:837:1, end:837:2))"]
#[derive(Clone, Debug)]
struct vpkpx_instructionVar685 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vpkpx_instructionVar685 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkpx"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:842:1, end:842:2))"]
#[derive(Clone, Debug)]
struct vpkshss_instructionVar686 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vpkshss_instructionVar686 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkshss"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:847:1, end:847:2))"]
#[derive(Clone, Debug)]
struct vpkshus_instructionVar687 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vpkshus_instructionVar687 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkshus"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:852:1, end:852:2))"]
#[derive(Clone, Debug)]
struct vpkswss_instructionVar688 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vpkswss_instructionVar688 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkswss"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:857:1, end:857:2))"]
#[derive(Clone, Debug)]
struct vpkswus_instructionVar689 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vpkswus_instructionVar689 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkswus"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:862:1, end:862:2))"]
#[derive(Clone, Debug)]
struct vpkuhum_instructionVar690 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vpkuhum_instructionVar690 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkuhum"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:867:1, end:867:2))"]
#[derive(Clone, Debug)]
struct vpkuhus_instructionVar691 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vpkuhus_instructionVar691 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkuhus"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:872:1, end:872:2))"]
#[derive(Clone, Debug)]
struct vpkuwum_instructionVar692 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vpkuwum_instructionVar692 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkuwum"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:877:1, end:877:2))"]
#[derive(Clone, Debug)]
struct vpkuwus_instructionVar693 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vpkuwus_instructionVar693 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkuwus"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:907:1, end:907:2))"]
#[derive(Clone, Debug)]
struct vrlb_instructionVar694 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vrlb_instructionVar694 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrlb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:912:1, end:912:2))"]
#[derive(Clone, Debug)]
struct vrlh_instructionVar695 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vrlh_instructionVar695 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrlh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:917:1, end:917:2))"]
#[derive(Clone, Debug)]
struct vrlw_instructionVar696 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vrlw_instructionVar696 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrlw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:932:1, end:932:2))"]
#[derive(Clone, Debug)]
struct vsl_instructionVar697 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vsl_instructionVar697 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:937:1, end:937:2))"]
#[derive(Clone, Debug)]
struct vslb_instructionVar698 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vslb_instructionVar698 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vslb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:949:1, end:949:2))"]
#[derive(Clone, Debug)]
struct vslh_instructionVar699 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vslh_instructionVar699 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vslh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:954:1, end:954:2))"]
#[derive(Clone, Debug)]
struct vslo_instructionVar700 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vslo_instructionVar700 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vslo"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:959:1, end:959:2))"]
#[derive(Clone, Debug)]
struct vslw_instructionVar701 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vslw_instructionVar701 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vslw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1004:1, end:1004:2))"]
#[derive(Clone, Debug)]
struct vsr_instructionVar702 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vsr_instructionVar702 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1009:1, end:1009:2))"]
#[derive(Clone, Debug)]
struct vsrab_instructionVar703 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vsrab_instructionVar703 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsrab"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1014:1, end:1014:2))"]
#[derive(Clone, Debug)]
struct vsrah_instructionVar704 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vsrah_instructionVar704 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsrah"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1019:1, end:1019:2))"]
#[derive(Clone, Debug)]
struct vsraw_instructionVar705 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsraw_instructionVar705 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsraw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1024:1, end:1024:2))"]
#[derive(Clone, Debug)]
struct vsrb_instructionVar706 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vsrb_instructionVar706 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsrb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1029:1, end:1029:2))"]
#[derive(Clone, Debug)]
struct vsrh_instructionVar707 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vsrh_instructionVar707 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsrh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1034:1, end:1034:2))"]
#[derive(Clone, Debug)]
struct vsro_instructionVar708 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vsro_instructionVar708 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsro"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1039:1, end:1039:2))"]
#[derive(Clone, Debug)]
struct vsrw_instructionVar709 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vsrw_instructionVar709 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsrw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1044:1, end:1044:2))"]
#[derive(Clone, Debug)]
struct vsubcuw_instructionVar710 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vsubcuw_instructionVar710 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubcuw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1049:1, end:1049:2))"]
#[derive(Clone, Debug)]
struct vsubfp_instructionVar711 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsubfp_instructionVar711 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubfp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1054:1, end:1054:2))"]
#[derive(Clone, Debug)]
struct vsubsbs_instructionVar712 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vsubsbs_instructionVar712 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubsbs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1059:1, end:1059:2))"]
#[derive(Clone, Debug)]
struct vsubshs_instructionVar713 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsubshs_instructionVar713 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubshs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1064:1, end:1064:2))"]
#[derive(Clone, Debug)]
struct vsubsws_instructionVar714 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsubsws_instructionVar714 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubsws"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1069:1, end:1069:2))"]
#[derive(Clone, Debug)]
struct vsububm_instructionVar715 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsububm_instructionVar715 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsububm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1074:1, end:1074:2))"]
#[derive(Clone, Debug)]
struct vsububs_instructionVar716 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsububs_instructionVar716 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsububs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1079:1, end:1079:2))"]
#[derive(Clone, Debug)]
struct vsubuhm_instructionVar717 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsubuhm_instructionVar717 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubuhm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA_16_4 = token_1(tokens_current);
        let vrA_16_0 = token_1(tokens_current);
        let vrD_16_3 = token_51(tokens_current);
        let vrD_16_7 = token_51(tokens_current);
        let vrD_16_0 = token_51(tokens_current);
        let vrB_16_0 = token_4(tokens_current);
        let vrD_16_1 = token_51(tokens_current);
        let vrA_16_6 = token_1(tokens_current);
        let vrB_16_3 = token_4(tokens_current);
        let vrB_16_4 = token_4(tokens_current);
        let vrA_16_1 = token_1(tokens_current);
        let vrB_16_5 = token_4(tokens_current);
        let vrB_16_1 = token_4(tokens_current);
        let vrD_16_6 = token_51(tokens_current);
        let vrA_16_7 = token_1(tokens_current);
        let vrA_16_3 = token_1(tokens_current);
        let vrB_16_7 = token_4(tokens_current);
        let vrD_16_5 = token_51(tokens_current);
        let vrA_16_2 = token_1(tokens_current);
        let vrB_16_2 = token_4(tokens_current);
        let vrB_16_6 = token_4(tokens_current);
        let vrA_16_5 = token_1(tokens_current);
        let vrD_16_2 = token_51(tokens_current);
        let vrD_16_4 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1094:1, end:1094:2))"]
#[derive(Clone, Debug)]
struct vsubuhs_instructionVar718 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsubuhs_instructionVar718 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubuhs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1099:1, end:1099:2))"]
#[derive(Clone, Debug)]
struct vsubuwm_instructionVar719 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vsubuwm_instructionVar719 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubuwm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1104:1, end:1104:2))"]
#[derive(Clone, Debug)]
struct vsubuws_instructionVar720 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vsubuws_instructionVar720 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubuws"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1109:1, end:1109:2))"]
#[derive(Clone, Debug)]
struct vsumsws_instructionVar721 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vsumsws_instructionVar721 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsumsws"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1114:1, end:1114:2))"]
#[derive(Clone, Debug)]
struct vsum2sws_instructionVar722 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vsum2sws_instructionVar722 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsum2sws"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1119:1, end:1119:2))"]
#[derive(Clone, Debug)]
struct vsum4sbs_instructionVar723 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vsum4sbs_instructionVar723 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsum4sbs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1124:1, end:1124:2))"]
#[derive(Clone, Debug)]
struct vsum4shs_instructionVar724 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vsum4shs_instructionVar724 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsum4shs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1129:1, end:1129:2))"]
#[derive(Clone, Debug)]
struct vsum4ubs_instructionVar725 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vsum4ubs_instructionVar725 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsum4ubs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1164:1, end:1164:2))"]
#[derive(Clone, Debug)]
struct vxor_instructionVar726 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vxor_instructionVar726 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vxor"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1315:1, end:1315:2))"]
#[derive(Clone, Debug)]
struct vaddcuq_instructionVar727 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vaddcuq_instructionVar727 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddcuq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1327:1, end:1327:2))"]
#[derive(Clone, Debug)]
struct vaddudm_instructionVar728 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vaddudm_instructionVar728 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddudm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1331:1, end:1331:2))"]
#[derive(Clone, Debug)]
struct vadduqm_instructionVar729 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vadduqm_instructionVar729 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vadduqm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1335:1, end:1335:2))"]
#[derive(Clone, Debug)]
struct vbpermq_instructionVar730 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vbpermq_instructionVar730 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vbpermq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1339:1, end:1339:2))"]
#[derive(Clone, Debug)]
struct vcipher_instructionVar731 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vcipher_instructionVar731 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcipher"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1343:1, end:1343:2))"]
#[derive(Clone, Debug)]
struct vcipherlast_instructionVar732 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vcipherlast_instructionVar732 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcipherlast"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1363:1, end:1363:2))"]
#[derive(Clone, Debug)]
struct vcmpequd_instructionVar733 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpequd_instructionVar733 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpequd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1367:1, end:1367:2))"]
#[derive(Clone, Debug)]
struct vcmpequd__instructionVar734 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vcmpequd__instructionVar734 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpequd."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1371:1, end:1371:2))"]
#[derive(Clone, Debug)]
struct vcmpgtsd_instructionVar735 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpgtsd_instructionVar735 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtsd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1375:1, end:1375:2))"]
#[derive(Clone, Debug)]
struct vcmpgtsd__instructionVar736 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vcmpgtsd__instructionVar736 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtsd."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1379:1, end:1379:2))"]
#[derive(Clone, Debug)]
struct vcmpgtud_instructionVar737 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpgtud_instructionVar737 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtud"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1383:1, end:1383:2))"]
#[derive(Clone, Debug)]
struct vcmpgtud__instructionVar738 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpgtud__instructionVar738 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpgtud."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1387:1, end:1387:2))"]
#[derive(Clone, Debug)]
struct veqv_instructionVar739 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl veqv_instructionVar739 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("veqv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1395:1, end:1395:2))"]
#[derive(Clone, Debug)]
struct vmaxsd_instructionVar740 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmaxsd_instructionVar740 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmaxsd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1399:1, end:1399:2))"]
#[derive(Clone, Debug)]
struct vmaxud_instructionVar741 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vmaxud_instructionVar741 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmaxud"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1403:1, end:1403:2))"]
#[derive(Clone, Debug)]
struct vminsd_instructionVar742 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vminsd_instructionVar742 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vminsd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1407:1, end:1407:2))"]
#[derive(Clone, Debug)]
struct vminud_instructionVar743 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vminud_instructionVar743 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vminud"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1411:1, end:1411:2))"]
#[derive(Clone, Debug)]
struct vmrgew_instructionVar744 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vmrgew_instructionVar744 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmrgew"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1415:1, end:1415:2))"]
#[derive(Clone, Debug)]
struct vmrgow_instructionVar745 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vmrgow_instructionVar745 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmrgow"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1419:1, end:1419:2))"]
#[derive(Clone, Debug)]
struct vmulesw_instructionVar746 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vmulesw_instructionVar746 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmulesw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1423:1, end:1423:2))"]
#[derive(Clone, Debug)]
struct vmuleuw_instructionVar747 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vmuleuw_instructionVar747 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmuleuw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1427:1, end:1427:2))"]
#[derive(Clone, Debug)]
struct vmulosw_instructionVar748 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vmulosw_instructionVar748 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmulosw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1431:1, end:1431:2))"]
#[derive(Clone, Debug)]
struct vmulouw_instructionVar749 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vmulouw_instructionVar749 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmulouw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1435:1, end:1435:2))"]
#[derive(Clone, Debug)]
struct vmuluwm_instructionVar750 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmuluwm_instructionVar750 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmuluwm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1439:1, end:1439:2))"]
#[derive(Clone, Debug)]
struct vnand_instructionVar751 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vnand_instructionVar751 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vnand"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1443:1, end:1443:2))"]
#[derive(Clone, Debug)]
struct vncipher_instructionVar752 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vncipher_instructionVar752 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vncipher"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1447:1, end:1447:2))"]
#[derive(Clone, Debug)]
struct vncipherlast_instructionVar753 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vncipherlast_instructionVar753 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vncipherlast"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1451:1, end:1451:2))"]
#[derive(Clone, Debug)]
struct vorc_instructionVar754 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vorc_instructionVar754 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vorc"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1459:1, end:1459:2))"]
#[derive(Clone, Debug)]
struct vpksdss_instructionVar755 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vpksdss_instructionVar755 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpksdss"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1463:1, end:1463:2))"]
#[derive(Clone, Debug)]
struct vpksdus_instructionVar756 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vpksdus_instructionVar756 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpksdus"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1467:1, end:1467:2))"]
#[derive(Clone, Debug)]
struct vpkudum_instructionVar757 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vpkudum_instructionVar757 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkudum"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1471:1, end:1471:2))"]
#[derive(Clone, Debug)]
struct vpkudus_instructionVar758 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vpkudus_instructionVar758 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpkudus"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1475:1, end:1475:2))"]
#[derive(Clone, Debug)]
struct vpmsumb_instructionVar759 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vpmsumb_instructionVar759 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpmsumb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1479:1, end:1479:2))"]
#[derive(Clone, Debug)]
struct vpmsumd_instructionVar760 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vpmsumd_instructionVar760 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpmsumd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1483:1, end:1483:2))"]
#[derive(Clone, Debug)]
struct vpmsumh_instructionVar761 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vpmsumh_instructionVar761 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpmsumh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1487:1, end:1487:2))"]
#[derive(Clone, Debug)]
struct vpmsumw_instructionVar762 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vpmsumw_instructionVar762 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpmsumw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1507:1, end:1507:2))"]
#[derive(Clone, Debug)]
struct vrld_instructionVar763 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vrld_instructionVar763 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrld"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1515:1, end:1515:2))"]
#[derive(Clone, Debug)]
struct vshasigmad_instructionVar764 {
    ST: u8,
    SIX: u8,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vshasigmad_instructionVar764 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vshasigmad"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.ST as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.SIX as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ST = token_18(tokens_current);
        let SIX = token_85(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, ST, SIX }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1519:1, end:1519:2))"]
#[derive(Clone, Debug)]
struct vshasigmaw_instructionVar765 {
    ST: u8,
    SIX: u8,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vshasigmaw_instructionVar765 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vshasigmaw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.ST as u64),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.SIX as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SIX = token_85(tokens_current);
        let ST = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, ST, SIX }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1523:1, end:1523:2))"]
#[derive(Clone, Debug)]
struct vsld_instructionVar766 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vsld_instructionVar766 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsld"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1527:1, end:1527:2))"]
#[derive(Clone, Debug)]
struct vsrad_instructionVar767 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vsrad_instructionVar767 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsrad"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1531:1, end:1531:2))"]
#[derive(Clone, Debug)]
struct vsrd_instructionVar768 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsrd_instructionVar768 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsrd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1535:1, end:1535:2))"]
#[derive(Clone, Debug)]
struct vsubcuq_instructionVar769 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsubcuq_instructionVar769 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubcuq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1547:1, end:1547:2))"]
#[derive(Clone, Debug)]
struct vsubudm_instructionVar770 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vsubudm_instructionVar770 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubudm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1551:1, end:1551:2))"]
#[derive(Clone, Debug)]
struct vsubuqm_instructionVar771 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsubuqm_instructionVar771 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubuqm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1578:1, end:1578:2))"]
#[derive(Clone, Debug)]
struct bcdcpsgn__instructionVar772 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl bcdcpsgn__instructionVar772 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdcpsgn."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1618:1, end:1618:2))"]
#[derive(Clone, Debug)]
struct vabsdub_instructionVar773 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vabsdub_instructionVar773 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vabsdub"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1622:1, end:1622:2))"]
#[derive(Clone, Debug)]
struct vabsduh_instructionVar774 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vabsduh_instructionVar774 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vabsduh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1626:1, end:1626:2))"]
#[derive(Clone, Debug)]
struct vabsduw_instructionVar775 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vabsduw_instructionVar775 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vabsduw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1630:1, end:1630:2))"]
#[derive(Clone, Debug)]
struct vbpermd_instructionVar776 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vbpermd_instructionVar776 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vbpermd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1638:1, end:1638:2))"]
#[derive(Clone, Debug)]
struct vcmpneb_instructionVar777 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vcmpneb_instructionVar777 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpneb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1642:1, end:1642:2))"]
#[derive(Clone, Debug)]
struct vcmpneb__instructionVar778 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vcmpneb__instructionVar778 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpneb."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1646:1, end:1646:2))"]
#[derive(Clone, Debug)]
struct vcmpneh_instructionVar779 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vcmpneh_instructionVar779 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpneh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1650:1, end:1650:2))"]
#[derive(Clone, Debug)]
struct vcmpneh__instructionVar780 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vcmpneh__instructionVar780 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpneh."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1654:1, end:1654:2))"]
#[derive(Clone, Debug)]
struct vcmpnew_instructionVar781 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpnew_instructionVar781 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpnew"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1658:1, end:1658:2))"]
#[derive(Clone, Debug)]
struct vcmpnew__instructionVar782 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vcmpnew__instructionVar782 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpnew."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1662:1, end:1662:2))"]
#[derive(Clone, Debug)]
struct vcmpnezb_instructionVar783 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vcmpnezb_instructionVar783 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpnezb"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1666:1, end:1666:2))"]
#[derive(Clone, Debug)]
struct vcmpnezb__instructionVar784 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vcmpnezb__instructionVar784 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpnezb."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1670:1, end:1670:2))"]
#[derive(Clone, Debug)]
struct vcmpnezh_instructionVar785 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vcmpnezh_instructionVar785 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpnezh"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1674:1, end:1674:2))"]
#[derive(Clone, Debug)]
struct vcmpnezh__instructionVar786 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vcmpnezh__instructionVar786 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpnezh."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1678:1, end:1678:2))"]
#[derive(Clone, Debug)]
struct vcmpnezw_instructionVar787 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vcmpnezw_instructionVar787 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpnezw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1682:1, end:1682:2))"]
#[derive(Clone, Debug)]
struct vcmpnezw__instructionVar788 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vcmpnezw__instructionVar788 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vcmpnezw."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1746:1, end:1746:2))"]
#[derive(Clone, Debug)]
struct vextublx_instructionVar789 {
    D: u8,
    A: u8,
    vrB: TablevrB,
}
impl vextublx_instructionVar789 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextublx"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1750:1, end:1750:2))"]
#[derive(Clone, Debug)]
struct vextubrx_instructionVar790 {
    D: u8,
    A: u8,
    vrB: TablevrB,
}
impl vextubrx_instructionVar790 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextubrx"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1754:1, end:1754:2))"]
#[derive(Clone, Debug)]
struct vextuhlx_instructionVar791 {
    D: u8,
    A: u8,
    vrB: TablevrB,
}
impl vextuhlx_instructionVar791 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextuhlx"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1758:1, end:1758:2))"]
#[derive(Clone, Debug)]
struct vextuhrx_instructionVar792 {
    D: u8,
    A: u8,
    vrB: TablevrB,
}
impl vextuhrx_instructionVar792 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextuhrx"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1763:1, end:1763:2))"]
#[derive(Clone, Debug)]
struct vextuwlx_instructionVar793 {
    D: u8,
    A: u8,
    vrB: TablevrB,
}
impl vextuwlx_instructionVar793 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextuwlx"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let D = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1770:1, end:1770:2))"]
#[derive(Clone, Debug)]
struct vextuwrx_instructionVar794 {
    D: u8,
    A: u8,
    vrB: TablevrB,
}
impl vextuwrx_instructionVar794 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vextuwrx"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, D, A }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1794:1, end:1794:2))"]
#[derive(Clone, Debug)]
struct vmul10ecuq_instructionVar795 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vmul10ecuq_instructionVar795 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmul10ecuq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1798:1, end:1798:2))"]
#[derive(Clone, Debug)]
struct vmul10euq_instructionVar796 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vmul10euq_instructionVar796 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmul10euq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1830:1, end:1830:2))"]
#[derive(Clone, Debug)]
struct vrldmi_instructionVar797 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vrldmi_instructionVar797 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrldmi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1834:1, end:1834:2))"]
#[derive(Clone, Debug)]
struct vrldnm_instructionVar798 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vrldnm_instructionVar798 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrldnm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1838:1, end:1838:2))"]
#[derive(Clone, Debug)]
struct vrlwmi_instructionVar799 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vrlwmi_instructionVar799 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrlwmi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1842:1, end:1842:2))"]
#[derive(Clone, Debug)]
struct vrlwnm_instructionVar800 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vrlwnm_instructionVar800 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vrlwnm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1846:1, end:1846:2))"]
#[derive(Clone, Debug)]
struct vslv_instructionVar801 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vslv_instructionVar801 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vslv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1850:1, end:1850:2))"]
#[derive(Clone, Debug)]
struct vsrv_instructionVar802 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vsrv_instructionVar802 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsrv"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3817:1, end:3817:2))"]
#[derive(Clone, Debug)]
struct sradi_instructionVar803 {
    A: u8,
    S: u8,
    SH: TableSH,
}
impl sradi_instructionVar803 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sradi"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SH
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SH = if let Some((len, table)) =
            TableSH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SH, A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3824:1, end:3824:2))"]
#[derive(Clone, Debug)]
struct sradi__instructionVar804 {
    A: u8,
    S: u8,
    SH: TableSH,
}
impl sradi__instructionVar804 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sradi."));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.SH
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SH = if let Some((len, table)) =
            TableSH::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SH, A, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3938:1, end:3938:2))"]
#[derive(Clone, Debug)]
struct stb_instructionVar805 {
    S: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl stb_instructionVar805 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stb"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                S,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3945:1, end:3945:2))"]
#[derive(Clone, Debug)]
struct stbu_instructionVar806 {
    S: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl stbu_instructionVar806 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stbu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4018:1, end:4018:2))"]
#[derive(Clone, Debug)]
struct stfd_instructionVar807 {
    fS: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl stfd_instructionVar807 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stfd"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fS),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fS = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                fS,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4025:1, end:4025:2))"]
#[derive(Clone, Debug)]
struct stfdu_instructionVar808 {
    fS: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl stfdu_instructionVar808 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stfdu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fS),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fS = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, fS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4056:1, end:4056:2))"]
#[derive(Clone, Debug)]
struct stfs_instructionVar809 {
    fS: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl stfs_instructionVar809 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stfs"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fS),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fS = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                fS,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4064:1, end:4064:2))"]
#[derive(Clone, Debug)]
struct stfsu_instructionVar810 {
    fS: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl stfsu_instructionVar810 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stfsu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_6_display(self.fS),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let fS = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, fS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4089:1, end:4089:2))"]
#[derive(Clone, Debug)]
struct sth_instructionVar811 {
    S: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl sth_instructionVar811 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sth"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                S,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4104:1, end:4104:2))"]
#[derive(Clone, Debug)]
struct sthu_instructionVar812 {
    S: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl sthu_instructionVar812 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sthu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:96:1, end:96:2))"]
#[derive(Clone, Debug)]
struct stmw_instructionVar813 {
    S: u8,
    BITS_21_25: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
    STMR31: TableSTMR31,
}
impl stmw_instructionVar813 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stmw"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        context_instance.write_lsmul(
            u8::try_from(i128::try_from(token_51(tokens_current)).unwrap() & 31).unwrap(),
        );
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let STMR31 = if let Some((len, table)) =
            TableSTMR31::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let BITS_21_25 = token_51(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                STMR31,
                S,
                BITS_21_25,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4146:1, end:4146:2))"]
#[derive(Clone, Debug)]
struct stw_instructionVar814 {
    S: u8,
    dPlusRaOrZeroAddress: TabledPlusRaOrZeroAddress,
}
impl stw_instructionVar814 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stw"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaOrZeroAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaOrZeroAddress = if let Some((len, table)) =
            TabledPlusRaOrZeroAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                dPlusRaOrZeroAddress,
                S,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4182:1, end:4182:2))"]
#[derive(Clone, Debug)]
struct stwu_instructionVar815 {
    S: u8,
    dPlusRaAddress: TabledPlusRaAddress,
}
impl stwu_instructionVar815 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stwu"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.dPlusRaAddress
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let dPlusRaAddress = if let Some((len, table)) =
            TabledPlusRaAddress::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { dPlusRaAddress, S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4313:1, end:4313:2))"]
#[derive(Clone, Debug)]
struct subfic_instructionVar816 {
    D: u8,
    A: u8,
    SIMM: u16,
}
impl subfic_instructionVar816 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subfic"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        let SIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4414:1, end:4414:2))"]
#[derive(Clone, Debug)]
struct td_instructionVar817 {
    A: u8,
    SIMM: u16,
    TOm: TableTOm,
}
impl td_instructionVar817 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("td"));
        self.TOm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("i"),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let TOm = if let Some((len, table)) =
            TableTOm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let A = token_1(tokens_current);
        let SIMM = token_84(tokens_current);
        let TO = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOm, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4473:1, end:4473:2))"]
#[derive(Clone, Debug)]
struct tw_instructionVar818 {
    A: u8,
    SIMM: u16,
    TOm: TableTOm,
}
impl tw_instructionVar818 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tw"));
        self.TOm
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("i"),
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let TOm = if let Some((len, table)) =
            TableTOm::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let TO = token_51(tokens_current);
        let A = token_1(tokens_current);
        let SIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { TOm, A, SIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4526:1, end:4526:2))"]
#[derive(Clone, Debug)]
struct xori_instructionVar819 {
    A: u8,
    S: u8,
    UIMM: u16,
}
impl xori_instructionVar819 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xori"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        let UIMM = token_84(tokens_current);
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, UIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:4532:1, end:4532:2))"]
#[derive(Clone, Debug)]
struct xoris_instructionVar820 {
    A: u8,
    S: u8,
    UIMM: u16,
}
impl xoris_instructionVar820 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("xoris"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.S),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.UIMM as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let UIMM = token_84(tokens_current);
        let S = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, S, UIMM }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:54:1, end:54:2))"]
#[derive(Clone, Debug)]
struct mbar_instructionVar821 {
    MO: u8,
}
impl mbar_instructionVar821 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mbar"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.MO as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let MO = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { MO }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:177:1, end:177:2))"]
#[derive(Clone, Debug)]
struct tlbre_instructionVar822 {}
impl tlbre_instructionVar822 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbre"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:198:1, end:198:2))"]
#[derive(Clone, Debug)]
struct tlbwe_instructionVar823 {
    D: u8,
    A: u8,
    B_BITS: u8,
}
impl tlbwe_instructionVar823 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tlbwe"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.D),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.B_BITS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B_BITS = token_4(tokens_current);
        let D = token_51(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D, A, B_BITS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:205:1, end:205:2))"]
#[derive(Clone, Debug)]
struct wrtee_instructionVar824 {
    S: u8,
}
impl wrtee_instructionVar824 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrtee"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_3_display(self.S)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_embedded.sinc, start:211:1, end:211:2))"]
#[derive(Clone, Debug)]
struct wrteei_instructionVar825 {
    BIT_15: u8,
}
impl wrteei_instructionVar825 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("wrteei"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(true, false, self.BIT_15 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BIT_15 = token_18(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BIT_15 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1566:1, end:1566:2))"]
#[derive(Clone, Debug)]
struct bcdcfn__instructionVar826 {
    PS: u8,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl bcdcfn__instructionVar826 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdcfn."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.PS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let PS = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, PS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1570:1, end:1570:2))"]
#[derive(Clone, Debug)]
struct bcdcfsq__instructionVar827 {
    PS: u8,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl bcdcfsq__instructionVar827 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdcfsq."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.PS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let PS = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, PS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1574:1, end:1574:2))"]
#[derive(Clone, Debug)]
struct bcdcfz__instructionVar828 {
    PS: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl bcdcfz__instructionVar828 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdcfz."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.PS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let PS = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, PS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1590:1, end:1590:2))"]
#[derive(Clone, Debug)]
struct bcdctz__instructionVar829 {
    PS: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl bcdctz__instructionVar829 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdctz."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.PS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let PS = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, PS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1598:1, end:1598:2))"]
#[derive(Clone, Debug)]
struct bcdsetsgn__instructionVar830 {
    PS: u8,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl bcdsetsgn__instructionVar830 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdsetsgn."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.PS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let PS = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, PS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1306:1, end:1306:2))"]
#[derive(Clone, Debug)]
struct bcdadd__instructionVar831 {
    PS: u8,
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl bcdadd__instructionVar831 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdadd."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.PS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let PS = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA, PS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1310:1, end:1310:2))"]
#[derive(Clone, Debug)]
struct bcdsub__instructionVar832 {
    PS: u8,
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl bcdsub__instructionVar832 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdsub."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.PS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let PS = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD, PS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1594:1, end:1594:2))"]
#[derive(Clone, Debug)]
struct bcds__instructionVar833 {
    PS: u8,
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl bcds__instructionVar833 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcds."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.PS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let PS = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA, PS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1602:1, end:1602:2))"]
#[derive(Clone, Debug)]
struct bcdsr__instructionVar834 {
    PS: u8,
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl bcdsr__instructionVar834 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdsr."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.PS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let PS = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD, PS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1606:1, end:1606:2))"]
#[derive(Clone, Debug)]
struct bcdtrunc__instructionVar835 {
    PS: u8,
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl bcdtrunc__instructionVar835 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdtrunc."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.PS as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let PS = token_24(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA, PS }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1610:1, end:1610:2))"]
#[derive(Clone, Debug)]
struct bcdus__instructionVar836 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl bcdus__instructionVar836 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdus."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1614:1, end:1614:2))"]
#[derive(Clone, Debug)]
struct bcdutrunc__instructionVar837 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl bcdutrunc__instructionVar837 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bcdutrunc."));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:942:1, end:942:2))"]
#[derive(Clone, Debug)]
struct vsldoi_instructionVar838 {
    SHB: u8,
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsldoi_instructionVar838 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsldoi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(true, false, self.SHB as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SHB = token_82(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA, SHB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:614:1, end:614:2))"]
#[derive(Clone, Debug)]
struct vmaddfp_instructionVar839 {
    vrA: TablevrA,
    vrD: TablevrD,
    vrB: TablevrB,
    vrC: TablevrC,
}
impl vmaddfp_instructionVar839 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmaddfp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrD, vrB, vrC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:654:1, end:654:2))"]
#[derive(Clone, Debug)]
struct vmhaddshs_instructionVar840 {
    vrB: TablevrB,
    vrA: TablevrA,
    vrD: TablevrD,
    vrC: TablevrC,
}
impl vmhaddshs_instructionVar840 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmhaddshs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrA, vrD, vrC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:659:1, end:659:2))"]
#[derive(Clone, Debug)]
struct vmhraddshs_instructionVar841 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrC: TablevrC,
    vrA: TablevrA,
}
impl vmhraddshs_instructionVar841 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmhraddshs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrC, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:699:1, end:699:2))"]
#[derive(Clone, Debug)]
struct vmladduhm_instructionVar842 {
    vrB: TablevrB,
    vrC: TablevrC,
    vrA: TablevrA,
    vrD: TablevrD,
}
impl vmladduhm_instructionVar842 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmladduhm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrC, vrA, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:734:1, end:734:2))"]
#[derive(Clone, Debug)]
struct vmsummbm_instructionVar843 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrC: TablevrC,
    vrA: TablevrA,
}
impl vmsummbm_instructionVar843 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmsummbm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrC, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:739:1, end:739:2))"]
#[derive(Clone, Debug)]
struct vmsumshm_instructionVar844 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
    vrC: TablevrC,
}
impl vmsumshm_instructionVar844 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmsumshm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD, vrC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:744:1, end:744:2))"]
#[derive(Clone, Debug)]
struct vmsumshs_instructionVar845 {
    vrA: TablevrA,
    vrC: TablevrC,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmsumshs_instructionVar845 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmsumshs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrC, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:749:1, end:749:2))"]
#[derive(Clone, Debug)]
struct vmsumubm_instructionVar846 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrC: TablevrC,
    vrB: TablevrB,
}
impl vmsumubm_instructionVar846 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmsumubm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrC, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:754:1, end:754:2))"]
#[derive(Clone, Debug)]
struct vmsumuhm_instructionVar847 {
    vrA: TablevrA,
    vrC: TablevrC,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmsumuhm_instructionVar847 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmsumuhm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrC, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:759:1, end:759:2))"]
#[derive(Clone, Debug)]
struct vmsumuhs_instructionVar848 {
    vrC: TablevrC,
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
}
impl vmsumuhs_instructionVar848 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vmsumuhs"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrC, vrA, vrB, vrD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:804:1, end:804:2))"]
#[derive(Clone, Debug)]
struct vnmsubfp_instructionVar849 {
    vrC: TablevrC,
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vnmsubfp_instructionVar849 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vnmsubfp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrC, vrD, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:819:1, end:819:2))"]
#[derive(Clone, Debug)]
struct vperm_instructionVar850 {
    vrD: TablevrD,
    vrB: TablevrB,
    vrA: TablevrA,
    vrC: TablevrC,
}
impl vperm_instructionVar850 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vperm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrB, vrA, vrC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:927:1, end:927:2))"]
#[derive(Clone, Debug)]
struct vsel_instructionVar851 {
    vrB: TablevrB,
    vrD: TablevrD,
    vrA: TablevrA,
    vrC: TablevrC,
}
impl vsel_instructionVar851 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsel"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrD, vrA, vrC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1319:1, end:1319:2))"]
#[derive(Clone, Debug)]
struct vaddecuq_instructionVar852 {
    vrA: TablevrA,
    vrB: TablevrB,
    vrD: TablevrD,
    vrC: TablevrC,
}
impl vaddecuq_instructionVar852 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddecuq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrB, vrD, vrC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1323:1, end:1323:2))"]
#[derive(Clone, Debug)]
struct vaddeuqm_instructionVar853 {
    vrD: TablevrD,
    vrC: TablevrC,
    vrB: TablevrB,
    vrA: TablevrA,
}
impl vaddeuqm_instructionVar853 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vaddeuqm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrC, vrB, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1455:1, end:1455:2))"]
#[derive(Clone, Debug)]
struct vpermxor_instructionVar854 {
    vrD: TablevrD,
    vrA: TablevrA,
    vrB: TablevrB,
    vrC: TablevrC,
}
impl vpermxor_instructionVar854 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpermxor"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrA, vrB, vrC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1539:1, end:1539:2))"]
#[derive(Clone, Debug)]
struct vsubecuq_instructionVar855 {
    vrD: TablevrD,
    vrC: TablevrC,
    vrA: TablevrA,
    vrB: TablevrB,
}
impl vsubecuq_instructionVar855 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubecuq"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrD, vrC, vrA, vrB }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1543:1, end:1543:2))"]
#[derive(Clone, Debug)]
struct vsubeuqm_instructionVar856 {
    vrB: TablevrB,
    vrC: TablevrC,
    vrD: TablevrD,
    vrA: TablevrA,
}
impl vsubeuqm_instructionVar856 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vsubeuqm"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrB, vrC, vrD, vrA }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:1814:1, end:1814:2))"]
#[derive(Clone, Debug)]
struct vpermr_instructionVar857 {
    vrA: TablevrA,
    vrC: TablevrC,
    vrD: TablevrD,
    vrB: TablevrB,
}
impl vpermr_instructionVar857 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("vpermr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.vrD
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrA
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrB
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.vrC
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrD = if let Some((len, table)) =
            TablevrD::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrA = if let Some((len, table)) =
            TablevrA::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrB = if let Some((len, table)) =
            TablevrB::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let vrC = if let Some((len, table)) =
            TablevrC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrA, vrC, vrD, vrB }))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(bl_instructionVar0),
    Var1(bctr_instructionVar1),
    Var2(rfid_instructionVar2),
    Var3(slbia_instructionVar3),
    Var4(std_instructionVar4),
    Var5(tlbia_instructionVar5),
    Var6(trap_instructionVar6),
    Var7(isync_instructionVar7),
    Var8(rfci_instructionVar8),
    Var9(rfi_instructionVar9),
    Var10(dss_instructionVar10),
    Var11(dssall_instructionVar11),
    Var12(b_instructionVar12),
    Var13(b_instructionVar13),
    Var14(b_instructionVar14),
    Var15(b_instructionVar15),
    Var16(b_instructionVar16),
    Var17(b_instructionVar17),
    Var18(b_instructionVar18),
    Var19(b_instructionVar19),
    Var20(bctr_instructionVar20),
    Var21(bctrl_instructionVar21),
    Var22(b_instructionVar22),
    Var23(b_instructionVar23),
    Var24(blr_instructionVar24),
    Var25(blrl_instructionVar25),
    Var26(b_instructionVar26),
    Var27(b_instructionVar27),
    Var28(b_instructionVar28),
    Var29(bd_instructionVar29),
    Var30(bd_instructionVar30),
    Var31(bd_instructionVar31),
    Var32(bd_instructionVar32),
    Var33(mtspr_instructionVar33),
    Var34(eieio_instructionVar34),
    Var35(mcrf_instructionVar35),
    Var36(mcrfs_instructionVar36),
    Var37(tlbsync_instructionVar37),
    Var38(mtspr_instructionVar38),
    Var39(mcrxr_instructionVar39),
    Var40(mffs_instructionVar40),
    Var41(mffs__instructionVar41),
    Var42(mtfsb0_instructionVar42),
    Var43(mtfsb0__instructionVar43),
    Var44(mtfsb1_instructionVar44),
    Var45(mtfsb1__instructionVar45),
    Var46(mtmsrd_instructionVar46),
    Var47(mtmsrd_instructionVar47),
    Var48(sync_instructionVar48),
    Var49(mftb_instructionVar49),
    Var50(mftb_instructionVar50),
    Var51(mfcr_instructionVar51),
    Var52(mfsr_instructionVar52),
    Var53(mtsr_instructionVar53),
    Var54(mtsrd_instructionVar54),
    Var55(nego_instructionVar55),
    Var56(mfmsr_instructionVar56),
    Var57(mtmsr_instructionVar57),
    Var58(mtmsr_instructionVar58),
    Var59(mfvscr_instructionVar59),
    Var60(addme_instructionVar60),
    Var61(addme__instructionVar61),
    Var62(addmeo_instructionVar62),
    Var63(addmeo__instructionVar63),
    Var64(addze_instructionVar64),
    Var65(addze__instructionVar65),
    Var66(addzeo_instructionVar66),
    Var67(addzeo__instructionVar67),
    Var68(bctr_instructionVar68),
    Var69(bctrl_instructionVar69),
    Var70(b_instructionVar70),
    Var71(b_instructionVar71),
    Var72(blr_instructionVar72),
    Var73(blrl_instructionVar73),
    Var74(b_instructionVar74),
    Var75(bd_instructionVar75),
    Var76(bd_instructionVar76),
    Var77(bd_instructionVar77),
    Var78(bd_instructionVar78),
    Var79(tlbiel_instructionVar79),
    Var80(tlbld_instructionVar80),
    Var81(tlbli_instructionVar81),
    Var82(mtvscr_instructionVar82),
    Var83(dccci_instructionVar83),
    Var84(iccci_instructionVar84),
    Var85(icread_instructionVar85),
    Var86(dcba_instructionVar86),
    Var87(dcbf_instructionVar87),
    Var88(dcbi_instructionVar88),
    Var89(dcbst_instructionVar89),
    Var90(dcbt_instructionVar90),
    Var91(dcbtst_instructionVar91),
    Var92(dcbz_instructionVar92),
    Var93(icbi_instructionVar93),
    Var94(cmp_instructionVar94),
    Var95(cmpl_instructionVar95),
    Var96(mtfsfi_instructionVar96),
    Var97(mtfsfi__instructionVar97),
    Var98(fcmpo_instructionVar98),
    Var99(fcmpu_instructionVar99),
    Var100(cmp_instructionVar100),
    Var101(cmpl_instructionVar101),
    Var102(cntlzd_instructionVar102),
    Var103(cntlzd__instructionVar103),
    Var104(cntlzw_instructionVar104),
    Var105(cntlzw__instructionVar105),
    Var106(fabs_instructionVar106),
    Var107(fabs__instructionVar107),
    Var108(fcfid_instructionVar108),
    Var109(fcfid__instructionVar109),
    Var110(fctid_instructionVar110),
    Var111(fctid__instructionVar111),
    Var112(fctidz_instructionVar112),
    Var113(fctidz__instructionVar113),
    Var114(fctiw_instructionVar114),
    Var115(fctiw__instructionVar115),
    Var116(fctiwz_instructionVar116),
    Var117(fctiwz__instructionVar117),
    Var118(fmr_instructionVar118),
    Var119(fmr__instructionVar119),
    Var120(fnabs_instructionVar120),
    Var121(fnabs__instructionVar121),
    Var122(fneg_instructionVar122),
    Var123(fneg__instructionVar123),
    Var124(frsp_instructionVar124),
    Var125(frsp__instructionVar125),
    Var126(fsqrt_instructionVar126),
    Var127(fsqrt__instructionVar127),
    Var128(fsqrts_instructionVar128),
    Var129(fsqrts__instructionVar129),
    Var130(mfsrin_instructionVar130),
    Var131(mtfsf_instructionVar131),
    Var132(mtfsf__instructionVar132),
    Var133(mtsrdin_instructionVar133),
    Var134(mtsrin_instructionVar134),
    Var135(slbie_instructionVar135),
    Var136(slbmfee_instructionVar136),
    Var137(slbmfev_instructionVar137),
    Var138(slbmte_instructionVar138),
    Var139(tlbie_instructionVar139),
    Var140(dst_instructionVar140),
    Var141(dstt_instructionVar141),
    Var142(dstst_instructionVar142),
    Var143(dststt_instructionVar143),
    Var144(crand_instructionVar144),
    Var145(crandc_instructionVar145),
    Var146(creqv_instructionVar146),
    Var147(crnand_instructionVar147),
    Var148(crnor_instructionVar148),
    Var149(cror_instructionVar149),
    Var150(crorc_instructionVar150),
    Var151(crxor_instructionVar151),
    Var152(eciwx_instructionVar152),
    Var153(ecowx_instructionVar153),
    Var154(extsb_instructionVar154),
    Var155(extsb__instructionVar155),
    Var156(extsh_instructionVar156),
    Var157(extsh__instructionVar157),
    Var158(extsw_instructionVar158),
    Var159(extsw__instructionVar159),
    Var160(fadd_instructionVar160),
    Var161(fadd__instructionVar161),
    Var162(fadds_instructionVar162),
    Var163(fadds__instructionVar163),
    Var164(fdiv_instructionVar164),
    Var165(fdiv__instructionVar165),
    Var166(fdivs_instructionVar166),
    Var167(fdivs__instructionVar167),
    Var168(fres_instructionVar168),
    Var169(fres__instructionVar169),
    Var170(frsqrte_instructionVar170),
    Var171(frsqrte__instructionVar171),
    Var172(fsub_instructionVar172),
    Var173(fsub__instructionVar173),
    Var174(fsubs_instructionVar174),
    Var175(fsubs__instructionVar175),
    Var176(lfdux_instructionVar176),
    Var177(lfdx_instructionVar177),
    Var178(lfsux_instructionVar178),
    Var179(lfsx_instructionVar179),
    Var180(lswi_instructionVar180),
    Var181(lswi_instructionVar181),
    Var182(lswi_instructionVar182),
    Var183(lswi_instructionVar183),
    Var184(lswi_instructionVar184),
    Var185(lswi_instructionVar185),
    Var186(lswi_instructionVar186),
    Var187(lswi_instructionVar187),
    Var188(neg_instructionVar188),
    Var189(neg__instructionVar189),
    Var190(nego__instructionVar190),
    Var191(stswi_instructionVar191),
    Var192(stswi_instructionVar192),
    Var193(stswi_instructionVar193),
    Var194(stswi_instructionVar194),
    Var195(stswi_instructionVar195),
    Var196(stswi_instructionVar196),
    Var197(stswi_instructionVar197),
    Var198(stswi_instructionVar198),
    Var199(subfme_instructionVar199),
    Var200(subfme__instructionVar200),
    Var201(subfmeo_instructionVar201),
    Var202(subfmeo__instructionVar202),
    Var203(subfze_instructionVar203),
    Var204(subfze__instructionVar204),
    Var205(subfzeo_instructionVar205),
    Var206(subfzeo__instructionVar206),
    Var207(vspltisb_instructionVar207),
    Var208(vspltish_instructionVar208),
    Var209(vspltisw_instructionVar209),
    Var210(vsbox_instructionVar210),
    Var211(vmul10cuq_instructionVar211),
    Var212(vmul10uq_instructionVar212),
    Var213(lswi_instructionVar213),
    Var214(lswi_instructionVar214),
    Var215(lswi_instructionVar215),
    Var216(lswi_instructionVar216),
    Var217(lswi_instructionVar217),
    Var218(lswi_instructionVar218),
    Var219(lswi_instructionVar219),
    Var220(lswi_instructionVar220),
    Var221(mtcrf_instructionVar221),
    Var222(mtocrf_instructionVar222),
    Var223(vexptefp_instructionVar223),
    Var224(vlogefp_instructionVar224),
    Var225(vrefp_instructionVar225),
    Var226(vrfim_instructionVar226),
    Var227(vrfin_instructionVar227),
    Var228(vrfip_instructionVar228),
    Var229(vrfiz_instructionVar229),
    Var230(vrsqrtefp_instructionVar230),
    Var231(vupkhpx_instructionVar231),
    Var232(vupkhsb_instructionVar232),
    Var233(vupkhsh_instructionVar233),
    Var234(vupklpx_instructionVar234),
    Var235(vupklsb_instructionVar235),
    Var236(vupklsh_instructionVar236),
    Var237(vclzb_instructionVar237),
    Var238(vclzd_instructionVar238),
    Var239(vclzh_instructionVar239),
    Var240(vclzw_instructionVar240),
    Var241(vgbbd_instructionVar241),
    Var242(vpopcntb_instructionVar242),
    Var243(vpopcntd_instructionVar243),
    Var244(vpopcnth_instructionVar244),
    Var245(vpopcntw_instructionVar245),
    Var246(vupkhsw_instructionVar246),
    Var247(vupklsw_instructionVar247),
    Var248(bcdctn__instructionVar248),
    Var249(bcdctsq__instructionVar249),
    Var250(vclzlsbb_instructionVar250),
    Var251(vctzb_instructionVar251),
    Var252(vctzh_instructionVar252),
    Var253(vctzd_instructionVar253),
    Var254(vctzlsbb_instructionVar254),
    Var255(vctzw_instructionVar255),
    Var256(vextsb2d_instructionVar256),
    Var257(vextsb2w_instructionVar257),
    Var258(vextsh2d_instructionVar258),
    Var259(vextsh2w_instructionVar259),
    Var260(vextsw2d_instructionVar260),
    Var261(vnegd_instructionVar261),
    Var262(vnegw_instructionVar262),
    Var263(vprtybd_instructionVar263),
    Var264(vprtybq_instructionVar264),
    Var265(vprtybw_instructionVar265),
    Var266(vspltw_instructionVar266),
    Var267(vsplth_instructionVar267),
    Var268(mfocrf_instructionVar268),
    Var269(stfdux_instructionVar269),
    Var270(stfdx_instructionVar270),
    Var271(stfiwx_instructionVar271),
    Var272(stfsux_instructionVar272),
    Var273(stfsx_instructionVar273),
    Var274(stswi_instructionVar274),
    Var275(stswi_instructionVar275),
    Var276(stswi_instructionVar276),
    Var277(stswi_instructionVar277),
    Var278(stswi_instructionVar278),
    Var279(stswi_instructionVar279),
    Var280(stswi_instructionVar280),
    Var281(stswi_instructionVar281),
    Var282(xor__instructionVar282),
    Var283(icbt_instructionVar283),
    Var284(tlbsx__instructionVar284),
    Var285(vspltb_instructionVar285),
    Var286(vextractd_instructionVar286),
    Var287(vextractub_instructionVar287),
    Var288(vextractuh_instructionVar288),
    Var289(vextractuw_instructionVar289),
    Var290(vinsertb_instructionVar290),
    Var291(vinsertd_instructionVar291),
    Var292(vinserth_instructionVar292),
    Var293(vinsertw_instructionVar293),
    Var294(add_instructionVar294),
    Var295(add__instructionVar295),
    Var296(addo_instructionVar296),
    Var297(addo__instructionVar297),
    Var298(addc_instructionVar298),
    Var299(addc__instructionVar299),
    Var300(addco_instructionVar300),
    Var301(addco__instructionVar301),
    Var302(adde_instructionVar302),
    Var303(adde__instructionVar303),
    Var304(addeo_instructionVar304),
    Var305(addeo__instructionVar305),
    Var306(sc_instructionVar306),
    Var307(li_instructionVar307),
    Var308(li_instructionVar308),
    Var309(lis_instructionVar309),
    Var310(lis_instructionVar310),
    Var311(bl_instructionVar311),
    Var312(fmul_instructionVar312),
    Var313(fmul__instructionVar313),
    Var314(fmuls_instructionVar314),
    Var315(fmuls__instructionVar315),
    Var316(addi_instructionVar316),
    Var317(subi_instructionVar317),
    Var318(addic_instructionVar318),
    Var319(subic_instructionVar319),
    Var320(addic__instructionVar320),
    Var321(subic__instructionVar321),
    Var322(addis_instructionVar322),
    Var323(subis_instructionVar323),
    Var324(and_instructionVar324),
    Var325(and__instructionVar325),
    Var326(andc_instructionVar326),
    Var327(andc__instructionVar327),
    Var328(b_instructionVar328),
    Var329(b_instructionVar329),
    Var330(b_instructionVar330),
    Var331(bl_instructionVar331),
    Var332(b_instructionVar332),
    Var333(b_instructionVar333),
    Var334(bd_instructionVar334),
    Var335(bd_instructionVar335),
    Var336(bd_instructionVar336),
    Var337(bd_instructionVar337),
    Var338(fmadd_instructionVar338),
    Var339(fmadd__instructionVar339),
    Var340(fmadds_instructionVar340),
    Var341(fmadds__instructionVar341),
    Var342(fmsub_instructionVar342),
    Var343(fmsub__instructionVar343),
    Var344(fmsubs_instructionVar344),
    Var345(fmsubs__instructionVar345),
    Var346(fnmadd_instructionVar346),
    Var347(fnmadd__instructionVar347),
    Var348(fnmadds_instructionVar348),
    Var349(fnmadds__instructionVar349),
    Var350(fnmsub_instructionVar350),
    Var351(fnmsub__instructionVar351),
    Var352(fnmsubs_instructionVar352),
    Var353(fnmsubs__instructionVar353),
    Var354(fsel_instructionVar354),
    Var355(fsel__instructionVar355),
    Var356(rldcl_instructionVar356),
    Var357(rldcl__instructionVar357),
    Var358(rldcr_instructionVar358),
    Var359(rldcr__instructionVar359),
    Var360(ld_instructionVar360),
    Var361(ldu_instructionVar361),
    Var362(lwa_instructionVar362),
    Var363(rldic_instructionVar363),
    Var364(rldic__instructionVar364),
    Var365(rldicl_instructionVar365),
    Var366(rldicl__instructionVar366),
    Var367(rldicr_instructionVar367),
    Var368(rldicr__instructionVar368),
    Var369(rldimi_instructionVar369),
    Var370(rldimi__instructionVar370),
    Var371(std_instructionVar371),
    Var372(stdu_instructionVar372),
    Var373(b_instructionVar373),
    Var374(bl_instructionVar374),
    Var375(cmp_instructionVar375),
    Var376(cmpl_instructionVar376),
    Var377(cmp_instructionVar377),
    Var378(cmpl_instructionVar378),
    Var379(rlwimi_instructionVar379),
    Var380(rlwimi__instructionVar380),
    Var381(rlwinm_instructionVar381),
    Var382(rlwinm__instructionVar382),
    Var383(rlwnm_instructionVar383),
    Var384(rlwnm__instructionVar384),
    Var385(andi__instructionVar385),
    Var386(andis__instructionVar386),
    Var387(b_instructionVar387),
    Var388(b_instructionVar388),
    Var389(b_instructionVar389),
    Var390(divd_instructionVar390),
    Var391(divd__instructionVar391),
    Var392(divdo_instructionVar392),
    Var393(divdo__instructionVar393),
    Var394(divdu_instructionVar394),
    Var395(divdu__instructionVar395),
    Var396(divduo_instructionVar396),
    Var397(divduo__instructionVar397),
    Var398(divw_instructionVar398),
    Var399(divw__instructionVar399),
    Var400(divwo_instructionVar400),
    Var401(divwo__instructionVar401),
    Var402(divwu_instructionVar402),
    Var403(divwu__instructionVar403),
    Var404(divwuo_instructionVar404),
    Var405(divwuo__instructionVar405),
    Var406(eqv_instructionVar406),
    Var407(eqv__instructionVar407),
    Var408(lbz_instructionVar408),
    Var409(lbzu_instructionVar409),
    Var410(lbzux_instructionVar410),
    Var411(lbzx_instructionVar411),
    Var412(ldux_instructionVar412),
    Var413(ldarx_instructionVar413),
    Var414(lfd_instructionVar414),
    Var415(lfdu_instructionVar415),
    Var416(lfs_instructionVar416),
    Var417(lfsu_instructionVar417),
    Var418(lha_instructionVar418),
    Var419(lhau_instructionVar419),
    Var420(lhaux_instructionVar420),
    Var421(lhax_instructionVar421),
    Var422(lhbrx_instructionVar422),
    Var423(lhz_instructionVar423),
    Var424(lhzu_instructionVar424),
    Var425(lhzux_instructionVar425),
    Var426(lhzx_instructionVar426),
    Var427(lmw_instructionVar427),
    Var428(lswx_instructionVar428),
    Var429(lwarx_instructionVar429),
    Var430(lwaux_instructionVar430),
    Var431(lwax_instructionVar431),
    Var432(lwbrx_instructionVar432),
    Var433(lwz_instructionVar433),
    Var434(lwzu_instructionVar434),
    Var435(lwzux_instructionVar435),
    Var436(lwzx_instructionVar436),
    Var437(macchw_instructionVar437),
    Var438(macchw__instructionVar438),
    Var439(macchwo_instructionVar439),
    Var440(macchwo__instructionVar440),
    Var441(macchws_instructionVar441),
    Var442(macchws__instructionVar442),
    Var443(macchwso_instructionVar443),
    Var444(macchwso__instructionVar444),
    Var445(macchwsu_instructionVar445),
    Var446(macchwsu__instructionVar446),
    Var447(macchwsuo_instructionVar447),
    Var448(macchwsuo__instructionVar448),
    Var449(macchwu_instructionVar449),
    Var450(macchwu__instructionVar450),
    Var451(macchwuo_instructionVar451),
    Var452(macchwuo__instructionVar452),
    Var453(machhw_instructionVar453),
    Var454(machhw__instructionVar454),
    Var455(machhwo_instructionVar455),
    Var456(machhwo__instructionVar456),
    Var457(machhws_instructionVar457),
    Var458(machhws__instructionVar458),
    Var459(machhwso_instructionVar459),
    Var460(machhwso__instructionVar460),
    Var461(machhwsu_instructionVar461),
    Var462(machhwsu__instructionVar462),
    Var463(machhwsuo_instructionVar463),
    Var464(machhwsuo__instructionVar464),
    Var465(machhwu_instructionVar465),
    Var466(machhwu__instructionVar466),
    Var467(machhwuo_instructionVar467),
    Var468(machhwuo__instructionVar468),
    Var469(maclhw_instructionVar469),
    Var470(maclhw__instructionVar470),
    Var471(maclhwo_instructionVar471),
    Var472(maclhwo__instructionVar472),
    Var473(maclhws_instructionVar473),
    Var474(maclhws__instructionVar474),
    Var475(maclhwso_instructionVar475),
    Var476(maclhwso__instructionVar476),
    Var477(maclhwsu_instructionVar477),
    Var478(maclhwsu__instructionVar478),
    Var479(maclhwsuo_instructionVar479),
    Var480(maclhwsuo__instructionVar480),
    Var481(maclhwu_instructionVar481),
    Var482(maclhwu__instructionVar482),
    Var483(maclhwuo_instructionVar483),
    Var484(maclhwuo__instructionVar484),
    Var485(mulchw_instructionVar485),
    Var486(mulchw__instructionVar486),
    Var487(mulchwu_instructionVar487),
    Var488(mulchwu__instructionVar488),
    Var489(mulhhw_instructionVar489),
    Var490(mulhhw__instructionVar490),
    Var491(mulhhwu_instructionVar491),
    Var492(mulhhwu__instructionVar492),
    Var493(mullhw_instructionVar493),
    Var494(mullhw__instructionVar494),
    Var495(mullhwu_instructionVar495),
    Var496(mullhwu__instructionVar496),
    Var497(nmacchw_instructionVar497),
    Var498(nmacchw__instructionVar498),
    Var499(nmacchwo_instructionVar499),
    Var500(nmacchwo__instructionVar500),
    Var501(nmacchws_instructionVar501),
    Var502(nmacchws__instructionVar502),
    Var503(nmacchwso_instructionVar503),
    Var504(nmacchwso__instructionVar504),
    Var505(nmachhw_instructionVar505),
    Var506(nmachhw__instructionVar506),
    Var507(nmachhwo_instructionVar507),
    Var508(nmachhwo__instructionVar508),
    Var509(nmachhws_instructionVar509),
    Var510(nmachhws__instructionVar510),
    Var511(nmachhwso_instructionVar511),
    Var512(nmachhwso__instructionVar512),
    Var513(nmaclhw_instructionVar513),
    Var514(nmaclhw__instructionVar514),
    Var515(nmaclhwo_instructionVar515),
    Var516(nmaclhwo__instructionVar516),
    Var517(nmaclhws_instructionVar517),
    Var518(nmaclhws__instructionVar518),
    Var519(nmaclhwso_instructionVar519),
    Var520(nmaclhwso__instructionVar520),
    Var521(mulhd_instructionVar521),
    Var522(mulhd__instructionVar522),
    Var523(mulhdu_instructionVar523),
    Var524(mulhdu__instructionVar524),
    Var525(mulhw_instructionVar525),
    Var526(mulhw__instructionVar526),
    Var527(mulhwu_instructionVar527),
    Var528(mulhwu__instructionVar528),
    Var529(mulld_instructionVar529),
    Var530(mulld__instructionVar530),
    Var531(mulldo_instructionVar531),
    Var532(mulldo__instructionVar532),
    Var533(mulli_instructionVar533),
    Var534(mullw_instructionVar534),
    Var535(mullw__instructionVar535),
    Var536(mullwo_instructionVar536),
    Var537(mullwo__instructionVar537),
    Var538(nand_instructionVar538),
    Var539(nand__instructionVar539),
    Var540(nor_instructionVar540),
    Var541(nor__instructionVar541),
    Var542(or_instructionVar542),
    Var543(or__instructionVar543),
    Var544(orc_instructionVar544),
    Var545(orc__instructionVar545),
    Var546(ori_instructionVar546),
    Var547(oris_instructionVar547),
    Var548(sld_instructionVar548),
    Var549(sld__instructionVar549),
    Var550(slw_instructionVar550),
    Var551(slw__instructionVar551),
    Var552(srad_instructionVar552),
    Var553(srad__instructionVar553),
    Var554(sraw_instructionVar554),
    Var555(sraw__instructionVar555),
    Var556(srawi_instructionVar556),
    Var557(srawi__instructionVar557),
    Var558(srd_instructionVar558),
    Var559(srd__instructionVar559),
    Var560(srw_instructionVar560),
    Var561(srw__instructionVar561),
    Var562(stbux_instructionVar562),
    Var563(stbx_instructionVar563),
    Var564(stdcx__instructionVar564),
    Var565(stdux_instructionVar565),
    Var566(stdx_instructionVar566),
    Var567(sthbrx_instructionVar567),
    Var568(sthux_instructionVar568),
    Var569(sthx_instructionVar569),
    Var570(stswx_instructionVar570),
    Var571(stwbrx_instructionVar571),
    Var572(stwcx__instructionVar572),
    Var573(stwux_instructionVar573),
    Var574(stwx_instructionVar574),
    Var575(subf_instructionVar575),
    Var576(subf__instructionVar576),
    Var577(subfo_instructionVar577),
    Var578(subfo__instructionVar578),
    Var579(subfc_instructionVar579),
    Var580(subfc__instructionVar580),
    Var581(subfco_instructionVar581),
    Var582(subfco__instructionVar582),
    Var583(subfe_instructionVar583),
    Var584(subfe__instructionVar584),
    Var585(subfeo_instructionVar585),
    Var586(subfeo__instructionVar586),
    Var587(td_instructionVar587),
    Var588(tw_instructionVar588),
    Var589(xor_instructionVar589),
    Var590(mfdcr_instructionVar590),
    Var591(mfspr_instructionVar591),
    Var592(mtdcr_instructionVar592),
    Var593(mtspr_instructionVar593),
    Var594(tlbsx_instructionVar594),
    Var595(lvebx_instructionVar595),
    Var596(lvehx_instructionVar596),
    Var597(lvewx_instructionVar597),
    Var598(lvsl_instructionVar598),
    Var599(lvsr_instructionVar599),
    Var600(lvx_instructionVar600),
    Var601(lvxl_instructionVar601),
    Var602(stvebx_instructionVar602),
    Var603(stvehx_instructionVar603),
    Var604(stvewx_instructionVar604),
    Var605(stvx_instructionVar605),
    Var606(stvxl_instructionVar606),
    Var607(vaddcuw_instructionVar607),
    Var608(vaddfp_instructionVar608),
    Var609(vaddsbs_instructionVar609),
    Var610(vaddshs_instructionVar610),
    Var611(vaddsws_instructionVar611),
    Var612(vaddubm_instructionVar612),
    Var613(vaddubs_instructionVar613),
    Var614(vadduhm_instructionVar614),
    Var615(vadduhs_instructionVar615),
    Var616(vadduwm_instructionVar616),
    Var617(vand_instructionVar617),
    Var618(vandc_instructionVar618),
    Var619(vavgsb_instructionVar619),
    Var620(vavgsh_instructionVar620),
    Var621(vavgsw_instructionVar621),
    Var622(vavgub_instructionVar622),
    Var623(vavguh_instructionVar623),
    Var624(vavguw_instructionVar624),
    Var625(vcfsx_instructionVar625),
    Var626(vcfux_instructionVar626),
    Var627(vcmpbfp_instructionVar627),
    Var628(vcmpbfp__instructionVar628),
    Var629(vcmpeqfp_instructionVar629),
    Var630(vcmpeqfp__instructionVar630),
    Var631(vcmpequb_instructionVar631),
    Var632(vcmpequb__instructionVar632),
    Var633(vcmpequh_instructionVar633),
    Var634(vcmpequh__instructionVar634),
    Var635(vcmpequw_instructionVar635),
    Var636(vcmpequw__instructionVar636),
    Var637(vcmpgefp_instructionVar637),
    Var638(vcmpgefp__instructionVar638),
    Var639(vcmpgtfp_instructionVar639),
    Var640(vcmpgtfp__instructionVar640),
    Var641(vcmpgtsb_instructionVar641),
    Var642(vcmpgtsb__instructionVar642),
    Var643(vcmpgtsh_instructionVar643),
    Var644(vcmpgtsh__instructionVar644),
    Var645(vcmpgtsw_instructionVar645),
    Var646(vcmpgtsw__instructionVar646),
    Var647(vcmpgtub_instructionVar647),
    Var648(vcmpgtub__instructionVar648),
    Var649(vcmpgtuh_instructionVar649),
    Var650(vcmpgtuh__instructionVar650),
    Var651(vcmpgtuw_instructionVar651),
    Var652(vcmpgtuw__instructionVar652),
    Var653(vctsxs_instructionVar653),
    Var654(vctuxs_instructionVar654),
    Var655(vmaxfp_instructionVar655),
    Var656(vmaxsb_instructionVar656),
    Var657(vmaxsh_instructionVar657),
    Var658(vmaxsw_instructionVar658),
    Var659(vmaxub_instructionVar659),
    Var660(vmaxuh_instructionVar660),
    Var661(vmaxuw_instructionVar661),
    Var662(vminfp_instructionVar662),
    Var663(vminsb_instructionVar663),
    Var664(vminsh_instructionVar664),
    Var665(vminsw_instructionVar665),
    Var666(vminub_instructionVar666),
    Var667(vminuh_instructionVar667),
    Var668(vminuw_instructionVar668),
    Var669(vmrghb_instructionVar669),
    Var670(vmrghh_instructionVar670),
    Var671(vmrghw_instructionVar671),
    Var672(vmrglb_instructionVar672),
    Var673(vmrglh_instructionVar673),
    Var674(vmrglw_instructionVar674),
    Var675(vmulesb_instructionVar675),
    Var676(vmulesh_instructionVar676),
    Var677(vmuleub_instructionVar677),
    Var678(vmuleuh_instructionVar678),
    Var679(vmulosb_instructionVar679),
    Var680(vmulosh_instructionVar680),
    Var681(vmuloub_instructionVar681),
    Var682(vmulouh_instructionVar682),
    Var683(vnor_instructionVar683),
    Var684(vor_instructionVar684),
    Var685(vpkpx_instructionVar685),
    Var686(vpkshss_instructionVar686),
    Var687(vpkshus_instructionVar687),
    Var688(vpkswss_instructionVar688),
    Var689(vpkswus_instructionVar689),
    Var690(vpkuhum_instructionVar690),
    Var691(vpkuhus_instructionVar691),
    Var692(vpkuwum_instructionVar692),
    Var693(vpkuwus_instructionVar693),
    Var694(vrlb_instructionVar694),
    Var695(vrlh_instructionVar695),
    Var696(vrlw_instructionVar696),
    Var697(vsl_instructionVar697),
    Var698(vslb_instructionVar698),
    Var699(vslh_instructionVar699),
    Var700(vslo_instructionVar700),
    Var701(vslw_instructionVar701),
    Var702(vsr_instructionVar702),
    Var703(vsrab_instructionVar703),
    Var704(vsrah_instructionVar704),
    Var705(vsraw_instructionVar705),
    Var706(vsrb_instructionVar706),
    Var707(vsrh_instructionVar707),
    Var708(vsro_instructionVar708),
    Var709(vsrw_instructionVar709),
    Var710(vsubcuw_instructionVar710),
    Var711(vsubfp_instructionVar711),
    Var712(vsubsbs_instructionVar712),
    Var713(vsubshs_instructionVar713),
    Var714(vsubsws_instructionVar714),
    Var715(vsububm_instructionVar715),
    Var716(vsububs_instructionVar716),
    Var717(vsubuhm_instructionVar717),
    Var718(vsubuhs_instructionVar718),
    Var719(vsubuwm_instructionVar719),
    Var720(vsubuws_instructionVar720),
    Var721(vsumsws_instructionVar721),
    Var722(vsum2sws_instructionVar722),
    Var723(vsum4sbs_instructionVar723),
    Var724(vsum4shs_instructionVar724),
    Var725(vsum4ubs_instructionVar725),
    Var726(vxor_instructionVar726),
    Var727(vaddcuq_instructionVar727),
    Var728(vaddudm_instructionVar728),
    Var729(vadduqm_instructionVar729),
    Var730(vbpermq_instructionVar730),
    Var731(vcipher_instructionVar731),
    Var732(vcipherlast_instructionVar732),
    Var733(vcmpequd_instructionVar733),
    Var734(vcmpequd__instructionVar734),
    Var735(vcmpgtsd_instructionVar735),
    Var736(vcmpgtsd__instructionVar736),
    Var737(vcmpgtud_instructionVar737),
    Var738(vcmpgtud__instructionVar738),
    Var739(veqv_instructionVar739),
    Var740(vmaxsd_instructionVar740),
    Var741(vmaxud_instructionVar741),
    Var742(vminsd_instructionVar742),
    Var743(vminud_instructionVar743),
    Var744(vmrgew_instructionVar744),
    Var745(vmrgow_instructionVar745),
    Var746(vmulesw_instructionVar746),
    Var747(vmuleuw_instructionVar747),
    Var748(vmulosw_instructionVar748),
    Var749(vmulouw_instructionVar749),
    Var750(vmuluwm_instructionVar750),
    Var751(vnand_instructionVar751),
    Var752(vncipher_instructionVar752),
    Var753(vncipherlast_instructionVar753),
    Var754(vorc_instructionVar754),
    Var755(vpksdss_instructionVar755),
    Var756(vpksdus_instructionVar756),
    Var757(vpkudum_instructionVar757),
    Var758(vpkudus_instructionVar758),
    Var759(vpmsumb_instructionVar759),
    Var760(vpmsumd_instructionVar760),
    Var761(vpmsumh_instructionVar761),
    Var762(vpmsumw_instructionVar762),
    Var763(vrld_instructionVar763),
    Var764(vshasigmad_instructionVar764),
    Var765(vshasigmaw_instructionVar765),
    Var766(vsld_instructionVar766),
    Var767(vsrad_instructionVar767),
    Var768(vsrd_instructionVar768),
    Var769(vsubcuq_instructionVar769),
    Var770(vsubudm_instructionVar770),
    Var771(vsubuqm_instructionVar771),
    Var772(bcdcpsgn__instructionVar772),
    Var773(vabsdub_instructionVar773),
    Var774(vabsduh_instructionVar774),
    Var775(vabsduw_instructionVar775),
    Var776(vbpermd_instructionVar776),
    Var777(vcmpneb_instructionVar777),
    Var778(vcmpneb__instructionVar778),
    Var779(vcmpneh_instructionVar779),
    Var780(vcmpneh__instructionVar780),
    Var781(vcmpnew_instructionVar781),
    Var782(vcmpnew__instructionVar782),
    Var783(vcmpnezb_instructionVar783),
    Var784(vcmpnezb__instructionVar784),
    Var785(vcmpnezh_instructionVar785),
    Var786(vcmpnezh__instructionVar786),
    Var787(vcmpnezw_instructionVar787),
    Var788(vcmpnezw__instructionVar788),
    Var789(vextublx_instructionVar789),
    Var790(vextubrx_instructionVar790),
    Var791(vextuhlx_instructionVar791),
    Var792(vextuhrx_instructionVar792),
    Var793(vextuwlx_instructionVar793),
    Var794(vextuwrx_instructionVar794),
    Var795(vmul10ecuq_instructionVar795),
    Var796(vmul10euq_instructionVar796),
    Var797(vrldmi_instructionVar797),
    Var798(vrldnm_instructionVar798),
    Var799(vrlwmi_instructionVar799),
    Var800(vrlwnm_instructionVar800),
    Var801(vslv_instructionVar801),
    Var802(vsrv_instructionVar802),
    Var803(sradi_instructionVar803),
    Var804(sradi__instructionVar804),
    Var805(stb_instructionVar805),
    Var806(stbu_instructionVar806),
    Var807(stfd_instructionVar807),
    Var808(stfdu_instructionVar808),
    Var809(stfs_instructionVar809),
    Var810(stfsu_instructionVar810),
    Var811(sth_instructionVar811),
    Var812(sthu_instructionVar812),
    Var813(stmw_instructionVar813),
    Var814(stw_instructionVar814),
    Var815(stwu_instructionVar815),
    Var816(subfic_instructionVar816),
    Var817(td_instructionVar817),
    Var818(tw_instructionVar818),
    Var819(xori_instructionVar819),
    Var820(xoris_instructionVar820),
    Var821(mbar_instructionVar821),
    Var822(tlbre_instructionVar822),
    Var823(tlbwe_instructionVar823),
    Var824(wrtee_instructionVar824),
    Var825(wrteei_instructionVar825),
    Var826(bcdcfn__instructionVar826),
    Var827(bcdcfsq__instructionVar827),
    Var828(bcdcfz__instructionVar828),
    Var829(bcdctz__instructionVar829),
    Var830(bcdsetsgn__instructionVar830),
    Var831(bcdadd__instructionVar831),
    Var832(bcdsub__instructionVar832),
    Var833(bcds__instructionVar833),
    Var834(bcdsr__instructionVar834),
    Var835(bcdtrunc__instructionVar835),
    Var836(bcdus__instructionVar836),
    Var837(bcdutrunc__instructionVar837),
    Var838(vsldoi_instructionVar838),
    Var839(vmaddfp_instructionVar839),
    Var840(vmhaddshs_instructionVar840),
    Var841(vmhraddshs_instructionVar841),
    Var842(vmladduhm_instructionVar842),
    Var843(vmsummbm_instructionVar843),
    Var844(vmsumshm_instructionVar844),
    Var845(vmsumshs_instructionVar845),
    Var846(vmsumubm_instructionVar846),
    Var847(vmsumuhm_instructionVar847),
    Var848(vmsumuhs_instructionVar848),
    Var849(vnmsubfp_instructionVar849),
    Var850(vperm_instructionVar850),
    Var851(vsel_instructionVar851),
    Var852(vaddecuq_instructionVar852),
    Var853(vaddeuqm_instructionVar853),
    Var854(vpermxor_instructionVar854),
    Var855(vsubecuq_instructionVar855),
    Var856(vsubeuqm_instructionVar856),
    Var857(vpermr_instructionVar857),
}
impl Tableinstruction {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var64(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var65(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var66(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var67(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var68(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var69(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var70(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var71(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var72(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var73(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var74(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var75(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var76(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var77(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var78(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var79(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var80(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var81(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var82(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var83(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var84(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var85(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var86(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var87(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var88(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var89(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var90(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var91(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var92(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var93(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var94(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var95(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var96(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var97(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var98(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var99(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var100(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var101(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var102(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var103(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var104(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var105(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var106(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var107(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var108(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var109(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var110(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var111(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var112(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var113(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var114(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var115(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var116(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var117(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var118(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var119(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var120(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var121(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var122(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var123(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var124(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var125(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var126(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var127(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var128(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var129(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var130(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var131(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var132(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var133(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var134(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var135(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var136(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var137(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var138(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var139(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var140(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var141(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var142(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var143(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var144(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var145(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var146(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var147(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var148(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var149(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var150(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var151(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var152(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var153(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var154(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var155(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var156(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var157(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var158(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var159(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var160(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var161(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var162(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var163(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var164(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var165(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var166(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var167(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var168(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var169(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var170(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var171(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var172(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var173(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var174(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var175(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var176(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var177(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var178(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var179(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var180(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var181(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var182(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var183(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var184(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var185(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var186(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var187(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var188(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var189(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var190(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var191(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var192(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var193(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var194(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var195(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var196(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var197(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var198(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var199(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var200(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var201(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var202(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var203(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var204(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var205(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var206(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var207(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var208(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var209(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var210(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var211(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var212(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var213(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var214(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var215(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var216(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var217(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var218(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var219(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var220(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var221(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var222(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var223(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var224(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var225(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var226(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var227(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var228(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var229(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var230(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var231(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var232(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var233(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var234(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var235(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var236(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var237(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var238(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var239(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var240(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var241(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var242(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var243(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var244(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var245(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var246(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var247(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var248(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var249(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var250(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var251(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var252(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var253(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var254(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var255(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var256(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var257(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var258(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var259(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var260(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var261(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var262(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var263(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var264(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var265(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var266(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var267(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var268(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var269(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var270(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var271(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var272(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var273(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var274(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var275(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var276(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var277(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var278(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var279(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var280(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var281(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var282(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var283(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var284(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var285(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var286(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var287(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var288(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var289(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var290(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var291(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var292(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var293(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var294(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var295(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var296(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var297(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var298(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var299(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var300(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var301(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var302(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var303(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var304(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var305(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var306(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var307(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var308(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var309(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var310(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var311(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var312(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var313(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var314(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var315(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var316(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var317(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var318(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var319(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var320(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var321(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var322(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var323(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var324(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var325(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var326(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var327(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var328(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var329(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var330(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var331(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var332(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var333(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var334(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var335(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var336(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var337(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var338(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var339(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var340(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var341(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var342(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var343(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var344(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var345(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var346(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var347(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var348(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var349(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var350(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var351(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var352(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var353(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var354(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var355(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var356(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var357(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var358(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var359(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var360(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var361(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var362(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var363(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var364(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var365(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var366(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var367(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var368(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var369(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var370(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var371(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var372(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var373(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var374(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var375(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var376(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var377(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var378(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var379(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var380(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var381(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var382(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var383(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var384(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var385(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var386(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var387(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var388(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var389(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var390(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var391(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var392(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var393(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var394(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var395(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var396(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var397(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var398(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var399(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var400(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var401(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var402(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var403(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var404(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var405(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var406(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var407(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var408(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var409(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var410(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var411(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var412(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var413(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var414(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var415(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var416(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var417(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var418(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var419(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var420(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var421(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var422(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var423(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var424(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var425(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var426(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var427(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var428(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var429(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var430(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var431(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var432(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var433(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var434(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var435(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var436(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var437(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var438(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var439(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var440(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var441(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var442(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var443(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var444(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var445(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var446(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var447(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var448(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var449(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var450(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var451(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var452(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var453(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var454(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var455(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var456(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var457(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var458(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var459(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var460(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var461(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var462(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var463(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var464(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var465(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var466(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var467(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var468(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var469(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var470(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var471(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var472(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var473(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var474(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var475(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var476(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var477(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var478(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var479(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var480(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var481(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var482(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var483(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var484(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var485(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var486(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var487(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var488(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var489(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var490(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var491(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var492(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var493(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var494(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var495(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var496(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var497(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var498(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var499(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var500(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var501(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var502(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var503(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var504(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var505(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var506(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var507(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var508(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var509(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var510(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var511(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var512(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var513(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var514(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var515(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var516(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var517(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var518(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var519(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var520(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var521(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var522(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var523(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var524(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var525(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var526(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var527(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var528(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var529(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var530(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var531(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var532(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var533(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var534(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var535(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var536(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var537(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var538(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var539(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var540(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var541(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var542(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var543(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var544(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var545(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var546(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var547(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var548(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var549(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var550(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var551(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var552(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var553(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var554(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var555(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var556(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var557(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var558(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var559(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var560(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var561(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var562(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var563(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var564(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var565(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var566(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var567(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var568(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var569(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var570(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var571(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var572(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var573(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var574(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var575(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var576(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var577(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var578(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var579(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var580(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var581(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var582(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var583(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var584(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var585(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var586(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var587(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var588(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var589(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var590(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var591(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var592(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var593(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var594(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var595(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var596(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var597(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var598(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var599(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var600(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var601(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var602(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var603(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var604(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var605(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var606(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var607(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var608(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var609(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var610(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var611(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var612(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var613(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var614(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var615(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var616(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var617(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var618(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var619(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var620(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var621(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var622(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var623(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var624(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var625(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var626(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var627(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var628(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var629(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var630(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var631(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var632(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var633(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var634(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var635(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var636(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var637(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var638(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var639(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var640(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var641(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var642(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var643(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var644(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var645(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var646(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var647(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var648(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var649(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var650(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var651(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var652(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var653(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var654(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var655(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var656(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var657(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var658(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var659(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var660(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var661(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var662(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var663(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var664(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var665(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var666(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var667(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var668(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var669(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var670(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var671(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var672(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var673(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var674(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var675(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var676(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var677(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var678(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var679(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var680(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var681(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var682(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var683(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var684(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var685(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var686(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var687(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var688(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var689(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var690(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var691(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var692(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var693(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var694(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var695(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var696(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var697(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var698(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var699(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var700(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var701(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var702(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var703(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var704(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var705(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var706(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var707(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var708(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var709(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var710(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var711(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var712(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var713(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var714(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var715(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var716(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var717(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var718(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var719(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var720(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var721(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var722(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var723(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var724(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var725(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var726(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var727(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var728(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var729(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var730(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var731(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var732(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var733(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var734(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var735(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var736(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var737(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var738(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var739(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var740(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var741(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var742(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var743(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var744(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var745(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var746(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var747(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var748(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var749(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var750(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var751(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var752(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var753(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var754(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var755(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var756(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var757(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var758(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var759(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var760(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var761(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var762(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var763(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var764(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var765(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var766(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var767(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var768(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var769(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var770(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var771(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var772(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var773(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var774(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var775(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var776(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var777(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var778(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var779(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var780(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var781(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var782(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var783(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var784(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var785(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var786(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var787(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var788(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var789(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var790(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var791(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var792(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var793(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var794(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var795(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var796(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var797(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var798(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var799(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var800(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var801(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var802(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var803(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var804(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var805(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var806(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var807(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var808(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var809(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var810(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var811(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var812(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var813(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var814(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var815(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var816(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var817(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var818(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var819(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var820(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var821(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var822(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var823(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var824(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var825(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var826(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var827(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var828(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var829(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var830(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var831(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var832(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var833(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var834(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var835(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var836(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var837(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var838(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var839(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var840(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var841(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var842(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var843(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var844(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var845(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var846(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var847(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var848(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var849(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var850(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var851(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var852(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var853(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var854(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var855(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var856(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var857(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 5
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 72
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 7 == 2
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                bctr_instructionVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 76
        {
            if let Some((inst_len, parsed)) =
                rfid_instructionVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 228
            && (tokens_param[1] & 255) == 3
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                slbia_instructionVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 40
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 65
            && (tokens_param[3] & 255) == 248
        {
            if let Some((inst_len, parsed)) =
                std_instructionVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 228
            && (tokens_param[1] & 255) == 2
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                tlbia_instructionVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 224
            && (tokens_param[3] & 255) == 127
        {
            if let Some((inst_len, parsed)) =
                trap_instructionVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 76
        {
            if let Some((inst_len, parsed)) =
                isync_instructionVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 102
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 76
        {
            if let Some((inst_len, parsed)) =
                rfci_instructionVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 100
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 76
        {
            if let Some((inst_len, parsed)) =
                rfi_instructionVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 108
            && (tokens_param[1] & 255) == 6
            && (tokens_param[2] & 159) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dss_instructionVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 108
            && (tokens_param[1] & 255) == 6
            && (tokens_param[2] & 159) == 0
            && (tokens_param[3] & 255) == 126
        {
            if let Some((inst_len, parsed)) =
                dssall_instructionVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 231) == 4
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 231) == 4
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                bctr_instructionVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                bctrl_instructionVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                blr_instructionVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                blrl_instructionVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 3 == 2
            && (tokens_param[0] & 255) == 166
            && (tokens_param[1] & 255) == 3
            && (tokens_param[2] & 255) == 8
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                mtspr_instructionVar33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 172
            && (tokens_param[1] & 255) == 6
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                eieio_instructionVar34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 99) == 0
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                mcrf_instructionVar35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 128
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 99) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                mcrfs_instructionVar36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 108
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                tlbsync_instructionVar37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 166
            && (tokens_param[1] & 255) == 3
            && (tokens_param[2] & 255) == 8
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                mtspr_instructionVar38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 127) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mcrxr_instructionVar39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 142
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                mffs_instructionVar40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 143
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                mffs__instructionVar41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 140
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                mtfsb0_instructionVar42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 141
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                mtfsb0__instructionVar43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                mtfsb1_instructionVar44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 77
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                mtfsb1__instructionVar45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 100
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtmsrd_instructionVar46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 100
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 31) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtmsrd_instructionVar47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 172
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 159) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                sync_instructionVar48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 230
            && (tokens_param[1] & 255) == 66
            && (tokens_param[2] & 31) == 12
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mftb_instructionVar49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 230
            && (tokens_param[1] & 255) == 66
            && (tokens_param[2] & 31) == 13
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mftb_instructionVar50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 38
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mfcr_instructionVar51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 166
            && (tokens_param[1] & 255) == 4
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mfsr_instructionVar52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 164
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtsr_instructionVar53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 164
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtsrd_instructionVar54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 208
            && (tokens_param[1] & 255) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                nego_instructionVar55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 166
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mfmsr_instructionVar56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtmsr_instructionVar57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 255) == 1
            && (tokens_param[2] & 31) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtmsr_instructionVar58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 255) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mfvscr_instructionVar59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 212
            && (tokens_param[1] & 255) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addme_instructionVar60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 213
            && (tokens_param[1] & 255) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addme__instructionVar61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 212
            && (tokens_param[1] & 255) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addmeo_instructionVar62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 213
            && (tokens_param[1] & 255) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addmeo__instructionVar63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 148
            && (tokens_param[1] & 255) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addze_instructionVar64::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var64(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 149
            && (tokens_param[1] & 255) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addze__instructionVar65::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var65(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 148
            && (tokens_param[1] & 255) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addzeo_instructionVar66::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var66(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 149
            && (tokens_param[1] & 255) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addzeo__instructionVar67::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var67(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 231) == 4
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                bctr_instructionVar68::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var68(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 231) == 4
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                bctrl_instructionVar69::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var69(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 231) == 4
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar70::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var70(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 231) == 4
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar71::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var71(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                blr_instructionVar72::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var72(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                blrl_instructionVar73::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var73(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar74::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var74(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar75::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var75(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 78
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar76::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var76(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar77::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var77(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 33
            && (tokens_param[1] & 231) == 0
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 76
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar78::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var78(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                tlbiel_instructionVar79::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var79(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 164
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                tlbld_instructionVar80::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var80(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 228
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                tlbli_instructionVar81::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var81(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 16
        {
            if let Some((inst_len, parsed)) =
                mtvscr_instructionVar82::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var82(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 140
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dccci_instructionVar83::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var83(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 140
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                iccci_instructionVar84::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var84(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 204
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                icread_instructionVar85::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var85(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 236
            && (tokens_param[1] & 7) == 5
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dcba_instructionVar86::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var86(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 172
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dcbf_instructionVar87::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var87(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 172
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dcbi_instructionVar88::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var88(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 108
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dcbst_instructionVar89::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var89(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dcbt_instructionVar90::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var90(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 236
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dcbtst_instructionVar91::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var91(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 236
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dcbz_instructionVar92::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var92(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 172
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                icbi_instructionVar93::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var93(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 192) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar94::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var94(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 192) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                cmpl_instructionVar95::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var95(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 15) == 1
            && (tokens_param[2] & 127) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                mtfsfi_instructionVar96::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var96(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 13
            && (tokens_param[1] & 15) == 1
            && (tokens_param[2] & 127) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                mtfsfi__instructionVar97::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var97(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 96) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fcmpo_instructionVar98::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var98(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 96) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fcmpu_instructionVar99::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var99(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 64) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar100::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var100(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 64) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cmpl_instructionVar101::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var101(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 116
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cntlzd_instructionVar102::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var102(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 117
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cntlzd__instructionVar103::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var103(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 52
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cntlzw_instructionVar104::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var104(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 53
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                cntlzw__instructionVar105::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var105(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fabs_instructionVar106::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var106(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fabs__instructionVar107::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var107(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 156
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fcfid_instructionVar108::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var108(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 157
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fcfid__instructionVar109::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var109(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 92
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fctid_instructionVar110::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var110(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 93
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fctid__instructionVar111::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var111(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 94
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fctidz_instructionVar112::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var112(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 95
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fctidz__instructionVar113::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var113(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 28
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fctiw_instructionVar114::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var114(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 29
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fctiw__instructionVar115::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var115(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 30
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fctiwz_instructionVar116::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var116(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 31
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fctiwz__instructionVar117::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var117(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 144
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fmr_instructionVar118::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var118(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 145
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fmr__instructionVar119::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var119(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fnabs_instructionVar120::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var120(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fnabs__instructionVar121::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var121(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fneg_instructionVar122::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var122(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fneg__instructionVar123::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var123(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                frsp_instructionVar124::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var124(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 25
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                frsp__instructionVar125::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var125(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fsqrt_instructionVar126::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var126(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 45
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fsqrt__instructionVar127::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var127(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fsqrts_instructionVar128::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var128(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 45
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fsqrts__instructionVar129::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var129(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 38
            && (tokens_param[1] & 7) == 5
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mfsrin_instructionVar130::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var130(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 142
            && (tokens_param[1] & 7) == 5
            && (tokens_param[2] & 1) == 0
            && (tokens_param[3] & 254) == 252
        {
            if let Some((inst_len, parsed)) =
                mtfsf_instructionVar131::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var131(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 143
            && (tokens_param[1] & 7) == 5
            && (tokens_param[2] & 1) == 0
            && (tokens_param[3] & 254) == 252
        {
            if let Some((inst_len, parsed)) =
                mtfsf__instructionVar132::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var132(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 228
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtsrdin_instructionVar133::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var133(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 228
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtsrin_instructionVar134::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var134(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 100
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                slbie_instructionVar135::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var135(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 38
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                slbmfee_instructionVar136::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var136(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 166
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                slbmfev_instructionVar137::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var137(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                slbmte_instructionVar138::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var138(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 100
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                tlbie_instructionVar139::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var139(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 172
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dst_instructionVar140::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var140(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 172
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 255) == 126
        {
            if let Some((inst_len, parsed)) =
                dstt_instructionVar141::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var141(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 236
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                dstst_instructionVar142::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var142(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 236
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 255) == 126
        {
            if let Some((inst_len, parsed)) =
                dststt_instructionVar143::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var143(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                crand_instructionVar144::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var144(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                crandc_instructionVar145::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var145(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                creqv_instructionVar146::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var146(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 194
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                crnand_instructionVar147::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var147(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                crnor_instructionVar148::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var148(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                cror_instructionVar149::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var149(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                crorc_instructionVar150::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var150(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 76
        {
            if let Some((inst_len, parsed)) =
                crxor_instructionVar151::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var151(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 108
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                eciwx_instructionVar152::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var152(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 108
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                ecowx_instructionVar153::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var153(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 116
            && (tokens_param[1] & 255) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extsb_instructionVar154::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var154(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 117
            && (tokens_param[1] & 255) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extsb__instructionVar155::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var155(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 52
            && (tokens_param[1] & 255) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extsh_instructionVar156::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var156(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 53
            && (tokens_param[1] & 255) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extsh__instructionVar157::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var157(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 180
            && (tokens_param[1] & 255) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extsw_instructionVar158::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var158(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 181
            && (tokens_param[1] & 255) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                extsw__instructionVar159::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var159(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 42
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fadd_instructionVar160::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var160(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 43
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fadd__instructionVar161::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var161(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 42
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fadds_instructionVar162::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var162(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 43
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fadds__instructionVar163::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var163(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fdiv_instructionVar164::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var164(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 37
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fdiv__instructionVar165::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var165(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fdivs_instructionVar166::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var166(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 37
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fdivs__instructionVar167::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var167(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fres_instructionVar168::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var168(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 49
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fres__instructionVar169::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var169(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 52
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                frsqrte_instructionVar170::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var170(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 53
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                frsqrte__instructionVar171::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var171(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 40
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fsub_instructionVar172::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var172(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 41
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fsub__instructionVar173::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var173(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 40
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fsubs_instructionVar174::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var174(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 41
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fsubs__instructionVar175::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var175(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 238
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lfdux_instructionVar176::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var176(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 174
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lfdx_instructionVar177::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var177(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 110
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lfsux_instructionVar178::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var178(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 46
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lfsx_instructionVar179::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var179(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar180::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var180(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 36
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar181::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var181(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 68
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar182::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var182(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 100
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar183::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var183(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 132
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar184::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var184(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 164
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar185::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var185(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 196
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar186::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var186(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 228
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar187::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var187(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 208
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                neg_instructionVar188::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var188(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 209
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                neg__instructionVar189::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var189(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 209
            && (tokens_param[1] & 255) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                nego__instructionVar190::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var190(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar191::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var191(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 37
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar192::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var192(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 69
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar193::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var193(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 101
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar194::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var194(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 133
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar195::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var195(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 165
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar196::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var196(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 197
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar197::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var197(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 255) == 229
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar198::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var198(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 208
            && (tokens_param[1] & 255) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfme_instructionVar199::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var199(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 209
            && (tokens_param[1] & 255) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfme__instructionVar200::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var200(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 208
            && (tokens_param[1] & 255) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfmeo_instructionVar201::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var201(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 209
            && (tokens_param[1] & 255) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfmeo__instructionVar202::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var202(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 144
            && (tokens_param[1] & 255) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfze_instructionVar203::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var203(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 145
            && (tokens_param[1] & 255) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfze__instructionVar204::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var204(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 144
            && (tokens_param[1] & 255) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfzeo_instructionVar205::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var205(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 145
            && (tokens_param[1] & 255) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfzeo__instructionVar206::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var206(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 255) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vspltisb_instructionVar207::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var207(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 255) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vspltish_instructionVar208::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var208(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 140
            && (tokens_param[1] & 255) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vspltisw_instructionVar209::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var209(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 200
            && (tokens_param[1] & 255) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsbox_instructionVar210::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var210(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 255) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmul10cuq_instructionVar211::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var211(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 255) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmul10uq_instructionVar212::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var212(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar213::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var213(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 36
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar214::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var214(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 68
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar215::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var215(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 100
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar216::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var216(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 132
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar217::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var217(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 164
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar218::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var218(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 196
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar219::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var219(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 228
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswi_instructionVar220::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var220(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 15) == 1
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtcrf_instructionVar221::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var221(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 32
            && (tokens_param[1] & 15) == 1
            && (tokens_param[2] & 16) == 16
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtocrf_instructionVar222::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var222(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 138
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vexptefp_instructionVar223::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var223(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 202
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vlogefp_instructionVar224::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var224(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrefp_instructionVar225::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var225(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 202
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrfim_instructionVar226::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var226(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrfin_instructionVar227::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var227(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 138
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrfip_instructionVar228::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var228(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 74
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrfiz_instructionVar229::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var229(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 74
            && (tokens_param[1] & 7) == 1
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrsqrtefp_instructionVar230::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var230(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vupkhpx_instructionVar231::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var231(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vupkhsb_instructionVar232::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var232(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vupkhsh_instructionVar233::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var233(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vupklpx_instructionVar234::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var234(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 142
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vupklsb_instructionVar235::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var235(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vupklsh_instructionVar236::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var236(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vclzb_instructionVar237::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var237(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 194
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vclzd_instructionVar238::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var238(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vclzh_instructionVar239::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var239(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vclzw_instructionVar240::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var240(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 7) == 5
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vgbbd_instructionVar241::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var241(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 3
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpopcntb_instructionVar242::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var242(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 195
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpopcntd_instructionVar243::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var243(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 67
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpopcnth_instructionVar244::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var244(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 131
            && (tokens_param[1] & 7) == 7
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpopcntw_instructionVar245::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var245(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vupkhsw_instructionVar246::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var246(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vupklsw_instructionVar247::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var247(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 7) == 5
            && (tokens_param[2] & 31) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdctn__instructionVar248::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var248(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 7) == 5
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdctsq__instructionVar249::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var249(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vclzlsbb_instructionVar250::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var250(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 28
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vctzb_instructionVar251::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var251(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 29
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vctzh_instructionVar252::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var252(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 31
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vctzd_instructionVar253::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var253(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vctzlsbb_instructionVar254::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var254(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 30
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vctzw_instructionVar255::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var255(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 24
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextsb2d_instructionVar256::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var256(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 16
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextsb2w_instructionVar257::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var257(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 25
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextsh2d_instructionVar258::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var258(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 17
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextsh2w_instructionVar259::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var259(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 26
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextsw2d_instructionVar260::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var260(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vnegd_instructionVar261::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var261(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vnegw_instructionVar262::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var262(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 9
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vprtybd_instructionVar263::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var263(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 10
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vprtybq_instructionVar264::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var264(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 6
            && (tokens_param[2] & 31) == 8
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vprtybw_instructionVar265::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var265(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 140
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 28) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vspltw_instructionVar266::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var266(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 24) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsplth_instructionVar267::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var267(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 38
            && (tokens_param[1] & 7) == 0
            && (tokens_param[2] & 16) == 16
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mfocrf_instructionVar268::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var268(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 238
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stfdux_instructionVar269::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var269(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 174
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stfdx_instructionVar270::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var270(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 174
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stfiwx_instructionVar271::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var271(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 110
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stfsux_instructionVar272::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var272(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 46
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stfsx_instructionVar273::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var273(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar274::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var274(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 37
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar275::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var275(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 69
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar276::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var276(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 101
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar277::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var277(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 133
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar278::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var278(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 165
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar279::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var279(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 197
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar280::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var280(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 231) == 229
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswi_instructionVar281::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var281(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 121
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                xor__instructionVar282::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var282(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 254) == 124
        {
            if let Some((inst_len, parsed)) =
                icbt_instructionVar283::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var283(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 255) == 37
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                tlbsx__instructionVar284::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var284(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vspltb_instructionVar285::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var285(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 205
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextractd_instructionVar286::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var286(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 13
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextractub_instructionVar287::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var287(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 77
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextractuh_instructionVar288::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var288(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 141
            && (tokens_param[1] & 7) == 2
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextractuw_instructionVar289::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var289(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 13
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vinsertb_instructionVar290::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var290(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 205
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vinsertd_instructionVar291::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var291(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 77
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vinserth_instructionVar292::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var292(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 141
            && (tokens_param[1] & 7) == 3
            && (tokens_param[2] & 16) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vinsertw_instructionVar293::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var293(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 20
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                add_instructionVar294::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var294(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 21
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                add__instructionVar295::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var295(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 20
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addo_instructionVar296::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var296(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 21
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addo__instructionVar297::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var297(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 20
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addc_instructionVar298::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var298(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 21
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addc__instructionVar299::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var299(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 20
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addco_instructionVar300::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var300(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 21
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addco__instructionVar301::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var301(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 20
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                adde_instructionVar302::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var302(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 21
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                adde__instructionVar303::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var303(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 20
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addeo_instructionVar304::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var304(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 21
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                addeo__instructionVar305::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var305(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 31) == 2
            && (tokens_param[1] & 240) == 0
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 68
        {
            if let Some((inst_len, parsed)) =
                sc_instructionVar306::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var306(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 128
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 56
        {
            if let Some((inst_len, parsed)) =
                li_instructionVar307::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var307(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 56
        {
            if let Some((inst_len, parsed)) =
                li_instructionVar308::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var308(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 128
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 60
        {
            if let Some((inst_len, parsed)) =
                lis_instructionVar309::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var309(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 0
            && (tokens_param[2] & 31) == 0
            && (tokens_param[3] & 252) == 60
        {
            if let Some((inst_len, parsed)) =
                lis_instructionVar310::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var310(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 253) == 5
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 66
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar311::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var311(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 50
            && (tokens_param[1] & 248) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fmul_instructionVar312::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var312(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 51
            && (tokens_param[1] & 248) == 0
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fmul__instructionVar313::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var313(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 50
            && (tokens_param[1] & 248) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fmuls_instructionVar314::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var314(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 51
            && (tokens_param[1] & 248) == 0
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fmuls__instructionVar315::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var315(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 0
            && (tokens_param[3] & 252) == 56
        {
            if let Some((inst_len, parsed)) =
                addi_instructionVar316::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var316(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 128
            && (tokens_param[3] & 252) == 56
        {
            if let Some((inst_len, parsed)) =
                subi_instructionVar317::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var317(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 0
            && (tokens_param[3] & 252) == 48
        {
            if let Some((inst_len, parsed)) =
                addic_instructionVar318::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var318(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 128
            && (tokens_param[3] & 252) == 48
        {
            if let Some((inst_len, parsed)) =
                subic_instructionVar319::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var319(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 0
            && (tokens_param[3] & 252) == 52
        {
            if let Some((inst_len, parsed)) =
                addic__instructionVar320::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var320(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 128
            && (tokens_param[3] & 252) == 52
        {
            if let Some((inst_len, parsed)) =
                subic__instructionVar321::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var321(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 0
            && (tokens_param[3] & 252) == 60
        {
            if let Some((inst_len, parsed)) =
                addis_instructionVar322::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var322(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[1] & 128) == 128
            && (tokens_param[3] & 252) == 60
        {
            if let Some((inst_len, parsed)) =
                subis_instructionVar323::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var323(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 56
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                and_instructionVar324::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var324(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 57
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                and__instructionVar325::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var325(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 120
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                andc_instructionVar326::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var326(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 121
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                andc__instructionVar327::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var327(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 0
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 64
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar328::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var328(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 1
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 64
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar329::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var329(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 66
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar330::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var330(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 1
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 66
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar331::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var331(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 64
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar332::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var332(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 1
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 64
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar333::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var333(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 0
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 66
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar334::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var334(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 1
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 66
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar335::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var335(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 0
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 64
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar336::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var336(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 1
            && (tokens_param[2] & 128) == 0
            && (tokens_param[3] & 254) == 64
        {
            if let Some((inst_len, parsed)) =
                bd_instructionVar337::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var337(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 58
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fmadd_instructionVar338::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var338(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 59
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fmadd__instructionVar339::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var339(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 58
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fmadds_instructionVar340::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var340(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 59
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fmadds__instructionVar341::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var341(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 56
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fmsub_instructionVar342::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var342(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 57
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fmsub__instructionVar343::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var343(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 56
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fmsubs_instructionVar344::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var344(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 57
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fmsubs__instructionVar345::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var345(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 62
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fnmadd_instructionVar346::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var346(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 63
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fnmadd__instructionVar347::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var347(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 62
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fnmadds_instructionVar348::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var348(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 63
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fnmadds__instructionVar349::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var349(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 60
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fnmsub_instructionVar350::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var350(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 61
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fnmsub__instructionVar351::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var351(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 60
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fnmsubs_instructionVar352::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var352(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 61
            && (tokens_param[3] & 252) == 236
        {
            if let Some((inst_len, parsed)) =
                fnmsubs__instructionVar353::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var353(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 46
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fsel_instructionVar354::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var354(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 63) == 47
            && (tokens_param[3] & 252) == 252
        {
            if let Some((inst_len, parsed)) =
                fsel__instructionVar355::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var355(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 31) == 16
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldcl_instructionVar356::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var356(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 31) == 17
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldcl__instructionVar357::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var357(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 31) == 18
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldcr_instructionVar358::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var358(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 31) == 19
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldcr__instructionVar359::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var359(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 3) == 0
            && (tokens_param[3] & 252) == 232
        {
            if let Some((inst_len, parsed)) =
                ld_instructionVar360::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var360(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 3) == 1
            && (tokens_param[3] & 252) == 232
        {
            if let Some((inst_len, parsed)) =
                ldu_instructionVar361::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var361(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 3) == 2
            && (tokens_param[3] & 252) == 232
        {
            if let Some((inst_len, parsed)) =
                lwa_instructionVar362::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var362(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 29) == 8
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldic_instructionVar363::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var363(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 29) == 9
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldic__instructionVar364::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var364(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 29) == 0
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldicl_instructionVar365::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var365(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 29) == 1
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldicl__instructionVar366::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var366(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 29) == 4
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldicr_instructionVar367::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var367(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 29) == 5
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldicr__instructionVar368::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var368(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 29) == 12
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldimi_instructionVar369::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var369(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 29) == 13
            && (tokens_param[3] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                rldimi__instructionVar370::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var370(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 3) == 0
            && (tokens_param[3] & 252) == 248
        {
            if let Some((inst_len, parsed)) =
                std_instructionVar371::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var371(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 3) == 1
            && (tokens_param[3] & 252) == 248
        {
            if let Some((inst_len, parsed)) =
                stdu_instructionVar372::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var372(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 0
            && (tokens_param[3] & 252) == 72
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar373::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var373(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 1
            && (tokens_param[3] & 252) == 72
        {
            if let Some((inst_len, parsed)) =
                bl_instructionVar374::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var374(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[2] & 192) == 0
            && (tokens_param[3] & 255) == 44
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar375::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var375(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[2] & 192) == 0
            && (tokens_param[3] & 255) == 40
        {
            if let Some((inst_len, parsed)) =
                cmpl_instructionVar376::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var376(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[2] & 64) == 0
            && (tokens_param[3] & 252) == 44
        {
            if let Some((inst_len, parsed)) =
                cmp_instructionVar377::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var377(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[2] & 64) == 0
            && (tokens_param[3] & 252) == 40
        {
            if let Some((inst_len, parsed)) =
                cmpl_instructionVar378::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var378(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 0
            && (tokens_param[3] & 252) == 80
        {
            if let Some((inst_len, parsed)) =
                rlwimi_instructionVar379::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var379(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 1
            && (tokens_param[3] & 252) == 80
        {
            if let Some((inst_len, parsed)) =
                rlwimi__instructionVar380::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var380(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 0
            && (tokens_param[3] & 252) == 84
        {
            if let Some((inst_len, parsed)) =
                rlwinm_instructionVar381::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var381(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 1
            && (tokens_param[3] & 252) == 84
        {
            if let Some((inst_len, parsed)) =
                rlwinm__instructionVar382::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var382(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 0
            && (tokens_param[3] & 252) == 92
        {
            if let Some((inst_len, parsed)) =
                rlwnm_instructionVar383::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var383(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 4 == 0
            && (tokens_param[0] & 1) == 1
            && (tokens_param[3] & 252) == 92
        {
            if let Some((inst_len, parsed)) =
                rlwnm__instructionVar384::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var384(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 112 {
            if let Some((inst_len, parsed)) =
                andi__instructionVar385::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var385(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 116 {
            if let Some((inst_len, parsed)) =
                andis__instructionVar386::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var386(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 3 == 2
            && (tokens_param[0] & 1) == 0
            && (tokens_param[2] & 156) == 128
            && (tokens_param[3] & 254) == 64
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar387::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var387(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 3 == 2
            && (tokens_param[0] & 1) == 0
            && (tokens_param[2] & 128) == 128
            && (tokens_param[3] & 254) == 66
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar388::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var388(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 3 == 2
            && (tokens_param[0] & 1) == 0
            && (tokens_param[3] & 252) == 72
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar389::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var389(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 210
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divd_instructionVar390::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var390(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 211
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divd__instructionVar391::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var391(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 210
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divdo_instructionVar392::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var392(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 211
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divdo__instructionVar393::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var393(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 146
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divdu_instructionVar394::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var394(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 147
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divdu__instructionVar395::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var395(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 146
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divduo_instructionVar396::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var396(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 147
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divduo__instructionVar397::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var397(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 214
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divw_instructionVar398::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var398(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 215
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divw__instructionVar399::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var399(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 214
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divwo_instructionVar400::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var400(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 215
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divwo__instructionVar401::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var401(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 150
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divwu_instructionVar402::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var402(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 151
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divwu__instructionVar403::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var403(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 150
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divwuo_instructionVar404::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var404(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 151
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                divwuo__instructionVar405::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var405(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 56
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                eqv_instructionVar406::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var406(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 57
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                eqv__instructionVar407::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var407(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 136 {
            if let Some((inst_len, parsed)) =
                lbz_instructionVar408::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var408(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 140 {
            if let Some((inst_len, parsed)) =
                lbzu_instructionVar409::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var409(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 238
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lbzux_instructionVar410::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var410(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 174
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lbzx_instructionVar411::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var411(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 106
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                ldux_instructionVar412::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var412(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 42
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                ldarx_instructionVar413::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var413(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 200 {
            if let Some((inst_len, parsed)) =
                lfd_instructionVar414::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var414(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 204 {
            if let Some((inst_len, parsed)) =
                lfdu_instructionVar415::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var415(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 192 {
            if let Some((inst_len, parsed)) =
                lfs_instructionVar416::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var416(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 196 {
            if let Some((inst_len, parsed)) =
                lfsu_instructionVar417::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var417(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 168 {
            if let Some((inst_len, parsed)) =
                lha_instructionVar418::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var418(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 172 {
            if let Some((inst_len, parsed)) =
                lhau_instructionVar419::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var419(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 238
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lhaux_instructionVar420::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var420(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 174
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lhax_instructionVar421::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var421(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lhbrx_instructionVar422::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var422(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 160 {
            if let Some((inst_len, parsed)) =
                lhz_instructionVar423::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var423(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 164 {
            if let Some((inst_len, parsed)) =
                lhzu_instructionVar424::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var424(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 110
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lhzux_instructionVar425::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var425(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 46
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lhzx_instructionVar426::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var426(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 184 {
            if let Some((inst_len, parsed)) =
                lmw_instructionVar427::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var427(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 42
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lswx_instructionVar428::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var428(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 40
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lwarx_instructionVar429::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var429(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 234
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lwaux_instructionVar430::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var430(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 170
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lwax_instructionVar431::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var431(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lwbrx_instructionVar432::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var432(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 128 {
            if let Some((inst_len, parsed)) =
                lwz_instructionVar433::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var433(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 132 {
            if let Some((inst_len, parsed)) =
                lwzu_instructionVar434::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var434(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 110
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lwzux_instructionVar435::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var435(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 46
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lwzx_instructionVar436::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var436(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 88
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchw_instructionVar437::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var437(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 89
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchw__instructionVar438::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var438(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 88
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwo_instructionVar439::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var439(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 89
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwo__instructionVar440::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var440(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchws_instructionVar441::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var441(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 217
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchws__instructionVar442::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var442(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwso_instructionVar443::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var443(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 217
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwso__instructionVar444::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var444(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwsu_instructionVar445::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var445(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 153
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwsu__instructionVar446::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var446(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwsuo_instructionVar447::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var447(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 153
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwsuo__instructionVar448::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var448(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwu_instructionVar449::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var449(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 25
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwu__instructionVar450::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var450(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwuo_instructionVar451::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var451(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 25
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                macchwuo__instructionVar452::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var452(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 88
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhw_instructionVar453::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var453(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 89
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhw__instructionVar454::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var454(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 88
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwo_instructionVar455::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var455(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 89
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwo__instructionVar456::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var456(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhws_instructionVar457::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var457(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 217
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhws__instructionVar458::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var458(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwso_instructionVar459::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var459(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 217
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwso__instructionVar460::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var460(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwsu_instructionVar461::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var461(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 153
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwsu__instructionVar462::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var462(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwsuo_instructionVar463::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var463(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 153
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwsuo__instructionVar464::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var464(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwu_instructionVar465::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var465(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 25
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwu__instructionVar466::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var466(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwuo_instructionVar467::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var467(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 25
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                machhwuo__instructionVar468::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var468(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 88
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhw_instructionVar469::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var469(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 89
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhw__instructionVar470::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var470(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 88
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwo_instructionVar471::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var471(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 89
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwo__instructionVar472::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var472(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhws_instructionVar473::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var473(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 217
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhws__instructionVar474::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var474(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 216
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwso_instructionVar475::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var475(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 217
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwso__instructionVar476::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var476(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwsu_instructionVar477::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var477(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 153
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwsu__instructionVar478::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var478(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 152
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwsuo_instructionVar479::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var479(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 153
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwsuo__instructionVar480::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var480(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwu_instructionVar481::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var481(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 25
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwu__instructionVar482::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var482(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 24
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwuo_instructionVar483::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var483(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 25
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                maclhwuo__instructionVar484::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var484(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mulchw_instructionVar485::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var485(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mulchw__instructionVar486::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var486(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mulchwu_instructionVar487::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var487(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mulchwu__instructionVar488::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var488(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mulhhw_instructionVar489::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var489(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mulhhw__instructionVar490::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var490(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mulhhwu_instructionVar491::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var491(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mulhhwu__instructionVar492::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var492(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mullhw_instructionVar493::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var493(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mullhw__instructionVar494::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var494(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mullhwu_instructionVar495::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var495(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                mullhwu__instructionVar496::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var496(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 92
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmacchw_instructionVar497::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var497(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 93
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmacchw__instructionVar498::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var498(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 92
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmacchwo_instructionVar499::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var499(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 93
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmacchwo__instructionVar500::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var500(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 220
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmacchws_instructionVar501::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var501(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 221
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmacchws__instructionVar502::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var502(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 220
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmacchwso_instructionVar503::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var503(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 221
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmacchwso__instructionVar504::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var504(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 92
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmachhw_instructionVar505::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var505(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 93
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmachhw__instructionVar506::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var506(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 92
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmachhwo_instructionVar507::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var507(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 93
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmachhwo__instructionVar508::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var508(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 220
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmachhws_instructionVar509::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var509(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 221
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmachhws__instructionVar510::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var510(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 220
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmachhwso_instructionVar511::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var511(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 221
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmachhwso__instructionVar512::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var512(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 92
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmaclhw_instructionVar513::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var513(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 93
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmaclhw__instructionVar514::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var514(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 92
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmaclhwo_instructionVar515::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var515(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 93
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmaclhwo__instructionVar516::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var516(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 220
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmaclhws_instructionVar517::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var517(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 221
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmaclhws__instructionVar518::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var518(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 220
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmaclhwso_instructionVar519::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var519(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 221
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                nmaclhwso__instructionVar520::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var520(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 146
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulhd_instructionVar521::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var521(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 147
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulhd__instructionVar522::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var522(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 18
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulhdu_instructionVar523::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var523(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 19
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulhdu__instructionVar524::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var524(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 150
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulhw_instructionVar525::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var525(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 151
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulhw__instructionVar526::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var526(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 22
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulhwu_instructionVar527::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var527(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 23
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulhwu__instructionVar528::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var528(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 210
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulld_instructionVar529::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var529(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 211
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulld__instructionVar530::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var530(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 210
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulldo_instructionVar531::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var531(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 211
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mulldo__instructionVar532::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var532(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 28 {
            if let Some((inst_len, parsed)) =
                mulli_instructionVar533::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var533(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 214
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mullw_instructionVar534::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var534(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 215
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mullw__instructionVar535::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var535(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 214
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mullwo_instructionVar536::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var536(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 215
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mullwo__instructionVar537::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var537(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 184
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                nand_instructionVar538::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var538(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 185
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                nand__instructionVar539::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var539(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 248
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                nor_instructionVar540::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var540(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 249
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                nor__instructionVar541::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var541(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 120
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                or_instructionVar542::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var542(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 121
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                or__instructionVar543::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var543(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 56
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                orc_instructionVar544::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var544(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 57
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                orc__instructionVar545::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var545(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 96 {
            if let Some((inst_len, parsed)) =
                ori_instructionVar546::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var546(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 100 {
            if let Some((inst_len, parsed)) =
                oris_instructionVar547::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var547(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 54
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sld_instructionVar548::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var548(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 55
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sld__instructionVar549::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var549(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                slw_instructionVar550::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var550(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 49
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                slw__instructionVar551::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var551(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 52
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                srad_instructionVar552::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var552(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 53
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                srad__instructionVar553::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var553(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sraw_instructionVar554::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var554(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 49
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sraw__instructionVar555::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var555(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 112
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                srawi_instructionVar556::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var556(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 113
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                srawi__instructionVar557::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var557(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 54
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                srd_instructionVar558::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var558(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 55
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                srd__instructionVar559::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var559(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 48
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                srw_instructionVar560::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var560(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 49
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                srw__instructionVar561::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var561(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 238
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stbux_instructionVar562::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var562(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 174
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stbx_instructionVar563::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var563(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 173
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stdcx__instructionVar564::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var564(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 106
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stdux_instructionVar565::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var565(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 42
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stdx_instructionVar566::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var566(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sthbrx_instructionVar567::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var567(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 110
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sthux_instructionVar568::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var568(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 46
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sthx_instructionVar569::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var569(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 42
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stswx_instructionVar570::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var570(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 44
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stwbrx_instructionVar571::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var571(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 45
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stwcx__instructionVar572::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var572(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 110
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stwux_instructionVar573::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var573(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 46
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stwx_instructionVar574::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var574(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subf_instructionVar575::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var575(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subf__instructionVar576::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var576(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 80
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfo_instructionVar577::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var577(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 81
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfo__instructionVar578::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var578(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfc_instructionVar579::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var579(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfc__instructionVar580::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var580(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfco_instructionVar581::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var581(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfco__instructionVar582::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var582(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfe_instructionVar583::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var583(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfe__instructionVar584::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var584(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 16
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfeo_instructionVar585::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var585(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 17
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                subfeo__instructionVar586::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var586(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 136
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                td_instructionVar587::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var587(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                tw_instructionVar588::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var588(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 120
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                xor_instructionVar589::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var589(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 134
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mfdcr_instructionVar590::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var590(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 166
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mfspr_instructionVar591::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var591(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 134
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtdcr_instructionVar592::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var592(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 166
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mtspr_instructionVar593::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var593(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 36
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                tlbsx_instructionVar594::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var594(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lvebx_instructionVar595::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var595(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lvehx_instructionVar596::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var596(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 142
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lvewx_instructionVar597::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var597(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lvsl_instructionVar598::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var598(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lvsr_instructionVar599::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var599(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lvx_instructionVar600::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var600(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                lvxl_instructionVar601::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var601(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stvebx_instructionVar602::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var602(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stvehx_instructionVar603::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var603(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 142
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stvewx_instructionVar604::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var604(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stvx_instructionVar605::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var605(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                stvxl_instructionVar606::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var606(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 128
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddcuw_instructionVar607::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var607(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddfp_instructionVar608::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var608(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddsbs_instructionVar609::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var609(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddshs_instructionVar610::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var610(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 128
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddsws_instructionVar611::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var611(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddubm_instructionVar612::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var612(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddubs_instructionVar613::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var613(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vadduhm_instructionVar614::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var614(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vadduhs_instructionVar615::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var615(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 128
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vadduwm_instructionVar616::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var616(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vand_instructionVar617::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var617(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vandc_instructionVar618::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var618(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vavgsb_instructionVar619::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var619(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vavgsh_instructionVar620::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var620(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vavgsw_instructionVar621::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var621(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vavgub_instructionVar622::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var622(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vavguh_instructionVar623::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var623(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vavguw_instructionVar624::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var624(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 74
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcfsx_instructionVar625::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var625(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcfux_instructionVar626::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var626(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 198
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpbfp_instructionVar627::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var627(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 198
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpbfp__instructionVar628::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var628(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 198
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpeqfp_instructionVar629::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var629(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 198
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpeqfp__instructionVar630::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var630(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpequb_instructionVar631::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var631(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpequb__instructionVar632::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var632(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpequh_instructionVar633::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var633(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpequh__instructionVar634::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var634(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 134
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpequw_instructionVar635::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var635(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 134
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpequw__instructionVar636::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var636(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 198
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgefp_instructionVar637::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var637(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 198
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgefp__instructionVar638::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var638(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 198
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtfp_instructionVar639::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var639(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 198
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtfp__instructionVar640::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var640(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtsb_instructionVar641::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var641(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtsb__instructionVar642::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var642(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtsh_instructionVar643::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var643(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtsh__instructionVar644::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var644(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 134
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtsw_instructionVar645::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var645(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 134
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtsw__instructionVar646::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var646(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtub_instructionVar647::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var647(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtub__instructionVar648::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var648(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtuh_instructionVar649::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var649(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtuh__instructionVar650::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var650(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 134
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtuw_instructionVar651::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var651(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 134
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtuw__instructionVar652::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var652(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 202
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vctsxs_instructionVar653::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var653(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 138
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vctuxs_instructionVar654::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var654(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmaxfp_instructionVar655::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var655(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmaxsb_instructionVar656::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var656(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmaxsh_instructionVar657::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var657(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmaxsw_instructionVar658::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var658(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmaxub_instructionVar659::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var659(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmaxuh_instructionVar660::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var660(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmaxuw_instructionVar661::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var661(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 74
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vminfp_instructionVar662::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var662(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vminsb_instructionVar663::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var663(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vminsh_instructionVar664::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var664(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vminsw_instructionVar665::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var665(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vminub_instructionVar666::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var666(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vminuh_instructionVar667::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var667(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vminuw_instructionVar668::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var668(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmrghb_instructionVar669::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var669(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmrghh_instructionVar670::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var670(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 140
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmrghw_instructionVar671::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var671(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmrglb_instructionVar672::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var672(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmrglh_instructionVar673::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var673(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 140
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmrglw_instructionVar674::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var674(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmulesb_instructionVar675::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var675(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmulesh_instructionVar676::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var676(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmuleub_instructionVar677::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var677(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmuleuh_instructionVar678::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var678(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmulosb_instructionVar679::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var679(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmulosh_instructionVar680::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var680(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmuloub_instructionVar681::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var681(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmulouh_instructionVar682::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var682(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vnor_instructionVar683::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var683(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 132
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vor_instructionVar684::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var684(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkpx_instructionVar685::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var685(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 142
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkshss_instructionVar686::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var686(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkshus_instructionVar687::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var687(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkswss_instructionVar688::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var688(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkswus_instructionVar689::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var689(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkuhum_instructionVar690::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var690(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 142
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkuhus_instructionVar691::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var691(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkuwum_instructionVar692::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var692(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkuwus_instructionVar693::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var693(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrlb_instructionVar694::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var694(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrlh_instructionVar695::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var695(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 132
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrlw_instructionVar696::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var696(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 196
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsl_instructionVar697::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var697(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vslb_instructionVar698::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var698(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vslh_instructionVar699::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var699(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vslo_instructionVar700::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var700(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 132
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vslw_instructionVar701::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var701(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 196
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsr_instructionVar702::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var702(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsrab_instructionVar703::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var703(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsrah_instructionVar704::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var704(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 132
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsraw_instructionVar705::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var705(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsrb_instructionVar706::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var706(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsrh_instructionVar707::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var707(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsro_instructionVar708::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var708(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 132
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsrw_instructionVar709::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var709(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 128
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubcuw_instructionVar710::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var710(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 74
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubfp_instructionVar711::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var711(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubsbs_instructionVar712::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var712(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubshs_instructionVar713::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var713(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 128
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubsws_instructionVar714::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var714(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsububm_instructionVar715::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var715(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsububs_instructionVar716::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var716(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubuhm_instructionVar717::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var717(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubuhs_instructionVar718::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var718(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 128
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubuwm_instructionVar719::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var719(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 128
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubuws_instructionVar720::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var720(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 136
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsumsws_instructionVar721::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var721(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 136
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsum2sws_instructionVar722::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var722(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsum4sbs_instructionVar723::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var723(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsum4shs_instructionVar724::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var724(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsum4ubs_instructionVar725::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var725(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 196
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vxor_instructionVar726::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var726(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddcuq_instructionVar727::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var727(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 192
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddudm_instructionVar728::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var728(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vadduqm_instructionVar729::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var729(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vbpermq_instructionVar730::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var730(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcipher_instructionVar731::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var731(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 9
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcipherlast_instructionVar732::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var732(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 199
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpequd_instructionVar733::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var733(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 199
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpequd__instructionVar734::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var734(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 199
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtsd_instructionVar735::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var735(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 199
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtsd__instructionVar736::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var736(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 199
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtud_instructionVar737::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var737(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 199
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpgtud__instructionVar738::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var738(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 132
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                veqv_instructionVar739::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var739(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 194
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmaxsd_instructionVar740::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var740(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 194
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmaxud_instructionVar741::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var741(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 194
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vminsd_instructionVar742::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var742(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 194
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vminud_instructionVar743::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var743(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 140
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmrgew_instructionVar744::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var744(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 140
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmrgow_instructionVar745::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var745(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 136
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmulesw_instructionVar746::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var746(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 136
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmuleuw_instructionVar747::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var747(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 136
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmulosw_instructionVar748::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var748(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 136
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmulouw_instructionVar749::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var749(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 137
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmuluwm_instructionVar750::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var750(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 132
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vnand_instructionVar751::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var751(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vncipher_instructionVar752::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var752(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 73
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) = vncipherlast_instructionVar753::parse(
                tokens_param,
                &mut context_current,
                inst_start,
            ) {
                *context_param = context_current;
                return Some((inst_len, Self::Var753(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vorc_instructionVar754::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var754(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpksdss_instructionVar755::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var755(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpksdus_instructionVar756::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var756(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkudum_instructionVar757::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var757(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 206
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpkudus_instructionVar758::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var758(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpmsumb_instructionVar759::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var759(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 200
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpmsumd_instructionVar760::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var760(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpmsumh_instructionVar761::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var761(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 136
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpmsumw_instructionVar762::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var762(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 196
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrld_instructionVar763::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var763(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 194
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vshasigmad_instructionVar764::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var764(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 130
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vshasigmaw_instructionVar765::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var765(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 196
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsld_instructionVar766::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var766(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 196
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsrad_instructionVar767::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var767(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 196
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsrd_instructionVar768::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var768(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubcuq_instructionVar769::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var769(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 192
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubudm_instructionVar770::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var770(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubuqm_instructionVar771::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var771(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 65
            && (tokens_param[1] & 7) == 3
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdcpsgn__instructionVar772::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var772(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 3
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vabsdub_instructionVar773::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var773(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 67
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vabsduh_instructionVar774::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var774(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 131
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vabsduw_instructionVar775::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var775(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 204
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vbpermd_instructionVar776::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var776(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 7
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpneb_instructionVar777::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var777(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 7
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpneb__instructionVar778::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var778(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 71
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpneh_instructionVar779::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var779(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 71
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpneh__instructionVar780::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var780(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 135
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpnew_instructionVar781::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var781(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 135
            && (tokens_param[1] & 7) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpnew__instructionVar782::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var782(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 7
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpnezb_instructionVar783::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var783(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 7
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpnezb__instructionVar784::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var784(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 71
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpnezh_instructionVar785::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var785(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 71
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpnezh__instructionVar786::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var786(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 135
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpnezw_instructionVar787::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var787(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 135
            && (tokens_param[1] & 7) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vcmpnezw__instructionVar788::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var788(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 13
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextublx_instructionVar789::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var789(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 13
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextubrx_instructionVar790::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var790(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 77
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextuhlx_instructionVar791::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var791(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 77
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextuhrx_instructionVar792::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var792(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 141
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextuwlx_instructionVar793::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var793(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 141
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vextuwrx_instructionVar794::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var794(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 65
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmul10ecuq_instructionVar795::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var795(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 65
            && (tokens_param[1] & 7) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmul10euq_instructionVar796::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var796(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 197
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrldmi_instructionVar797::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var797(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 197
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrldnm_instructionVar798::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var798(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 133
            && (tokens_param[1] & 7) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrlwmi_instructionVar799::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var799(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 133
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vrlwnm_instructionVar800::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var800(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vslv_instructionVar801::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var801(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsrv_instructionVar802::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var802(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 253) == 116
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sradi_instructionVar803::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var803(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 253) == 117
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                sradi__instructionVar804::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var804(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 152 {
            if let Some((inst_len, parsed)) =
                stb_instructionVar805::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var805(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 156 {
            if let Some((inst_len, parsed)) =
                stbu_instructionVar806::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var806(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 216 {
            if let Some((inst_len, parsed)) =
                stfd_instructionVar807::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var807(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 220 {
            if let Some((inst_len, parsed)) =
                stfdu_instructionVar808::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var808(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 208 {
            if let Some((inst_len, parsed)) =
                stfs_instructionVar809::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var809(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 212 {
            if let Some((inst_len, parsed)) =
                stfsu_instructionVar810::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var810(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 176 {
            if let Some((inst_len, parsed)) =
                sth_instructionVar811::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var811(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 180 {
            if let Some((inst_len, parsed)) =
                sthu_instructionVar812::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var812(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 188 {
            if let Some((inst_len, parsed)) =
                stmw_instructionVar813::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var813(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 144 {
            if let Some((inst_len, parsed)) =
                stw_instructionVar814::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var814(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 148 {
            if let Some((inst_len, parsed)) =
                stwu_instructionVar815::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var815(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 32 {
            if let Some((inst_len, parsed)) =
                subfic_instructionVar816::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var816(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 8 {
            if let Some((inst_len, parsed)) =
                td_instructionVar817::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var817(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 12 {
            if let Some((inst_len, parsed)) =
                tw_instructionVar818::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var818(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 104 {
            if let Some((inst_len, parsed)) =
                xori_instructionVar819::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var819(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 4 == 0 && (tokens_param[3] & 252) == 108 {
            if let Some((inst_len, parsed)) =
                xoris_instructionVar820::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var820(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 254) == 172
            && (tokens_param[1] & 7) == 6
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                mbar_instructionVar821::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var821(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 254) == 100
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                tlbre_instructionVar822::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var822(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 254) == 164
            && (tokens_param[1] & 7) == 7
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                tlbwe_instructionVar823::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var823(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 254) == 6
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                wrtee_instructionVar824::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var824(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 254) == 70
            && (tokens_param[1] & 7) == 1
            && (tokens_param[3] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                wrteei_instructionVar825::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var825(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 5) == 5
            && (tokens_param[2] & 31) == 7
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdcfn__instructionVar826::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var826(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 5) == 5
            && (tokens_param[2] & 31) == 2
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdcfsq__instructionVar827::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var827(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 5) == 5
            && (tokens_param[2] & 31) == 6
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdcfz__instructionVar828::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var828(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 5) == 5
            && (tokens_param[2] & 31) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdctz__instructionVar829::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var829(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 5) == 5
            && (tokens_param[2] & 31) == 31
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdsetsgn__instructionVar830::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var830(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 5) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdadd__instructionVar831::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var831(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 65
            && (tokens_param[1] & 5) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdsub__instructionVar832::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var832(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 193
            && (tokens_param[1] & 5) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcds__instructionVar833::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var833(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 193
            && (tokens_param[1] & 5) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdsr__instructionVar834::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var834(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 1
            && (tokens_param[1] & 5) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdtrunc__instructionVar835::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var835(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 129
            && (tokens_param[1] & 5) == 4
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdus__instructionVar836::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var836(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 255) == 65
            && (tokens_param[1] & 5) == 5
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                bcdutrunc__instructionVar837::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var837(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && (tokens_param[0] & 63) == 44
            && (tokens_param[1] & 4) == 0
            && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsldoi_instructionVar838::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var838(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 46 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmaddfp_instructionVar839::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var839(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 32 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmhaddshs_instructionVar840::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var840(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 33 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmhraddshs_instructionVar841::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var841(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 34 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmladduhm_instructionVar842::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var842(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 37 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmsummbm_instructionVar843::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var843(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 40 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmsumshm_instructionVar844::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var844(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 41 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmsumshs_instructionVar845::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var845(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 36 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmsumubm_instructionVar846::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var846(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 38 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmsumuhm_instructionVar847::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var847(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 39 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vmsumuhs_instructionVar848::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var848(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 47 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vnmsubfp_instructionVar849::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var849(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 43 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vperm_instructionVar850::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var850(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 42 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsel_instructionVar851::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var851(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 61 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddecuq_instructionVar852::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var852(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 60 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vaddeuqm_instructionVar853::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var853(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 45 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpermxor_instructionVar854::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var854(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 63 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubecuq_instructionVar855::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var855(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 62 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vsubeuqm_instructionVar856::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var856(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 63) == 59 && (tokens_param[3] & 252) == 16
        {
            if let Some((inst_len, parsed)) =
                vpermr_instructionVar857::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var857(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1067:1, end:1067:13))"]
#[derive(Clone, Debug)]
struct EVUIMM_2_RAtVar0 {
    A: u8,
    EVUIMM_2: u8,
}
impl EVUIMM_2_RAtVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.EVUIMM_2).unwrap().wrapping_mul(2i128);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Number(true, calc_val.is_negative(), calc_val.abs() as u64),
            <DisplayElement>::Literal("("),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = i128::try_from(token_4(tokens_current))
            .unwrap()
            .wrapping_mul(2i128);
        let EVUIMM_2 = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, EVUIMM_2 }))
    }
}
#[derive(Clone, Debug)]
enum TableEVUIMM_2_RAt {
    Var0(EVUIMM_2_RAtVar0),
}
impl TableEVUIMM_2_RAt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                EVUIMM_2_RAtVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1068:1, end:1068:13))"]
#[derive(Clone, Debug)]
struct EVUIMM_4_RAtVar0 {
    A: u8,
    EVUIMM_4: u8,
}
impl EVUIMM_4_RAtVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.EVUIMM_4).unwrap().wrapping_mul(4i128);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Number(true, calc_val.is_negative(), calc_val.abs() as u64),
            <DisplayElement>::Literal("("),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = i128::try_from(token_4(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let A = token_1(tokens_current);
        let EVUIMM_4 = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, EVUIMM_4 }))
    }
}
#[derive(Clone, Debug)]
enum TableEVUIMM_4_RAt {
    Var0(EVUIMM_4_RAtVar0),
}
impl TableEVUIMM_4_RAt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                EVUIMM_4_RAtVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1069:1, end:1069:13))"]
#[derive(Clone, Debug)]
struct EVUIMM_8_RAtVar0 {
    A: u8,
    EVUIMM_8: u8,
}
impl EVUIMM_8_RAtVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = i128::try_from(self.EVUIMM_8).unwrap().wrapping_mul(8i128);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Number(true, calc_val.is_negative(), calc_val.abs() as u64),
            <DisplayElement>::Literal("("),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = i128::try_from(token_4(tokens_current))
            .unwrap()
            .wrapping_mul(8i128);
        let EVUIMM_8 = token_4(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, EVUIMM_8 }))
    }
}
#[derive(Clone, Debug)]
enum TableEVUIMM_8_RAt {
    Var0(EVUIMM_8_RAtVar0),
}
impl TableEVUIMM_8_RAt {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                EVUIMM_8_RAtVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1203:1, end:1203:4))"]
#[derive(Clone, Debug)]
struct vrDVar0 {
    vrDD: u8,
}
impl vrDVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_162_display(self.vrDD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrDD = token_51(tokens_current);
        let vrDR = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrDD }))
    }
}
#[derive(Clone, Debug)]
enum TablevrD {
    Var0(vrDVar0),
}
impl TablevrD {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                vrDVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1204:1, end:1204:4))"]
#[derive(Clone, Debug)]
struct vrAVar0 {
    vrAD: u8,
}
impl vrAVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_162_display(self.vrAD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrAD = token_1(tokens_current);
        let vrAR = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrAD }))
    }
}
#[derive(Clone, Debug)]
enum TablevrA {
    Var0(vrAVar0),
}
impl TablevrA {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                vrAVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1205:1, end:1205:4))"]
#[derive(Clone, Debug)]
struct vrBVar0 {
    vrBD: u8,
}
impl vrBVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_162_display(self.vrBD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrBR = token_4(tokens_current);
        let vrBD = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrBD }))
    }
}
#[derive(Clone, Debug)]
enum TablevrB {
    Var0(vrBVar0),
}
impl TablevrB {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                vrBVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1206:1, end:1206:4))"]
#[derive(Clone, Debug)]
struct vrCVar0 {
    vrCD: u8,
}
impl vrCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_162_display(self.vrCD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrCD = token_62(tokens_current);
        let vrCR = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrCD }))
    }
}
#[derive(Clone, Debug)]
enum TablevrC {
    Var0(vrCVar0),
}
impl TablevrC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                vrCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1207:1, end:1207:4))"]
#[derive(Clone, Debug)]
struct vrSVar0 {
    vrSD: u8,
}
impl vrSVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_162_display(self.vrSD)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrSD = token_51(tokens_current);
        let vrSR = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { vrSD }))
    }
}
#[derive(Clone, Debug)]
enum TablevrS {
    Var0(vrSVar0),
}
impl TablevrS {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                vrSVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1824:1, end:1824:8))"]
#[derive(Clone, Debug)]
struct REL_ABSVar0 {}
impl REL_ABSVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("a")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1825:1, end:1825:8))"]
#[derive(Clone, Debug)]
struct REL_ABSVar1 {}
impl REL_ABSVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREL_ABS {
    Var0(REL_ABSVar0),
    Var1(REL_ABSVar1),
}
impl TableREL_ABS {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                REL_ABSVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                REL_ABSVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1827:1, end:1827:10))"]
#[derive(Clone, Debug)]
struct addressLIVar0 {
    LI: u32,
}
impl addressLIVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(
            i128::try_from(
                (if self.LI & 8388608 != 0 {
                    -1 & !8388607
                } else {
                    0
                } | self.LI as i32),
            )
            .unwrap()
            .wrapping_mul(4i128),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(
            i128::try_from(token_56(tokens_current))
                .unwrap()
                .wrapping_mul(4i128),
        );
        let LI = token_56(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LI }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1828:1, end:1828:10))"]
#[derive(Clone, Debug)]
struct addressLIVar1 {
    LI: u32,
}
impl addressLIVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(
            (if self.LI & 8388608 != 0 {
                -1 & !8388607
            } else {
                0
            } | self.LI as i32),
        )
        .unwrap()
        .wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(token_56(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let LI = token_56(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LI }))
    }
}
#[derive(Clone, Debug)]
enum TableaddressLI {
    Var0(addressLIVar0),
    Var1(addressLIVar1),
}
impl TableaddressLI {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                addressLIVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                addressLIVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1829:1, end:1829:10))"]
#[derive(Clone, Debug)]
struct addressBDVar0 {
    BD: u16,
}
impl addressBDVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(
            i128::try_from((if self.BD & 8192 != 0 { -1 & !8191 } else { 0 } | self.BD as i16))
                .unwrap()
                .wrapping_mul(4i128),
        );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(inst_start).unwrap().wrapping_add(
            i128::try_from(token_5(tokens_current))
                .unwrap()
                .wrapping_mul(4i128),
        );
        let BD = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BD }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1830:1, end:1830:10))"]
#[derive(Clone, Debug)]
struct addressBDVar1 {
    BD: u16,
}
impl addressBDVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc =
            i128::try_from((if self.BD & 8192 != 0 { -1 & !8191 } else { 0 } | self.BD as i16))
                .unwrap()
                .wrapping_mul(4i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(token_5(tokens_current))
            .unwrap()
            .wrapping_mul(4i128);
        let BD = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BD }))
    }
}
#[derive(Clone, Debug)]
enum TableaddressBD {
    Var0(addressBDVar0),
    Var1(addressBDVar1),
}
impl TableaddressBD {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 0 {
            if let Some((inst_len, parsed)) =
                addressBDVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 2) == 2 {
            if let Some((inst_len, parsed)) =
                addressBDVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1832:1, end:1832:8))"]
#[derive(Clone, Debug)]
struct OFF16SHVar0 {
    D0: u16,
    D1: u8,
    D2: u8,
}
impl OFF16SHVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(16i128)
            .ok()
            .and_then(|shl| {
                ((u32::try_from(6i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(
                            (if self.D0 & 512 != 0 { -1 & !511 } else { 0 } | self.D0 as i16),
                        )
                        .unwrap()
                        .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | u32::try_from(1i128)
                        .ok()
                        .and_then(|shl| i128::try_from(self.D1).unwrap().checked_shl(shl))
                        .unwrap_or(0))
                    | i128::try_from(self.D2).unwrap())
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_val.is_negative(),
            calc_val.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = u32::try_from(16i128)
            .ok()
            .and_then(|shl| {
                ((u32::try_from(6i128)
                    .ok()
                    .and_then(|shl| {
                        i128::try_from(token_73(tokens_current))
                            .unwrap()
                            .checked_shl(shl)
                    })
                    .unwrap_or(0)
                    | u32::try_from(1i128)
                        .ok()
                        .and_then(|shl| {
                            i128::try_from(token_1(tokens_current))
                                .unwrap()
                                .checked_shl(shl)
                        })
                        .unwrap_or(0))
                    | i128::try_from(token_16(tokens_current)).unwrap())
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let D0 = token_73(tokens_current);
        let D1 = token_1(tokens_current);
        let D2 = token_16(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { D0, D1, D2 }))
    }
}
#[derive(Clone, Debug)]
enum TableOFF16SH {
    Var0(OFF16SHVar0),
}
impl TableOFF16SH {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                OFF16SHVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1836:1, end:1836:3))"]
#[derive(Clone, Debug)]
struct CCVar0 {}
impl CCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CC = token_13(tokens_current);
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1837:1, end:1837:3))"]
#[derive(Clone, Debug)]
struct CCVar1 {}
impl CCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CC = token_13(tokens_current);
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1838:1, end:1838:3))"]
#[derive(Clone, Debug)]
struct CCVar2 {}
impl CCVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CR = token_8(tokens_current);
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1839:1, end:1839:3))"]
#[derive(Clone, Debug)]
struct CCVar3 {}
impl CCVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CR = token_8(tokens_current);
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1840:1, end:1840:3))"]
#[derive(Clone, Debug)]
struct CCVar4 {}
impl CCVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CR = token_8(tokens_current);
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1841:1, end:1841:3))"]
#[derive(Clone, Debug)]
struct CCVar5 {}
impl CCVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CR = token_8(tokens_current);
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1842:1, end:1842:3))"]
#[derive(Clone, Debug)]
struct CCVar6 {}
impl CCVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CC = token_13(tokens_current);
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1843:1, end:1843:3))"]
#[derive(Clone, Debug)]
struct CCVar7 {}
impl CCVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ns")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CR = token_8(tokens_current);
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCC {
    Var0(CCVar0),
    Var1(CCVar1),
    Var2(CCVar2),
    Var3(CCVar3),
    Var4(CCVar4),
    Var5(CCVar5),
    Var6(CCVar6),
    Var7(CCVar7),
}
impl TableCC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 0 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                CCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 1 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                CCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 2 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                CCVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 0 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                CCVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 1 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                CCVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 2 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                CCVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 3 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                CCVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 3 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                CCVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1845:1, end:1845:4))"]
#[derive(Clone, Debug)]
struct TOmVar0 {}
impl TOmVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1846:1, end:1846:4))"]
#[derive(Clone, Debug)]
struct TOmVar1 {}
impl TOmVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1847:1, end:1847:4))"]
#[derive(Clone, Debug)]
struct TOmVar2 {}
impl TOmVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1848:1, end:1848:4))"]
#[derive(Clone, Debug)]
struct TOmVar3 {}
impl TOmVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1849:1, end:1849:4))"]
#[derive(Clone, Debug)]
struct TOmVar4 {}
impl TOmVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1850:1, end:1850:4))"]
#[derive(Clone, Debug)]
struct TOmVar5 {}
impl TOmVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1851:1, end:1851:4))"]
#[derive(Clone, Debug)]
struct TOmVar6 {}
impl TOmVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("llt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1852:1, end:1852:4))"]
#[derive(Clone, Debug)]
struct TOmVar7 {}
impl TOmVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lle")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1853:1, end:1853:4))"]
#[derive(Clone, Debug)]
struct TOmVar8 {}
impl TOmVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1854:1, end:1854:4))"]
#[derive(Clone, Debug)]
struct TOmVar9 {}
impl TOmVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lgt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1855:1, end:1855:4))"]
#[derive(Clone, Debug)]
struct TOmVar10 {}
impl TOmVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let TO = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableTOm {
    Var0(TOmVar0),
    Var1(TOmVar1),
    Var2(TOmVar2),
    Var3(TOmVar3),
    Var4(TOmVar4),
    Var5(TOmVar5),
    Var6(TOmVar6),
    Var7(TOmVar7),
    Var8(TOmVar8),
    Var9(TOmVar9),
    Var10(TOmVar10),
}
impl TableTOm {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                TOmVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 && (tokens_param[3] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                TOmVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                TOmVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 128 && (tokens_param[3] & 3) == 1 {
            if let Some((inst_len, parsed)) =
                TOmVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 && (tokens_param[3] & 3) == 1 {
            if let Some((inst_len, parsed)) =
                TOmVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 && (tokens_param[3] & 3) == 3 {
            if let Some((inst_len, parsed)) =
                TOmVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                TOmVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 192 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                TOmVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 160 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                TOmVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                TOmVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                TOmVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1857:1, end:1857:8))"]
#[derive(Clone, Debug)]
struct CTR_DECVar0 {}
impl CTR_DECVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("z")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1858:1, end:1858:8))"]
#[derive(Clone, Debug)]
struct CTR_DECVar1 {}
impl CTR_DECVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("nz")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCTR_DEC {
    Var0(CTR_DECVar0),
    Var1(CTR_DECVar1),
}
impl TableCTR_DEC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 64 {
            if let Some((inst_len, parsed)) =
                CTR_DECVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 64) == 0 {
            if let Some((inst_len, parsed)) =
                CTR_DECVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1860:1, end:1860:6))"]
#[derive(Clone, Debug)]
struct CC_TFVar0 {}
impl CC_TFVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1861:1, end:1861:6))"]
#[derive(Clone, Debug)]
struct CC_TFVar1 {}
impl CC_TFVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("f")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCC_TF {
    Var0(CC_TFVar0),
    Var1(CC_TFVar1),
}
impl TableCC_TF {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 1 {
            if let Some((inst_len, parsed)) =
                CC_TFVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[3] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                CC_TFVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1868:1, end:1868:6))"]
#[derive(Clone, Debug)]
struct CC_OPVar0 {}
impl CC_OPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1869:1, end:1869:6))"]
#[derive(Clone, Debug)]
struct CC_OPVar1 {}
impl CC_OPVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1870:1, end:1870:6))"]
#[derive(Clone, Debug)]
struct CC_OPVar2 {}
impl CC_OPVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1871:1, end:1871:6))"]
#[derive(Clone, Debug)]
struct CC_OPVar3 {}
impl CC_OPVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1872:1, end:1872:6))"]
#[derive(Clone, Debug)]
struct CC_OPVar4 {
    BI_CR: u8,
}
impl CC_OPVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.BI_CR),
            <DisplayElement>::Literal("+lt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CR = token_8(tokens_current);
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BI_CR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1873:1, end:1873:6))"]
#[derive(Clone, Debug)]
struct CC_OPVar5 {
    BI_CR: u8,
}
impl CC_OPVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.BI_CR),
            <DisplayElement>::Literal("+eq"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CC = token_13(tokens_current);
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BI_CR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1874:1, end:1874:6))"]
#[derive(Clone, Debug)]
struct CC_OPVar6 {
    BI_CR: u8,
}
impl CC_OPVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.BI_CR),
            <DisplayElement>::Literal("+gt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CR = token_8(tokens_current);
        let BI_CC = token_13(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BI_CR }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1875:1, end:1875:6))"]
#[derive(Clone, Debug)]
struct CC_OPVar7 {
    BI_CR: u8,
}
impl CC_OPVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.BI_CR),
            <DisplayElement>::Literal("+so"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let BI_CC = token_13(tokens_current);
        let BI_CR = token_8(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BI_CR }))
    }
}
#[derive(Clone, Debug)]
enum TableCC_OP {
    Var0(CC_OPVar0),
    Var1(CC_OPVar1),
    Var2(CC_OPVar2),
    Var3(CC_OPVar3),
    Var4(CC_OPVar4),
    Var5(CC_OPVar5),
    Var6(CC_OPVar6),
    Var7(CC_OPVar7),
}
impl TableCC_OP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                CC_OPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 2 {
            if let Some((inst_len, parsed)) =
                CC_OPVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 1 {
            if let Some((inst_len, parsed)) =
                CC_OPVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 3 {
            if let Some((inst_len, parsed)) =
                CC_OPVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                CC_OPVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 2 {
            if let Some((inst_len, parsed)) =
                CC_OPVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 1 {
            if let Some((inst_len, parsed)) =
                CC_OPVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 3) == 3 {
            if let Some((inst_len, parsed)) =
                CC_OPVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1879:1, end:1879:8))"]
#[derive(Clone, Debug)]
struct CC_B_OPVar0 {}
impl CC_B_OPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_B_CC = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1880:1, end:1880:8))"]
#[derive(Clone, Debug)]
struct CC_B_OPVar1 {}
impl CC_B_OPVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_B_CC = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1881:1, end:1881:8))"]
#[derive(Clone, Debug)]
struct CC_B_OPVar2 {}
impl CC_B_OPVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_B_CC = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1882:1, end:1882:8))"]
#[derive(Clone, Debug)]
struct CC_B_OPVar3 {}
impl CC_B_OPVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_B_CC = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1883:1, end:1883:8))"]
#[derive(Clone, Debug)]
struct CC_B_OPVar4 {
    CR_B: u8,
}
impl CC_B_OPVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.CR_B),
            <DisplayElement>::Literal("+lt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_B = token_38(tokens_current);
        let CR_B_CC = token_10(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1884:1, end:1884:8))"]
#[derive(Clone, Debug)]
struct CC_B_OPVar5 {
    CR_B: u8,
}
impl CC_B_OPVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.CR_B),
            <DisplayElement>::Literal("+eq"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_B_CC = token_10(tokens_current);
        let CR_B = token_38(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1885:1, end:1885:8))"]
#[derive(Clone, Debug)]
struct CC_B_OPVar6 {
    CR_B: u8,
}
impl CC_B_OPVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.CR_B),
            <DisplayElement>::Literal("+gt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_B_CC = token_10(tokens_current);
        let CR_B = token_38(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_B }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1886:1, end:1886:8))"]
#[derive(Clone, Debug)]
struct CC_B_OPVar7 {
    CR_B: u8,
}
impl CC_B_OPVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.CR_B),
            <DisplayElement>::Literal("+so"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_B_CC = token_10(tokens_current);
        let CR_B = token_38(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_B }))
    }
}
#[derive(Clone, Debug)]
enum TableCC_B_OP {
    Var0(CC_B_OPVar0),
    Var1(CC_B_OPVar1),
    Var2(CC_B_OPVar2),
    Var3(CC_B_OPVar3),
    Var4(CC_B_OPVar4),
    Var5(CC_B_OPVar5),
    Var6(CC_B_OPVar6),
    Var7(CC_B_OPVar7),
}
impl TableCC_B_OP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 248) == 0 {
            if let Some((inst_len, parsed)) =
                CC_B_OPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 248) == 16 {
            if let Some((inst_len, parsed)) =
                CC_B_OPVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 248) == 8 {
            if let Some((inst_len, parsed)) =
                CC_B_OPVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 248) == 24 {
            if let Some((inst_len, parsed)) =
                CC_B_OPVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 24) == 0 {
            if let Some((inst_len, parsed)) =
                CC_B_OPVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 24) == 16 {
            if let Some((inst_len, parsed)) =
                CC_B_OPVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 24) == 8 {
            if let Some((inst_len, parsed)) =
                CC_B_OPVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 24) == 24 {
            if let Some((inst_len, parsed)) =
                CC_B_OPVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1890:1, end:1890:8))"]
#[derive(Clone, Debug)]
struct CC_X_OPVar0 {}
impl CC_X_OPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1891:1, end:1891:8))"]
#[derive(Clone, Debug)]
struct CC_X_OPVar1 {}
impl CC_X_OPVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1892:1, end:1892:8))"]
#[derive(Clone, Debug)]
struct CC_X_OPVar2 {}
impl CC_X_OPVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1893:1, end:1893:8))"]
#[derive(Clone, Debug)]
struct CC_X_OPVar3 {}
impl CC_X_OPVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1894:1, end:1894:8))"]
#[derive(Clone, Debug)]
struct CC_X_OPVar4 {
    CR_X: u8,
}
impl CC_X_OPVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.CR_X)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        let CR_X = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_X }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1895:1, end:1895:8))"]
#[derive(Clone, Debug)]
struct CC_X_OPVar5 {
    CR_X: u8,
}
impl CC_X_OPVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.CR_X)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        let CR_X = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_X }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1896:1, end:1896:8))"]
#[derive(Clone, Debug)]
struct CC_X_OPVar6 {
    CR_X: u8,
}
impl CC_X_OPVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.CR_X)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X = token_69(tokens_current);
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_X }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1897:1, end:1897:8))"]
#[derive(Clone, Debug)]
struct CC_X_OPVar7 {
    CR_X: u8,
}
impl CC_X_OPVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_4_display(self.CR_X)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X = token_69(tokens_current);
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_X }))
    }
}
#[derive(Clone, Debug)]
enum TableCC_X_OP {
    Var0(CC_X_OPVar0),
    Var1(CC_X_OPVar1),
    Var2(CC_X_OPVar2),
    Var3(CC_X_OPVar3),
    Var4(CC_X_OPVar4),
    Var5(CC_X_OPVar5),
    Var6(CC_X_OPVar6),
    Var7(CC_X_OPVar7),
}
impl TableCC_X_OP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 0 && (tokens_param[1] & 7) == 0 {
            if let Some((inst_len, parsed)) =
                CC_X_OPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 64 && (tokens_param[1] & 7) == 0 {
            if let Some((inst_len, parsed)) =
                CC_X_OPVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 128 && (tokens_param[1] & 7) == 0 {
            if let Some((inst_len, parsed)) =
                CC_X_OPVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 192 && (tokens_param[1] & 7) == 0 {
            if let Some((inst_len, parsed)) =
                CC_X_OPVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                CC_X_OPVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                CC_X_OPVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                CC_X_OPVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                CC_X_OPVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1899:1, end:1899:9))"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar0 {}
impl CC_X_OPmVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1900:1, end:1900:9))"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar1 {}
impl CC_X_OPmVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1901:1, end:1901:9))"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar2 {}
impl CC_X_OPmVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1902:1, end:1902:9))"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar3 {}
impl CC_X_OPmVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1903:1, end:1903:9))"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar4 {}
impl CC_X_OPmVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        let CR_X = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1904:1, end:1904:9))"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar5 {}
impl CC_X_OPmVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X = token_69(tokens_current);
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1905:1, end:1905:9))"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar6 {}
impl CC_X_OPmVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X_CC = token_70(tokens_current);
        let CR_X = token_69(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1906:1, end:1906:9))"]
#[derive(Clone, Debug)]
struct CC_X_OPmVar7 {}
impl CC_X_OPmVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_X = token_69(tokens_current);
        let CR_X_CC = token_70(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCC_X_OPm {
    Var0(CC_X_OPmVar0),
    Var1(CC_X_OPmVar1),
    Var2(CC_X_OPmVar2),
    Var3(CC_X_OPmVar3),
    Var4(CC_X_OPmVar4),
    Var5(CC_X_OPmVar5),
    Var6(CC_X_OPmVar6),
    Var7(CC_X_OPmVar7),
}
impl TableCC_X_OPm {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 0 && (tokens_param[1] & 7) == 0 {
            if let Some((inst_len, parsed)) =
                CC_X_OPmVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 64 && (tokens_param[1] & 7) == 0 {
            if let Some((inst_len, parsed)) =
                CC_X_OPmVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 128 && (tokens_param[1] & 7) == 0 {
            if let Some((inst_len, parsed)) =
                CC_X_OPmVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 192 && (tokens_param[1] & 7) == 0 {
            if let Some((inst_len, parsed)) =
                CC_X_OPmVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 0 {
            if let Some((inst_len, parsed)) =
                CC_X_OPmVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 64 {
            if let Some((inst_len, parsed)) =
                CC_X_OPmVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 128 {
            if let Some((inst_len, parsed)) =
                CC_X_OPmVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 192) == 192 {
            if let Some((inst_len, parsed)) =
                CC_X_OPmVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1910:1, end:1910:8))"]
#[derive(Clone, Debug)]
struct CC_D_OPVar0 {}
impl CC_D_OPVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1911:1, end:1911:8))"]
#[derive(Clone, Debug)]
struct CC_D_OPVar1 {}
impl CC_D_OPVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1912:1, end:1912:8))"]
#[derive(Clone, Debug)]
struct CC_D_OPVar2 {}
impl CC_D_OPVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1913:1, end:1913:8))"]
#[derive(Clone, Debug)]
struct CC_D_OPVar3 {}
impl CC_D_OPVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("so")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1914:1, end:1914:8))"]
#[derive(Clone, Debug)]
struct CC_D_OPVar4 {
    CR_D: u8,
}
impl CC_D_OPVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.CR_D),
            <DisplayElement>::Literal("+lt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_D = token_9(tokens_current);
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1915:1, end:1915:8))"]
#[derive(Clone, Debug)]
struct CC_D_OPVar5 {
    CR_D: u8,
}
impl CC_D_OPVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.CR_D),
            <DisplayElement>::Literal("+eq"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_D = token_9(tokens_current);
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1916:1, end:1916:8))"]
#[derive(Clone, Debug)]
struct CC_D_OPVar6 {
    CR_D: u8,
}
impl CC_D_OPVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.CR_D),
            <DisplayElement>::Literal("+gt"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_D = token_9(tokens_current);
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_D }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1917:1, end:1917:8))"]
#[derive(Clone, Debug)]
struct CC_D_OPVar7 {
    CR_D: u8,
}
impl CC_D_OPVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("4*"),
            meaning_4_display(self.CR_D),
            <DisplayElement>::Literal("+so"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let CR_D = token_9(tokens_current);
        let CR_D_CC = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CR_D }))
    }
}
#[derive(Clone, Debug)]
enum TableCC_D_OP {
    Var0(CC_D_OPVar0),
    Var1(CC_D_OPVar1),
    Var2(CC_D_OPVar2),
    Var3(CC_D_OPVar3),
    Var4(CC_D_OPVar4),
    Var5(CC_D_OPVar5),
    Var6(CC_D_OPVar6),
    Var7(CC_D_OPVar7),
}
impl TableCC_D_OP {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                CC_D_OPVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 64 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                CC_D_OPVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 32 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                CC_D_OPVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 96 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                CC_D_OPVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 0 {
            if let Some((inst_len, parsed)) =
                CC_D_OPVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 64 {
            if let Some((inst_len, parsed)) =
                CC_D_OPVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 32 {
            if let Some((inst_len, parsed)) =
                CC_D_OPVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 96 {
            if let Some((inst_len, parsed)) =
                CC_D_OPVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1920:1, end:1920:11))"]
#[derive(Clone, Debug)]
struct RA_OR_ZEROVar0 {}
impl RA_OR_ZEROVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("0")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1919:1, end:1919:11))"]
#[derive(Clone, Debug)]
struct RA_OR_ZEROVar1 {
    A: u8,
}
impl RA_OR_ZEROVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.A)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A }))
    }
}
#[derive(Clone, Debug)]
enum TableRA_OR_ZERO {
    Var0(RA_OR_ZEROVar0),
    Var1(RA_OR_ZEROVar1),
}
impl TableRA_OR_ZERO {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 31) == 0 {
            if let Some((inst_len, parsed)) =
                RA_OR_ZEROVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RA_OR_ZEROVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1923:1, end:1923:11))"]
#[derive(Clone, Debug)]
struct RB_OR_ZEROVar0 {}
impl RB_OR_ZEROVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("0")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1922:1, end:1922:11))"]
#[derive(Clone, Debug)]
struct RB_OR_ZEROVar1 {
    B: u8,
}
impl RB_OR_ZEROVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.B)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { B }))
    }
}
#[derive(Clone, Debug)]
enum TableRB_OR_ZERO {
    Var0(RB_OR_ZEROVar0),
    Var1(RB_OR_ZEROVar1),
}
impl TableRB_OR_ZERO {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 248) == 0 {
            if let Some((inst_len, parsed)) =
                RB_OR_ZEROVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RB_OR_ZEROVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1926:1, end:1926:11))"]
#[derive(Clone, Debug)]
struct RS_OR_ZEROVar0 {}
impl RS_OR_ZEROVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("0")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1925:1, end:1925:11))"]
#[derive(Clone, Debug)]
struct RS_OR_ZEROVar1 {
    S: u8,
}
impl RS_OR_ZEROVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.S)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let S = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { S }))
    }
}
#[derive(Clone, Debug)]
enum TableRS_OR_ZERO {
    Var0(RS_OR_ZEROVar0),
    Var1(RS_OR_ZEROVar1),
}
impl TableRS_OR_ZERO {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 224) == 0 && (tokens_param[3] & 3) == 0 {
            if let Some((inst_len, parsed)) =
                RS_OR_ZEROVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                RS_OR_ZEROVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1929:1, end:1929:3))"]
#[derive(Clone, Debug)]
struct MBVar0 {
    MBH: u8,
    MBL: u8,
}
impl MBVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_mbValue: i128 = 0;
        calc_mbValue = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| i128::try_from(self.MBH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.MBL).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_mbValue.is_negative(),
            calc_mbValue.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_mbValue: i128 = 0;
        let mut block_0_len = 4;
        calc_mbValue = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_78(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_62(tokens_current)).unwrap());
        let MBL = token_62(tokens_current);
        let MBH = token_78(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { MBH, MBL }))
    }
}
#[derive(Clone, Debug)]
enum TableMB {
    Var0(MBVar0),
}
impl TableMB {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                MBVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1930:1, end:1930:3))"]
#[derive(Clone, Debug)]
struct SHVar0 {
    SHH: u8,
    SHL: u8,
}
impl SHVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_shValue: i128 = 0;
        calc_shValue = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| i128::try_from(self.SHH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.SHL).unwrap());
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_shValue.is_negative(),
            calc_shValue.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_shValue: i128 = 0;
        let mut block_0_len = 4;
        calc_shValue = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_2(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_4(tokens_current)).unwrap());
        let SHH = token_2(tokens_current);
        let SHL = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SHH, SHL }))
    }
}
#[derive(Clone, Debug)]
enum TableSH {
    Var0(SHVar0),
}
impl TableSH {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                SHVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1932:1, end:1932:8))"]
#[derive(Clone, Debug)]
struct rotmaskVar0 {
    ME: u8,
    MBL: u8,
}
impl rotmaskVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_mask: i128 = 0;
        calc_mask = (((u32::try_from(8i128)
            .ok()
            .and_then(|shr| {
                i128::try_from(self.ME)
                    .unwrap()
                    .wrapping_sub(i128::try_from(self.MBL).unwrap())
                    .checked_shr(shr)
            })
            .unwrap_or(0)
            & 1i128)
            .wrapping_mul(18446744073709551615i128)
            ^ u32::try_from(i128::try_from(self.ME).unwrap())
                .ok()
                .and_then(|shr| 2147483647i128.checked_shr(shr))
                .unwrap_or(0))
            ^ u32::try_from(i128::try_from(self.MBL).unwrap())
                .ok()
                .and_then(|shr| 4294967295i128.checked_shr(shr))
                .unwrap_or(0));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_mask.is_negative(),
            calc_mask.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_mask: i128 = 0;
        let mut block_0_len = 4;
        calc_mask = (((u32::try_from(8i128)
            .ok()
            .and_then(|shr| {
                i128::try_from(token_79(tokens_current))
                    .unwrap()
                    .wrapping_sub(i128::try_from(token_62(tokens_current)).unwrap())
                    .checked_shr(shr)
            })
            .unwrap_or(0)
            & 1i128)
            .wrapping_mul(18446744073709551615i128)
            ^ u32::try_from(i128::try_from(token_79(tokens_current)).unwrap())
                .ok()
                .and_then(|shr| 2147483647i128.checked_shr(shr))
                .unwrap_or(0))
            ^ u32::try_from(i128::try_from(token_62(tokens_current)).unwrap())
                .ok()
                .and_then(|shr| 4294967295i128.checked_shr(shr))
                .unwrap_or(0));
        let MBL = token_62(tokens_current);
        let ME = token_79(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ME, MBL }))
    }
}
#[derive(Clone, Debug)]
enum Tablerotmask {
    Var0(rotmaskVar0),
}
impl Tablerotmask {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                rotmaskVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1934:1, end:1934:11))"]
#[derive(Clone, Debug)]
struct rotmask_SHVar0 {
    MBH: u8,
    MBL: u8,
    SHH: u8,
    SHL: u8,
}
impl rotmask_SHVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_mbValue: i128 = 0;
        let mut calc_shValue: i128 = 0;
        let mut calc_masksh: i128 = 0;
        calc_mbValue = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| i128::try_from(self.MBH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.MBL).unwrap());
        calc_shValue = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| i128::try_from(self.SHH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.SHL).unwrap());
        calc_masksh = ((u32::try_from(8i128)
            .ok()
            .and_then(|shr| calc_shValue.wrapping_sub(calc_mbValue).checked_shr(shr))
            .unwrap_or(0)
            & 1i128)
            .wrapping_mul(18446744073709551615i128)
            ^ (u32::try_from(calc_shValue)
                .ok()
                .and_then(|shr| 9223372036854775807i128.checked_shr(shr))
                .unwrap_or(0)
                ^ u32::try_from(calc_mbValue)
                    .ok()
                    .and_then(|shr| 18446744073709551615i128.checked_shr(shr))
                    .unwrap_or(0)));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Number(true, calc_masksh.is_negative(), calc_masksh.abs() as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Number(true, calc_mbValue.is_negative(), calc_mbValue.abs() as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Number(true, calc_shValue.is_negative(), calc_shValue.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_mbValue: i128 = 0;
        let mut calc_shValue: i128 = 0;
        let mut calc_masksh: i128 = 0;
        let mut block_0_len = 4;
        calc_mbValue = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_78(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_62(tokens_current)).unwrap());
        calc_shValue = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_2(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_4(tokens_current)).unwrap());
        calc_masksh = ((u32::try_from(8i128)
            .ok()
            .and_then(|shr| calc_shValue.wrapping_sub(calc_mbValue).checked_shr(shr))
            .unwrap_or(0)
            & 1i128)
            .wrapping_mul(18446744073709551615i128)
            ^ (u32::try_from(calc_shValue)
                .ok()
                .and_then(|shr| 9223372036854775807i128.checked_shr(shr))
                .unwrap_or(0)
                ^ u32::try_from(calc_mbValue)
                    .ok()
                    .and_then(|shr| 18446744073709551615i128.checked_shr(shr))
                    .unwrap_or(0)));
        let MBH = token_78(tokens_current);
        let SHH = token_2(tokens_current);
        let SHL = token_4(tokens_current);
        let MBL = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { MBH, MBL, SHH, SHL }))
    }
}
#[derive(Clone, Debug)]
enum Tablerotmask_SH {
    Var0(rotmask_SHVar0),
}
impl Tablerotmask_SH {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                rotmask_SHVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1946:1, end:1946:10))"]
#[derive(Clone, Debug)]
struct rotmask_ZVar0 {
    MBH: u8,
    MBL: u8,
}
impl rotmask_ZVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_mbValue: i128 = 0;
        let mut calc_mask: i128 = 0;
        calc_mbValue = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| i128::try_from(self.MBH).unwrap().checked_shl(shl))
            .unwrap_or(0)
            | i128::try_from(self.MBL).unwrap());
        calc_mask = (!u32::try_from(calc_mbValue.wrapping_add(1i128))
            .ok()
            .and_then(|shr| 18446744073709551615i128.checked_shr(shr))
            .unwrap_or(0));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Number(true, calc_mask.is_negative(), calc_mask.abs() as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Number(true, calc_mbValue.is_negative(), calc_mbValue.abs() as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_mbValue: i128 = 0;
        let mut calc_mask: i128 = 0;
        let mut block_0_len = 4;
        calc_mbValue = (u32::try_from(5i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_78(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0)
            | i128::try_from(token_62(tokens_current)).unwrap());
        calc_mask = (!u32::try_from(calc_mbValue.wrapping_add(1i128))
            .ok()
            .and_then(|shr| 18446744073709551615i128.checked_shr(shr))
            .unwrap_or(0));
        let MBH = token_78(tokens_current);
        let MBL = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { MBH, MBL }))
    }
}
#[derive(Clone, Debug)]
enum Tablerotmask_Z {
    Var0(rotmask_ZVar0),
}
impl Tablerotmask_Z {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                rotmask_ZVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1955:1, end:1955:6))"]
#[derive(Clone, Debug)]
struct DSIZEVar0 {}
impl DSIZEVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("d")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1953:1, end:1953:6))"]
#[derive(Clone, Debug)]
struct DSIZEVar1 {}
impl DSIZEVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("w")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let L = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableDSIZE {
    Var0(DSIZEVar0),
    Var1(DSIZEVar1),
}
impl TableDSIZE {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 32 {
            if let Some((inst_len, parsed)) =
                DSIZEVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DSIZEVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1959:1, end:1959:6))"]
#[derive(Clone, Debug)]
struct REG_AVar0 {}
impl REG_AVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1960:1, end:1960:6))"]
#[derive(Clone, Debug)]
struct REG_AVar1 {}
impl REG_AVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREG_A {
    Var0(REG_AVar0),
    Var1(REG_AVar1),
}
impl TableREG_A {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 0 {
            if let Some((inst_len, parsed)) =
                REG_AVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 32 {
            if let Some((inst_len, parsed)) =
                REG_AVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1961:1, end:1961:6))"]
#[derive(Clone, Debug)]
struct REG_BVar0 {}
impl REG_BVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1962:1, end:1962:6))"]
#[derive(Clone, Debug)]
struct REG_BVar1 {}
impl REG_BVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableREG_B {
    Var0(REG_BVar0),
    Var1(REG_BVar1),
}
impl TableREG_B {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 0 {
            if let Some((inst_len, parsed)) =
                REG_BVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 32 {
            if let Some((inst_len, parsed)) =
                REG_BVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1969:1, end:1969:7))"]
#[derive(Clone, Debug)]
struct UREG_AVar0 {}
impl UREG_AVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1970:1, end:1970:7))"]
#[derive(Clone, Debug)]
struct UREG_AVar1 {}
impl UREG_AVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableUREG_A {
    Var0(UREG_AVar0),
    Var1(UREG_AVar1),
}
impl TableUREG_A {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 0 {
            if let Some((inst_len, parsed)) =
                UREG_AVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 32 {
            if let Some((inst_len, parsed)) =
                UREG_AVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1971:1, end:1971:7))"]
#[derive(Clone, Debug)]
struct UREG_BVar0 {}
impl UREG_BVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1972:1, end:1972:7))"]
#[derive(Clone, Debug)]
struct UREG_BVar1 {}
impl UREG_BVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let B = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableUREG_B {
    Var0(UREG_BVar0),
    Var1(UREG_BVar1),
}
impl TableUREG_B {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 0 {
            if let Some((inst_len, parsed)) =
                UREG_BVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 96) == 32 {
            if let Some((inst_len, parsed)) =
                UREG_BVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1978:1, end:1978:21))"]
#[derive(Clone, Debug)]
struct dPlusRaOrZeroAddressVar0 {
    SIMM: u16,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dPlusRaOrZeroAddressVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SIMM = token_84(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { RA_OR_ZERO, SIMM }))
    }
}
#[derive(Clone, Debug)]
enum TabledPlusRaOrZeroAddress {
    Var0(dPlusRaOrZeroAddressVar0),
}
impl TabledPlusRaOrZeroAddress {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                dPlusRaOrZeroAddressVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1979:1, end:1979:15))"]
#[derive(Clone, Debug)]
struct dPlusRaAddressVar0 {
    SIMM: u16,
    A: u8,
}
impl dPlusRaAddressVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 4usize] = [
            DisplayElement::Number(
                true,
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .is_negative(),
                (if self.SIMM & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.SIMM as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal("("),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let SIMM = token_84(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { SIMM, A }))
    }
}
#[derive(Clone, Debug)]
enum TabledPlusRaAddress {
    Var0(dPlusRaAddressVar0),
}
impl TabledPlusRaAddress {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                dPlusRaAddressVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1981:1, end:1981:25))"]
#[derive(Clone, Debug)]
struct dUI16PlusRAOrZeroAddressVar0 {
    UI_16_s8: u8,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dUI16PlusRAOrZeroAddressVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_val: i128 = 0;
        calc_val = u32::try_from(3i128)
            .ok()
            .and_then(|shl| i128::try_from(self.UI_16_s8).unwrap().checked_shl(shl))
            .unwrap_or(0);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Number(true, calc_val.is_negative(), calc_val.abs() as u64),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_val: i128 = 0;
        let mut block_0_len = 4;
        calc_val = u32::try_from(3i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_4(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let UI_16_s8 = token_4(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                UI_16_s8,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TabledUI16PlusRAOrZeroAddress {
    Var0(dUI16PlusRAOrZeroAddressVar0),
}
impl TabledUI16PlusRAOrZeroAddress {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                dUI16PlusRAOrZeroAddressVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1984:1, end:1984:16))"]
#[derive(Clone, Debug)]
struct dsPlusRaAddressVar0 {
    A: u8,
    SIMM_DS: u16,
}
impl dsPlusRaAddressVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_simm_ds: i128 = 0;
        calc_simm_ds = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.SIMM_DS & 8192 != 0 {
                        -1 & !8191
                    } else {
                        0
                    } | self.SIMM_DS as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Number(true, calc_simm_ds.is_negative(), calc_simm_ds.abs() as u64),
            <DisplayElement>::Literal("("),
            meaning_3_display(self.A),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_simm_ds: i128 = 0;
        let mut block_0_len = 4;
        calc_simm_ds = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_5(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let SIMM_DS = token_5(tokens_current);
        let A = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { A, SIMM_DS }))
    }
}
#[derive(Clone, Debug)]
enum TabledsPlusRaAddress {
    Var0(dsPlusRaAddressVar0),
}
impl TabledsPlusRaAddress {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                dsPlusRaAddressVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1985:1, end:1985:22))"]
#[derive(Clone, Debug)]
struct dsPlusRaOrZeroAddressVar0 {
    SIMM_DS: u16,
    RA_OR_ZERO: TableRA_OR_ZERO,
}
impl dsPlusRaOrZeroAddressVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_simm_ds: i128 = 0;
        calc_simm_ds = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(
                    (if self.SIMM_DS & 8192 != 0 {
                        -1 & !8191
                    } else {
                        0
                    } | self.SIMM_DS as i16),
                )
                .unwrap()
                .checked_shl(shl)
            })
            .unwrap_or(0);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Number(true, calc_simm_ds.is_negative(), calc_simm_ds.abs() as u64),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.RA_OR_ZERO
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_simm_ds: i128 = 0;
        let mut block_0_len = 4;
        calc_simm_ds = u32::try_from(2i128)
            .ok()
            .and_then(|shl| {
                i128::try_from(token_5(tokens_current))
                    .unwrap()
                    .checked_shl(shl)
            })
            .unwrap_or(0);
        let RA_OR_ZERO = if let Some((len, table)) =
            TableRA_OR_ZERO::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let SIMM_DS = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                RA_OR_ZERO,
                SIMM_DS,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum TabledsPlusRaOrZeroAddress {
    Var0(dsPlusRaOrZeroAddressVar0),
}
impl TabledsPlusRaOrZeroAddress {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                dsPlusRaOrZeroAddressVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1989:1, end:1989:11))"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar0 {}
impl FPSCR_CRFSVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1990:1, end:1990:11))"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar1 {}
impl FPSCR_CRFSVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1991:1, end:1991:11))"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar2 {}
impl FPSCR_CRFSVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1992:1, end:1992:11))"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar3 {}
impl FPSCR_CRFSVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1993:1, end:1993:11))"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar4 {}
impl FPSCR_CRFSVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1994:1, end:1994:11))"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar5 {}
impl FPSCR_CRFSVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1995:1, end:1995:11))"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar6 {}
impl FPSCR_CRFSVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1996:1, end:1996:11))"]
#[derive(Clone, Debug)]
struct FPSCR_CRFSVar7 {}
impl FPSCR_CRFSVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableFPSCR_CRFS {
    Var0(FPSCR_CRFSVar0),
    Var1(FPSCR_CRFSVar1),
    Var2(FPSCR_CRFSVar2),
    Var3(FPSCR_CRFSVar3),
    Var4(FPSCR_CRFSVar4),
    Var5(FPSCR_CRFSVar5),
    Var6(FPSCR_CRFSVar6),
    Var7(FPSCR_CRFSVar7),
}
impl TableFPSCR_CRFS {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 0 {
            if let Some((inst_len, parsed)) =
                FPSCR_CRFSVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 4 {
            if let Some((inst_len, parsed)) =
                FPSCR_CRFSVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 8 {
            if let Some((inst_len, parsed)) =
                FPSCR_CRFSVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 12 {
            if let Some((inst_len, parsed)) =
                FPSCR_CRFSVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 16 {
            if let Some((inst_len, parsed)) =
                FPSCR_CRFSVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 20 {
            if let Some((inst_len, parsed)) =
                FPSCR_CRFSVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 24 {
            if let Some((inst_len, parsed)) =
                FPSCR_CRFSVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[2] & 28) == 28 {
            if let Some((inst_len, parsed)) =
                FPSCR_CRFSVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1998:1, end:1998:7))"]
#[derive(Clone, Debug)]
struct CRM_CRVar0 {}
impl CRM_CRVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:1999:1, end:1999:7))"]
#[derive(Clone, Debug)]
struct CRM_CRVar1 {}
impl CRM_CRVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr6)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:2000:1, end:2000:7))"]
#[derive(Clone, Debug)]
struct CRM_CRVar2 {}
impl CRM_CRVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr5)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:2001:1, end:2001:7))"]
#[derive(Clone, Debug)]
struct CRM_CRVar3 {}
impl CRM_CRVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr4)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:2002:1, end:2002:7))"]
#[derive(Clone, Debug)]
struct CRM_CRVar4 {}
impl CRM_CRVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr3)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:2003:1, end:2003:7))"]
#[derive(Clone, Debug)]
struct CRM_CRVar5 {}
impl CRM_CRVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr2)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:2004:1, end:2004:7))"]
#[derive(Clone, Debug)]
struct CRM_CRVar6 {}
impl CRM_CRVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_common.sinc, start:2005:1, end:2005:7))"]
#[derive(Clone, Debug)]
struct CRM_CRVar7 {}
impl CRM_CRVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::cr0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableCRM_CR {
    Var0(CRM_CRVar0),
    Var1(CRM_CRVar1),
    Var2(CRM_CRVar2),
    Var3(CRM_CRVar3),
    Var4(CRM_CRVar4),
    Var5(CRM_CRVar5),
    Var6(CRM_CRVar6),
    Var7(CRM_CRVar7),
}
impl TableCRM_CR {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 240) == 16 && (tokens_param[2] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                CRM_CRVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 240) == 32 && (tokens_param[2] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                CRM_CRVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 240) == 64 && (tokens_param[2] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                CRM_CRVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 240) == 128 && (tokens_param[2] & 15) == 0
        {
            if let Some((inst_len, parsed)) =
                CRM_CRVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 240) == 0 && (tokens_param[2] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                CRM_CRVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 240) == 0 && (tokens_param[2] & 15) == 2 {
            if let Some((inst_len, parsed)) =
                CRM_CRVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 240) == 0 && (tokens_param[2] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                CRM_CRVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 240) == 0 && (tokens_param[2] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                CRM_CRVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:1:1, end:1:6))"]
#[derive(Clone, Debug)]
struct LDMR0Var0 {}
impl LDMR0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:2:1, end:2:6))"]
#[derive(Clone, Debug)]
struct LDMR0Var1 {}
impl LDMR0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR0 {
    Var0(LDMR0Var0),
    Var1(LDMR0Var1),
}
impl TableLDMR0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 128 {
            if let Some((inst_len, parsed)) =
                LDMR0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:4:1, end:4:6))"]
#[derive(Clone, Debug)]
struct LDMR1Var0 {}
impl LDMR1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:5:1, end:5:6))"]
#[derive(Clone, Debug)]
struct LDMR1Var1 {
    LDMR0: TableLDMR0,
}
impl LDMR1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR0 = if let Some((len, table)) =
            TableLDMR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR0 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR1 {
    Var0(LDMR1Var0),
    Var1(LDMR1Var1),
}
impl TableLDMR1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 64 {
            if let Some((inst_len, parsed)) =
                LDMR1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:7:1, end:7:6))"]
#[derive(Clone, Debug)]
struct LDMR2Var0 {}
impl LDMR2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:8:1, end:8:6))"]
#[derive(Clone, Debug)]
struct LDMR2Var1 {
    LDMR1: TableLDMR1,
}
impl LDMR2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR1 = if let Some((len, table)) =
            TableLDMR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR1 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR2 {
    Var0(LDMR2Var0),
    Var1(LDMR2Var1),
}
impl TableLDMR2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 192 {
            if let Some((inst_len, parsed)) =
                LDMR2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:10:1, end:10:6))"]
#[derive(Clone, Debug)]
struct LDMR3Var0 {}
impl LDMR3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:11:1, end:11:6))"]
#[derive(Clone, Debug)]
struct LDMR3Var1 {
    LDMR2: TableLDMR2,
}
impl LDMR3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR2 = if let Some((len, table)) =
            TableLDMR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR2 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR3 {
    Var0(LDMR3Var0),
    Var1(LDMR3Var1),
}
impl TableLDMR3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 32 {
            if let Some((inst_len, parsed)) =
                LDMR3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:13:1, end:13:6))"]
#[derive(Clone, Debug)]
struct LDMR4Var0 {}
impl LDMR4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:14:1, end:14:6))"]
#[derive(Clone, Debug)]
struct LDMR4Var1 {
    LDMR3: TableLDMR3,
}
impl LDMR4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR3 = if let Some((len, table)) =
            TableLDMR3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR3 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR4 {
    Var0(LDMR4Var0),
    Var1(LDMR4Var1),
}
impl TableLDMR4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 160 {
            if let Some((inst_len, parsed)) =
                LDMR4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:16:1, end:16:6))"]
#[derive(Clone, Debug)]
struct LDMR5Var0 {}
impl LDMR5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:17:1, end:17:6))"]
#[derive(Clone, Debug)]
struct LDMR5Var1 {
    LDMR4: TableLDMR4,
}
impl LDMR5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR4 = if let Some((len, table)) =
            TableLDMR4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR4 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR5 {
    Var0(LDMR5Var0),
    Var1(LDMR5Var1),
}
impl TableLDMR5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 96 {
            if let Some((inst_len, parsed)) =
                LDMR5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:19:1, end:19:6))"]
#[derive(Clone, Debug)]
struct LDMR6Var0 {}
impl LDMR6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:20:1, end:20:6))"]
#[derive(Clone, Debug)]
struct LDMR6Var1 {
    LDMR5: TableLDMR5,
}
impl LDMR6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR5 = if let Some((len, table)) =
            TableLDMR5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR5 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR6 {
    Var0(LDMR6Var0),
    Var1(LDMR6Var1),
}
impl TableLDMR6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 224 {
            if let Some((inst_len, parsed)) =
                LDMR6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:22:1, end:22:6))"]
#[derive(Clone, Debug)]
struct LDMR7Var0 {}
impl LDMR7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:23:1, end:23:6))"]
#[derive(Clone, Debug)]
struct LDMR7Var1 {
    LDMR6: TableLDMR6,
}
impl LDMR7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR6 = if let Some((len, table)) =
            TableLDMR6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR6 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR7 {
    Var0(LDMR7Var0),
    Var1(LDMR7Var1),
}
impl TableLDMR7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 16 {
            if let Some((inst_len, parsed)) =
                LDMR7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:25:1, end:25:6))"]
#[derive(Clone, Debug)]
struct LDMR8Var0 {}
impl LDMR8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:26:1, end:26:6))"]
#[derive(Clone, Debug)]
struct LDMR8Var1 {
    LDMR7: TableLDMR7,
}
impl LDMR8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR7 = if let Some((len, table)) =
            TableLDMR7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR7 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR8 {
    Var0(LDMR8Var0),
    Var1(LDMR8Var1),
}
impl TableLDMR8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 144 {
            if let Some((inst_len, parsed)) =
                LDMR8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:28:1, end:28:6))"]
#[derive(Clone, Debug)]
struct LDMR9Var0 {}
impl LDMR9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:29:1, end:29:6))"]
#[derive(Clone, Debug)]
struct LDMR9Var1 {
    LDMR8: TableLDMR8,
}
impl LDMR9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR8 = if let Some((len, table)) =
            TableLDMR8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR8 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR9 {
    Var0(LDMR9Var0),
    Var1(LDMR9Var1),
}
impl TableLDMR9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 80 {
            if let Some((inst_len, parsed)) =
                LDMR9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:31:1, end:31:7))"]
#[derive(Clone, Debug)]
struct LDMR10Var0 {}
impl LDMR10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:32:1, end:32:7))"]
#[derive(Clone, Debug)]
struct LDMR10Var1 {
    LDMR9: TableLDMR9,
}
impl LDMR10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR9 = if let Some((len, table)) =
            TableLDMR9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR9 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR10 {
    Var0(LDMR10Var0),
    Var1(LDMR10Var1),
}
impl TableLDMR10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 208 {
            if let Some((inst_len, parsed)) =
                LDMR10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:34:1, end:34:7))"]
#[derive(Clone, Debug)]
struct LDMR11Var0 {}
impl LDMR11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:35:1, end:35:7))"]
#[derive(Clone, Debug)]
struct LDMR11Var1 {
    LDMR10: TableLDMR10,
}
impl LDMR11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR10 = if let Some((len, table)) =
            TableLDMR10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR10 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR11 {
    Var0(LDMR11Var0),
    Var1(LDMR11Var1),
}
impl TableLDMR11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 48 {
            if let Some((inst_len, parsed)) =
                LDMR11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:37:1, end:37:7))"]
#[derive(Clone, Debug)]
struct LDMR12Var0 {}
impl LDMR12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:38:1, end:38:7))"]
#[derive(Clone, Debug)]
struct LDMR12Var1 {
    LDMR11: TableLDMR11,
}
impl LDMR12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR11 = if let Some((len, table)) =
            TableLDMR11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR11 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR12 {
    Var0(LDMR12Var0),
    Var1(LDMR12Var1),
}
impl TableLDMR12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 176 {
            if let Some((inst_len, parsed)) =
                LDMR12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:40:1, end:40:7))"]
#[derive(Clone, Debug)]
struct LDMR13Var0 {}
impl LDMR13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:41:1, end:41:7))"]
#[derive(Clone, Debug)]
struct LDMR13Var1 {
    LDMR12: TableLDMR12,
}
impl LDMR13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR12 = if let Some((len, table)) =
            TableLDMR12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR12 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR13 {
    Var0(LDMR13Var0),
    Var1(LDMR13Var1),
}
impl TableLDMR13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 112 {
            if let Some((inst_len, parsed)) =
                LDMR13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:43:1, end:43:7))"]
#[derive(Clone, Debug)]
struct LDMR14Var0 {}
impl LDMR14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:44:1, end:44:7))"]
#[derive(Clone, Debug)]
struct LDMR14Var1 {
    LDMR13: TableLDMR13,
}
impl LDMR14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR13 = if let Some((len, table)) =
            TableLDMR13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR13 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR14 {
    Var0(LDMR14Var0),
    Var1(LDMR14Var1),
}
impl TableLDMR14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 240 {
            if let Some((inst_len, parsed)) =
                LDMR14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:46:1, end:46:7))"]
#[derive(Clone, Debug)]
struct LDMR15Var0 {}
impl LDMR15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:47:1, end:47:7))"]
#[derive(Clone, Debug)]
struct LDMR15Var1 {
    LDMR14: TableLDMR14,
}
impl LDMR15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR14 = if let Some((len, table)) =
            TableLDMR14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR14 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR15 {
    Var0(LDMR15Var0),
    Var1(LDMR15Var1),
}
impl TableLDMR15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 8 {
            if let Some((inst_len, parsed)) =
                LDMR15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:49:1, end:49:7))"]
#[derive(Clone, Debug)]
struct LDMR16Var0 {}
impl LDMR16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:50:1, end:50:7))"]
#[derive(Clone, Debug)]
struct LDMR16Var1 {
    LDMR15: TableLDMR15,
}
impl LDMR16Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR15 = if let Some((len, table)) =
            TableLDMR15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR15 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR16 {
    Var0(LDMR16Var0),
    Var1(LDMR16Var1),
}
impl TableLDMR16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 136 {
            if let Some((inst_len, parsed)) =
                LDMR16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR16Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:52:1, end:52:7))"]
#[derive(Clone, Debug)]
struct LDMR17Var0 {}
impl LDMR17Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:53:1, end:53:7))"]
#[derive(Clone, Debug)]
struct LDMR17Var1 {
    LDMR16: TableLDMR16,
}
impl LDMR17Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR16 = if let Some((len, table)) =
            TableLDMR16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR16 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR17 {
    Var0(LDMR17Var0),
    Var1(LDMR17Var1),
}
impl TableLDMR17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 72 {
            if let Some((inst_len, parsed)) =
                LDMR17Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR17Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:55:1, end:55:7))"]
#[derive(Clone, Debug)]
struct LDMR18Var0 {}
impl LDMR18Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:56:1, end:56:7))"]
#[derive(Clone, Debug)]
struct LDMR18Var1 {
    LDMR17: TableLDMR17,
}
impl LDMR18Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR17 = if let Some((len, table)) =
            TableLDMR17::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR17 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR18 {
    Var0(LDMR18Var0),
    Var1(LDMR18Var1),
}
impl TableLDMR18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 200 {
            if let Some((inst_len, parsed)) =
                LDMR18Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR18Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:58:1, end:58:7))"]
#[derive(Clone, Debug)]
struct LDMR19Var0 {}
impl LDMR19Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:59:1, end:59:7))"]
#[derive(Clone, Debug)]
struct LDMR19Var1 {
    LDMR18: TableLDMR18,
}
impl LDMR19Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR18 = if let Some((len, table)) =
            TableLDMR18::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR18 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR19 {
    Var0(LDMR19Var0),
    Var1(LDMR19Var1),
}
impl TableLDMR19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 40 {
            if let Some((inst_len, parsed)) =
                LDMR19Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR19Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:61:1, end:61:7))"]
#[derive(Clone, Debug)]
struct LDMR20Var0 {}
impl LDMR20Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:62:1, end:62:7))"]
#[derive(Clone, Debug)]
struct LDMR20Var1 {
    LDMR19: TableLDMR19,
}
impl LDMR20Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR19 = if let Some((len, table)) =
            TableLDMR19::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR19 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR20 {
    Var0(LDMR20Var0),
    Var1(LDMR20Var1),
}
impl TableLDMR20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 168 {
            if let Some((inst_len, parsed)) =
                LDMR20Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR20Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:64:1, end:64:7))"]
#[derive(Clone, Debug)]
struct LDMR21Var0 {}
impl LDMR21Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:65:1, end:65:7))"]
#[derive(Clone, Debug)]
struct LDMR21Var1 {
    LDMR20: TableLDMR20,
}
impl LDMR21Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR20 = if let Some((len, table)) =
            TableLDMR20::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR20 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR21 {
    Var0(LDMR21Var0),
    Var1(LDMR21Var1),
}
impl TableLDMR21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 104 {
            if let Some((inst_len, parsed)) =
                LDMR21Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR21Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:67:1, end:67:7))"]
#[derive(Clone, Debug)]
struct LDMR22Var0 {}
impl LDMR22Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:68:1, end:68:7))"]
#[derive(Clone, Debug)]
struct LDMR22Var1 {
    LDMR21: TableLDMR21,
}
impl LDMR22Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR21 = if let Some((len, table)) =
            TableLDMR21::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR21 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR22 {
    Var0(LDMR22Var0),
    Var1(LDMR22Var1),
}
impl TableLDMR22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 232 {
            if let Some((inst_len, parsed)) =
                LDMR22Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR22Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:70:1, end:70:7))"]
#[derive(Clone, Debug)]
struct LDMR23Var0 {}
impl LDMR23Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:71:1, end:71:7))"]
#[derive(Clone, Debug)]
struct LDMR23Var1 {
    LDMR22: TableLDMR22,
}
impl LDMR23Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR22 = if let Some((len, table)) =
            TableLDMR22::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR22 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR23 {
    Var0(LDMR23Var0),
    Var1(LDMR23Var1),
}
impl TableLDMR23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 24 {
            if let Some((inst_len, parsed)) =
                LDMR23Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR23Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:73:1, end:73:7))"]
#[derive(Clone, Debug)]
struct LDMR24Var0 {}
impl LDMR24Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:74:1, end:74:7))"]
#[derive(Clone, Debug)]
struct LDMR24Var1 {
    LDMR23: TableLDMR23,
}
impl LDMR24Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR23 = if let Some((len, table)) =
            TableLDMR23::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR23 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR24 {
    Var0(LDMR24Var0),
    Var1(LDMR24Var1),
}
impl TableLDMR24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 152 {
            if let Some((inst_len, parsed)) =
                LDMR24Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR24Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:76:1, end:76:7))"]
#[derive(Clone, Debug)]
struct LDMR25Var0 {}
impl LDMR25Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:77:1, end:77:7))"]
#[derive(Clone, Debug)]
struct LDMR25Var1 {
    LDMR24: TableLDMR24,
}
impl LDMR25Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR24 = if let Some((len, table)) =
            TableLDMR24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR24 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR25 {
    Var0(LDMR25Var0),
    Var1(LDMR25Var1),
}
impl TableLDMR25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 88 {
            if let Some((inst_len, parsed)) =
                LDMR25Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR25Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:79:1, end:79:7))"]
#[derive(Clone, Debug)]
struct LDMR26Var0 {}
impl LDMR26Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:80:1, end:80:7))"]
#[derive(Clone, Debug)]
struct LDMR26Var1 {
    LDMR25: TableLDMR25,
}
impl LDMR26Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR25 = if let Some((len, table)) =
            TableLDMR25::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR25 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR26 {
    Var0(LDMR26Var0),
    Var1(LDMR26Var1),
}
impl TableLDMR26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 216 {
            if let Some((inst_len, parsed)) =
                LDMR26Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR26Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:82:1, end:82:7))"]
#[derive(Clone, Debug)]
struct LDMR27Var0 {}
impl LDMR27Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:83:1, end:83:7))"]
#[derive(Clone, Debug)]
struct LDMR27Var1 {
    LDMR26: TableLDMR26,
}
impl LDMR27Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR26 = if let Some((len, table)) =
            TableLDMR26::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR26 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR27 {
    Var0(LDMR27Var0),
    Var1(LDMR27Var1),
}
impl TableLDMR27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 56 {
            if let Some((inst_len, parsed)) =
                LDMR27Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR27Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:85:1, end:85:7))"]
#[derive(Clone, Debug)]
struct LDMR28Var0 {}
impl LDMR28Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:86:1, end:86:7))"]
#[derive(Clone, Debug)]
struct LDMR28Var1 {
    LDMR27: TableLDMR27,
}
impl LDMR28Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR27 = if let Some((len, table)) =
            TableLDMR27::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR27 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR28 {
    Var0(LDMR28Var0),
    Var1(LDMR28Var1),
}
impl TableLDMR28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 184 {
            if let Some((inst_len, parsed)) =
                LDMR28Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR28Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:88:1, end:88:7))"]
#[derive(Clone, Debug)]
struct LDMR29Var0 {}
impl LDMR29Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:89:1, end:89:7))"]
#[derive(Clone, Debug)]
struct LDMR29Var1 {
    LDMR28: TableLDMR28,
}
impl LDMR29Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR28 = if let Some((len, table)) =
            TableLDMR28::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR28 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR29 {
    Var0(LDMR29Var0),
    Var1(LDMR29Var1),
}
impl TableLDMR29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 120 {
            if let Some((inst_len, parsed)) =
                LDMR29Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR29Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:91:1, end:91:7))"]
#[derive(Clone, Debug)]
struct LDMR30Var0 {}
impl LDMR30Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:92:1, end:92:7))"]
#[derive(Clone, Debug)]
struct LDMR30Var1 {
    LDMR29: TableLDMR29,
}
impl LDMR30Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR29 = if let Some((len, table)) =
            TableLDMR29::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR29 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR30 {
    Var0(LDMR30Var0),
    Var1(LDMR30Var1),
}
impl TableLDMR30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 248 {
            if let Some((inst_len, parsed)) =
                LDMR30Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR30Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lmwInstructions.sinc, start:94:1, end:94:7))"]
#[derive(Clone, Debug)]
struct LDMR31Var0 {
    LDMR30: TableLDMR30,
}
impl LDMR31Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let LDMR30 = if let Some((len, table)) =
            TableLDMR30::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { LDMR30 }))
    }
}
#[derive(Clone, Debug)]
enum TableLDMR31 {
    Var0(LDMR31Var0),
}
impl TableLDMR31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                LDMR31Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:4:1, end:4:7))"]
#[derive(Clone, Debug)]
struct DYN_D1Var0 {
    BITS_21_25: u8,
}
impl DYN_D1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(1i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(1i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D1 {
    Var0(DYN_D1Var0),
}
impl TableDYN_D1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_D1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:5:1, end:5:7))"]
#[derive(Clone, Debug)]
struct DYN_D2Var0 {
    BITS_21_25: u8,
}
impl DYN_D2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(2i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(2i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D2 {
    Var0(DYN_D2Var0),
}
impl TableDYN_D2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_D2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:6:1, end:6:7))"]
#[derive(Clone, Debug)]
struct DYN_D3Var0 {
    BITS_21_25: u8,
}
impl DYN_D3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(3i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(3i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D3 {
    Var0(DYN_D3Var0),
}
impl TableDYN_D3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_D3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:7:1, end:7:7))"]
#[derive(Clone, Debug)]
struct DYN_D4Var0 {
    BITS_21_25: u8,
}
impl DYN_D4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(4i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(4i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D4 {
    Var0(DYN_D4Var0),
}
impl TableDYN_D4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_D4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:8:1, end:8:7))"]
#[derive(Clone, Debug)]
struct DYN_D5Var0 {
    BITS_21_25: u8,
}
impl DYN_D5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(5i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(5i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D5 {
    Var0(DYN_D5Var0),
}
impl TableDYN_D5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_D5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:9:1, end:9:7))"]
#[derive(Clone, Debug)]
struct DYN_D6Var0 {
    BITS_21_25: u8,
}
impl DYN_D6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(6i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(6i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D6 {
    Var0(DYN_D6Var0),
}
impl TableDYN_D6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_D6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/lswInstructions.sinc, start:10:1, end:10:7))"]
#[derive(Clone, Debug)]
struct DYN_D7Var0 {
    BITS_21_25: u8,
}
impl DYN_D7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(7i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(7i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_D7 {
    Var0(DYN_D7Var0),
}
impl TableDYN_D7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_D7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/ppc_instructions.sinc, start:3197:1, end:3197:8))"]
#[derive(Clone, Debug)]
struct CRM_valVar0 {
    CRM: u8,
}
impl CRM_valVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_crmval: i128 = 0;
        calc_crmval = i128::try_from(self.CRM).unwrap().wrapping_add(0i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_crmval.is_negative(),
            calc_crmval.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_crmval: i128 = 0;
        let mut block_0_len = 4;
        calc_crmval = i128::try_from(token_36(tokens_current))
            .unwrap()
            .wrapping_add(0i128);
        let CRM = token_36(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { CRM }))
    }
}
#[derive(Clone, Debug)]
enum TableCRM_val {
    Var0(CRM_valVar0),
}
impl TableCRM_val {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                CRM_valVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:1:1, end:1:6))"]
#[derive(Clone, Debug)]
struct STMR0Var0 {}
impl STMR0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:2:1, end:2:6))"]
#[derive(Clone, Debug)]
struct STMR0Var1 {}
impl STMR0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR0 {
    Var0(STMR0Var0),
    Var1(STMR0Var1),
}
impl TableSTMR0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 128 {
            if let Some((inst_len, parsed)) =
                STMR0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:4:1, end:4:6))"]
#[derive(Clone, Debug)]
struct STMR1Var0 {}
impl STMR1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:5:1, end:5:6))"]
#[derive(Clone, Debug)]
struct STMR1Var1 {
    STMR0: TableSTMR0,
}
impl STMR1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR0 = if let Some((len, table)) =
            TableSTMR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR0 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR1 {
    Var0(STMR1Var0),
    Var1(STMR1Var1),
}
impl TableSTMR1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 64 {
            if let Some((inst_len, parsed)) =
                STMR1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:7:1, end:7:6))"]
#[derive(Clone, Debug)]
struct STMR2Var0 {}
impl STMR2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:8:1, end:8:6))"]
#[derive(Clone, Debug)]
struct STMR2Var1 {
    STMR1: TableSTMR1,
}
impl STMR2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR1 = if let Some((len, table)) =
            TableSTMR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR1 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR2 {
    Var0(STMR2Var0),
    Var1(STMR2Var1),
}
impl TableSTMR2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 192 {
            if let Some((inst_len, parsed)) =
                STMR2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:10:1, end:10:6))"]
#[derive(Clone, Debug)]
struct STMR3Var0 {}
impl STMR3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:11:1, end:11:6))"]
#[derive(Clone, Debug)]
struct STMR3Var1 {
    STMR2: TableSTMR2,
}
impl STMR3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR2 = if let Some((len, table)) =
            TableSTMR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR2 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR3 {
    Var0(STMR3Var0),
    Var1(STMR3Var1),
}
impl TableSTMR3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 32 {
            if let Some((inst_len, parsed)) =
                STMR3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:13:1, end:13:6))"]
#[derive(Clone, Debug)]
struct STMR4Var0 {}
impl STMR4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:14:1, end:14:6))"]
#[derive(Clone, Debug)]
struct STMR4Var1 {
    STMR3: TableSTMR3,
}
impl STMR4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR3 = if let Some((len, table)) =
            TableSTMR3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR3 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR4 {
    Var0(STMR4Var0),
    Var1(STMR4Var1),
}
impl TableSTMR4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 160 {
            if let Some((inst_len, parsed)) =
                STMR4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:16:1, end:16:6))"]
#[derive(Clone, Debug)]
struct STMR5Var0 {}
impl STMR5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:17:1, end:17:6))"]
#[derive(Clone, Debug)]
struct STMR5Var1 {
    STMR4: TableSTMR4,
}
impl STMR5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR4 = if let Some((len, table)) =
            TableSTMR4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR4 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR5 {
    Var0(STMR5Var0),
    Var1(STMR5Var1),
}
impl TableSTMR5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 96 {
            if let Some((inst_len, parsed)) =
                STMR5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:19:1, end:19:6))"]
#[derive(Clone, Debug)]
struct STMR6Var0 {}
impl STMR6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:20:1, end:20:6))"]
#[derive(Clone, Debug)]
struct STMR6Var1 {
    STMR5: TableSTMR5,
}
impl STMR6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR5 = if let Some((len, table)) =
            TableSTMR5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR5 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR6 {
    Var0(STMR6Var0),
    Var1(STMR6Var1),
}
impl TableSTMR6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 224 {
            if let Some((inst_len, parsed)) =
                STMR6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:22:1, end:22:6))"]
#[derive(Clone, Debug)]
struct STMR7Var0 {}
impl STMR7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:23:1, end:23:6))"]
#[derive(Clone, Debug)]
struct STMR7Var1 {
    STMR6: TableSTMR6,
}
impl STMR7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR6 = if let Some((len, table)) =
            TableSTMR6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR6 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR7 {
    Var0(STMR7Var0),
    Var1(STMR7Var1),
}
impl TableSTMR7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 16 {
            if let Some((inst_len, parsed)) =
                STMR7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:25:1, end:25:6))"]
#[derive(Clone, Debug)]
struct STMR8Var0 {}
impl STMR8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:26:1, end:26:6))"]
#[derive(Clone, Debug)]
struct STMR8Var1 {
    STMR7: TableSTMR7,
}
impl STMR8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR7 = if let Some((len, table)) =
            TableSTMR7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR7 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR8 {
    Var0(STMR8Var0),
    Var1(STMR8Var1),
}
impl TableSTMR8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 144 {
            if let Some((inst_len, parsed)) =
                STMR8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:28:1, end:28:6))"]
#[derive(Clone, Debug)]
struct STMR9Var0 {}
impl STMR9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:29:1, end:29:6))"]
#[derive(Clone, Debug)]
struct STMR9Var1 {
    STMR8: TableSTMR8,
}
impl STMR9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR8 = if let Some((len, table)) =
            TableSTMR8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR8 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR9 {
    Var0(STMR9Var0),
    Var1(STMR9Var1),
}
impl TableSTMR9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 80 {
            if let Some((inst_len, parsed)) =
                STMR9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:31:1, end:31:7))"]
#[derive(Clone, Debug)]
struct STMR10Var0 {}
impl STMR10Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:32:1, end:32:7))"]
#[derive(Clone, Debug)]
struct STMR10Var1 {
    STMR9: TableSTMR9,
}
impl STMR10Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR9 = if let Some((len, table)) =
            TableSTMR9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR9 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR10 {
    Var0(STMR10Var0),
    Var1(STMR10Var1),
}
impl TableSTMR10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 208 {
            if let Some((inst_len, parsed)) =
                STMR10Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR10Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:34:1, end:34:7))"]
#[derive(Clone, Debug)]
struct STMR11Var0 {}
impl STMR11Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:35:1, end:35:7))"]
#[derive(Clone, Debug)]
struct STMR11Var1 {
    STMR10: TableSTMR10,
}
impl STMR11Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR10 = if let Some((len, table)) =
            TableSTMR10::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR10 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR11 {
    Var0(STMR11Var0),
    Var1(STMR11Var1),
}
impl TableSTMR11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 48 {
            if let Some((inst_len, parsed)) =
                STMR11Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR11Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:37:1, end:37:7))"]
#[derive(Clone, Debug)]
struct STMR12Var0 {}
impl STMR12Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:38:1, end:38:7))"]
#[derive(Clone, Debug)]
struct STMR12Var1 {
    STMR11: TableSTMR11,
}
impl STMR12Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR11 = if let Some((len, table)) =
            TableSTMR11::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR11 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR12 {
    Var0(STMR12Var0),
    Var1(STMR12Var1),
}
impl TableSTMR12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 176 {
            if let Some((inst_len, parsed)) =
                STMR12Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR12Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:40:1, end:40:7))"]
#[derive(Clone, Debug)]
struct STMR13Var0 {}
impl STMR13Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:41:1, end:41:7))"]
#[derive(Clone, Debug)]
struct STMR13Var1 {
    STMR12: TableSTMR12,
}
impl STMR13Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR12 = if let Some((len, table)) =
            TableSTMR12::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR12 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR13 {
    Var0(STMR13Var0),
    Var1(STMR13Var1),
}
impl TableSTMR13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 112 {
            if let Some((inst_len, parsed)) =
                STMR13Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR13Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:43:1, end:43:7))"]
#[derive(Clone, Debug)]
struct STMR14Var0 {}
impl STMR14Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:44:1, end:44:7))"]
#[derive(Clone, Debug)]
struct STMR14Var1 {
    STMR13: TableSTMR13,
}
impl STMR14Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR13 = if let Some((len, table)) =
            TableSTMR13::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR13 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR14 {
    Var0(STMR14Var0),
    Var1(STMR14Var1),
}
impl TableSTMR14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 240 {
            if let Some((inst_len, parsed)) =
                STMR14Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR14Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:46:1, end:46:7))"]
#[derive(Clone, Debug)]
struct STMR15Var0 {}
impl STMR15Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:47:1, end:47:7))"]
#[derive(Clone, Debug)]
struct STMR15Var1 {
    STMR14: TableSTMR14,
}
impl STMR15Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR14 = if let Some((len, table)) =
            TableSTMR14::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR14 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR15 {
    Var0(STMR15Var0),
    Var1(STMR15Var1),
}
impl TableSTMR15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 8 {
            if let Some((inst_len, parsed)) =
                STMR15Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR15Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:49:1, end:49:7))"]
#[derive(Clone, Debug)]
struct STMR16Var0 {}
impl STMR16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:50:1, end:50:7))"]
#[derive(Clone, Debug)]
struct STMR16Var1 {
    STMR15: TableSTMR15,
}
impl STMR16Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR15 = if let Some((len, table)) =
            TableSTMR15::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR15 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR16 {
    Var0(STMR16Var0),
    Var1(STMR16Var1),
}
impl TableSTMR16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 136 {
            if let Some((inst_len, parsed)) =
                STMR16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR16Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:52:1, end:52:7))"]
#[derive(Clone, Debug)]
struct STMR17Var0 {}
impl STMR17Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:53:1, end:53:7))"]
#[derive(Clone, Debug)]
struct STMR17Var1 {
    STMR16: TableSTMR16,
}
impl STMR17Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR16 = if let Some((len, table)) =
            TableSTMR16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR16 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR17 {
    Var0(STMR17Var0),
    Var1(STMR17Var1),
}
impl TableSTMR17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 72 {
            if let Some((inst_len, parsed)) =
                STMR17Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR17Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:55:1, end:55:7))"]
#[derive(Clone, Debug)]
struct STMR18Var0 {}
impl STMR18Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:56:1, end:56:7))"]
#[derive(Clone, Debug)]
struct STMR18Var1 {
    STMR17: TableSTMR17,
}
impl STMR18Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR17 = if let Some((len, table)) =
            TableSTMR17::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR17 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR18 {
    Var0(STMR18Var0),
    Var1(STMR18Var1),
}
impl TableSTMR18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 200 {
            if let Some((inst_len, parsed)) =
                STMR18Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR18Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:58:1, end:58:7))"]
#[derive(Clone, Debug)]
struct STMR19Var0 {}
impl STMR19Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:59:1, end:59:7))"]
#[derive(Clone, Debug)]
struct STMR19Var1 {
    STMR18: TableSTMR18,
}
impl STMR19Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR18 = if let Some((len, table)) =
            TableSTMR18::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR18 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR19 {
    Var0(STMR19Var0),
    Var1(STMR19Var1),
}
impl TableSTMR19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 40 {
            if let Some((inst_len, parsed)) =
                STMR19Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR19Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:61:1, end:61:7))"]
#[derive(Clone, Debug)]
struct STMR20Var0 {}
impl STMR20Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:62:1, end:62:7))"]
#[derive(Clone, Debug)]
struct STMR20Var1 {
    STMR19: TableSTMR19,
}
impl STMR20Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR19 = if let Some((len, table)) =
            TableSTMR19::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR19 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR20 {
    Var0(STMR20Var0),
    Var1(STMR20Var1),
}
impl TableSTMR20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 168 {
            if let Some((inst_len, parsed)) =
                STMR20Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR20Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:64:1, end:64:7))"]
#[derive(Clone, Debug)]
struct STMR21Var0 {}
impl STMR21Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:65:1, end:65:7))"]
#[derive(Clone, Debug)]
struct STMR21Var1 {
    STMR20: TableSTMR20,
}
impl STMR21Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR20 = if let Some((len, table)) =
            TableSTMR20::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR20 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR21 {
    Var0(STMR21Var0),
    Var1(STMR21Var1),
}
impl TableSTMR21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 104 {
            if let Some((inst_len, parsed)) =
                STMR21Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR21Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:67:1, end:67:7))"]
#[derive(Clone, Debug)]
struct STMR22Var0 {}
impl STMR22Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:68:1, end:68:7))"]
#[derive(Clone, Debug)]
struct STMR22Var1 {
    STMR21: TableSTMR21,
}
impl STMR22Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR21 = if let Some((len, table)) =
            TableSTMR21::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR21 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR22 {
    Var0(STMR22Var0),
    Var1(STMR22Var1),
}
impl TableSTMR22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 232 {
            if let Some((inst_len, parsed)) =
                STMR22Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR22Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:70:1, end:70:7))"]
#[derive(Clone, Debug)]
struct STMR23Var0 {}
impl STMR23Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:71:1, end:71:7))"]
#[derive(Clone, Debug)]
struct STMR23Var1 {
    STMR22: TableSTMR22,
}
impl STMR23Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR22 = if let Some((len, table)) =
            TableSTMR22::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR22 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR23 {
    Var0(STMR23Var0),
    Var1(STMR23Var1),
}
impl TableSTMR23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 24 {
            if let Some((inst_len, parsed)) =
                STMR23Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR23Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:73:1, end:73:7))"]
#[derive(Clone, Debug)]
struct STMR24Var0 {}
impl STMR24Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:74:1, end:74:7))"]
#[derive(Clone, Debug)]
struct STMR24Var1 {
    STMR23: TableSTMR23,
}
impl STMR24Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR23 = if let Some((len, table)) =
            TableSTMR23::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR23 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR24 {
    Var0(STMR24Var0),
    Var1(STMR24Var1),
}
impl TableSTMR24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 152 {
            if let Some((inst_len, parsed)) =
                STMR24Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR24Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:76:1, end:76:7))"]
#[derive(Clone, Debug)]
struct STMR25Var0 {}
impl STMR25Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:77:1, end:77:7))"]
#[derive(Clone, Debug)]
struct STMR25Var1 {
    STMR24: TableSTMR24,
}
impl STMR25Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR24 = if let Some((len, table)) =
            TableSTMR24::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR24 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR25 {
    Var0(STMR25Var0),
    Var1(STMR25Var1),
}
impl TableSTMR25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 88 {
            if let Some((inst_len, parsed)) =
                STMR25Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR25Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:79:1, end:79:7))"]
#[derive(Clone, Debug)]
struct STMR26Var0 {}
impl STMR26Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:80:1, end:80:7))"]
#[derive(Clone, Debug)]
struct STMR26Var1 {
    STMR25: TableSTMR25,
}
impl STMR26Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR25 = if let Some((len, table)) =
            TableSTMR25::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR25 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR26 {
    Var0(STMR26Var0),
    Var1(STMR26Var1),
}
impl TableSTMR26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 216 {
            if let Some((inst_len, parsed)) =
                STMR26Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR26Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:82:1, end:82:7))"]
#[derive(Clone, Debug)]
struct STMR27Var0 {}
impl STMR27Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:83:1, end:83:7))"]
#[derive(Clone, Debug)]
struct STMR27Var1 {
    STMR26: TableSTMR26,
}
impl STMR27Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR26 = if let Some((len, table)) =
            TableSTMR26::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR26 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR27 {
    Var0(STMR27Var0),
    Var1(STMR27Var1),
}
impl TableSTMR27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 56 {
            if let Some((inst_len, parsed)) =
                STMR27Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR27Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:85:1, end:85:7))"]
#[derive(Clone, Debug)]
struct STMR28Var0 {}
impl STMR28Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:86:1, end:86:7))"]
#[derive(Clone, Debug)]
struct STMR28Var1 {
    STMR27: TableSTMR27,
}
impl STMR28Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR27 = if let Some((len, table)) =
            TableSTMR27::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR27 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR28 {
    Var0(STMR28Var0),
    Var1(STMR28Var1),
}
impl TableSTMR28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 184 {
            if let Some((inst_len, parsed)) =
                STMR28Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR28Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:88:1, end:88:7))"]
#[derive(Clone, Debug)]
struct STMR29Var0 {}
impl STMR29Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:89:1, end:89:7))"]
#[derive(Clone, Debug)]
struct STMR29Var1 {
    STMR28: TableSTMR28,
}
impl STMR29Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR28 = if let Some((len, table)) =
            TableSTMR28::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR28 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR29 {
    Var0(STMR29Var0),
    Var1(STMR29Var1),
}
impl TableSTMR29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 120 {
            if let Some((inst_len, parsed)) =
                STMR29Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR29Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:91:1, end:91:7))"]
#[derive(Clone, Debug)]
struct STMR30Var0 {}
impl STMR30Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:92:1, end:92:7))"]
#[derive(Clone, Debug)]
struct STMR30Var1 {
    STMR29: TableSTMR29,
}
impl STMR30Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR29 = if let Some((len, table)) =
            TableSTMR29::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR29 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR30 {
    Var0(STMR30Var0),
    Var1(STMR30Var1),
}
impl TableSTMR30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 248 == 248 {
            if let Some((inst_len, parsed)) =
                STMR30Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR30Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stmwInstructions.sinc, start:94:1, end:94:7))"]
#[derive(Clone, Debug)]
struct STMR31Var0 {
    STMR30: TableSTMR30,
}
impl STMR31Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let STMR30 = if let Some((len, table)) =
            TableSTMR30::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { STMR30 }))
    }
}
#[derive(Clone, Debug)]
enum TableSTMR31 {
    Var0(STMR31Var0),
}
impl TableSTMR31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 {
            if let Some((inst_len, parsed)) =
                STMR31Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:5:1, end:5:7))"]
#[derive(Clone, Debug)]
struct DYN_S1Var0 {
    BITS_21_25: u8,
}
impl DYN_S1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(1i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(1i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S1 {
    Var0(DYN_S1Var0),
}
impl TableDYN_S1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_S1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:6:1, end:6:7))"]
#[derive(Clone, Debug)]
struct DYN_S2Var0 {
    BITS_21_25: u8,
}
impl DYN_S2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(2i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(2i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S2 {
    Var0(DYN_S2Var0),
}
impl TableDYN_S2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_S2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:7:1, end:7:7))"]
#[derive(Clone, Debug)]
struct DYN_S3Var0 {
    BITS_21_25: u8,
}
impl DYN_S3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(3i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(3i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S3 {
    Var0(DYN_S3Var0),
}
impl TableDYN_S3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_S3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:8:1, end:8:7))"]
#[derive(Clone, Debug)]
struct DYN_S4Var0 {
    BITS_21_25: u8,
}
impl DYN_S4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(4i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(4i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S4 {
    Var0(DYN_S4Var0),
}
impl TableDYN_S4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_S4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:9:1, end:9:7))"]
#[derive(Clone, Debug)]
struct DYN_S5Var0 {
    BITS_21_25: u8,
}
impl DYN_S5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(5i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(5i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S5 {
    Var0(DYN_S5Var0),
}
impl TableDYN_S5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_S5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:10:1, end:10:7))"]
#[derive(Clone, Debug)]
struct DYN_S6Var0 {
    BITS_21_25: u8,
}
impl DYN_S6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(6i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(6i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S6 {
    Var0(DYN_S6Var0),
}
impl TableDYN_S6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_S6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/stswiInstructions.sinc, start:11:1, end:11:7))"]
#[derive(Clone, Debug)]
struct DYN_S7Var0 {
    BITS_21_25: u8,
}
impl DYN_S7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_regaddr: i128 = 0;
        calc_regaddr = (i128::try_from(self.BITS_21_25).unwrap().wrapping_add(7i128) & 31i128)
            .wrapping_mul(8i128);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_regaddr.is_negative(),
            calc_regaddr.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_regaddr: i128 = 0;
        let mut block_0_len = 4;
        calc_regaddr = (i128::try_from(token_51(tokens_current))
            .unwrap()
            .wrapping_add(7i128)
            & 31i128)
            .wrapping_mul(8i128);
        let BITS_21_25 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { BITS_21_25 }))
    }
}
#[derive(Clone, Debug)]
enum TableDYN_S7 {
    Var0(DYN_S7Var0),
}
impl TableDYN_S7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                DYN_S7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:315:1, end:315:14))"]
#[derive(Clone, Debug)]
struct vaddubm_part1Var0 {}
impl vaddubm_part1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrA_8_0 = token_1(tokens_current);
        let vrA_8_2 = token_1(tokens_current);
        let vrA_8_7 = token_1(tokens_current);
        let vrB_8_1 = token_4(tokens_current);
        let vrB_8_5 = token_4(tokens_current);
        let vrA_8_5 = token_1(tokens_current);
        let vrA_8_4 = token_1(tokens_current);
        let vrB_8_2 = token_4(tokens_current);
        let vrD_8_2 = token_51(tokens_current);
        let vrB_8_3 = token_4(tokens_current);
        let vrD_8_5 = token_51(tokens_current);
        let vrD_8_0 = token_51(tokens_current);
        let vrD_8_1 = token_51(tokens_current);
        let vrD_8_6 = token_51(tokens_current);
        let vrB_8_6 = token_4(tokens_current);
        let vrA_8_6 = token_1(tokens_current);
        let vrA_8_3 = token_1(tokens_current);
        let vrD_8_4 = token_51(tokens_current);
        let vrB_8_0 = token_4(tokens_current);
        let vrD_8_7 = token_51(tokens_current);
        let vrB_8_4 = token_4(tokens_current);
        let vrA_8_1 = token_1(tokens_current);
        let vrB_8_7 = token_4(tokens_current);
        let vrD_8_3 = token_51(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablevaddubm_part1 {
    Var0(vaddubm_part1Var0),
}
impl Tablevaddubm_part1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                vaddubm_part1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/PowerPC/data/languages/altivec.sinc, start:329:1, end:329:14))"]
#[derive(Clone, Debug)]
struct vaddubm_part2Var0 {}
impl vaddubm_part2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let vrB_8_9 = token_4(tokens_current);
        let vrA_8_13 = token_1(tokens_current);
        let vrD_8_13 = token_51(tokens_current);
        let vrD_8_14 = token_51(tokens_current);
        let vrD_8_12 = token_51(tokens_current);
        let vrA_8_11 = token_1(tokens_current);
        let vrD_8_9 = token_51(tokens_current);
        let vrD_8_10 = token_51(tokens_current);
        let vrA_8_12 = token_1(tokens_current);
        let vrB_8_8 = token_4(tokens_current);
        let vrD_8_8 = token_51(tokens_current);
        let vrD_8_11 = token_51(tokens_current);
        let vrB_8_10 = token_4(tokens_current);
        let vrD_8_15 = token_51(tokens_current);
        let vrA_8_9 = token_1(tokens_current);
        let vrA_8_15 = token_1(tokens_current);
        let vrB_8_15 = token_4(tokens_current);
        let vrB_8_11 = token_4(tokens_current);
        let vrA_8_8 = token_1(tokens_current);
        let vrB_8_14 = token_4(tokens_current);
        let vrB_8_13 = token_4(tokens_current);
        let vrA_8_14 = token_1(tokens_current);
        let vrB_8_12 = token_4(tokens_current);
        let vrA_8_10 = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablevaddubm_part2 {
    Var0(vaddubm_part2Var0),
}
impl Tablevaddubm_part2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                vaddubm_part2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
pub fn parse_instruction(
    tokens: &[u8],
    context: &mut ContextMemory,
    inst_start: AddrType,
    global_set: &mut GlobalSet,
) -> Option<(u64, Vec<DisplayElement>)> {
    let (inst_len, instruction) = Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(&mut display, context, inst_start, inst_next, global_set);
    Some((inst_next, display))
}
