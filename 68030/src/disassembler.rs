pub type AddrType = u32;
#[derive(Clone, Copy, Debug)]
pub enum Register {
    D0,
    D1,
    D2,
    D3,
    D4,
    D5,
    D6,
    D7,
    D0u,
    D0w,
    D1u,
    D1w,
    D2u,
    D2w,
    D3u,
    D3w,
    D4u,
    D4w,
    D5u,
    D5w,
    D6u,
    D6w,
    D7u,
    D7w,
    D0b,
    D1b,
    D2b,
    D3b,
    D4b,
    D5b,
    D6b,
    D7b,
    A0,
    A1,
    A2,
    A3,
    A4,
    A5,
    A6,
    SP,
    A0u,
    A0w,
    A1u,
    A1w,
    A2u,
    A2w,
    A3u,
    A3w,
    A4u,
    A4w,
    A5u,
    A5w,
    A6u,
    A6w,
    A7u,
    A7w,
    A0b,
    A1b,
    A2b,
    A3b,
    A4b,
    A5b,
    A6b,
    A7b,
    TF,
    SVF,
    IPL,
    XF,
    NF,
    ZF,
    VF,
    CF,
    PC,
    FP0,
    FP1,
    FP2,
    FP3,
    FP4,
    FP5,
    FP6,
    FP7,
    FPCR,
    FPSR,
    FPIAR,
    CRP,
    ISP,
    MSP,
    VBR,
    CACR,
    CAAR,
    AC0,
    AC1,
    USP,
    TT0,
    TT1,
    SFC,
    DFC,
    TC,
    ITT0,
    ITT1,
    DTT0,
    DTT1,
    MMUSR,
    URP,
    SRP,
    PCR,
    CAC,
    BUSCR,
    MBB,
    RAMBAR0,
    RAMBAR1,
    SR,
    ACUSR,
    glbdenom,
    movemptr,
    contextreg,
}
impl Register {
    fn as_str(&self) -> &'static str {
        match self {
            Self::D0 => "D0",
            Self::D1 => "D1",
            Self::D2 => "D2",
            Self::D3 => "D3",
            Self::D4 => "D4",
            Self::D5 => "D5",
            Self::D6 => "D6",
            Self::D7 => "D7",
            Self::D0u => "D0u",
            Self::D0w => "D0w",
            Self::D1u => "D1u",
            Self::D1w => "D1w",
            Self::D2u => "D2u",
            Self::D2w => "D2w",
            Self::D3u => "D3u",
            Self::D3w => "D3w",
            Self::D4u => "D4u",
            Self::D4w => "D4w",
            Self::D5u => "D5u",
            Self::D5w => "D5w",
            Self::D6u => "D6u",
            Self::D6w => "D6w",
            Self::D7u => "D7u",
            Self::D7w => "D7w",
            Self::D0b => "D0b",
            Self::D1b => "D1b",
            Self::D2b => "D2b",
            Self::D3b => "D3b",
            Self::D4b => "D4b",
            Self::D5b => "D5b",
            Self::D6b => "D6b",
            Self::D7b => "D7b",
            Self::A0 => "A0",
            Self::A1 => "A1",
            Self::A2 => "A2",
            Self::A3 => "A3",
            Self::A4 => "A4",
            Self::A5 => "A5",
            Self::A6 => "A6",
            Self::SP => "SP",
            Self::A0u => "A0u",
            Self::A0w => "A0w",
            Self::A1u => "A1u",
            Self::A1w => "A1w",
            Self::A2u => "A2u",
            Self::A2w => "A2w",
            Self::A3u => "A3u",
            Self::A3w => "A3w",
            Self::A4u => "A4u",
            Self::A4w => "A4w",
            Self::A5u => "A5u",
            Self::A5w => "A5w",
            Self::A6u => "A6u",
            Self::A6w => "A6w",
            Self::A7u => "A7u",
            Self::A7w => "A7w",
            Self::A0b => "A0b",
            Self::A1b => "A1b",
            Self::A2b => "A2b",
            Self::A3b => "A3b",
            Self::A4b => "A4b",
            Self::A5b => "A5b",
            Self::A6b => "A6b",
            Self::A7b => "A7b",
            Self::TF => "TF",
            Self::SVF => "SVF",
            Self::IPL => "IPL",
            Self::XF => "XF",
            Self::NF => "NF",
            Self::ZF => "ZF",
            Self::VF => "VF",
            Self::CF => "CF",
            Self::PC => "PC",
            Self::FP0 => "FP0",
            Self::FP1 => "FP1",
            Self::FP2 => "FP2",
            Self::FP3 => "FP3",
            Self::FP4 => "FP4",
            Self::FP5 => "FP5",
            Self::FP6 => "FP6",
            Self::FP7 => "FP7",
            Self::FPCR => "FPCR",
            Self::FPSR => "FPSR",
            Self::FPIAR => "FPIAR",
            Self::CRP => "CRP",
            Self::ISP => "ISP",
            Self::MSP => "MSP",
            Self::VBR => "VBR",
            Self::CACR => "CACR",
            Self::CAAR => "CAAR",
            Self::AC0 => "AC0",
            Self::AC1 => "AC1",
            Self::USP => "USP",
            Self::TT0 => "TT0",
            Self::TT1 => "TT1",
            Self::SFC => "SFC",
            Self::DFC => "DFC",
            Self::TC => "TC",
            Self::ITT0 => "ITT0",
            Self::ITT1 => "ITT1",
            Self::DTT0 => "DTT0",
            Self::DTT1 => "DTT1",
            Self::MMUSR => "MMUSR",
            Self::URP => "URP",
            Self::SRP => "SRP",
            Self::PCR => "PCR",
            Self::CAC => "CAC",
            Self::BUSCR => "BUSCR",
            Self::MBB => "MBB",
            Self::RAMBAR0 => "RAMBAR0",
            Self::RAMBAR1 => "RAMBAR1",
            Self::SR => "SR",
            Self::ACUSR => "ACUSR",
            Self::glbdenom => "glbdenom",
            Self::movemptr => "movemptr",
            Self::contextreg => "contextreg",
        }
    }
}
impl core::fmt::Display for Register {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.as_str())
    }
}
fn meaning_0_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::D0,
        1 => Register::D1,
        2 => Register::D2,
        3 => Register::D3,
        4 => Register::D4,
        5 => Register::D5,
        6 => Register::D6,
        7 => Register::D7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_0_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_0_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_1_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::D0,
        1 => Register::D1,
        2 => Register::D2,
        3 => Register::D3,
        4 => Register::D4,
        5 => Register::D5,
        6 => Register::D6,
        7 => Register::D7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_1_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_1_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_2_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::D0w,
        1 => Register::D1w,
        2 => Register::D2w,
        3 => Register::D3w,
        4 => Register::D4w,
        5 => Register::D5w,
        6 => Register::D6w,
        7 => Register::D7w,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_2_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_2_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_3_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::D0b,
        1 => Register::D1b,
        2 => Register::D2b,
        3 => Register::D3b,
        4 => Register::D4b,
        5 => Register::D5b,
        6 => Register::D6b,
        7 => Register::D7b,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_3_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_3_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_4_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::D0,
        1 => Register::D1,
        2 => Register::D2,
        3 => Register::D3,
        4 => Register::D4,
        5 => Register::D5,
        6 => Register::D6,
        7 => Register::D7,
        8 => Register::A0,
        9 => Register::A1,
        10 => Register::A2,
        11 => Register::A3,
        12 => Register::A4,
        13 => Register::A5,
        14 => Register::A6,
        15 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_4_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_4_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_5_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A0,
        1 => Register::A1,
        2 => Register::A2,
        3 => Register::A3,
        4 => Register::A4,
        5 => Register::A5,
        6 => Register::A6,
        7 => Register::SP,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_5_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_5_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_6_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A0w,
        1 => Register::A1w,
        2 => Register::A2w,
        3 => Register::A3w,
        4 => Register::A4w,
        5 => Register::A5w,
        6 => Register::A6w,
        7 => Register::A7w,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_6_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_6_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_7_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::A0b,
        1 => Register::A1b,
        2 => Register::A2b,
        3 => Register::A3b,
        4 => Register::A4b,
        5 => Register::A5b,
        6 => Register::A6b,
        7 => Register::A7b,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_7_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_7_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_8_value<T>(num: T) -> Register
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => Register::FP0,
        1 => Register::FP1,
        2 => Register::FP2,
        3 => Register::FP3,
        4 => Register::FP4,
        5 => Register::FP5,
        6 => Register::FP6,
        7 => Register::FP7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_8_display<T>(num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_8_value(num.try_into().unwrap());
    <DisplayElement>::Register(value)
}
fn meaning_9_value<T>(num: T) -> u8
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => 1,
        1 => 2,
        2 => 4,
        3 => 8,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_9_display<T>(hex: bool, num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_9_value(num);
    <DisplayElement>::Number(hex, false, value as u64)
}
fn meaning_10_value<T>(num: T) -> u8
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    match u8::try_from(num).unwrap() {
        0 => 8,
        1 => 1,
        2 => 2,
        3 => 3,
        4 => 4,
        5 => 5,
        6 => 6,
        7 => 7,
        _ => unreachable!("Invalid Attach Value"),
    }
}
fn meaning_10_display<T>(hex: bool, num: T) -> DisplayElement
where
    u8: TryFrom<T>,
    <u8 as TryFrom<T>>::Error: core::fmt::Debug,
{
    let value = meaning_10_value(num);
    <DisplayElement>::Number(hex, false, value as u64)
}
#[derive(Clone, Copy, Debug)]
pub enum DisplayElement {
    Literal(&'static str),
    Register(Register),
    Number(bool, bool, u64),
}
impl core::fmt::Display for DisplayElement {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::Literal(lit) => lit.fmt(f),
            Self::Register(reg) => reg.fmt(f),
            Self::Number(true, false, value) => {
                write!(f, "0x{:x}", value)
            }
            Self::Number(true, true, value) => {
                write!(f, "-0x{:x}", value)
            }
            Self::Number(false, false, value) => value.fmt(f),
            Self::Number(false, true, value) => {
                write!(f, "-{:x}", value)
            }
        }
    }
}
#[doc = "Create token_fields: op11 wl f11 flmode_t flddo divsgn mvm11"]
fn token_24(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 11) & 1) as u8)
}
#[doc = "Create token_fields: f0306"]
fn token_42(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 15) as u8)
}
#[doc = "Create token_fields: d8base d8 freglist"]
fn token_27(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 255) as u8)
}
#[doc = "Create token_fields: op7 bs f0707 frlist7 mvm7"]
fn token_22(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 7) & 1) as u8)
}
#[doc = "Create token_fields: frlist0 mvm0"]
fn token_50(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 1) as u8)
}
#[doc = "Create token_fields: f1415"]
fn token_37(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 14) & 3) as u8)
}
#[doc = "Create token_fields: op69 f0609"]
fn token_17(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 15) as u8)
}
#[doc = "Create token_fields: op67"]
fn token_18(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 3) as u8)
}
#[doc = "Create token_fields: op03 fc03"]
fn token_9(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 15) as u8)
}
#[doc = "Create token_fields: frm mvm14"]
fn token_43(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 14) & 1) as u8)
}
#[doc = "Create token_fields: fdsin fdst"]
fn token_47(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 7) & 7) as u8)
}
#[doc = "Create token_fields: reg9dn reg9dnw reg9dnb reg9an copid quick ext_911 ext2_911 fcopid"]
fn token_5(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 9) & 7) as u8)
}
#[doc = "Create token_fields: signX"]
fn token_58(tokens: &[u8]) -> u8 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 31) & 1) as u8)
}
#[doc = "Create token_fields: op015 opx015 fword d16 bd16 od16"]
fn token_11(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 65535) as u16)
}
#[doc = "Create token_fields: op8 fbit f0808 mvm8"]
fn token_23(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 1) as u8)
}
#[doc = "Create token_fields: op811"]
fn token_25(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 15) as u8)
}
#[doc = "Create token_fields: f10 divsz mvm10"]
fn token_45(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 1) as u8)
}
#[doc = "Create token_fields: f12 flmode_m mvm12"]
fn token_46(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 1) as u8)
}
#[doc = "Create token_fields: op01 odsize"]
fn token_8(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 3) as u8)
}
#[doc = "Create token_fields: op1315 opx1315 f1315"]
fn token_19(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 13) & 7) as u8)
}
#[doc = "Create token_fields: fkfacreg fldynreg"]
fn token_49(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 7) as u8)
}
#[doc = "Create token_fields: copcc1 copcc2 fcode"]
fn token_26(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 63) as u8)
}
#[doc = "Create token_fields: mantissaD"]
fn token_56(tokens: &[u8]) -> u64 {
    (((u64::from_be_bytes(tokens[0..8].try_into().unwrap()) >> 0) & 4503599627370495) as u64)
}
#[doc = "Create token_fields: f1313 fdr mvm13"]
fn token_44(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 13) & 1) as u8)
}
#[doc = "Create token_fields: d64"]
fn token_57(tokens: &[u8]) -> u64 {
    (((u64::from_be_bytes(tokens[0..8].try_into().unwrap()) >> 0) & 18446744073709551615) as u64)
}
#[doc = "Create token_fields: mregn fsrc f1012 ffmt"]
fn token_31(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 7) as u8)
}
#[doc = "Create token_fields: f1015"]
fn token_38(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 10) & 63) as u8)
}
#[doc = "Create token_fields: op5 frlist5 flddw mvm5"]
fn token_21(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 1) as u8)
}
#[doc = "Create token_fields: fopmode fkfactor fromoffset"]
fn token_48(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 127) as u8)
}
#[doc = "Create token_fields: mode2 op68 regdu regduw regdub regdu2 regdu2w f0608 fldoffreg"]
fn token_2(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 7) as u8)
}
#[doc = "Create token_fields: ctl"]
fn token_36(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 4095) as u16)
}
#[doc = "Create token_fields: f0615"]
fn token_41(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 1023) as u16)
}
#[doc = "Create token_fields: exponentD"]
fn token_55(tokens: &[u8]) -> u16 {
    (((u64::from_be_bytes(tokens[0..8].try_into().unwrap()) >> 52) & 2047) as u16)
}
#[doc = "Create token_fields: exponentX"]
fn token_59(tokens: &[u8]) -> u16 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 16) & 32767) as u16)
}
#[doc = "Create token_fields: fcmask aregx"]
fn token_34(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 7) as u8)
}
#[doc = "Create token_fields: op34"]
fn token_12(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 3) as u8)
}
#[doc = "Create token_fields: frlist1 mvm1"]
fn token_51(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 1) & 1) as u8)
}
#[doc = "Create token_fields: opbig bigopx"]
fn token_7(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 255) as u8)
}
#[doc = "Create token_fields: mode op35 ext_35 ext2_35"]
fn token_1(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 7) as u8)
}
#[doc = "Create token_fields: IS fsize frlist6 mvm6"]
fn token_35(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 1) as u8)
}
#[doc = "Create token_fields: f0009"]
fn token_39(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 1023) as u16)
}
#[doc = "Create token_fields: op4 fc4 frlist4 mvm4"]
fn token_20(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 1) as u8)
}
#[doc = "Create token_fields: da f1515 mvm15"]
fn token_29(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 15) & 1) as u8)
}
#[doc = "Create token_fields: op37"]
fn token_13(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 31) as u8)
}
#[doc = "Create token_fields: rwx mvm9"]
fn token_32(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 9) & 1) as u8)
}
#[doc = "Create token_fields: opx515"]
fn token_28(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 5) & 2047) as u16)
}
#[doc = "Create token_fields: regdn regdnw regdnb regan reganw reganb op02 regdc regdcw regdcb iis fc02 regdc2 regdc2w fcnt fmode fdcos fldwdreg regdr"]
fn token_3(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 7) as u8)
}
#[doc = "Create token_fields: fldoffdat"]
fn token_61(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 6) & 31) as u8)
}
#[doc = "Create token_fields: f0810"]
fn token_40(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 8) & 7) as u8)
}
#[doc = "Create token_fields: op08 f0008"]
fn token_10(tokens: &[u8]) -> u16 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 511) as u16)
}
#[doc = "Create token_fields: op38 f0308"]
fn token_14(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 63) as u8)
}
#[doc = "Create token_fields: frlist2 mvm2"]
fn token_52(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 2) & 1) as u8)
}
#[doc = "Create token_fields: mantissaX"]
fn token_60(tokens: &[u8]) -> u64 {
    (((u64::from_be_bytes(tokens[0..8].try_into().unwrap()) >> 0) & 9223372036854775807) as u64)
}
#[doc = "Create token_fields: regxdn regxdnw regxan regxanw f_reg regdq"]
fn token_30(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 7) as u8)
}
#[doc = "Create token_fields: scale"]
fn token_33(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 9) & 3) as u8)
}
#[doc = "Create token_fields: d32 bd32 od32"]
fn token_53(tokens: &[u8]) -> u32 {
    (((u32::from_be_bytes(tokens[0..4].try_into().unwrap()) >> 0) & 4294967295) as u32)
}
#[doc = "Create token_fields: op45 bdsize"]
fn token_15(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 3) as u8)
}
#[doc = "Create token_fields: op48"]
fn token_16(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 4) & 31) as u8)
}
#[doc = "Create token_fields: signD expintbitX"]
fn token_54(tokens: &[u8]) -> u8 {
    (((u64::from_be_bytes(tokens[0..8].try_into().unwrap()) >> 63) & 1) as u8)
}
#[doc = "Create token_fields: op regda regda2 fop"]
fn token_6(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 12) & 15) as u8)
}
#[doc = "Create token_fields: fldwddat"]
fn token_62(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 0) & 31) as u8)
}
#[doc = "Create token_fields: rmbit fc3 frlist3 mvm3"]
fn token_4(tokens: &[u8]) -> u8 {
    (((u16::from_be_bytes(tokens[0..2].try_into().unwrap()) >> 3) & 1) as u8)
}
#[derive(Clone, Copy, Default)]
pub struct ContextMemory(pub u16);
impl ContextMemory {
    pub fn read_eanum(&self) -> u8 {
        (((self.0.reverse_bits() >> 15) & 1) as u8)
    }
    pub fn write_eanum(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 15)) | ((value as u16 & 1) << 15)).reverse_bits();
    }
    pub fn read_pcmode(&self) -> u8 {
        (((self.0.reverse_bits() >> 14) & 1) as u8)
    }
    pub fn write_pcmode(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 14)) | ((value as u16 & 1) << 14)).reverse_bits();
    }
    pub fn read_regfan(&self) -> u8 {
        (((self.0.reverse_bits() >> 11) & 7) as u8)
    }
    pub fn write_regfan(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 11)) | ((value as u16 & 7) << 11)).reverse_bits();
    }
    pub fn read_regtfan(&self) -> u8 {
        (((self.0.reverse_bits() >> 11) & 7) as u8)
    }
    pub fn write_regtfan(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 11)) | ((value as u16 & 7) << 11)).reverse_bits();
    }
    pub fn read_savmod1(&self) -> u8 {
        (((self.0.reverse_bits() >> 8) & 7) as u8)
    }
    pub fn write_savmod1(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 8)) | ((value as u16 & 7) << 8)).reverse_bits();
    }
    pub fn read_savmod2(&self) -> u8 {
        (((self.0.reverse_bits() >> 5) & 7) as u8)
    }
    pub fn write_savmod2(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 5)) | ((value as u16 & 7) << 5)).reverse_bits();
    }
    pub fn read_regsdn(&self) -> u8 {
        (((self.0.reverse_bits() >> 2) & 7) as u8)
    }
    pub fn write_regsdn(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 2)) | ((value as u16 & 7) << 2)).reverse_bits();
    }
    pub fn read_regsdnw(&self) -> u8 {
        (((self.0.reverse_bits() >> 2) & 7) as u8)
    }
    pub fn write_regsdnw(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 2)) | ((value as u16 & 7) << 2)).reverse_bits();
    }
    pub fn read_regsdnb(&self) -> u8 {
        (((self.0.reverse_bits() >> 2) & 7) as u8)
    }
    pub fn write_regsdnb(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 2)) | ((value as u16 & 7) << 2)).reverse_bits();
    }
    pub fn read_regsan(&self) -> u8 {
        (((self.0.reverse_bits() >> 2) & 7) as u8)
    }
    pub fn write_regsan(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 2)) | ((value as u16 & 7) << 2)).reverse_bits();
    }
    pub fn read_regtsan(&self) -> u8 {
        (((self.0.reverse_bits() >> 2) & 7) as u8)
    }
    pub fn write_regtsan(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 2)) | ((value as u16 & 7) << 2)).reverse_bits();
    }
    pub fn read_regsanw(&self) -> u8 {
        (((self.0.reverse_bits() >> 2) & 7) as u8)
    }
    pub fn write_regsanw(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 2)) | ((value as u16 & 7) << 2)).reverse_bits();
    }
    pub fn read_regsanb(&self) -> u8 {
        (((self.0.reverse_bits() >> 2) & 7) as u8)
    }
    pub fn write_regsanb(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(7 << 2)) | ((value as u16 & 7) << 2)).reverse_bits();
    }
    pub fn read_extGUARD(&self) -> u8 {
        (((self.0.reverse_bits() >> 1) & 1) as u8)
    }
    pub fn write_extGUARD(&mut self, value: u8) {
        self.0 = ((self.0.reverse_bits() & !(1 << 1)) | ((value as u16 & 1) << 1)).reverse_bits();
    }
}
#[derive(Clone)]
pub struct GlobalSet {
    default: ContextMemory,
    branches: std::collections::HashMap<AddrType, ContextMemory>,
}
impl GlobalSet {
    pub fn new(default: ContextMemory) -> Self {
        Self {
            default,
            branches: std::collections::HashMap::new(),
        }
    }
    pub fn set(&mut self, address: Option<AddrType>, set: impl FnOnce(&mut ContextMemory)) {
        let Some (address) = address else { return } ;
        let entry = self
            .branches
            .entry(address)
            .or_insert_with(|| self.default.clone());
        set(entry);
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1018:1, end:1018:2))"]
#[derive(Clone, Debug)]
struct cas2_w_instructionVar0 {
    regdcw: u8,
    regdc2w: u8,
    regduw: u8,
    regdu2w: u8,
    regda: u8,
    regda2: u8,
}
impl cas2_w_instructionVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cas2.w"));
        let extend: [DisplayElement; 13usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.regdcw),
            <DisplayElement>::Literal(":"),
            meaning_2_display(self.regdc2w),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.regduw),
            <DisplayElement>::Literal(":"),
            meaning_2_display(self.regdu2w),
            <DisplayElement>::Literal(",("),
            meaning_4_display(self.regda),
            <DisplayElement>::Literal("):("),
            meaning_4_display(self.regda2),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let regdcw = token_3(tokens_current);
        let regda = token_6(tokens_current);
        let regduw = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let regdu2w = token_2(tokens_current);
        let regdc2w = token_3(tokens_current);
        let regda2 = token_6(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                regdcw,
                regdc2w,
                regduw,
                regdu2w,
                regda,
                regda2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1034:1, end:1034:2))"]
#[derive(Clone, Debug)]
struct cas2_l_instructionVar1 {
    regdc: u8,
    regdc2: u8,
    regdu: u8,
    regdu2: u8,
    regda: u8,
    regda2: u8,
}
impl cas2_l_instructionVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cas2.l"));
        let extend: [DisplayElement; 13usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.regdc),
            <DisplayElement>::Literal(":"),
            meaning_0_display(self.regdc2),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdu),
            <DisplayElement>::Literal(":"),
            meaning_0_display(self.regdu2),
            <DisplayElement>::Literal(",("),
            meaning_4_display(self.regda),
            <DisplayElement>::Literal("):("),
            meaning_4_display(self.regda2),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let regdu = token_2(tokens_current);
        let regda = token_6(tokens_current);
        let regdc = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let regdc2 = token_3(tokens_current);
        let regdu2 = token_2(tokens_current);
        let regda2 = token_6(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                regdc,
                regdc2,
                regdu,
                regdu2,
                regda,
                regda2,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1780:1, end:1780:2))"]
#[derive(Clone, Debug)]
struct pflusha_instructionVar2 {}
impl pflusha_instructionVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pflusha"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1789:1, end:1789:2))"]
#[derive(Clone, Debug)]
struct pflush_instructionVar3 {
    FCmask: TableFCmask,
    FC: TableFC,
}
impl pflush_instructionVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pflush"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FCmask
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let FCmask = if let Some((len, table)) =
            TableFCmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FC = if let Some((len, table)) =
            TableFC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FCmask, FC }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:868:1, end:868:2))"]
#[derive(Clone, Debug)]
struct andi_instructionVar4 {
    const8: Tableconst8,
}
impl andi_instructionVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.const8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",CCR")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let const8 = if let Some((len, table)) =
            Tableconst8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { const8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:869:1, end:869:2))"]
#[derive(Clone, Debug)]
struct andi_instructionVar5 {
    const16: Tableconst16,
}
impl andi_instructionVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andi"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.const16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::SR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let const16 = if let Some((len, table)) =
            Tableconst16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { const16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1797:1, end:1797:2))"]
#[derive(Clone, Debug)]
struct pmove_l_instructionVar6 {
    e2l: Tablee2l,
}
impl pmove_l_instructionVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.l"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::TC),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1798:1, end:1798:2))"]
#[derive(Clone, Debug)]
struct pmove_l_instructionVar7 {
    e2l: Tablee2l,
}
impl pmove_l_instructionVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::TC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1799:1, end:1799:2))"]
#[derive(Clone, Debug)]
struct pmovefd_l_instructionVar8 {
    e2l: Tablee2l,
}
impl pmovefd_l_instructionVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmovefd.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::TC),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1801:1, end:1801:2))"]
#[derive(Clone, Debug)]
struct pmove_d_instructionVar9 {
    e2d: Tablee2d,
}
impl pmove_d_instructionVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.d"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::SRP),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1802:1, end:1802:2))"]
#[derive(Clone, Debug)]
struct pmove_d_instructionVar10 {
    e2d: Tablee2d,
}
impl pmove_d_instructionVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.d"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::SRP),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1803:1, end:1803:2))"]
#[derive(Clone, Debug)]
struct pmovefd_d_instructionVar11 {
    e2d: Tablee2d,
}
impl pmovefd_d_instructionVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmovefd.d"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::SRP),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1805:1, end:1805:2))"]
#[derive(Clone, Debug)]
struct pmove_d_instructionVar12 {
    e2d: Tablee2d,
}
impl pmove_d_instructionVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.d"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::CRP),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1806:1, end:1806:2))"]
#[derive(Clone, Debug)]
struct pmove_d_instructionVar13 {
    e2d: Tablee2d,
}
impl pmove_d_instructionVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.d"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::CRP),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1807:1, end:1807:2))"]
#[derive(Clone, Debug)]
struct pmovefd_d_instructionVar14 {
    e2d: Tablee2d,
}
impl pmovefd_d_instructionVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmovefd.d"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::CRP),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1809:1, end:1809:2))"]
#[derive(Clone, Debug)]
struct pmove_w_instructionVar15 {
    e2w: Tablee2w,
}
impl pmove_w_instructionVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.w"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::MMUSR),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2w }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1810:1, end:1810:2))"]
#[derive(Clone, Debug)]
struct pmove_w_instructionVar16 {
    e2w: Tablee2w,
}
impl pmove_w_instructionVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::MMUSR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2w }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1812:1, end:1812:2))"]
#[derive(Clone, Debug)]
struct pmove_l_instructionVar17 {
    e2l: Tablee2l,
}
impl pmove_l_instructionVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.l"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::TT0),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1813:1, end:1813:2))"]
#[derive(Clone, Debug)]
struct pmove_l_instructionVar18 {
    e2l: Tablee2l,
}
impl pmove_l_instructionVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::TT0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1814:1, end:1814:2))"]
#[derive(Clone, Debug)]
struct pmovefd_l_instructionVar19 {
    e2l: Tablee2l,
}
impl pmovefd_l_instructionVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmovefd.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::TT0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1816:1, end:1816:2))"]
#[derive(Clone, Debug)]
struct pmove_l_instructionVar20 {
    e2l: Tablee2l,
}
impl pmove_l_instructionVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.l"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::TT1),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1817:1, end:1817:2))"]
#[derive(Clone, Debug)]
struct pmove_l_instructionVar21 {
    e2l: Tablee2l,
}
impl pmove_l_instructionVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmove.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::TT1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1818:1, end:1818:2))"]
#[derive(Clone, Debug)]
struct pmovefd_l_instructionVar22 {
    e2l: Tablee2l,
}
impl pmovefd_l_instructionVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pmovefd.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::TT1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:939:1, end:939:2))"]
#[derive(Clone, Debug)]
struct bfffo_instructionVar23 {
    f_reg: u8,
    f_wd: Tablef_wd,
    f_off: Tablef_off,
    e2l: Tablee2l,
}
impl bfffo_instructionVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bfffo"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.f_off
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(":")];
        display.extend_from_slice(&extend);
        self.f_wd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("},"),
            meaning_1_display(self.f_reg),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let f_off = if let Some((len, table)) =
            Tablef_off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_wd = if let Some((len, table)) =
            Tablef_wd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_reg = token_30(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                f_wd,
                f_off,
                e2l,
                f_reg,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:978:1, end:978:2))"]
#[derive(Clone, Debug)]
struct bra_w_instructionVar24 {
    addr16: Tableaddr16,
}
impl bra_w_instructionVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bra.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addr16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let addr16 = if let Some((len, table)) =
            Tableaddr16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:979:1, end:979:2))"]
#[derive(Clone, Debug)]
struct bra_l_instructionVar25 {
    addr32: Tableaddr32,
}
impl bra_l_instructionVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bra.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addr32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let addr32 = if let Some((len, table)) =
            Tableaddr32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:987:1, end:987:2))"]
#[derive(Clone, Debug)]
struct bsr_w_instructionVar26 {
    addr16: Tableaddr16,
}
impl bsr_w_instructionVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bsr.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addr16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let addr16 = if let Some((len, table)) =
            Tableaddr16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:988:1, end:988:2))"]
#[derive(Clone, Debug)]
struct bsr_l_instructionVar27 {
    addr32: Tableaddr32,
}
impl bsr_l_instructionVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bsr.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addr32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let addr32 = if let Some((len, table)) =
            Tableaddr32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1793:1, end:1793:2))"]
#[derive(Clone, Debug)]
struct ploadr_instructionVar28 {
    FC: TableFC,
    e2l: Tablee2l,
}
impl ploadr_instructionVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ploadr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let FC = if let Some((len, table)) =
            TableFC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FC, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1795:1, end:1795:2))"]
#[derive(Clone, Debug)]
struct ploadw_instructionVar29 {
    FC: TableFC,
    e2l: Tablee2l,
}
impl ploadw_instructionVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ploadw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let FC = if let Some((len, table)) =
            TableFC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FC, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1791:1, end:1791:2))"]
#[derive(Clone, Debug)]
struct pflush_instructionVar30 {
    FCmask: TableFCmask,
    FC: TableFC,
    e2l: Tablee2l,
}
impl pflush_instructionVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pflush"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.FCmask
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let FCmask = if let Some((len, table)) =
            TableFCmask::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FC = if let Some((len, table)) =
            TableFC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { FCmask, FC, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1107:1, end:1107:2))"]
#[derive(Clone, Debug)]
struct chk2_b_instructionVar31 {
    rreg: Tablerreg,
    e2b: Tablee2b,
}
impl chk2_b_instructionVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("chk2.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rreg, e2b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1122:1, end:1122:2))"]
#[derive(Clone, Debug)]
struct chk2_w_instructionVar32 {
    rreg: Tablerreg,
    e2w: Tablee2w,
}
impl chk2_w_instructionVar32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("chk2.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rreg, e2w }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1137:1, end:1137:2))"]
#[derive(Clone, Debug)]
struct chk2_l_instructionVar33 {
    rreg: Tablerreg,
    e2l: Tablee2l,
}
impl chk2_l_instructionVar33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("chk2.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rreg, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1152:1, end:1152:2))"]
#[derive(Clone, Debug)]
struct cmp2_b_instructionVar34 {
    rreg: Tablerreg,
    e2b: Tablee2b,
}
impl cmp2_b_instructionVar34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp2.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rreg, e2b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1165:1, end:1165:2))"]
#[derive(Clone, Debug)]
struct cmp2_w_instructionVar35 {
    rreg: Tablerreg,
    e2w: Tablee2w,
}
impl cmp2_w_instructionVar35 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp2.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rreg, e2w }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1178:1, end:1178:2))"]
#[derive(Clone, Debug)]
struct cmp2_l_instructionVar36 {
    rreg: Tablerreg,
    e2l: Tablee2l,
}
impl cmp2_l_instructionVar36 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp2.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rreg, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1286:1, end:1286:2))"]
#[derive(Clone, Debug)]
struct eori_instructionVar37 {
    d8: u8,
}
impl eori_instructionVar37 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eori"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(",CCR"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1287:1, end:1287:2))"]
#[derive(Clone, Debug)]
struct eori_instructionVar38 {
    d16: u16,
}
impl eori_instructionVar38 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eori"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::SR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1302:1, end:1302:2))"]
#[derive(Clone, Debug)]
struct illegal_instructionVar39 {}
impl illegal_instructionVar39 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("illegal"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1312:1, end:1312:2))"]
#[derive(Clone, Debug)]
struct jmp_instructionVar40 {
    addrpc16: Tableaddrpc16,
}
impl jmp_instructionVar40 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jmp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addrpc16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let addrpc16 = if let Some((len, table)) =
            Tableaddrpc16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrpc16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1313:1, end:1313:2))"]
#[derive(Clone, Debug)]
struct jmp_instructionVar41 {
    extw: Tableextw,
}
impl jmp_instructionVar41 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jmp"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1314:1, end:1314:2))"]
#[derive(Clone, Debug)]
struct jmp_instructionVar42 {
    addrd16: Tableaddrd16,
}
impl jmp_instructionVar42 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jmp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addrd16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(".w")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let addrd16 = if let Some((len, table)) =
            Tableaddrd16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrd16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1315:1, end:1315:2))"]
#[derive(Clone, Debug)]
struct jmp_instructionVar43 {
    addrd32: Tableaddrd32,
}
impl jmp_instructionVar43 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jmp"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addrd32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(".l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let addrd32 = if let Some((len, table)) =
            Tableaddrd32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrd32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1320:1, end:1320:2))"]
#[derive(Clone, Debug)]
struct jsr_instructionVar44 {
    addrpc16: Tableaddrpc16,
}
impl jsr_instructionVar44 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jsr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addrpc16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let addrpc16 = if let Some((len, table)) =
            Tableaddrpc16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrpc16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1321:1, end:1321:2))"]
#[derive(Clone, Debug)]
struct jsr_instructionVar45 {
    extw: Tableextw,
}
impl jsr_instructionVar45 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jsr"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1322:1, end:1322:2))"]
#[derive(Clone, Debug)]
struct jsr_instructionVar46 {
    addrd16: Tableaddrd16,
}
impl jsr_instructionVar46 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jsr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addrd16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(".w")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let addrd16 = if let Some((len, table)) =
            Tableaddrd16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrd16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1323:1, end:1323:2))"]
#[derive(Clone, Debug)]
struct jsr_instructionVar47 {
    addrd32: Tableaddrd32,
}
impl jsr_instructionVar47 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jsr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addrd32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(".l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let addrd32 = if let Some((len, table)) =
            Tableaddrd32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addrd32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1375:1, end:1375:2))"]
#[derive(Clone, Debug)]
struct movec_instructionVar48 {
    rreg: Tablerreg,
    ctlreg: Tablectlreg,
}
impl movec_instructionVar48 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movec"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.ctlreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ctlreg = if let Some((len, table)) =
            Tablectlreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { rreg, ctlreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1376:1, end:1376:2))"]
#[derive(Clone, Debug)]
struct movec_instructionVar49 {
    ctlreg: Tablectlreg,
    rreg: Tablerreg,
}
impl movec_instructionVar49 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movec"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ctlreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let ctlreg = if let Some((len, table)) =
            Tablectlreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ctlreg, rreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1633:1, end:1633:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar50 {
    d16: u16,
    r2mfw0: Tabler2mfw0,
}
impl movem_w_instructionVar50 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mfw0 = if let Some((len, table)) =
            Tabler2mfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw0, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1634:1, end:1634:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar51 {
    d32: u32,
    r2mfw0: Tabler2mfw0,
}
impl movem_w_instructionVar51 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mfw0 = if let Some((len, table)) =
            Tabler2mfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw0, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1639:1, end:1639:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar52 {
    d16: u16,
    r2mfl0: Tabler2mfl0,
}
impl movem_l_instructionVar52 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mfl0 = if let Some((len, table)) =
            Tabler2mfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl0, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1640:1, end:1640:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar53 {
    d32: u32,
    r2mfl0: Tabler2mfl0,
}
impl movem_l_instructionVar53 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mfl0 = if let Some((len, table)) =
            Tabler2mfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl0, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1646:1, end:1646:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar54 {
    d16: u16,
    m2rfw0: Tablem2rfw0,
}
impl movem_w_instructionVar54 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal("),"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfw0 = if let Some((len, table)) =
            Tablem2rfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw0, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1647:1, end:1647:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar55 {
    m2rfw0: Tablem2rfw0,
    extw: Tableextw,
}
impl movem_w_instructionVar55 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("),")];
        display.extend_from_slice(&extend);
        self.m2rfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfw0 = if let Some((len, table)) =
            Tablem2rfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw0, extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1648:1, end:1648:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar56 {
    d16: u16,
    m2rfw0: Tablem2rfw0,
}
impl movem_w_instructionVar56 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w,"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfw0 = if let Some((len, table)) =
            Tablem2rfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw0, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1649:1, end:1649:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar57 {
    d32: u32,
    m2rfw0: Tablem2rfw0,
}
impl movem_w_instructionVar57 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l,"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfw0 = if let Some((len, table)) =
            Tablem2rfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw0, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1654:1, end:1654:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar58 {
    d16: u16,
    m2rfl0: Tablem2rfl0,
}
impl movem_l_instructionVar58 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal("),"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfl0 = if let Some((len, table)) =
            Tablem2rfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl0, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1655:1, end:1655:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar59 {
    m2rfl0: Tablem2rfl0,
    extw: Tableextw,
}
impl movem_l_instructionVar59 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("),")];
        display.extend_from_slice(&extend);
        self.m2rfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfl0 = if let Some((len, table)) =
            Tablem2rfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl0, extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1656:1, end:1656:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar60 {
    d16: u16,
    m2rfl0: Tablem2rfl0,
}
impl movem_l_instructionVar60 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w,"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfl0 = if let Some((len, table)) =
            Tablem2rfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl0, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1657:1, end:1657:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar61 {
    d32: u32,
    m2rfl0: Tablem2rfl0,
}
impl movem_l_instructionVar61 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l,"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfl0 = if let Some((len, table)) =
            Tablem2rfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl0, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1736:1, end:1736:2))"]
#[derive(Clone, Debug)]
struct nop_instructionVar62 {}
impl nop_instructionVar62 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nop"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1753:1, end:1753:2))"]
#[derive(Clone, Debug)]
struct ori_instructionVar63 {
    d8: u8,
}
impl ori_instructionVar63 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ori"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(",CCR"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1754:1, end:1754:2))"]
#[derive(Clone, Debug)]
struct ori_instructionVar64 {
    d16: u16,
}
impl ori_instructionVar64 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ori"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::SR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1843:1, end:1843:2))"]
#[derive(Clone, Debug)]
struct ptestr_instructionVar65 {
    FC: TableFC,
    ptestLevel: TableptestLevel,
    e2l: Tablee2l,
}
impl ptestr_instructionVar65 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ptestr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ptestLevel
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let ptestLevel = if let Some((len, table)) =
            TableptestLevel::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FC = if let Some((len, table)) =
            TableFC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FC,
                ptestLevel,
                e2l,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1846:1, end:1846:2))"]
#[derive(Clone, Debug)]
struct ptestw_instructionVar66 {
    ptestLevel: TableptestLevel,
    FC: TableFC,
    e2l: Tablee2l,
}
impl ptestw_instructionVar66 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ptestw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ptestLevel
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let ptestLevel = if let Some((len, table)) =
            TableptestLevel::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FC = if let Some((len, table)) =
            TableFC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ptestLevel,
                FC,
                e2l,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1844:1, end:1844:2))"]
#[derive(Clone, Debug)]
struct ptestr_instructionVar67 {
    aregx: u8,
    ptestLevel: TableptestLevel,
    FC: TableFC,
    e2l: Tablee2l,
}
impl ptestr_instructionVar67 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ptestr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ptestLevel
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.aregx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let ptestLevel = if let Some((len, table)) =
            TableptestLevel::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FC = if let Some((len, table)) =
            TableFC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let aregx = token_34(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ptestLevel,
                FC,
                e2l,
                aregx,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1847:1, end:1847:2))"]
#[derive(Clone, Debug)]
struct ptestw_instructionVar68 {
    aregx: u8,
    FC: TableFC,
    ptestLevel: TableptestLevel,
    e2l: Tablee2l,
}
impl ptestw_instructionVar68 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ptestw"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.FC
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ptestLevel
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.aregx),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let ptestLevel = if let Some((len, table)) =
            TableptestLevel::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let FC = if let Some((len, table)) =
            TableFC::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let aregx = token_34(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                FC,
                ptestLevel,
                e2l,
                aregx,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1866:1, end:1866:2))"]
#[derive(Clone, Debug)]
struct reset_instructionVar69 {}
impl reset_instructionVar69 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("reset"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1920:1, end:1920:2))"]
#[derive(Clone, Debug)]
struct rtd_instructionVar70 {
    d16: u16,
}
impl rtd_instructionVar70 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rtd"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1921:1, end:1921:2))"]
#[derive(Clone, Debug)]
struct rte_instructionVar71 {}
impl rte_instructionVar71 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rte"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1926:1, end:1926:2))"]
#[derive(Clone, Debug)]
struct rtr_instructionVar72 {}
impl rtr_instructionVar72 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rtr"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1928:1, end:1928:2))"]
#[derive(Clone, Debug)]
struct rts_instructionVar73 {}
impl rts_instructionVar73 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rts"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1939:1, end:1939:2))"]
#[derive(Clone, Debug)]
struct stop_instructionVar74 {
    d16: u16,
}
impl stop_instructionVar74 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("stop"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2006:1, end:2006:2))"]
#[derive(Clone, Debug)]
struct trapv_instructionVar75 {}
impl trapv_instructionVar75 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trapv"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:915:1, end:915:2))"]
#[derive(Clone, Debug)]
struct bchg_l_instructionVar76 {
    d8: u8,
    regdn: u8,
}
impl bchg_l_instructionVar76 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bchg.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:920:1, end:920:2))"]
#[derive(Clone, Debug)]
struct bclr_l_instructionVar77 {
    d8: u8,
    regdn: u8,
}
impl bclr_l_instructionVar77 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bclr.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:922:1, end:922:2))"]
#[derive(Clone, Debug)]
struct bfchg_instructionVar78 {
    f_wd: Tablef_wd,
    f_off: Tablef_off,
    e2l: Tablee2l,
}
impl bfchg_instructionVar78 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bfchg"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.f_off
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(":")];
        display.extend_from_slice(&extend);
        self.f_wd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let f_off = if let Some((len, table)) =
            Tablef_off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_wd = if let Some((len, table)) =
            Tablef_wd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f_wd, f_off, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:926:1, end:926:2))"]
#[derive(Clone, Debug)]
struct bfclr_instructionVar79 {
    f_off: Tablef_off,
    f_wd: Tablef_wd,
    e2l: Tablee2l,
}
impl bfclr_instructionVar79 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bfclr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.f_off
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(":")];
        display.extend_from_slice(&extend);
        self.f_wd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let f_off = if let Some((len, table)) =
            Tablef_off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_wd = if let Some((len, table)) =
            Tablef_wd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f_off, f_wd, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:930:1, end:930:2))"]
#[derive(Clone, Debug)]
struct bfexts_instructionVar80 {
    f_reg: u8,
    f_wd: Tablef_wd,
    f_off: Tablef_off,
    e2l: Tablee2l,
}
impl bfexts_instructionVar80 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bfexts"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.f_off
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(":")];
        display.extend_from_slice(&extend);
        self.f_wd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("},"),
            meaning_1_display(self.f_reg),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let f_off = if let Some((len, table)) =
            Tablef_off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_wd = if let Some((len, table)) =
            Tablef_wd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_reg = token_30(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                f_wd,
                f_off,
                e2l,
                f_reg,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:935:1, end:935:2))"]
#[derive(Clone, Debug)]
struct bfextu_instructionVar81 {
    f_reg: u8,
    f_off: Tablef_off,
    f_wd: Tablef_wd,
    e2l: Tablee2l,
}
impl bfextu_instructionVar81 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bfextu"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.f_off
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(":")];
        display.extend_from_slice(&extend);
        self.f_wd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("},"),
            meaning_1_display(self.f_reg),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let f_off = if let Some((len, table)) =
            Tablef_off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_wd = if let Some((len, table)) =
            Tablef_wd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_reg = token_30(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                f_off,
                f_wd,
                e2l,
                f_reg,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:959:1, end:959:2))"]
#[derive(Clone, Debug)]
struct bfffo_instructionVar82 {
    f_reg: u8,
    f_off: Tablef_off,
    f_wd: Tablef_wd,
    e2l: Tablee2l,
}
impl bfffo_instructionVar82 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bfffo"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.f_off
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(":")];
        display.extend_from_slice(&extend);
        self.f_wd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("},"),
            meaning_1_display(self.f_reg),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let f_off = if let Some((len, table)) =
            Tablef_off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_wd = if let Some((len, table)) =
            Tablef_wd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_reg = token_30(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                f_off,
                f_wd,
                e2l,
                f_reg,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:963:1, end:963:2))"]
#[derive(Clone, Debug)]
struct bfins_instructionVar83 {
    f_reg: u8,
    f_wd: Tablef_wd,
    f_off: Tablef_off,
    e2l: Tablee2l,
}
impl bfins_instructionVar83 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bfins"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_1_display(self.f_reg),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.f_off
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(":")];
        display.extend_from_slice(&extend);
        self.f_wd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let f_off = if let Some((len, table)) =
            Tablef_off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_wd = if let Some((len, table)) =
            Tablef_wd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_reg = token_30(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                f_wd,
                f_off,
                e2l,
                f_reg,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:967:1, end:967:2))"]
#[derive(Clone, Debug)]
struct bfset_instructionVar84 {
    f_off: Tablef_off,
    f_wd: Tablef_wd,
    e2l: Tablee2l,
}
impl bfset_instructionVar84 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bfset"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.f_off
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(":")];
        display.extend_from_slice(&extend);
        self.f_wd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let f_off = if let Some((len, table)) =
            Tablef_off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_wd = if let Some((len, table)) =
            Tablef_wd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f_off, f_wd, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:971:1, end:971:2))"]
#[derive(Clone, Debug)]
struct bftst_instructionVar85 {
    f_off: Tablef_off,
    f_wd: Tablef_wd,
    e2l: Tablee2l,
}
impl bftst_instructionVar85 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bftst"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("{")];
        display.extend_from_slice(&extend);
        self.f_off
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(":")];
        display.extend_from_slice(&extend);
        self.f_wd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let f_off = if let Some((len, table)) =
            Tablef_off::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let f_wd = if let Some((len, table)) =
            Tablef_wd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { f_off, f_wd, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:975:1, end:975:2))"]
#[derive(Clone, Debug)]
struct bkpt_instructionVar86 {
    op02: u8,
}
impl bkpt_instructionVar86 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bkpt"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.op02 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let op02 = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { op02 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:984:1, end:984:2))"]
#[derive(Clone, Debug)]
struct bset_l_instructionVar87 {
    d8: u8,
    regdn: u8,
}
impl bset_l_instructionVar87 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bset.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:993:1, end:993:2))"]
#[derive(Clone, Debug)]
struct btst_l_instructionVar88 {
    d8: u8,
    regdn: u8,
}
impl btst_l_instructionVar88 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("btst.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1015:1, end:1015:2))"]
#[derive(Clone, Debug)]
struct callm_instructionVar89 {
    d8: u8,
    e2l: Tablee2l,
}
impl callm_instructionVar89 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("callm"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1294:1, end:1294:2))"]
#[derive(Clone, Debug)]
struct ext_w_instructionVar90 {
    regdnw: u8,
}
impl ext_w_instructionVar90 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ext.w"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.regdnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1295:1, end:1295:2))"]
#[derive(Clone, Debug)]
struct ext_l_instructionVar91 {
    regdn: u8,
}
impl ext_l_instructionVar91 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ext.l"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1296:1, end:1296:2))"]
#[derive(Clone, Debug)]
struct extb_l_instructionVar92 {
    regdn: u8,
}
impl extb_l_instructionVar92 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("extb.l"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1309:1, end:1309:2))"]
#[derive(Clone, Debug)]
struct jmp_instructionVar93 {
    regan: u8,
}
impl jmp_instructionVar93 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jmp"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1310:1, end:1310:2))"]
#[derive(Clone, Debug)]
struct jmp_instructionVar94 {
    d16: u16,
    regan: u8,
}
impl jmp_instructionVar94 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jmp"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1311:1, end:1311:2))"]
#[derive(Clone, Debug)]
struct jmp_instructionVar95 {
    regan: u8,
    extw: Tableextw,
}
impl jmp_instructionVar95 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jmp"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1317:1, end:1317:2))"]
#[derive(Clone, Debug)]
struct jsr_instructionVar96 {
    regan: u8,
}
impl jsr_instructionVar96 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jsr"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1318:1, end:1318:2))"]
#[derive(Clone, Debug)]
struct jsr_instructionVar97 {
    d16: u16,
    regan: u8,
}
impl jsr_instructionVar97 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jsr"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1319:1, end:1319:2))"]
#[derive(Clone, Debug)]
struct jsr_instructionVar98 {
    regan: u8,
    extw: Tableextw,
}
impl jsr_instructionVar98 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("jsr"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1327:1, end:1327:2))"]
#[derive(Clone, Debug)]
struct link_w_instructionVar99 {
    regan: u8,
    d16: u16,
}
impl link_w_instructionVar99 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("link.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1328:1, end:1328:2))"]
#[derive(Clone, Debug)]
struct link_l_instructionVar100 {
    regan: u8,
    d32: u32,
}
impl link_l_instructionVar100 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("link.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1369:1, end:1369:2))"]
#[derive(Clone, Debug)]
struct move_instructionVar101 {
    regan: u8,
}
impl move_instructionVar101 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::USP),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1370:1, end:1370:2))"]
#[derive(Clone, Debug)]
struct move_instructionVar102 {
    regan: u8,
}
impl move_instructionVar102 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::USP),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1629:1, end:1629:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar103 {
    regan: u8,
    r2mfw0: Tabler2mfw0,
}
impl movem_w_instructionVar103 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mfw0 = if let Some((len, table)) =
            Tabler2mfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw0, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1630:1, end:1630:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar104 {
    regan: u8,
    r2mbw0: Tabler2mbw0,
}
impl movem_w_instructionVar104 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mbw0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",-("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mbw0 = if let Some((len, table)) =
            Tabler2mbw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw0, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1631:1, end:1631:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar105 {
    d16: u16,
    regan: u8,
    r2mfw0: Tabler2mfw0,
}
impl movem_w_instructionVar105 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(",("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mfw0 = if let Some((len, table)) =
            Tabler2mfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw0, d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1632:1, end:1632:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar106 {
    regan: u8,
    r2mfw0: Tabler2mfw0,
    extw: Tableextw,
}
impl movem_w_instructionVar106 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mfw0 = if let Some((len, table)) =
            Tabler2mfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                r2mfw0,
                extw,
                regan,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1635:1, end:1635:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar107 {
    regan: u8,
    r2mfl0: Tabler2mfl0,
}
impl movem_l_instructionVar107 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mfl0 = if let Some((len, table)) =
            Tabler2mfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl0, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1636:1, end:1636:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar108 {
    regan: u8,
    r2mbl0: Tabler2mbl0,
}
impl movem_l_instructionVar108 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mbl0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(",-("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mbl0 = if let Some((len, table)) =
            Tabler2mbl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl0, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1637:1, end:1637:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar109 {
    d16: u16,
    regan: u8,
    r2mfl0: Tabler2mfl0,
}
impl movem_l_instructionVar109 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(",("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mfl0 = if let Some((len, table)) =
            Tabler2mfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl0, d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1638:1, end:1638:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar110 {
    regan: u8,
    r2mfl0: Tabler2mfl0,
    extw: Tableextw,
}
impl movem_l_instructionVar110 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.r2mfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let r2mfl0 = if let Some((len, table)) =
            Tabler2mfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                r2mfl0,
                extw,
                regan,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1642:1, end:1642:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar111 {
    regan: u8,
    m2rfw0: Tablem2rfw0,
}
impl movem_w_instructionVar111 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal("),"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfw0 = if let Some((len, table)) =
            Tablem2rfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw0, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1643:1, end:1643:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar112 {
    regan: u8,
    m2rfw0: Tablem2rfw0,
}
impl movem_w_instructionVar112 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")+,"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfw0 = if let Some((len, table)) =
            Tablem2rfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw0, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1644:1, end:1644:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar113 {
    d16: u16,
    regan: u8,
    m2rfw0: Tablem2rfw0,
}
impl movem_w_instructionVar113 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal("),"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfw0 = if let Some((len, table)) =
            Tablem2rfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw0, d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1645:1, end:1645:2))"]
#[derive(Clone, Debug)]
struct movem_w_instructionVar114 {
    regan: u8,
    m2rfw0: Tablem2rfw0,
    extw: Tableextw,
}
impl movem_w_instructionVar114 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.w"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("),")];
        display.extend_from_slice(&extend);
        self.m2rfw0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfw0 = if let Some((len, table)) =
            Tablem2rfw0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                m2rfw0,
                extw,
                regan,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1650:1, end:1650:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar115 {
    regan: u8,
    m2rfl0: Tablem2rfl0,
}
impl movem_l_instructionVar115 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal("),"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfl0 = if let Some((len, table)) =
            Tablem2rfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl0, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1651:1, end:1651:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar116 {
    regan: u8,
    m2rfl0: Tablem2rfl0,
}
impl movem_l_instructionVar116 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")+,"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfl0 = if let Some((len, table)) =
            Tablem2rfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl0, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1652:1, end:1652:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar117 {
    d16: u16,
    regan: u8,
    m2rfl0: Tablem2rfl0,
}
impl movem_l_instructionVar117 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal("),"),
        ];
        display.extend_from_slice(&extend);
        self.m2rfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfl0 = if let Some((len, table)) =
            Tablem2rfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl0, d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1653:1, end:1653:2))"]
#[derive(Clone, Debug)]
struct movem_l_instructionVar118 {
    regan: u8,
    m2rfl0: Tablem2rfl0,
    extw: Tableextw,
}
impl movem_l_instructionVar118 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movem.l"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
        ];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("),")];
        display.extend_from_slice(&extend);
        self.m2rfl0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2rfl0 = if let Some((len, table)) =
            Tablem2rfl0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                m2rfl0,
                extw,
                regan,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1767:1, end:1767:2))"]
#[derive(Clone, Debug)]
struct pea_instructionVar119 {
    eaptr: Tableeaptr,
}
impl pea_instructionVar119 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pea"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaptr
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 72 {
                return None;
            }
            if token_18(tokens) != 1 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 2 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 5 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 6 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 7 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaptr = if let Some((len, table)) =
            Tableeaptr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaptr }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1923:1, end:1923:2))"]
#[derive(Clone, Debug)]
struct rtm_instructionVar120 {
    regdn: u8,
}
impl rtm_instructionVar120 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rtm"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1924:1, end:1924:2))"]
#[derive(Clone, Debug)]
struct rtm_instructionVar121 {
    regan: u8,
}
impl rtm_instructionVar121 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rtm"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.regan),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1996:1, end:1996:2))"]
#[derive(Clone, Debug)]
struct swap_instructionVar122 {
    regdn: u8,
}
impl swap_instructionVar122 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("swap"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2016:1, end:2016:2))"]
#[derive(Clone, Debug)]
struct unlk_instructionVar123 {
    regan: u8,
}
impl unlk_instructionVar123 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("unlk"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.regan),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2559:1, end:2559:2))"]
#[derive(Clone, Debug)]
struct fnop_instructionVar124 {}
impl fnop_instructionVar124 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fnop"));
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2103:1, end:2103:2))"]
#[derive(Clone, Debug)]
struct fabs_instructionVar125 {
    fsrc: u8,
    fdst: u8,
}
impl fabs_instructionVar125 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fabs"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2123:1, end:2123:2))"]
#[derive(Clone, Debug)]
struct facos_instructionVar126 {
    fsrc: u8,
    fdst: u8,
}
impl facos_instructionVar126 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("facos"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2131:1, end:2131:2))"]
#[derive(Clone, Debug)]
struct fadd_instructionVar127 {
    fsrc: u8,
    fdst: u8,
}
impl fadd_instructionVar127 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fadd"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2151:1, end:2151:2))"]
#[derive(Clone, Debug)]
struct fasin_instructionVar128 {
    fsrc: u8,
    fdst: u8,
}
impl fasin_instructionVar128 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fasin"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2156:1, end:2156:2))"]
#[derive(Clone, Debug)]
struct fatan_instructionVar129 {
    fsrc: u8,
    fdst: u8,
}
impl fatan_instructionVar129 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fatan"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2161:1, end:2161:2))"]
#[derive(Clone, Debug)]
struct fatanh_instructionVar130 {
    fsrc: u8,
    fdst: u8,
}
impl fatanh_instructionVar130 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fatanh"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2184:1, end:2184:2))"]
#[derive(Clone, Debug)]
struct fcmp_instructionVar131 {
    fsrc: u8,
    fdst: u8,
}
impl fcmp_instructionVar131 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmp"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2190:1, end:2190:2))"]
#[derive(Clone, Debug)]
struct fcos_instructionVar132 {
    fsrc: u8,
    fdst: u8,
}
impl fcos_instructionVar132 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcos"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2195:1, end:2195:2))"]
#[derive(Clone, Debug)]
struct fcosh_instructionVar133 {
    fsrc: u8,
    fdst: u8,
}
impl fcosh_instructionVar133 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcosh"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2676:1, end:2676:2))"]
#[derive(Clone, Debug)]
struct ftrap_instructionVar134 {
    fcc: Tablefcc,
    const16: Tableconst16,
}
impl ftrap_instructionVar134 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftrap"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.const16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let const16 = if let Some((len, table)) =
            Tableconst16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc, const16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2677:1, end:2677:2))"]
#[derive(Clone, Debug)]
struct ftrap_instructionVar135 {
    fcc: Tablefcc,
    const32: Tableconst32,
}
impl ftrap_instructionVar135 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftrap"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.const32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let const32 = if let Some((len, table)) =
            Tableconst32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc, const32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2678:1, end:2678:2))"]
#[derive(Clone, Debug)]
struct ftrap_instructionVar136 {
    fcc: Tablefcc,
}
impl ftrap_instructionVar136 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftrap"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2197:1, end:2197:2))"]
#[derive(Clone, Debug)]
struct fdb_instructionVar137 {
    fcnt: u8,
    fcc: Tablefcc,
    addr16: Tableaddr16,
}
impl fdb_instructionVar137 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdb"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_1_display(self.fcnt),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.addr16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fcnt = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let addr16 = if let Some((len, table)) =
            Tableaddr16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc, addr16, fcnt }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2210:1, end:2210:2))"]
#[derive(Clone, Debug)]
struct fdiv_instructionVar138 {
    fsrc: u8,
    fdst: u8,
}
impl fdiv_instructionVar138 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdiv"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2230:1, end:2230:2))"]
#[derive(Clone, Debug)]
struct fetox_instructionVar139 {
    fsrc: u8,
    fdst: u8,
}
impl fetox_instructionVar139 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fetox"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2235:1, end:2235:2))"]
#[derive(Clone, Debug)]
struct fetoxm1_instructionVar140 {
    fsrc: u8,
    fdst: u8,
}
impl fetoxm1_instructionVar140 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fetoxm1"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2240:1, end:2240:2))"]
#[derive(Clone, Debug)]
struct fgetexp_instructionVar141 {
    fsrc: u8,
    fdst: u8,
}
impl fgetexp_instructionVar141 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fgetexp"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2245:1, end:2245:2))"]
#[derive(Clone, Debug)]
struct fgetman_instructionVar142 {
    fsrc: u8,
    fdst: u8,
}
impl fgetman_instructionVar142 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fgetman"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2250:1, end:2250:2))"]
#[derive(Clone, Debug)]
struct fint_instructionVar143 {
    fsrc: u8,
    fdst: u8,
}
impl fint_instructionVar143 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fint"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2255:1, end:2255:2))"]
#[derive(Clone, Debug)]
struct fintrz_instructionVar144 {
    fsrc: u8,
    fdst: u8,
}
impl fintrz_instructionVar144 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fintrz"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2260:1, end:2260:2))"]
#[derive(Clone, Debug)]
struct flog10_instructionVar145 {
    fsrc: u8,
    fdst: u8,
}
impl flog10_instructionVar145 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flog10"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2265:1, end:2265:2))"]
#[derive(Clone, Debug)]
struct flog2_instructionVar146 {
    fsrc: u8,
    fdst: u8,
}
impl flog2_instructionVar146 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flog2"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2270:1, end:2270:2))"]
#[derive(Clone, Debug)]
struct flogn_instructionVar147 {
    fsrc: u8,
    fdst: u8,
}
impl flogn_instructionVar147 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flogn"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2275:1, end:2275:2))"]
#[derive(Clone, Debug)]
struct flognp1_instructionVar148 {
    fsrc: u8,
    fdst: u8,
}
impl flognp1_instructionVar148 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flognp1"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2280:1, end:2280:2))"]
#[derive(Clone, Debug)]
struct fmod_instructionVar149 {
    fsrc: u8,
    fdst: u8,
}
impl fmod_instructionVar149 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmod"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2306:1, end:2306:2))"]
#[derive(Clone, Debug)]
struct fmove_instructionVar150 {
    fsrc: u8,
    fdst: u8,
}
impl fmove_instructionVar150 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2374:1, end:2374:2))"]
#[derive(Clone, Debug)]
struct fmovecr_x_instructionVar151 {
    fromoffset: u8,
    fdst: u8,
    romconst: Tableromconst,
}
impl fmovecr_x_instructionVar151 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovecr.x"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.fromoffset as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let romconst = if let Some((len, table)) =
            Tableromconst::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        let fromoffset = token_48(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                romconst,
                fromoffset,
                fdst,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2455:1, end:2455:2))"]
#[derive(Clone, Debug)]
struct fmovem_x_instructionVar152 {
    fp2mF0: Tablefp2mF0,
    e2x: Tablee2x,
}
impl fmovem_x_instructionVar152 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.x"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.fp2mF0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c65 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c65(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fp2mF0 = if let Some((len, table)) =
            Tablefp2mF0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF0, e2x }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2461:1, end:2461:2))"]
#[derive(Clone, Debug)]
struct fmovem_x_instructionVar153 {
    fp2mF0: Tablefp2mF0,
    e2x: Tablee2x,
}
impl fmovem_x_instructionVar153 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.x"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.fp2mF0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fp2mF0 = if let Some((len, table)) =
            Tablefp2mF0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF0, e2x }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2466:1, end:2466:2))"]
#[derive(Clone, Debug)]
struct fmovem_x_instructionVar154 {
    fp2mR0: Tablefp2mR0,
    e2x: Tablee2x,
}
impl fmovem_x_instructionVar154 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.x"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.fp2mR0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fp2mR0 = if let Some((len, table)) =
            Tablefp2mR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR0, e2x }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2471:1, end:2471:2))"]
#[derive(Clone, Debug)]
struct fmovem_x_instructionVar155 {
    m2fpF0: Tablem2fpF0,
    e2x: Tablee2x,
}
impl fmovem_x_instructionVar155 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.x"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2fpF0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c68 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c68(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2fpF0 = if let Some((len, table)) =
            Tablem2fpF0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF0, e2x }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2477:1, end:2477:2))"]
#[derive(Clone, Debug)]
struct fmovem_x_instructionVar156 {
    m2fpF0: Tablem2fpF0,
    e2x: Tablee2x,
}
impl fmovem_x_instructionVar156 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.x"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2fpF0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2fpF0 = if let Some((len, table)) =
            Tablem2fpF0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF0, e2x }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2483:1, end:2483:2))"]
#[derive(Clone, Debug)]
struct fmovem_x_instructionVar157 {
    m2fpR0: Tablem2fpR0,
    e2x: Tablee2x,
}
impl fmovem_x_instructionVar157 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.x"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2fpR0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2fpR0 = if let Some((len, table)) =
            Tablem2fpR0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR0, e2x }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2488:1, end:2488:2))"]
#[derive(Clone, Debug)]
struct fmovem_x_instructionVar158 {
    fldynreg: u8,
    e2l: Tablee2l,
}
impl fmovem_x_instructionVar158 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.x"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_1_display(self.fldynreg),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fldynreg = token_49(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fldynreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2489:1, end:2489:2))"]
#[derive(Clone, Debug)]
struct fmovem_x_instructionVar159 {
    fldynreg: u8,
    e2l: Tablee2l,
}
impl fmovem_x_instructionVar159 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.x"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_1_display(self.fldynreg),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fldynreg = token_49(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fldynreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2491:1, end:2491:2))"]
#[derive(Clone, Debug)]
struct fmovem_x_instructionVar160 {
    fldynreg: u8,
    e2l: Tablee2l,
}
impl fmovem_x_instructionVar160 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.x"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_1_display(self.fldynreg),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 5 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                if token_1(tokens_param) == 7 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fldynreg = token_49(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fldynreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2492:1, end:2492:2))"]
#[derive(Clone, Debug)]
struct fmovem_x_instructionVar161 {
    fldynreg: u8,
    e2l: Tablee2l,
}
impl fmovem_x_instructionVar161 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.x"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_1_display(self.fldynreg),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fldynreg = token_49(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fldynreg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2519:1, end:2519:2))"]
#[derive(Clone, Debug)]
struct fmul_instructionVar162 {
    fsrc: u8,
    fdst: u8,
}
impl fmul_instructionVar162 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2542:1, end:2542:2))"]
#[derive(Clone, Debug)]
struct fneg_instructionVar163 {
    fsrc: u8,
    fdst: u8,
}
impl fneg_instructionVar163 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fneg"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2564:1, end:2564:2))"]
#[derive(Clone, Debug)]
struct frem_instructionVar164 {
    fsrc: u8,
    fdst: u8,
}
impl frem_instructionVar164 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("frem"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2573:1, end:2573:2))"]
#[derive(Clone, Debug)]
struct fscale_instructionVar165 {
    fsrc: u8,
    fdst: u8,
}
impl fscale_instructionVar165 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fscale"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2584:1, end:2584:2))"]
#[derive(Clone, Debug)]
struct fsgldiv_instructionVar166 {
    fsrc: u8,
    fdst: u8,
}
impl fsgldiv_instructionVar166 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsgldiv"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2598:1, end:2598:2))"]
#[derive(Clone, Debug)]
struct fsglmul_instructionVar167 {
    fsrc: u8,
    fdst: u8,
}
impl fsglmul_instructionVar167 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsglmul"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2603:1, end:2603:2))"]
#[derive(Clone, Debug)]
struct fsin_instructionVar168 {
    fsrc: u8,
    fdst: u8,
}
impl fsin_instructionVar168 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsin"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2613:1, end:2613:2))"]
#[derive(Clone, Debug)]
struct fsinh_instructionVar169 {
    fsrc: u8,
    fdst: u8,
}
impl fsinh_instructionVar169 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsinh"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2621:1, end:2621:2))"]
#[derive(Clone, Debug)]
struct fsqrt_x_instructionVar170 {
    fsrc: u8,
    fdst: u8,
}
impl fsqrt_x_instructionVar170 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrt.x"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2644:1, end:2644:2))"]
#[derive(Clone, Debug)]
struct fsub_x_instructionVar171 {
    fsrc: u8,
    fdst: u8,
}
impl fsub_x_instructionVar171 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsub.x"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2664:1, end:2664:2))"]
#[derive(Clone, Debug)]
struct ftan_x_instructionVar172 {
    fsrc: u8,
    fdst: u8,
}
impl ftan_x_instructionVar172 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftan.x"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2669:1, end:2669:2))"]
#[derive(Clone, Debug)]
struct ftanh_x_instructionVar173 {
    fsrc: u8,
    fdst: u8,
}
impl ftanh_x_instructionVar173 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftanh.x"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2674:1, end:2674:2))"]
#[derive(Clone, Debug)]
struct ftentox_x_instructionVar174 {
    fsrc: u8,
    fdst: u8,
}
impl ftentox_x_instructionVar174 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftentox.x"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2683:1, end:2683:2))"]
#[derive(Clone, Debug)]
struct ftst_x_instructionVar175 {
    fsrc: u8,
}
impl ftst_x_instructionVar175 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftst.x"));
        let extend: [DisplayElement; 2usize] =
            [<DisplayElement>::Literal(" "), meaning_8_display(self.fsrc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fsrc = token_31(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2688:1, end:2688:2))"]
#[derive(Clone, Debug)]
struct ftwotox_x_instructionVar176 {
    fsrc: u8,
    fdst: u8,
}
impl ftwotox_x_instructionVar176 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftwotox.x"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fsrc = token_31(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2608:1, end:2608:2))"]
#[derive(Clone, Debug)]
struct fsincos_x_instructionVar177 {
    fsrc: u8,
    fdcos: u8,
    fdsin: u8,
}
impl fsincos_x_instructionVar177 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsincos.x"));
        let extend: [DisplayElement; 8usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fsrc),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdcos),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdsin),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdcos = token_3(tokens_current);
        let fsrc = token_31(tokens_current);
        let fdsin = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fsrc, fdcos, fdsin }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:847:1, end:847:2))"]
#[derive(Clone, Debug)]
struct addq_w_instructionVar178 {
    quick: u8,
    regan: u8,
}
impl addq_w_instructionVar178 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addq.w"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let quick = token_5(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { quick, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:848:1, end:848:2))"]
#[derive(Clone, Debug)]
struct addq_l_instructionVar179 {
    quick: u8,
    regan: u8,
}
impl addq_l_instructionVar179 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addq.l"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let quick = token_5(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { quick, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:914:1, end:914:2))"]
#[derive(Clone, Debug)]
struct bchg_l_instructionVar180 {
    reg9dn: u8,
    regdn: u8,
}
impl bchg_l_instructionVar180 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bchg.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dn = token_5(tokens_current);
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dn, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:919:1, end:919:2))"]
#[derive(Clone, Debug)]
struct bclr_l_instructionVar181 {
    reg9dn: u8,
    regdn: u8,
}
impl bclr_l_instructionVar181 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bclr.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dn = token_5(tokens_current);
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dn, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:983:1, end:983:2))"]
#[derive(Clone, Debug)]
struct bset_l_instructionVar182 {
    reg9dn: u8,
    regdn: u8,
}
impl bset_l_instructionVar182 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bset.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        let reg9dn = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dn, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:992:1, end:992:2))"]
#[derive(Clone, Debug)]
struct btst_l_instructionVar183 {
    reg9dn: u8,
    regdn: u8,
}
impl btst_l_instructionVar183 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("btst.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dn = token_5(tokens_current);
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dn, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1228:1, end:1228:2))"]
#[derive(Clone, Debug)]
struct cmpm_b_instructionVar184 {
    regan: u8,
    reg9an: u8,
}
impl cmpm_b_instructionVar184 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpm.b"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")+,("),
            meaning_5_display(self.reg9an),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9an = token_5(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1230:1, end:1230:2))"]
#[derive(Clone, Debug)]
struct cmpm_w_instructionVar185 {
    regan: u8,
    reg9an: u8,
}
impl cmpm_w_instructionVar185 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpm.w"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")+,("),
            meaning_5_display(self.reg9an),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9an = token_5(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1232:1, end:1232:2))"]
#[derive(Clone, Debug)]
struct cmpm_l_instructionVar186 {
    regan: u8,
    reg9an: u8,
}
impl cmpm_l_instructionVar186 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpm.l"));
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")+,("),
            meaning_5_display(self.reg9an),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        let reg9an = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1290:1, end:1290:2))"]
#[derive(Clone, Debug)]
struct exg_instructionVar187 {
    reg9dn: u8,
    regdn: u8,
}
impl exg_instructionVar187 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("exg"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        let reg9dn = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dn, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1291:1, end:1291:2))"]
#[derive(Clone, Debug)]
struct exg_instructionVar188 {
    reg9an: u8,
    regan: u8,
}
impl exg_instructionVar188 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("exg"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_5_display(self.reg9an),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        let reg9an = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9an, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1292:1, end:1292:2))"]
#[derive(Clone, Debug)]
struct exg_instructionVar189 {
    reg9dn: u8,
    regan: u8,
}
impl exg_instructionVar189 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("exg"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dn = token_5(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dn, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1659:1, end:1659:2))"]
#[derive(Clone, Debug)]
struct movep_w_instructionVar190 {
    d16: u16,
    regan: u8,
    reg9dnw: u8,
}
impl movep_w_instructionVar190 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movep.w"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal("),"),
            meaning_2_display(self.reg9dnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dnw = token_5(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                d16,
                regan,
                reg9dnw,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1660:1, end:1660:2))"]
#[derive(Clone, Debug)]
struct movep_l_instructionVar191 {
    d16: u16,
    regan: u8,
    reg9dn: u8,
}
impl movep_l_instructionVar191 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movep.l"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal("),"),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dn = token_5(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16, regan, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1661:1, end:1661:2))"]
#[derive(Clone, Debug)]
struct movep_w_instructionVar192 {
    reg9dnw: u8,
    d16: u16,
    regan: u8,
}
impl movep_w_instructionVar192 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movep.w"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.reg9dnw),
            <DisplayElement>::Literal(",("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        let reg9dnw = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                reg9dnw,
                d16,
                regan,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1662:1, end:1662:2))"]
#[derive(Clone, Debug)]
struct movep_l_instructionVar193 {
    reg9dn: u8,
    d16: u16,
    regan: u8,
}
impl movep_l_instructionVar193 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movep.l"));
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(",("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dn = token_5(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dn, d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1756:1, end:1756:2))"]
#[derive(Clone, Debug)]
struct pack_instructionVar194 {
    d16: u16,
    Txw: TableTxw,
    Tyw: TableTyw,
}
impl pack_instructionVar194 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pack"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Tyw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Txw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Txw = if let Some((len, table)) =
            TableTxw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Tyw = if let Some((len, table)) =
            TableTyw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Txw, Tyw, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1761:1, end:1761:2))"]
#[derive(Clone, Debug)]
struct pack_instructionVar195 {
    d16: u16,
    Tyw: TableTyw,
    Txb: TableTxb,
}
impl pack_instructionVar195 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("pack"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Tyw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Txb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Tyw = if let Some((len, table)) =
            TableTyw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Txb = if let Some((len, table)) =
            TableTxb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Tyw, Txb, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1981:1, end:1981:2))"]
#[derive(Clone, Debug)]
struct subq_w_instructionVar196 {
    quick: u8,
    regan: u8,
}
impl subq_w_instructionVar196 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subq.w"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        let quick = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { quick, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1982:1, end:1982:2))"]
#[derive(Clone, Debug)]
struct subq_l_instructionVar197 {
    quick: u8,
    regan: u8,
}
impl subq_l_instructionVar197 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subq.l"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let quick = token_5(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { quick, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2002:1, end:2002:2))"]
#[derive(Clone, Debug)]
struct trap_instructionVar198 {
    op03: u8,
}
impl trap_instructionVar198 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trap"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.op03 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let op03 = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { op03 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2018:1, end:2018:2))"]
#[derive(Clone, Debug)]
struct unpk_instructionVar199 {
    d16: u16,
    Txw: TableTxw,
    Tyw: TableTyw,
}
impl unpk_instructionVar199 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("unpk"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Tyw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Txw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Txw = if let Some((len, table)) =
            TableTxw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Tyw = if let Some((len, table)) =
            TableTyw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Txw, Tyw, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2022:1, end:2022:2))"]
#[derive(Clone, Debug)]
struct unpk_instructionVar200 {
    d16: u16,
    Txw: TableTxw,
    Tyb: TableTyb,
}
impl unpk_instructionVar200 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("unpk"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Tyb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Txw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(",#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Tyb = if let Some((len, table)) =
            TableTyb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Txw = if let Some((len, table)) =
            TableTxw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Txw, Tyb, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2566:1, end:2566:2))"]
#[derive(Clone, Debug)]
struct frestore_instructionVar201 {
    eal: Tableeal,
}
impl frestore_instructionVar201 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("frestore"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c21 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 15 {
                return None;
            }
            if token_2(tokens) != 5 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 2 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 3 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 5 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 6 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 7 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c21(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2568:1, end:2568:2))"]
#[derive(Clone, Debug)]
struct fsave_instructionVar202 {
    eal: Tableeal,
}
impl fsave_instructionVar202 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsave"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c19 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 15 {
                return None;
            }
            if token_2(tokens) != 4 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 2 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 4 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 5 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 6 {
                        return Some(((), (), 2));
                    }
                    if token_1(tokens_param) == 7 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c19(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:822:1, end:822:2))"]
#[derive(Clone, Debug)]
struct abcd_instructionVar203 {
    Txb: TableTxb,
    Tyb: TableTyb,
}
impl abcd_instructionVar203 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("abcd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Tyb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Txb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Tyb = if let Some((len, table)) =
            TableTyb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Txb = if let Some((len, table)) =
            TableTxb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Txb, Tyb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1049:1, end:1049:2))"]
#[derive(Clone, Debug)]
struct cas_b_instructionVar204 {
    regdcb: u8,
    regdub: u8,
    e2b: Tablee2b,
}
impl cas_b_instructionVar204 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cas.b"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.regdcb),
            <DisplayElement>::Literal(","),
            meaning_3_display(self.regdub),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let regdub = token_2(tokens_current);
        let regdcb = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                e2b,
                regdcb,
                regdub,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1060:1, end:1060:2))"]
#[derive(Clone, Debug)]
struct cas_w_instructionVar205 {
    regdcw: u8,
    regduw: u8,
    e2w: Tablee2w,
}
impl cas_w_instructionVar205 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cas.w"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.regdcw),
            <DisplayElement>::Literal(","),
            meaning_2_display(self.regduw),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let regduw = token_2(tokens_current);
        let regdcw = token_3(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                e2w,
                regdcw,
                regduw,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1071:1, end:1071:2))"]
#[derive(Clone, Debug)]
struct cas_l_instructionVar206 {
    regdc: u8,
    regdu: u8,
    e2l: Tablee2l,
}
impl cas_l_instructionVar206 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cas.l"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.regdc),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdu),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let regdc = token_3(tokens_current);
        let regdu = token_2(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, regdc, regdu }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1670:1, end:1670:2))"]
#[derive(Clone, Debug)]
struct moves_b_instructionVar207 {
    regan: u8,
    mode: u8,
    rreg: Tablerreg,
    e2b: Tablee2b,
}
impl moves_b_instructionVar207 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("moves.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(token_1(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        let mode = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rreg,
                e2b,
                regan,
                mode,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1671:1, end:1671:2))"]
#[derive(Clone, Debug)]
struct moves_w_instructionVar208 {
    regan: u8,
    mode: u8,
    rreg: Tablerreg,
    e2w: Tablee2w,
}
impl moves_w_instructionVar208 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("moves.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(token_1(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        let mode = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rreg,
                e2w,
                regan,
                mode,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1672:1, end:1672:2))"]
#[derive(Clone, Debug)]
struct moves_b_instructionVar209 {
    regan: u8,
    mode: u8,
    rreg: Tablerreg,
    e2b: Tablee2b,
}
impl moves_b_instructionVar209 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("moves.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(token_1(tokens_current)).unwrap() & 7).unwrap(),
        );
        let mode = token_1(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rreg,
                e2b,
                regan,
                mode,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1673:1, end:1673:2))"]
#[derive(Clone, Debug)]
struct moves_w_instructionVar210 {
    regan: u8,
    mode: u8,
    rreg: Tablerreg,
    e2w: Tablee2w,
}
impl moves_w_instructionVar210 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("moves.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(token_1(tokens_current)).unwrap() & 7).unwrap(),
        );
        let mode = token_1(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rreg,
                e2w,
                regan,
                mode,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1667:1, end:1667:2))"]
#[derive(Clone, Debug)]
struct moves_b_instructionVar211 {
    regan: u8,
    mode: u8,
    rreg: Tablerreg,
    e2b: Tablee2b,
}
impl moves_b_instructionVar211 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("moves.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(token_1(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        let mode = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rreg,
                e2b,
                regan,
                mode,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1668:1, end:1668:2))"]
#[derive(Clone, Debug)]
struct moves_w_instructionVar212 {
    regan: u8,
    mode: u8,
    rreg: Tablerreg,
    e2w: Tablee2w,
}
impl moves_w_instructionVar212 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("moves.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(token_1(tokens_current)).unwrap() & 7).unwrap(),
        );
        let mode = token_1(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rreg,
                e2w,
                regan,
                mode,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1669:1, end:1669:2))"]
#[derive(Clone, Debug)]
struct moves_l_instructionVar213 {
    regan: u8,
    mode: u8,
    rreg: Tablerreg,
    e2l: Tablee2l,
}
impl moves_l_instructionVar213 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("moves.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(token_1(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        let mode = token_1(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rreg,
                e2l,
                regan,
                mode,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1674:1, end:1674:2))"]
#[derive(Clone, Debug)]
struct moves_l_instructionVar214 {
    regan: u8,
    mode: u8,
    rreg: Tablerreg,
    e2l: Tablee2l,
}
impl moves_l_instructionVar214 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("moves.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.rreg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(token_1(tokens_current)).unwrap() & 7).unwrap(),
        );
        let mode = token_1(tokens_current);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let rreg = if let Some((len, table)) =
            Tablerreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                rreg,
                e2l,
                regan,
                mode,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:839:1, end:839:2))"]
#[derive(Clone, Debug)]
struct addi_b_instructionVar215 {
    d8: u8,
    e2b: Tablee2b,
}
impl addi_b_instructionVar215 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addi.b"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:840:1, end:840:2))"]
#[derive(Clone, Debug)]
struct addi_w_instructionVar216 {
    d16: u16,
    e2w: Tablee2w,
}
impl addi_w_instructionVar216 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addi.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2w, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:841:1, end:841:2))"]
#[derive(Clone, Debug)]
struct addi_l_instructionVar217 {
    d32: u32,
    e2l: Tablee2l,
}
impl addi_l_instructionVar217 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addi.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:851:1, end:851:2))"]
#[derive(Clone, Debug)]
struct addx_b_instructionVar218 {
    Txb: TableTxb,
    Tyb: TableTyb,
}
impl addx_b_instructionVar218 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addx.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Tyb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Txb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Tyb = if let Some((len, table)) =
            TableTyb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Txb = if let Some((len, table)) =
            TableTxb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Txb, Tyb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:853:1, end:853:2))"]
#[derive(Clone, Debug)]
struct addx_w_instructionVar219 {
    Tyw: TableTyw,
    Txw: TableTxw,
}
impl addx_w_instructionVar219 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addx.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Tyw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Txw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Tyw = if let Some((len, table)) =
            TableTyw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Txw = if let Some((len, table)) =
            TableTxw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Tyw, Txw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:855:1, end:855:2))"]
#[derive(Clone, Debug)]
struct addx_l_instructionVar220 {
    Ty: TableTy,
    Tx: TableTx,
}
impl addx_l_instructionVar220 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addx.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ty
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Tx
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Ty = if let Some((len, table)) =
            TableTy::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Tx = if let Some((len, table)) =
            TableTx::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ty, Tx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:865:1, end:865:2))"]
#[derive(Clone, Debug)]
struct andi_b_instructionVar221 {
    const8: Tableconst8,
    e2b: Tablee2b,
}
impl andi_b_instructionVar221 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andi.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.const8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let const8 = if let Some((len, table)) =
            Tableconst8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { const8, e2b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:866:1, end:866:2))"]
#[derive(Clone, Debug)]
struct andi_w_instructionVar222 {
    const16: Tableconst16,
    e2w: Tablee2w,
}
impl andi_w_instructionVar222 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andi.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.const16
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let const16 = if let Some((len, table)) =
            Tableconst16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { const16, e2w }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:867:1, end:867:2))"]
#[derive(Clone, Debug)]
struct andi_l_instructionVar223 {
    const32: Tableconst32,
    e2l: Tablee2l,
}
impl andi_l_instructionVar223 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("andi.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.const32
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let const32 = if let Some((len, table)) =
            Tableconst32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { const32, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:871:1, end:871:2))"]
#[derive(Clone, Debug)]
struct asl_b_instructionVar224 {
    regdnb: u8,
    cntreg: Tablecntreg,
}
impl asl_b_instructionVar224 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asl.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.regdnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:872:1, end:872:2))"]
#[derive(Clone, Debug)]
struct asl_w_instructionVar225 {
    regdnw: u8,
    cntreg: Tablecntreg,
}
impl asl_w_instructionVar225 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asl.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.regdnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:873:1, end:873:2))"]
#[derive(Clone, Debug)]
struct asl_l_instructionVar226 {
    regdn: u8,
    cntreg: Tablecntreg,
}
impl asl_l_instructionVar226 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asl.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:874:1, end:874:2))"]
#[derive(Clone, Debug)]
struct asl_instructionVar227 {
    eaw: Tableeaw,
}
impl asl_instructionVar227 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c15 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 225 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c15(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:886:1, end:886:2))"]
#[derive(Clone, Debug)]
struct asr_b_instructionVar228 {
    regdnb: u8,
    cntreg: Tablecntreg,
}
impl asr_b_instructionVar228 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asr.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.regdnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:887:1, end:887:2))"]
#[derive(Clone, Debug)]
struct asr_w_instructionVar229 {
    regdnw: u8,
    cntreg: Tablecntreg,
}
impl asr_w_instructionVar229 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asr.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.regdnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:888:1, end:888:2))"]
#[derive(Clone, Debug)]
struct asr_l_instructionVar230 {
    regdn: u8,
    cntreg: Tablecntreg,
}
impl asr_l_instructionVar230 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asr.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:889:1, end:889:2))"]
#[derive(Clone, Debug)]
struct asr_instructionVar231 {
    eaw: Tableeaw,
}
impl asr_instructionVar231 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("asr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c15 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 224 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c15(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:908:1, end:908:2))"]
#[derive(Clone, Debug)]
struct bchg_b_instructionVar232 {
    d8: u8,
    e2b: Tablee2b,
}
impl bchg_b_instructionVar232 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bchg.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:918:1, end:918:2))"]
#[derive(Clone, Debug)]
struct bclr_b_instructionVar233 {
    d8: u8,
    e2b: Tablee2b,
}
impl bclr_b_instructionVar233 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bclr.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:982:1, end:982:2))"]
#[derive(Clone, Debug)]
struct bset_b_instructionVar234 {
    d8: u8,
    e2b: Tablee2b,
}
impl bset_b_instructionVar234 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bset.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:991:1, end:991:2))"]
#[derive(Clone, Debug)]
struct btst_b_instructionVar235 {
    d8: u8,
    e2b: Tablee2b,
}
impl btst_b_instructionVar235 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("btst.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1212:1, end:1212:2))"]
#[derive(Clone, Debug)]
struct clr_b_instructionVar236 {
    eab: Tableeab,
}
impl clr_b_instructionVar236 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clr.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 66 {
                return None;
            }
            if token_18(tokens) != 0 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1213:1, end:1213:2))"]
#[derive(Clone, Debug)]
struct clr_w_instructionVar237 {
    eaw: Tableeaw,
}
impl clr_w_instructionVar237 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clr.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 66 {
                return None;
            }
            if token_18(tokens) != 1 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1214:1, end:1214:2))"]
#[derive(Clone, Debug)]
struct clr_l_instructionVar238 {
    eal: Tableeal,
}
impl clr_l_instructionVar238 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("clr.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 66 {
                return None;
            }
            if token_18(tokens) != 2 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1224:1, end:1224:2))"]
#[derive(Clone, Debug)]
struct cmpi_b_instructionVar239 {
    d8: u8,
    e2b: Tablee2b,
}
impl cmpi_b_instructionVar239 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpi.b"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1225:1, end:1225:2))"]
#[derive(Clone, Debug)]
struct cmpi_w_instructionVar240 {
    d16: u16,
    e2w: Tablee2w,
}
impl cmpi_w_instructionVar240 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpi.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2w, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1226:1, end:1226:2))"]
#[derive(Clone, Debug)]
struct cmpi_l_instructionVar241 {
    d32: u32,
    e2l: Tablee2l,
}
impl cmpi_l_instructionVar241 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpi.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1277:1, end:1277:2))"]
#[derive(Clone, Debug)]
struct div_instructionVar242 {
    remyes: Tableremyes,
    subdiv: Tablesubdiv,
    e2l: Tablee2l,
}
impl div_instructionVar242 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("div"));
        self.remyes
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(".l"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.subdiv
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let subdiv = if let Some((len, table)) =
            Tablesubdiv::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let remyes = if let Some((len, table)) =
            Tableremyes::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                remyes,
                subdiv,
                e2l,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1283:1, end:1283:2))"]
#[derive(Clone, Debug)]
struct eori_b_instructionVar243 {
    d8: u8,
    e2b: Tablee2b,
}
impl eori_b_instructionVar243 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eori.b"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1284:1, end:1284:2))"]
#[derive(Clone, Debug)]
struct eori_w_instructionVar244 {
    d16: u16,
    e2w: Tablee2w,
}
impl eori_w_instructionVar244 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eori.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2w, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1285:1, end:1285:2))"]
#[derive(Clone, Debug)]
struct eori_l_instructionVar245 {
    d32: u32,
    e2l: Tablee2l,
}
impl eori_l_instructionVar245 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eori.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1335:1, end:1335:2))"]
#[derive(Clone, Debug)]
struct lsl_b_instructionVar246 {
    regdnb: u8,
    cntreg: Tablecntreg,
}
impl lsl_b_instructionVar246 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsl.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.regdnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1336:1, end:1336:2))"]
#[derive(Clone, Debug)]
struct lsl_w_instructionVar247 {
    regdnw: u8,
    cntreg: Tablecntreg,
}
impl lsl_w_instructionVar247 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsl.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.regdnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1337:1, end:1337:2))"]
#[derive(Clone, Debug)]
struct lsl_l_instructionVar248 {
    regdn: u8,
    cntreg: Tablecntreg,
}
impl lsl_l_instructionVar248 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsl.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1338:1, end:1338:2))"]
#[derive(Clone, Debug)]
struct lsl_instructionVar249 {
    eaw: Tableeaw,
}
impl lsl_instructionVar249 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c39 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 227 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c39(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1348:1, end:1348:2))"]
#[derive(Clone, Debug)]
struct lsr_b_instructionVar250 {
    regdnb: u8,
    cntreg: Tablecntreg,
}
impl lsr_b_instructionVar250 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsr.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.regdnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1349:1, end:1349:2))"]
#[derive(Clone, Debug)]
struct lsr_w_instructionVar251 {
    regdnw: u8,
    cntreg: Tablecntreg,
}
impl lsr_w_instructionVar251 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsr.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.regdnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1350:1, end:1350:2))"]
#[derive(Clone, Debug)]
struct lsr_l_instructionVar252 {
    regdn: u8,
    cntreg: Tablecntreg,
}
impl lsr_l_instructionVar252 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsr.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1351:1, end:1351:2))"]
#[derive(Clone, Debug)]
struct lsr_instructionVar253 {
    eaw: Tableeaw,
}
impl lsr_instructionVar253 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lsr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c39 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 226 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c39(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1365:1, end:1365:2))"]
#[derive(Clone, Debug)]
struct move_instructionVar254 {
    eaw: Tableeaw,
}
impl move_instructionVar254 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move"));
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("CCR,"),
        ];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 66 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1366:1, end:1366:2))"]
#[derive(Clone, Debug)]
struct move_instructionVar255 {
    eaw: Tableeaw,
}
impl move_instructionVar255 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",CCR")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 68 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1367:1, end:1367:2))"]
#[derive(Clone, Debug)]
struct move_instructionVar256 {
    eaw: Tableeaw,
}
impl move_instructionVar256 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::SR),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 64 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1368:1, end:1368:2))"]
#[derive(Clone, Debug)]
struct move_instructionVar257 {
    eaw: Tableeaw,
}
impl move_instructionVar257 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::SR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 70 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1691:1, end:1691:2))"]
#[derive(Clone, Debug)]
struct mul_instructionVar258 {
    submul: Tablesubmul,
    mulsize: Tablemulsize,
    e2l: Tablee2l,
}
impl mul_instructionVar258 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mul"));
        self.mulsize
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.submul
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let submul = if let Some((len, table)) =
            Tablesubmul::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mulsize = if let Some((len, table)) =
            Tablemulsize::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                submul,
                mulsize,
                e2l,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1693:1, end:1693:2))"]
#[derive(Clone, Debug)]
struct nbcd_instructionVar259 {
    eab: Tableeab,
}
impl nbcd_instructionVar259 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("nbcd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c16 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 72 {
                return None;
            }
            if token_18(tokens) != 0 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c16(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1715:1, end:1715:2))"]
#[derive(Clone, Debug)]
struct neg_b_instructionVar260 {
    eab: Tableeab,
}
impl neg_b_instructionVar260 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 68 {
                return None;
            }
            if token_18(tokens) != 0 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1717:1, end:1717:2))"]
#[derive(Clone, Debug)]
struct neg_w_instructionVar261 {
    eaw: Tableeaw,
}
impl neg_w_instructionVar261 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 68 {
                return None;
            }
            if token_18(tokens) != 1 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1719:1, end:1719:2))"]
#[derive(Clone, Debug)]
struct neg_l_instructionVar262 {
    eal: Tableeal,
}
impl neg_l_instructionVar262 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("neg.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 68 {
                return None;
            }
            if token_18(tokens) != 2 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1729:1, end:1729:2))"]
#[derive(Clone, Debug)]
struct negx_b_instructionVar263 {
    eab: Tableeab,
}
impl negx_b_instructionVar263 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("negx.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c18 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 64 {
                return None;
            }
            if token_18(tokens) != 0 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c18(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1731:1, end:1731:2))"]
#[derive(Clone, Debug)]
struct negx_w_instructionVar264 {
    eaw: Tableeaw,
}
impl negx_w_instructionVar264 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("negx.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c18 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 64 {
                return None;
            }
            if token_18(tokens) != 1 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c18(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1733:1, end:1733:2))"]
#[derive(Clone, Debug)]
struct negx_l_instructionVar265 {
    eal: Tableeal,
}
impl negx_l_instructionVar265 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("negx.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c18 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 64 {
                return None;
            }
            if token_18(tokens) != 2 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c18(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1738:1, end:1738:2))"]
#[derive(Clone, Debug)]
struct not_b_instructionVar266 {
    eab: Tableeab,
}
impl not_b_instructionVar266 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("not.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 70 {
                return None;
            }
            if token_18(tokens) != 0 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1739:1, end:1739:2))"]
#[derive(Clone, Debug)]
struct not_w_instructionVar267 {
    eaw: Tableeaw,
}
impl not_w_instructionVar267 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("not.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 70 {
                return None;
            }
            if token_18(tokens) != 1 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1740:1, end:1740:2))"]
#[derive(Clone, Debug)]
struct not_l_instructionVar268 {
    eal: Tableeal,
}
impl not_l_instructionVar268 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("not.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 70 {
                return None;
            }
            if token_18(tokens) != 2 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1750:1, end:1750:2))"]
#[derive(Clone, Debug)]
struct ori_b_instructionVar269 {
    d8: u8,
    e2b: Tablee2b,
}
impl ori_b_instructionVar269 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ori.b"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1751:1, end:1751:2))"]
#[derive(Clone, Debug)]
struct ori_w_instructionVar270 {
    d16: u16,
    e2w: Tablee2w,
}
impl ori_w_instructionVar270 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ori.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2w, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1752:1, end:1752:2))"]
#[derive(Clone, Debug)]
struct ori_l_instructionVar271 {
    d32: u32,
    e2l: Tablee2l,
}
impl ori_l_instructionVar271 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ori.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1868:1, end:1868:2))"]
#[derive(Clone, Debug)]
struct rol_b_instructionVar272 {
    regdnb: u8,
    cntreg: Tablecntreg,
}
impl rol_b_instructionVar272 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rol.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.regdnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1869:1, end:1869:2))"]
#[derive(Clone, Debug)]
struct rol_w_instructionVar273 {
    regdnw: u8,
    cntreg: Tablecntreg,
}
impl rol_w_instructionVar273 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rol.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.regdnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1870:1, end:1870:2))"]
#[derive(Clone, Debug)]
struct rol_l_instructionVar274 {
    regdn: u8,
    cntreg: Tablecntreg,
}
impl rol_l_instructionVar274 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rol.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1871:1, end:1871:2))"]
#[derive(Clone, Debug)]
struct rol_instructionVar275 {
    eaw: Tableeaw,
}
impl rol_instructionVar275 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("rol"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c15 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 231 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c15(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1880:1, end:1880:2))"]
#[derive(Clone, Debug)]
struct ror_b_instructionVar276 {
    regdnb: u8,
    cntreg: Tablecntreg,
}
impl ror_b_instructionVar276 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ror.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.regdnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1881:1, end:1881:2))"]
#[derive(Clone, Debug)]
struct ror_w_instructionVar277 {
    regdnw: u8,
    cntreg: Tablecntreg,
}
impl ror_w_instructionVar277 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ror.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.regdnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1882:1, end:1882:2))"]
#[derive(Clone, Debug)]
struct ror_l_instructionVar278 {
    regdn: u8,
    cntreg: Tablecntreg,
}
impl ror_l_instructionVar278 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ror.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1883:1, end:1883:2))"]
#[derive(Clone, Debug)]
struct ror_instructionVar279 {
    eaw: Tableeaw,
}
impl ror_instructionVar279 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ror"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c15 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 230 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c15(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1892:1, end:1892:2))"]
#[derive(Clone, Debug)]
struct roxl_b_instructionVar280 {
    regdnb: u8,
    cntreg: Tablecntreg,
}
impl roxl_b_instructionVar280 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("roxl.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.regdnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1893:1, end:1893:2))"]
#[derive(Clone, Debug)]
struct roxl_w_instructionVar281 {
    regdnw: u8,
    cntreg: Tablecntreg,
}
impl roxl_w_instructionVar281 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("roxl.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.regdnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1894:1, end:1894:2))"]
#[derive(Clone, Debug)]
struct roxl_l_instructionVar282 {
    regdn: u8,
    cntreg: Tablecntreg,
}
impl roxl_l_instructionVar282 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("roxl.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1895:1, end:1895:2))"]
#[derive(Clone, Debug)]
struct roxl_instructionVar283 {
    eaw: Tableeaw,
}
impl roxl_instructionVar283 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("roxl"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c16 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 229 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c16(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1906:1, end:1906:2))"]
#[derive(Clone, Debug)]
struct roxr_b_instructionVar284 {
    regdnb: u8,
    cntreg: Tablecntreg,
}
impl roxr_b_instructionVar284 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("roxr.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.regdnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1907:1, end:1907:2))"]
#[derive(Clone, Debug)]
struct roxr_w_instructionVar285 {
    regdnw: u8,
    cntreg: Tablecntreg,
}
impl roxr_w_instructionVar285 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("roxr.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.regdnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1908:1, end:1908:2))"]
#[derive(Clone, Debug)]
struct roxr_l_instructionVar286 {
    regdn: u8,
    cntreg: Tablecntreg,
}
impl roxr_l_instructionVar286 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("roxr.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.cntreg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.regdn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cntreg = if let Some((len, table)) =
            Tablecntreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cntreg, regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1909:1, end:1909:2))"]
#[derive(Clone, Debug)]
struct roxr_instructionVar287 {
    eaw: Tableeaw,
}
impl roxr_instructionVar287 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("roxr"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c16 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 228 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c16(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1930:1, end:1930:2))"]
#[derive(Clone, Debug)]
struct sbcd_instructionVar288 {
    Txb: TableTxb,
    Tyb: TableTyb,
}
impl sbcd_instructionVar288 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sbcd"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Tyb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Txb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Txb = if let Some((len, table)) =
            TableTxb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Tyb = if let Some((len, table)) =
            TableTyb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Txb, Tyb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1962:1, end:1962:2))"]
#[derive(Clone, Debug)]
struct subi_b_instructionVar289 {
    d8: u8,
    e2b: Tablee2b,
}
impl subi_b_instructionVar289 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subi.b"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1965:1, end:1965:2))"]
#[derive(Clone, Debug)]
struct subi_w_instructionVar290 {
    d16: u16,
    e2w: Tablee2w,
}
impl subi_w_instructionVar290 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subi.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2w, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1968:1, end:1968:2))"]
#[derive(Clone, Debug)]
struct subi_l_instructionVar291 {
    d32: u32,
    e2l: Tablee2l,
}
impl subi_l_instructionVar291 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subi.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1986:1, end:1986:2))"]
#[derive(Clone, Debug)]
struct subx_b_instructionVar292 {
    Tyb: TableTyb,
    Txb: TableTxb,
}
impl subx_b_instructionVar292 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subx.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Tyb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Txb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Tyb = if let Some((len, table)) =
            TableTyb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Txb = if let Some((len, table)) =
            TableTxb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Tyb, Txb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1989:1, end:1989:2))"]
#[derive(Clone, Debug)]
struct subx_w_instructionVar293 {
    Txw: TableTxw,
    Tyw: TableTyw,
}
impl subx_w_instructionVar293 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subx.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Tyw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Txw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Tyw = if let Some((len, table)) =
            TableTyw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Txw = if let Some((len, table)) =
            TableTxw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Txw, Tyw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1992:1, end:1992:2))"]
#[derive(Clone, Debug)]
struct subx_l_instructionVar294 {
    Ty: TableTy,
    Tx: TableTx,
}
impl subx_l_instructionVar294 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subx.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.Ty
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.Tx
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let Ty = if let Some((len, table)) =
            TableTy::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let Tx = if let Some((len, table)) =
            TableTx::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { Ty, Tx }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1999:1, end:1999:2))"]
#[derive(Clone, Debug)]
struct tas_instructionVar295 {
    eab: Tableeab,
}
impl tas_instructionVar295 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tas"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c15 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 74 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c15(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2008:1, end:2008:2))"]
#[derive(Clone, Debug)]
struct tst_b_instructionVar296 {
    eab: Tableeab,
}
impl tst_b_instructionVar296 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tst.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 74 {
                return None;
            }
            if token_18(tokens) != 0 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2009:1, end:2009:2))"]
#[derive(Clone, Debug)]
struct tst_w_instructionVar297 {
    eaw: Tableeaw,
}
impl tst_w_instructionVar297 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tst.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 74 {
                return None;
            }
            if token_18(tokens) != 1 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2010:1, end:2010:2))"]
#[derive(Clone, Debug)]
struct tst_l_instructionVar298 {
    eal: Tableeal,
}
impl tst_l_instructionVar298 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("tst.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c17 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_7(tokens) != 74 {
                return None;
            }
            if token_18(tokens) != 2 {
                return None;
            }
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c17(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2356:1, end:2356:2))"]
#[derive(Clone, Debug)]
struct fmove_l_instructionVar299 {
    e2l: Tablee2l,
}
impl fmove_l_instructionVar299 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FPCR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2357:1, end:2357:2))"]
#[derive(Clone, Debug)]
struct fmove_l_instructionVar300 {
    e2l: Tablee2l,
}
impl fmove_l_instructionVar300 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FPCR),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2358:1, end:2358:2))"]
#[derive(Clone, Debug)]
struct fmove_l_instructionVar301 {
    e2l: Tablee2l,
}
impl fmove_l_instructionVar301 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FPSR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2359:1, end:2359:2))"]
#[derive(Clone, Debug)]
struct fmove_l_instructionVar302 {
    e2l: Tablee2l,
}
impl fmove_l_instructionVar302 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FPSR),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2360:1, end:2360:2))"]
#[derive(Clone, Debug)]
struct fmove_l_instructionVar303 {
    e2l: Tablee2l,
}
impl fmove_l_instructionVar303 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FPIAR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2361:1, end:2361:2))"]
#[derive(Clone, Debug)]
struct fmove_l_instructionVar304 {
    e2l: Tablee2l,
}
impl fmove_l_instructionVar304 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FPIAR),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2097:1, end:2097:2))"]
#[derive(Clone, Debug)]
struct fabs__instructionVar305 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fabs__instructionVar305 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fabs."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2099:1, end:2099:2))"]
#[derive(Clone, Debug)]
struct fabs__instructionVar306 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fabs__instructionVar306 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fabs."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2101:1, end:2101:2))"]
#[derive(Clone, Debug)]
struct fabs__instructionVar307 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fabs__instructionVar307 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fabs."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2120:1, end:2120:2))"]
#[derive(Clone, Debug)]
struct facos__instructionVar308 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl facos__instructionVar308 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("facos."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2121:1, end:2121:2))"]
#[derive(Clone, Debug)]
struct facos__instructionVar309 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl facos__instructionVar309 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("facos."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2122:1, end:2122:2))"]
#[derive(Clone, Debug)]
struct facos__instructionVar310 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl facos__instructionVar310 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("facos."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2125:1, end:2125:2))"]
#[derive(Clone, Debug)]
struct fadd__instructionVar311 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fadd__instructionVar311 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fadd."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2127:1, end:2127:2))"]
#[derive(Clone, Debug)]
struct fadd__instructionVar312 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fadd__instructionVar312 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fadd."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2129:1, end:2129:2))"]
#[derive(Clone, Debug)]
struct fadd__instructionVar313 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fadd__instructionVar313 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fadd."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2148:1, end:2148:2))"]
#[derive(Clone, Debug)]
struct fasin__instructionVar314 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fasin__instructionVar314 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fasin."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2149:1, end:2149:2))"]
#[derive(Clone, Debug)]
struct fasin__instructionVar315 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fasin__instructionVar315 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fasin."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2150:1, end:2150:2))"]
#[derive(Clone, Debug)]
struct fasin__instructionVar316 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fasin__instructionVar316 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fasin."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2153:1, end:2153:2))"]
#[derive(Clone, Debug)]
struct fatan__instructionVar317 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fatan__instructionVar317 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fatan."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2154:1, end:2154:2))"]
#[derive(Clone, Debug)]
struct fatan__instructionVar318 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fatan__instructionVar318 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fatan."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2155:1, end:2155:2))"]
#[derive(Clone, Debug)]
struct fatan__instructionVar319 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fatan__instructionVar319 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fatan."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2158:1, end:2158:2))"]
#[derive(Clone, Debug)]
struct fatanh__instructionVar320 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fatanh__instructionVar320 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fatanh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2159:1, end:2159:2))"]
#[derive(Clone, Debug)]
struct fatanh__instructionVar321 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fatanh__instructionVar321 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fatanh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2160:1, end:2160:2))"]
#[derive(Clone, Debug)]
struct fatanh__instructionVar322 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fatanh__instructionVar322 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fatanh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2166:1, end:2166:2))"]
#[derive(Clone, Debug)]
struct fcmp_b_instructionVar323 {
    fdst: u8,
    e2b: Tablee2b,
}
impl fcmp_b_instructionVar323 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmp.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2169:1, end:2169:2))"]
#[derive(Clone, Debug)]
struct fcmp_w_instructionVar324 {
    fdst: u8,
    e2w: Tablee2w,
}
impl fcmp_w_instructionVar324 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmp.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2w, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2172:1, end:2172:2))"]
#[derive(Clone, Debug)]
struct fcmp_l_instructionVar325 {
    fdst: u8,
    e2l: Tablee2l,
}
impl fcmp_l_instructionVar325 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmp.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2175:1, end:2175:2))"]
#[derive(Clone, Debug)]
struct fcmp_s_instructionVar326 {
    fdst: u8,
    e2l: Tablee2l,
}
impl fcmp_s_instructionVar326 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmp.s"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2178:1, end:2178:2))"]
#[derive(Clone, Debug)]
struct fcmp__instructionVar327 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fcmp__instructionVar327 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmp."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2181:1, end:2181:2))"]
#[derive(Clone, Debug)]
struct fcmp__instructionVar328 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fcmp__instructionVar328 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcmp."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2187:1, end:2187:2))"]
#[derive(Clone, Debug)]
struct fcos__instructionVar329 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fcos__instructionVar329 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcos."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2188:1, end:2188:2))"]
#[derive(Clone, Debug)]
struct fcos__instructionVar330 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fcos__instructionVar330 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcos."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2189:1, end:2189:2))"]
#[derive(Clone, Debug)]
struct fcos__instructionVar331 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fcos__instructionVar331 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcos."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2192:1, end:2192:2))"]
#[derive(Clone, Debug)]
struct fcosh__instructionVar332 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fcosh__instructionVar332 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcosh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2193:1, end:2193:2))"]
#[derive(Clone, Debug)]
struct fcosh__instructionVar333 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fcosh__instructionVar333 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcosh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2194:1, end:2194:2))"]
#[derive(Clone, Debug)]
struct fcosh__instructionVar334 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fcosh__instructionVar334 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fcosh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2204:1, end:2204:2))"]
#[derive(Clone, Debug)]
struct fdiv__instructionVar335 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fdiv__instructionVar335 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdiv."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2206:1, end:2206:2))"]
#[derive(Clone, Debug)]
struct fdiv__instructionVar336 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fdiv__instructionVar336 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdiv."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2208:1, end:2208:2))"]
#[derive(Clone, Debug)]
struct fdiv__instructionVar337 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fdiv__instructionVar337 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fdiv."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2227:1, end:2227:2))"]
#[derive(Clone, Debug)]
struct fetox__instructionVar338 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fetox__instructionVar338 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fetox."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2228:1, end:2228:2))"]
#[derive(Clone, Debug)]
struct fetox__instructionVar339 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fetox__instructionVar339 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fetox."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2229:1, end:2229:2))"]
#[derive(Clone, Debug)]
struct fetox__instructionVar340 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fetox__instructionVar340 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fetox."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2232:1, end:2232:2))"]
#[derive(Clone, Debug)]
struct fetoxm1__instructionVar341 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fetoxm1__instructionVar341 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fetoxm1."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2233:1, end:2233:2))"]
#[derive(Clone, Debug)]
struct fetoxm1__instructionVar342 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fetoxm1__instructionVar342 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fetoxm1."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2234:1, end:2234:2))"]
#[derive(Clone, Debug)]
struct fetoxm1__instructionVar343 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fetoxm1__instructionVar343 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fetoxm1."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2237:1, end:2237:2))"]
#[derive(Clone, Debug)]
struct fgetexp__instructionVar344 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fgetexp__instructionVar344 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fgetexp."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2238:1, end:2238:2))"]
#[derive(Clone, Debug)]
struct fgetexp__instructionVar345 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fgetexp__instructionVar345 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fgetexp."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2239:1, end:2239:2))"]
#[derive(Clone, Debug)]
struct fgetexp__instructionVar346 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fgetexp__instructionVar346 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fgetexp."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2242:1, end:2242:2))"]
#[derive(Clone, Debug)]
struct fgetman__instructionVar347 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fgetman__instructionVar347 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fgetman."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2243:1, end:2243:2))"]
#[derive(Clone, Debug)]
struct fgetman__instructionVar348 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fgetman__instructionVar348 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fgetman."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2244:1, end:2244:2))"]
#[derive(Clone, Debug)]
struct fgetman__instructionVar349 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fgetman__instructionVar349 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fgetman."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2247:1, end:2247:2))"]
#[derive(Clone, Debug)]
struct fint__instructionVar350 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fint__instructionVar350 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fint."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2248:1, end:2248:2))"]
#[derive(Clone, Debug)]
struct fint__instructionVar351 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fint__instructionVar351 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fint."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2249:1, end:2249:2))"]
#[derive(Clone, Debug)]
struct fint__instructionVar352 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fint__instructionVar352 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fint."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2252:1, end:2252:2))"]
#[derive(Clone, Debug)]
struct fintrz__instructionVar353 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fintrz__instructionVar353 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fintrz."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2253:1, end:2253:2))"]
#[derive(Clone, Debug)]
struct fintrz__instructionVar354 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fintrz__instructionVar354 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fintrz."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2254:1, end:2254:2))"]
#[derive(Clone, Debug)]
struct fintrz__instructionVar355 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fintrz__instructionVar355 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fintrz."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2257:1, end:2257:2))"]
#[derive(Clone, Debug)]
struct flog10__instructionVar356 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl flog10__instructionVar356 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flog10."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2258:1, end:2258:2))"]
#[derive(Clone, Debug)]
struct flog10__instructionVar357 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl flog10__instructionVar357 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flog10."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2259:1, end:2259:2))"]
#[derive(Clone, Debug)]
struct flog10__instructionVar358 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl flog10__instructionVar358 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flog10."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2262:1, end:2262:2))"]
#[derive(Clone, Debug)]
struct flog2__instructionVar359 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl flog2__instructionVar359 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flog2."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2263:1, end:2263:2))"]
#[derive(Clone, Debug)]
struct flog2__instructionVar360 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl flog2__instructionVar360 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flog2."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2264:1, end:2264:2))"]
#[derive(Clone, Debug)]
struct flog2__instructionVar361 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl flog2__instructionVar361 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flog2."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2267:1, end:2267:2))"]
#[derive(Clone, Debug)]
struct flogn__instructionVar362 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl flogn__instructionVar362 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flogn."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2268:1, end:2268:2))"]
#[derive(Clone, Debug)]
struct flogn__instructionVar363 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl flogn__instructionVar363 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flogn."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2269:1, end:2269:2))"]
#[derive(Clone, Debug)]
struct flogn__instructionVar364 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl flogn__instructionVar364 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flogn."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2272:1, end:2272:2))"]
#[derive(Clone, Debug)]
struct flognp1__instructionVar365 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl flognp1__instructionVar365 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flognp1."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2273:1, end:2273:2))"]
#[derive(Clone, Debug)]
struct flognp1__instructionVar366 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl flognp1__instructionVar366 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flognp1."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2274:1, end:2274:2))"]
#[derive(Clone, Debug)]
struct flognp1__instructionVar367 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl flognp1__instructionVar367 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("flognp1."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2277:1, end:2277:2))"]
#[derive(Clone, Debug)]
struct fmod__instructionVar368 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fmod__instructionVar368 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmod."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2278:1, end:2278:2))"]
#[derive(Clone, Debug)]
struct fmod__instructionVar369 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fmod__instructionVar369 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmod."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2279:1, end:2279:2))"]
#[derive(Clone, Debug)]
struct fmod__instructionVar370 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fmod__instructionVar370 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmod."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2283:1, end:2283:2))"]
#[derive(Clone, Debug)]
struct fmove_b_instructionVar371 {
    fdst: u8,
    e2b: Tablee2b,
}
impl fmove_b_instructionVar371 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2286:1, end:2286:2))"]
#[derive(Clone, Debug)]
struct fmove_w_instructionVar372 {
    fdst: u8,
    e2w: Tablee2w,
}
impl fmove_w_instructionVar372 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2w, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2289:1, end:2289:2))"]
#[derive(Clone, Debug)]
struct fmove_l_instructionVar373 {
    fdst: u8,
    e2l: Tablee2l,
}
impl fmove_l_instructionVar373 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2293:1, end:2293:2))"]
#[derive(Clone, Debug)]
struct fmove_s_instructionVar374 {
    fdst: u8,
    e2l: Tablee2l,
}
impl fmove_s_instructionVar374 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.s"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2298:1, end:2298:2))"]
#[derive(Clone, Debug)]
struct fmove__instructionVar375 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fmove__instructionVar375 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let mut sub_pattern_c8 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c8(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2303:1, end:2303:2))"]
#[derive(Clone, Debug)]
struct fmove_d_instructionVar376 {
    fdst: u8,
    e2d: Tablee2d,
}
impl fmove_d_instructionVar376 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.d"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2513:1, end:2513:2))"]
#[derive(Clone, Debug)]
struct fmul__instructionVar377 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fmul__instructionVar377 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2515:1, end:2515:2))"]
#[derive(Clone, Debug)]
struct fmul__instructionVar378 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fmul__instructionVar378 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2517:1, end:2517:2))"]
#[derive(Clone, Debug)]
struct fmul__instructionVar379 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fmul__instructionVar379 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmul."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2536:1, end:2536:2))"]
#[derive(Clone, Debug)]
struct fneg__instructionVar380 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fneg__instructionVar380 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fneg."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2538:1, end:2538:2))"]
#[derive(Clone, Debug)]
struct fneg__instructionVar381 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fneg__instructionVar381 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fneg."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2540:1, end:2540:2))"]
#[derive(Clone, Debug)]
struct fneg__instructionVar382 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fneg__instructionVar382 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fneg."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2561:1, end:2561:2))"]
#[derive(Clone, Debug)]
struct frem__instructionVar383 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl frem__instructionVar383 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("frem."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2562:1, end:2562:2))"]
#[derive(Clone, Debug)]
struct frem__instructionVar384 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl frem__instructionVar384 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("frem."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2563:1, end:2563:2))"]
#[derive(Clone, Debug)]
struct frem__instructionVar385 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl frem__instructionVar385 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("frem."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2570:1, end:2570:2))"]
#[derive(Clone, Debug)]
struct fscale__instructionVar386 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fscale__instructionVar386 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fscale."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2571:1, end:2571:2))"]
#[derive(Clone, Debug)]
struct fscale__instructionVar387 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fscale__instructionVar387 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fscale."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2572:1, end:2572:2))"]
#[derive(Clone, Debug)]
struct fscale__instructionVar388 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fscale__instructionVar388 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fscale."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2577:1, end:2577:2))"]
#[derive(Clone, Debug)]
struct fs_instructionVar389 {
    fcc: Tablefcc,
    e2b: Tablee2b,
}
impl fs_instructionVar389 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fs"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc, e2b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2581:1, end:2581:2))"]
#[derive(Clone, Debug)]
struct fsgldiv__instructionVar390 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fsgldiv__instructionVar390 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsgldiv."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2582:1, end:2582:2))"]
#[derive(Clone, Debug)]
struct fsgldiv__instructionVar391 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fsgldiv__instructionVar391 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsgldiv."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2583:1, end:2583:2))"]
#[derive(Clone, Debug)]
struct fsgldiv__instructionVar392 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fsgldiv__instructionVar392 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsgldiv."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2586:1, end:2586:2))"]
#[derive(Clone, Debug)]
struct fsglmul__instructionVar393 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fsglmul__instructionVar393 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsglmul."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c127 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c127(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2590:1, end:2590:2))"]
#[derive(Clone, Debug)]
struct fsglmul_s_instructionVar394 {
    fdst: u8,
    e2l: Tablee2l,
}
impl fsglmul_s_instructionVar394 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsglmul.s"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2596:1, end:2596:2))"]
#[derive(Clone, Debug)]
struct fsglmul__instructionVar395 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fsglmul__instructionVar395 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsglmul."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2597:1, end:2597:2))"]
#[derive(Clone, Debug)]
struct fsglmul__instructionVar396 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fsglmul__instructionVar396 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsglmul."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2600:1, end:2600:2))"]
#[derive(Clone, Debug)]
struct fsin__instructionVar397 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fsin__instructionVar397 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsin."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2601:1, end:2601:2))"]
#[derive(Clone, Debug)]
struct fsin__instructionVar398 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fsin__instructionVar398 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsin."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2602:1, end:2602:2))"]
#[derive(Clone, Debug)]
struct fsin__instructionVar399 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fsin__instructionVar399 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsin."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2610:1, end:2610:2))"]
#[derive(Clone, Debug)]
struct fsinh__instructionVar400 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fsinh__instructionVar400 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsinh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2611:1, end:2611:2))"]
#[derive(Clone, Debug)]
struct fsinh__instructionVar401 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fsinh__instructionVar401 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsinh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2612:1, end:2612:2))"]
#[derive(Clone, Debug)]
struct fsinh__instructionVar402 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fsinh__instructionVar402 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsinh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2615:1, end:2615:2))"]
#[derive(Clone, Debug)]
struct fsqrt__instructionVar403 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fsqrt__instructionVar403 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrt."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2617:1, end:2617:2))"]
#[derive(Clone, Debug)]
struct fsqrt__instructionVar404 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fsqrt__instructionVar404 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrt."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2619:1, end:2619:2))"]
#[derive(Clone, Debug)]
struct fsqrt__instructionVar405 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fsqrt__instructionVar405 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsqrt."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2638:1, end:2638:2))"]
#[derive(Clone, Debug)]
struct fsub__instructionVar406 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fsub__instructionVar406 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsub."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2640:1, end:2640:2))"]
#[derive(Clone, Debug)]
struct fsub__instructionVar407 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fsub__instructionVar407 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsub."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2642:1, end:2642:2))"]
#[derive(Clone, Debug)]
struct fsub__instructionVar408 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fsub__instructionVar408 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsub."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2661:1, end:2661:2))"]
#[derive(Clone, Debug)]
struct ftan__instructionVar409 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl ftan__instructionVar409 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftan."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2662:1, end:2662:2))"]
#[derive(Clone, Debug)]
struct ftan__instructionVar410 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl ftan__instructionVar410 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftan."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2663:1, end:2663:2))"]
#[derive(Clone, Debug)]
struct ftan__instructionVar411 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl ftan__instructionVar411 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftan."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2666:1, end:2666:2))"]
#[derive(Clone, Debug)]
struct ftanh__instructionVar412 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl ftanh__instructionVar412 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftanh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2667:1, end:2667:2))"]
#[derive(Clone, Debug)]
struct ftanh__instructionVar413 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl ftanh__instructionVar413 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftanh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2668:1, end:2668:2))"]
#[derive(Clone, Debug)]
struct ftanh__instructionVar414 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl ftanh__instructionVar414 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftanh."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2671:1, end:2671:2))"]
#[derive(Clone, Debug)]
struct ftentox__instructionVar415 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl ftentox__instructionVar415 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftentox."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2672:1, end:2672:2))"]
#[derive(Clone, Debug)]
struct ftentox__instructionVar416 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl ftentox__instructionVar416 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftentox."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2673:1, end:2673:2))"]
#[derive(Clone, Debug)]
struct ftentox__instructionVar417 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl ftentox__instructionVar417 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftentox."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2680:1, end:2680:2))"]
#[derive(Clone, Debug)]
struct ftst__instructionVar418 {
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl ftst__instructionVar418 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftst."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2681:1, end:2681:2))"]
#[derive(Clone, Debug)]
struct ftst__instructionVar419 {
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl ftst__instructionVar419 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftst."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2682:1, end:2682:2))"]
#[derive(Clone, Debug)]
struct ftst__instructionVar420 {
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl ftst__instructionVar420 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftst."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2685:1, end:2685:2))"]
#[derive(Clone, Debug)]
struct ftwotox__instructionVar421 {
    fdst: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl ftwotox__instructionVar421 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftwotox."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2686:1, end:2686:2))"]
#[derive(Clone, Debug)]
struct ftwotox__instructionVar422 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl ftwotox__instructionVar422 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftwotox."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2687:1, end:2687:2))"]
#[derive(Clone, Debug)]
struct ftwotox__instructionVar423 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl ftwotox__instructionVar423 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("ftwotox."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2605:1, end:2605:2))"]
#[derive(Clone, Debug)]
struct fsincos__instructionVar424 {
    fdcos: u8,
    fdsin: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fsincos__instructionVar424 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsincos."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdcos),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdsin),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 4 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 6 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdcos = token_3(tokens_current);
        let fdsin = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fprec,
                e2l,
                fdcos,
                fdsin,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2606:1, end:2606:2))"]
#[derive(Clone, Debug)]
struct fsincos__instructionVar425 {
    fdcos: u8,
    fdsin: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fsincos__instructionVar425 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsincos."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdcos),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdsin),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let mut sub_pattern_c10 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_31(tokens_param) == 2 {
                    return Some(((), (), 2));
                }
                if token_31(tokens_param) == 3 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c10(tokens_current, &mut context_instance)?;
        block_1_len = block_1_len.max(sub_len);
        let fdcos = token_3(tokens_current);
        let fdsin = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fprec,
                e2x,
                fdcos,
                fdsin,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2607:1, end:2607:2))"]
#[derive(Clone, Debug)]
struct fsincos__instructionVar426 {
    fdcos: u8,
    fdsin: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fsincos__instructionVar426 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fsincos."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 6usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdcos),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdsin),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdcos = token_3(tokens_current);
        let fdsin = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fprec,
                e2d,
                fdcos,
                fdsin,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2327:1, end:2327:2))"]
#[derive(Clone, Debug)]
struct fmove_b_instructionVar427 {
    fdst: u8,
    e2b: Tablee2b,
}
impl fmove_b_instructionVar427 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.b"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fkfacreg = token_49(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2b, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2331:1, end:2331:2))"]
#[derive(Clone, Debug)]
struct fmove_w_instructionVar428 {
    fdst: u8,
    e2w: Tablee2w,
}
impl fmove_w_instructionVar428 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fkfacreg = token_49(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2w, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2335:1, end:2335:2))"]
#[derive(Clone, Debug)]
struct fmove_l_instructionVar429 {
    fdst: u8,
    e2l: Tablee2l,
}
impl fmove_l_instructionVar429 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fdst = token_47(tokens_current);
        let fkfacreg = token_49(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2339:1, end:2339:2))"]
#[derive(Clone, Debug)]
struct fmove_s_instructionVar430 {
    fdst: u8,
    e2l: Tablee2l,
}
impl fmove_s_instructionVar430 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.s"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fkfacreg = token_49(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { e2l, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2342:1, end:2342:2))"]
#[derive(Clone, Debug)]
struct fmove__instructionVar431 {
    fdst: u8,
    fprec: Tablefprec,
    e2x: Tablee2x,
}
impl fmove__instructionVar431 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2x
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fkfacreg = token_49(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2x = if let Some((len, table)) =
            Tablee2x::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2x, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2346:1, end:2346:2))"]
#[derive(Clone, Debug)]
struct fmove__instructionVar432 {
    fdst: u8,
    fprec: Tablefprec,
    e2d: Tablee2d,
}
impl fmove__instructionVar432 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove."));
        self.fprec
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2d
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fkfacreg = token_49(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2d = if let Some((len, table)) =
            Tablee2d::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fprec, e2d, fdst }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2349:1, end:2349:2))"]
#[derive(Clone, Debug)]
struct fmove_p_instructionVar433 {
    fdst: u8,
    fkfactor: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fmove_p_instructionVar433 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.p"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("{#"),
            DisplayElement::Number(true, false, self.fkfactor as u64),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fdst = token_47(tokens_current);
        let fkfactor = token_48(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fprec,
                e2l,
                fdst,
                fkfactor,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2352:1, end:2352:2))"]
#[derive(Clone, Debug)]
struct fmove_p_instructionVar434 {
    fdst: u8,
    fkfacreg: u8,
    fprec: Tablefprec,
    e2l: Tablee2l,
}
impl fmove_p_instructionVar434 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmove.p"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            meaning_8_display(self.fdst),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("{"),
            meaning_1_display(self.fkfacreg),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_1(tokens_param) == 0 {
                    return Some(((), (), 2));
                }
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fprec = if let Some((len, table)) =
            Tablefprec::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fkfacreg = token_49(tokens_current);
        let fdst = token_47(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fprec,
                e2l,
                fdst,
                fkfacreg,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2510:1, end:2510:2))"]
#[derive(Clone, Debug)]
struct fmovem_l_instructionVar435 {
    fp2mC0: Tablefp2mC0,
    e2l: Tablee2l,
}
impl fmovem_l_instructionVar435 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.fp2mC0
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let fp2mC0 = if let Some((len, table)) =
            Tablefp2mC0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mC0, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2511:1, end:2511:2))"]
#[derive(Clone, Debug)]
struct fmovem_l_instructionVar436 {
    m2fpC0: Tablem2fpC0,
    e2l: Tablee2l,
}
impl fmovem_l_instructionVar436 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fmovem.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2fpC0
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(context_instance.read_savmod1()).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(context_instance.read_regtfan()).unwrap() & 7).unwrap(),
        );
        let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                if token_20(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                if token_21(tokens_param) == 1 {
                    return Some(((), (), 2));
                }
                None
            };
            let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c1(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let m2fpC0 = if let Some((len, table)) =
            Tablem2fpC0::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_2_len = block_2_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpC0, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:829:1, end:829:2))"]
#[derive(Clone, Debug)]
struct add_b_instructionVar437 {
    reg9dnb: u8,
    eab: Tableeab,
}
impl add_b_instructionVar437 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.reg9dnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 13 {
                return None;
            }
            if token_2(tokens) != 0 {
                return None;
            }
            let reg9dnb = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnb), pattern_len))
        };
        let ((), (reg9dnb), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:830:1, end:830:2))"]
#[derive(Clone, Debug)]
struct add_w_instructionVar438 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl add_w_instructionVar438 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.reg9dnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 13 {
                return None;
            }
            if token_2(tokens) != 1 {
                return None;
            }
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:831:1, end:831:2))"]
#[derive(Clone, Debug)]
struct add_l_instructionVar439 {
    reg9dn: u8,
    eal: Tableeal,
}
impl add_l_instructionVar439 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 13 {
                return None;
            }
            if token_2(tokens) != 2 {
                return None;
            }
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:832:1, end:832:2))"]
#[derive(Clone, Debug)]
struct add_b_instructionVar440 {
    reg9dnb: u8,
    eab: Tableeab,
}
impl add_b_instructionVar440 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.reg9dnb),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 13 {
                return None;
            }
            if token_2(tokens) != 4 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnb = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnb), pattern_len))
        };
        let ((), (reg9dnb), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:833:1, end:833:2))"]
#[derive(Clone, Debug)]
struct add_w_instructionVar441 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl add_w_instructionVar441 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.w"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.reg9dnw),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 13 {
                return None;
            }
            if token_2(tokens) != 5 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:834:1, end:834:2))"]
#[derive(Clone, Debug)]
struct add_l_instructionVar442 {
    reg9dn: u8,
    eal: Tableeal,
}
impl add_l_instructionVar442 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("add.l"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 13 {
                return None;
            }
            if token_2(tokens) != 6 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:836:1, end:836:2))"]
#[derive(Clone, Debug)]
struct adda_w_instructionVar443 {
    reg9an: u8,
    eaw: Tableeaw,
}
impl adda_w_instructionVar443 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adda.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.reg9an),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 13 {
                return None;
            }
            if token_2(tokens) != 3 {
                return None;
            }
            let reg9an = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9an), pattern_len))
        };
        let ((), (reg9an), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:837:1, end:837:2))"]
#[derive(Clone, Debug)]
struct adda_l_instructionVar444 {
    reg9an: u8,
    eal: Tableeal,
}
impl adda_l_instructionVar444 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("adda.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.reg9an),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 13 {
                return None;
            }
            if token_2(tokens) != 7 {
                return None;
            }
            let reg9an = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9an), pattern_len))
        };
        let ((), (reg9an), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:843:1, end:843:2))"]
#[derive(Clone, Debug)]
struct addq_b_instructionVar445 {
    quick: u8,
    eab: Tableeab,
}
impl addq_b_instructionVar445 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addq.b"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 5 {
                return None;
            }
            if token_2(tokens) != 0 {
                return None;
            }
            let quick = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (quick), pattern_len))
        };
        let ((), (quick), sub_len) = sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, quick }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:844:1, end:844:2))"]
#[derive(Clone, Debug)]
struct addq_w_instructionVar446 {
    quick: u8,
    eaw: Tableeaw,
}
impl addq_w_instructionVar446 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addq.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 5 {
                return None;
            }
            if token_2(tokens) != 1 {
                return None;
            }
            let quick = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (quick), pattern_len))
        };
        let ((), (quick), sub_len) = sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, quick }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:845:1, end:845:2))"]
#[derive(Clone, Debug)]
struct addq_l_instructionVar447 {
    quick: u8,
    eal: Tableeal,
}
impl addq_l_instructionVar447 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("addq.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 5 {
                return None;
            }
            if token_2(tokens) != 2 {
                return None;
            }
            let quick = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (quick), pattern_len))
        };
        let ((), (quick), sub_len) = sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, quick }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:858:1, end:858:2))"]
#[derive(Clone, Debug)]
struct and_b_instructionVar448 {
    reg9dnb: u8,
    eab: Tableeab,
}
impl and_b_instructionVar448 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.reg9dnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 12 {
                return None;
            }
            if token_2(tokens) != 0 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnb = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnb), pattern_len))
        };
        let ((), (reg9dnb), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:859:1, end:859:2))"]
#[derive(Clone, Debug)]
struct and_w_instructionVar449 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl and_w_instructionVar449 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.reg9dnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 12 {
                return None;
            }
            if token_2(tokens) != 1 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:860:1, end:860:2))"]
#[derive(Clone, Debug)]
struct and_l_instructionVar450 {
    reg9dn: u8,
    eal: Tableeal,
}
impl and_l_instructionVar450 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 12 {
                return None;
            }
            if token_2(tokens) != 2 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:861:1, end:861:2))"]
#[derive(Clone, Debug)]
struct and_b_instructionVar451 {
    reg9dnb: u8,
    eab: Tableeab,
}
impl and_b_instructionVar451 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.reg9dnb),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 12 {
                return None;
            }
            if token_2(tokens) != 4 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnb = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnb), pattern_len))
        };
        let ((), (reg9dnb), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:862:1, end:862:2))"]
#[derive(Clone, Debug)]
struct and_w_instructionVar452 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl and_w_instructionVar452 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and.w"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.reg9dnw),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 12 {
                return None;
            }
            if token_2(tokens) != 5 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:863:1, end:863:2))"]
#[derive(Clone, Debug)]
struct and_l_instructionVar453 {
    reg9dn: u8,
    eal: Tableeal,
}
impl and_l_instructionVar453 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("and.l"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 12 {
                return None;
            }
            if token_2(tokens) != 6 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:902:1, end:902:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar454 {
    cc: Tablecc,
    addr16: Tableaddr16,
}
impl b_instructionVar454 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(".w"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.addr16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let addr16 = if let Some((len, table)) =
            Tableaddr16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc, addr16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:903:1, end:903:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar455 {
    cc: Tablecc,
    addr32: Tableaddr32,
}
impl b_instructionVar455 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(".l:"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.addr32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let addr32 = if let Some((len, table)) =
            Tableaddr32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc, addr32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:905:1, end:905:2))"]
#[derive(Clone, Debug)]
struct bchg_b_instructionVar456 {
    reg9dn: u8,
    eab: Tableeab,
}
impl bchg_b_instructionVar456 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bchg.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c36 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 0 {
                return None;
            }
            if token_2(tokens) != 5 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c36(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:917:1, end:917:2))"]
#[derive(Clone, Debug)]
struct bclr_b_instructionVar457 {
    reg9dn: u8,
    eab: Tableeab,
}
impl bclr_b_instructionVar457 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bclr.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 0 {
                return None;
            }
            if token_2(tokens) != 6 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:977:1, end:977:2))"]
#[derive(Clone, Debug)]
struct bra_b_instructionVar458 {
    addr8: Tableaddr8,
}
impl bra_b_instructionVar458 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bra.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addr8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let addr8 = if let Some((len, table)) =
            Tableaddr8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:981:1, end:981:2))"]
#[derive(Clone, Debug)]
struct bset_b_instructionVar459 {
    reg9dn: u8,
    eab: Tableeab,
}
impl bset_b_instructionVar459 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bset.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 0 {
                return None;
            }
            if token_2(tokens) != 7 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:986:1, end:986:2))"]
#[derive(Clone, Debug)]
struct bsr_b_instructionVar460 {
    addr8: Tableaddr8,
}
impl bsr_b_instructionVar460 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("bsr.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.addr8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let addr8 = if let Some((len, table)) =
            Tableaddr8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:990:1, end:990:2))"]
#[derive(Clone, Debug)]
struct btst_b_instructionVar461 {
    reg9dn: u8,
    eab: Tableeab,
}
impl btst_b_instructionVar461 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("btst.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 0 {
                return None;
            }
            if token_2(tokens) != 4 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1083:1, end:1083:2))"]
#[derive(Clone, Debug)]
struct chk_w_instructionVar462 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl chk_w_instructionVar462 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("chk.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.reg9dnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 4 {
                return None;
            }
            if token_2(tokens) != 6 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1095:1, end:1095:2))"]
#[derive(Clone, Debug)]
struct chk_l_instructionVar463 {
    reg9dn: u8,
    eal: Tableeal,
}
impl chk_l_instructionVar463 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("chk.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 4 {
                return None;
            }
            if token_2(tokens) != 4 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1216:1, end:1216:2))"]
#[derive(Clone, Debug)]
struct cmp_b_instructionVar464 {
    reg9dnb: u8,
    eab: Tableeab,
}
impl cmp_b_instructionVar464 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.reg9dnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 11 {
                return None;
            }
            if token_2(tokens) != 0 {
                return None;
            }
            let reg9dnb = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnb), pattern_len))
        };
        let ((), (reg9dnb), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1217:1, end:1217:2))"]
#[derive(Clone, Debug)]
struct cmp_w_instructionVar465 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl cmp_w_instructionVar465 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.reg9dnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 11 {
                return None;
            }
            if token_2(tokens) != 1 {
                return None;
            }
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1218:1, end:1218:2))"]
#[derive(Clone, Debug)]
struct cmp_l_instructionVar466 {
    reg9dn: u8,
    eal: Tableeal,
}
impl cmp_l_instructionVar466 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmp.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 11 {
                return None;
            }
            if token_2(tokens) != 2 {
                return None;
            }
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1220:1, end:1220:2))"]
#[derive(Clone, Debug)]
struct cmpa_w_instructionVar467 {
    reg9an: u8,
    eaw: Tableeaw,
}
impl cmpa_w_instructionVar467 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpa.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.reg9an),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 11 {
                return None;
            }
            if token_2(tokens) != 3 {
                return None;
            }
            let reg9an = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9an), pattern_len))
        };
        let ((), (reg9an), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1221:1, end:1221:2))"]
#[derive(Clone, Debug)]
struct cmpa_l_instructionVar468 {
    reg9an: u8,
    eal: Tableeal,
}
impl cmpa_l_instructionVar468 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("cmpa.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.reg9an),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 11 {
                return None;
            }
            if token_2(tokens) != 7 {
                return None;
            }
            let reg9an = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9an), pattern_len))
        };
        let ((), (reg9an), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2003:1, end:2003:2))"]
#[derive(Clone, Debug)]
struct trap_instructionVar469 {
    cc: Tablecc,
}
impl trap_instructionVar469 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trap"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2004:1, end:2004:2))"]
#[derive(Clone, Debug)]
struct trap_instructionVar470 {
    d16: u16,
    cc: Tablecc,
}
impl trap_instructionVar470 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trap"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(".w"),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc, d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2005:1, end:2005:2))"]
#[derive(Clone, Debug)]
struct trap_instructionVar471 {
    d32: u32,
    cc: Tablecc,
}
impl trap_instructionVar471 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("trap"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(".l"),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc, d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1240:1, end:1240:2))"]
#[derive(Clone, Debug)]
struct db_instructionVar472 {
    regdnw: u8,
    cc: Tablecc,
    addr16: Tableaddr16,
}
impl db_instructionVar472 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("db"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.regdnw),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.addr16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let addr16 = if let Some((len, table)) =
            Tableaddr16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { cc, addr16, regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1242:1, end:1242:2))"]
#[derive(Clone, Debug)]
struct divs_w_instructionVar473 {
    reg9dn: u8,
    eaw: Tableeaw,
}
impl divs_w_instructionVar473 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divs.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 8 {
                return None;
            }
            if token_2(tokens) != 7 {
                return None;
            }
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1245:1, end:1245:2))"]
#[derive(Clone, Debug)]
struct divu_w_instructionVar474 {
    reg9dn: u8,
    eaw: Tableeaw,
}
impl divu_w_instructionVar474 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("divu.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 8 {
                return None;
            }
            if token_2(tokens) != 3 {
                return None;
            }
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1279:1, end:1279:2))"]
#[derive(Clone, Debug)]
struct eor_b_instructionVar475 {
    reg9dnb: u8,
    eab: Tableeab,
}
impl eor_b_instructionVar475 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.reg9dnb),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 11 {
                return None;
            }
            if token_2(tokens) != 4 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnb = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnb), pattern_len))
        };
        let ((), (reg9dnb), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1280:1, end:1280:2))"]
#[derive(Clone, Debug)]
struct eor_w_instructionVar476 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl eor_w_instructionVar476 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor.w"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.reg9dnw),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 11 {
                return None;
            }
            if token_2(tokens) != 5 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1281:1, end:1281:2))"]
#[derive(Clone, Debug)]
struct eor_l_instructionVar477 {
    reg9dn: u8,
    eal: Tableeal,
}
impl eor_l_instructionVar477 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("eor.l"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 11 {
                return None;
            }
            if token_2(tokens) != 6 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1325:1, end:1325:2))"]
#[derive(Clone, Debug)]
struct lea_instructionVar478 {
    reg9an: u8,
    eaptr: Tableeaptr,
}
impl lea_instructionVar478 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("lea"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaptr
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.reg9an),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 4 {
                return None;
            }
            if token_2(tokens) != 7 {
                return None;
            }
            let reg9an = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9an), pattern_len))
        };
        let ((), (reg9an), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaptr = if let Some((len, table)) =
            Tableeaptr::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaptr, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1372:1, end:1372:2))"]
#[derive(Clone, Debug)]
struct movea_w_instructionVar479 {
    reg9an: u8,
    eaw: Tableeaw,
}
impl movea_w_instructionVar479 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movea.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.reg9an),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c25 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 3 {
                return None;
            }
            if token_2(tokens) != 1 {
                return None;
            }
            let reg9an = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9an), pattern_len))
        };
        let ((), (reg9an), sub_len) = sub_pattern_c25(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1373:1, end:1373:2))"]
#[derive(Clone, Debug)]
struct movea_l_instructionVar480 {
    reg9an: u8,
    eal: Tableeal,
}
impl movea_l_instructionVar480 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("movea.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.reg9an),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c25 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 2 {
                return None;
            }
            if token_2(tokens) != 1 {
                return None;
            }
            let reg9an = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9an), pattern_len))
        };
        let ((), (reg9an), sub_len) = sub_pattern_c25(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1676:1, end:1676:2))"]
#[derive(Clone, Debug)]
struct muls_w_instructionVar481 {
    reg9dn: u8,
    eaw: Tableeaw,
}
impl muls_w_instructionVar481 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("muls.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 12 {
                return None;
            }
            if token_2(tokens) != 7 {
                return None;
            }
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1679:1, end:1679:2))"]
#[derive(Clone, Debug)]
struct mulu_w_instructionVar482 {
    reg9dn: u8,
    eaw: Tableeaw,
}
impl mulu_w_instructionVar482 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("mulu.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 12 {
                return None;
            }
            if token_2(tokens) != 3 {
                return None;
            }
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1742:1, end:1742:2))"]
#[derive(Clone, Debug)]
struct or_b_instructionVar483 {
    reg9dnb: u8,
    eab: Tableeab,
}
impl or_b_instructionVar483 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.reg9dnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 8 {
                return None;
            }
            if token_2(tokens) != 0 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnb = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnb), pattern_len))
        };
        let ((), (reg9dnb), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1743:1, end:1743:2))"]
#[derive(Clone, Debug)]
struct or_w_instructionVar484 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl or_w_instructionVar484 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.reg9dnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 8 {
                return None;
            }
            if token_2(tokens) != 1 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1744:1, end:1744:2))"]
#[derive(Clone, Debug)]
struct or_l_instructionVar485 {
    reg9dn: u8,
    eal: Tableeal,
}
impl or_l_instructionVar485 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 8 {
                return None;
            }
            if token_2(tokens) != 2 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1746:1, end:1746:2))"]
#[derive(Clone, Debug)]
struct or_b_instructionVar486 {
    reg9dnb: u8,
    eab: Tableeab,
}
impl or_b_instructionVar486 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.reg9dnb),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 8 {
                return None;
            }
            if token_2(tokens) != 4 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnb = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnb), pattern_len))
        };
        let ((), (reg9dnb), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1747:1, end:1747:2))"]
#[derive(Clone, Debug)]
struct or_w_instructionVar487 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl or_w_instructionVar487 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or.w"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.reg9dnw),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 8 {
                return None;
            }
            if token_2(tokens) != 5 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1748:1, end:1748:2))"]
#[derive(Clone, Debug)]
struct or_l_instructionVar488 {
    reg9dn: u8,
    eal: Tableeal,
}
impl or_l_instructionVar488 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("or.l"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 8 {
                return None;
            }
            if token_2(tokens) != 6 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1941:1, end:1941:2))"]
#[derive(Clone, Debug)]
struct sub_b_instructionVar489 {
    reg9dnb: u8,
    eab: Tableeab,
}
impl sub_b_instructionVar489 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_3_display(self.reg9dnb),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 9 {
                return None;
            }
            if token_2(tokens) != 0 {
                return None;
            }
            let reg9dnb = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnb), pattern_len))
        };
        let ((), (reg9dnb), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1944:1, end:1944:2))"]
#[derive(Clone, Debug)]
struct sub_w_instructionVar490 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl sub_w_instructionVar490 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_2_display(self.reg9dnw),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 9 {
                return None;
            }
            if token_2(tokens) != 1 {
                return None;
            }
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1947:1, end:1947:2))"]
#[derive(Clone, Debug)]
struct sub_l_instructionVar491 {
    reg9dn: u8,
    eal: Tableeal,
}
impl sub_l_instructionVar491 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 9 {
                return None;
            }
            if token_2(tokens) != 2 {
                return None;
            }
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1950:1, end:1950:2))"]
#[derive(Clone, Debug)]
struct sub_b_instructionVar492 {
    reg9dnb: u8,
    eab: Tableeab,
}
impl sub_b_instructionVar492 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.b"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_3_display(self.reg9dnb),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 9 {
                return None;
            }
            if token_2(tokens) != 4 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnb = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnb), pattern_len))
        };
        let ((), (reg9dnb), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, reg9dnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1953:1, end:1953:2))"]
#[derive(Clone, Debug)]
struct sub_w_instructionVar493 {
    reg9dnw: u8,
    eaw: Tableeaw,
}
impl sub_w_instructionVar493 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.w"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_2_display(self.reg9dnw),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 9 {
                return None;
            }
            if token_2(tokens) != 5 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dnw = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dnw), pattern_len))
        };
        let ((), (reg9dnw), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9dnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1956:1, end:1956:2))"]
#[derive(Clone, Debug)]
struct sub_l_instructionVar494 {
    reg9dn: u8,
    eal: Tableeal,
}
impl sub_l_instructionVar494 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("sub.l"));
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            meaning_0_display(self.reg9dn),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c23 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 9 {
                return None;
            }
            if token_2(tokens) != 6 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            let reg9dn = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9dn), pattern_len))
        };
        let ((), (reg9dn), sub_len) = sub_pattern_c23(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1959:1, end:1959:2))"]
#[derive(Clone, Debug)]
struct suba_w_instructionVar495 {
    reg9an: u8,
    eaw: Tableeaw,
}
impl suba_w_instructionVar495 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("suba.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.reg9an),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 9 {
                return None;
            }
            if token_2(tokens) != 3 {
                return None;
            }
            let reg9an = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9an), pattern_len))
        };
        let ((), (reg9an), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1960:1, end:1960:2))"]
#[derive(Clone, Debug)]
struct suba_l_instructionVar496 {
    reg9an: u8,
    eal: Tableeal,
}
impl suba_l_instructionVar496 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("suba.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            meaning_5_display(self.reg9an),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c24 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 9 {
                return None;
            }
            if token_2(tokens) != 7 {
                return None;
            }
            let reg9an = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (reg9an), pattern_len))
        };
        let ((), (reg9an), sub_len) = sub_pattern_c24(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1971:1, end:1971:2))"]
#[derive(Clone, Debug)]
struct subq_b_instructionVar497 {
    quick: u8,
    eab: Tableeab,
}
impl subq_b_instructionVar497 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subq.b"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 5 {
                return None;
            }
            if token_2(tokens) != 4 {
                return None;
            }
            let quick = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (quick), pattern_len))
        };
        let ((), (quick), sub_len) = sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, quick }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1974:1, end:1974:2))"]
#[derive(Clone, Debug)]
struct subq_w_instructionVar498 {
    quick: u8,
    eaw: Tableeaw,
}
impl subq_w_instructionVar498 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subq.w"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 5 {
                return None;
            }
            if token_2(tokens) != 5 {
                return None;
            }
            let quick = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (quick), pattern_len))
        };
        let ((), (quick), sub_len) = sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, quick }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1977:1, end:1977:2))"]
#[derive(Clone, Debug)]
struct subq_l_instructionVar499 {
    quick: u8,
    eal: Tableeal,
}
impl subq_l_instructionVar499 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("subq.l"));
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c27 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 5 {
                return None;
            }
            if token_2(tokens) != 6 {
                return None;
            }
            let quick = token_5(tokens);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (quick), pattern_len))
        };
        let ((), (quick), sub_len) = sub_pattern_c27(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, quick }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2163:1, end:2163:2))"]
#[derive(Clone, Debug)]
struct fb_instructionVar500 {
    fcc: Tablefcc,
    addr16: Tableaddr16,
}
impl fb_instructionVar500 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fb"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(".w"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.addr16
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let addr16 = if let Some((len, table)) =
            Tableaddr16::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc, addr16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2164:1, end:2164:2))"]
#[derive(Clone, Debug)]
struct fb_instructionVar501 {
    fcc: Tablefcc,
    addr32: Tableaddr32,
}
impl fb_instructionVar501 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("fb"));
        self.fcc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(".l"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.addr32
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fcc = if let Some((len, table)) =
            Tablefcc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let addr32 = if let Some((len, table)) =
            Tableaddr32::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcc, addr32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1665:1, end:1665:2))"]
#[derive(Clone, Debug)]
struct moveq_instructionVar502 {
    d8base: u8,
    reg9dn: u8,
}
impl moveq_instructionVar502 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("moveq"));
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8base & 128 != 0 { -1 & !127 } else { 0 } | self.d8base as i8)
                    .is_negative(),
                (if self.d8base & 128 != 0 { -1 & !127 } else { 0 } | self.d8base as i8).abs()
                    as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_0_display(self.reg9dn),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dn = token_5(tokens_current);
        let d8base = token_27(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8base, reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1937:1, end:1937:2))"]
#[derive(Clone, Debug)]
struct s_instructionVar503 {
    eab: Tableeab,
    cc: Tablecc,
}
impl s_instructionVar503 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("s"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c16 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 5 {
                return None;
            }
            if token_18(tokens) != 3 {
                return None;
            }
            let cc = if let Some((len, table)) =
                Tablecc::parse(tokens, &mut context_instance, inst_start)
            {
                block_0_len = block_0_len.max(len as AddrType);
                table
            } else {
                return None;
            };
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_1(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_20(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_21(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((cc), (), pattern_len))
        };
        let ((mut cc), (), sub_len) = sub_pattern_c16(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:901:1, end:901:2))"]
#[derive(Clone, Debug)]
struct b_instructionVar504 {
    addr8: Tableaddr8,
    cc: Tablecc,
}
impl b_instructionVar504 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("b"));
        self.cc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(".b"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.addr8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let cc = if let Some((len, table)) =
            Tablecc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let addr8 = if let Some((len, table)) =
            Tableaddr8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { addr8, cc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1361:1, end:1361:2))"]
#[derive(Clone, Debug)]
struct move_b_instructionVar505 {
    eab: Tableeab,
    e2b: Tablee2b,
}
impl move_b_instructionVar505 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move.b"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eab
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2b
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 1 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_2(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_22(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_23(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eab = if let Some((len, table)) =
            Tableeab::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0;
        let e2b = if let Some((len, table)) =
            Tablee2b::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eab, e2b }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1362:1, end:1362:2))"]
#[derive(Clone, Debug)]
struct move_w_instructionVar506 {
    eaw: Tableeaw,
    e2w: Tablee2w,
}
impl move_w_instructionVar506 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move.w"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eaw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2w
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 3 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_2(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_22(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_23(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eaw = if let Some((len, table)) =
            Tableeaw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0;
        let e2w = if let Some((len, table)) =
            Tablee2w::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eaw, e2w }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1363:1, end:1363:2))"]
#[derive(Clone, Debug)]
struct move_l_instructionVar507 {
    eal: Tableeal,
    e2l: Tablee2l,
}
impl move_l_instructionVar507 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        display.push(DisplayElement::Literal("move.l"));
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(" ")];
        display.extend_from_slice(&extend);
        self.eal
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.e2l
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mut sub_pattern_c22 = |tokens: &[u8], context_param: &mut ContextMemory| {
            let mut pattern_len = 0;
            let mut context_instance = context_param.clone();
            let mut tokens = tokens;
            let mut block_0_len = 2;
            if token_6(tokens) != 2 {
                return None;
            }
            let mut sub_pattern_c1 = |tokens: &[u8], context_param: &mut ContextMemory| {
                let mut pattern_len = 0;
                let mut context_instance = context_param.clone();
                let mut tokens = tokens;
                let block_0 = |tokens_param: &[u8], context_param: &mut ContextMemory| {
                    if token_2(tokens_param) == 0 {
                        return Some(((), (), 2));
                    }
                    if token_22(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    if token_23(tokens_param) == 1 {
                        return Some(((), (), 2));
                    }
                    None
                };
                let ((), (), block_0_len) = block_0(tokens, &mut context_instance)?;
                pattern_len += block_0_len;
                tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
                *context_param = context_instance;
                Some(((), (), pattern_len))
            };
            let ((), (), sub_len) = sub_pattern_c1(tokens, &mut context_instance)?;
            block_0_len = block_0_len.max(sub_len);
            pattern_len += block_0_len;
            tokens = &tokens[usize::try_from(block_0_len).unwrap()..];
            *context_param = context_instance;
            Some(((), (), pattern_len))
        };
        let ((), (), sub_len) = sub_pattern_c22(tokens_current, &mut context_instance)?;
        block_0_len = block_0_len.max(sub_len);
        let eal = if let Some((len, table)) =
            Tableeal::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 0;
        let e2l = if let Some((len, table)) =
            Tablee2l::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { eal, e2l }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:815:1, end:815:2))"]
#[derive(Clone, Debug)]
struct instructionVar508 {
    regan: u8,
    mode: u8,
    reg9an: u8,
    mode2: u8,
    instruction: Box<Tableinstruction>,
}
impl instructionVar508 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.instruction
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_extGUARD(u8::try_from(1i128 & 1).unwrap());
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_savmod1(
            u8::try_from(i128::try_from(token_1(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_regtsan(
            u8::try_from(i128::try_from(token_5(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_savmod2(
            u8::try_from(i128::try_from(token_2(tokens_current)).unwrap() & 7).unwrap(),
        );
        let instruction = if let Some((len, table)) =
            Tableinstruction::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            Box::new(table)
        } else {
            return None;
        };
        let mode = token_1(tokens_current);
        let regan = token_3(tokens_current);
        let mode2 = token_2(tokens_current);
        let reg9an = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                instruction,
                regan,
                mode,
                reg9an,
                mode2,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tableinstruction {
    Var0(cas2_w_instructionVar0),
    Var1(cas2_l_instructionVar1),
    Var2(pflusha_instructionVar2),
    Var3(pflush_instructionVar3),
    Var4(andi_instructionVar4),
    Var5(andi_instructionVar5),
    Var6(pmove_l_instructionVar6),
    Var7(pmove_l_instructionVar7),
    Var8(pmovefd_l_instructionVar8),
    Var9(pmove_d_instructionVar9),
    Var10(pmove_d_instructionVar10),
    Var11(pmovefd_d_instructionVar11),
    Var12(pmove_d_instructionVar12),
    Var13(pmove_d_instructionVar13),
    Var14(pmovefd_d_instructionVar14),
    Var15(pmove_w_instructionVar15),
    Var16(pmove_w_instructionVar16),
    Var17(pmove_l_instructionVar17),
    Var18(pmove_l_instructionVar18),
    Var19(pmovefd_l_instructionVar19),
    Var20(pmove_l_instructionVar20),
    Var21(pmove_l_instructionVar21),
    Var22(pmovefd_l_instructionVar22),
    Var23(bfffo_instructionVar23),
    Var24(bra_w_instructionVar24),
    Var25(bra_l_instructionVar25),
    Var26(bsr_w_instructionVar26),
    Var27(bsr_l_instructionVar27),
    Var28(ploadr_instructionVar28),
    Var29(ploadw_instructionVar29),
    Var30(pflush_instructionVar30),
    Var31(chk2_b_instructionVar31),
    Var32(chk2_w_instructionVar32),
    Var33(chk2_l_instructionVar33),
    Var34(cmp2_b_instructionVar34),
    Var35(cmp2_w_instructionVar35),
    Var36(cmp2_l_instructionVar36),
    Var37(eori_instructionVar37),
    Var38(eori_instructionVar38),
    Var39(illegal_instructionVar39),
    Var40(jmp_instructionVar40),
    Var41(jmp_instructionVar41),
    Var42(jmp_instructionVar42),
    Var43(jmp_instructionVar43),
    Var44(jsr_instructionVar44),
    Var45(jsr_instructionVar45),
    Var46(jsr_instructionVar46),
    Var47(jsr_instructionVar47),
    Var48(movec_instructionVar48),
    Var49(movec_instructionVar49),
    Var50(movem_w_instructionVar50),
    Var51(movem_w_instructionVar51),
    Var52(movem_l_instructionVar52),
    Var53(movem_l_instructionVar53),
    Var54(movem_w_instructionVar54),
    Var55(movem_w_instructionVar55),
    Var56(movem_w_instructionVar56),
    Var57(movem_w_instructionVar57),
    Var58(movem_l_instructionVar58),
    Var59(movem_l_instructionVar59),
    Var60(movem_l_instructionVar60),
    Var61(movem_l_instructionVar61),
    Var62(nop_instructionVar62),
    Var63(ori_instructionVar63),
    Var64(ori_instructionVar64),
    Var65(ptestr_instructionVar65),
    Var66(ptestw_instructionVar66),
    Var67(ptestr_instructionVar67),
    Var68(ptestw_instructionVar68),
    Var69(reset_instructionVar69),
    Var70(rtd_instructionVar70),
    Var71(rte_instructionVar71),
    Var72(rtr_instructionVar72),
    Var73(rts_instructionVar73),
    Var74(stop_instructionVar74),
    Var75(trapv_instructionVar75),
    Var76(bchg_l_instructionVar76),
    Var77(bclr_l_instructionVar77),
    Var78(bfchg_instructionVar78),
    Var79(bfclr_instructionVar79),
    Var80(bfexts_instructionVar80),
    Var81(bfextu_instructionVar81),
    Var82(bfffo_instructionVar82),
    Var83(bfins_instructionVar83),
    Var84(bfset_instructionVar84),
    Var85(bftst_instructionVar85),
    Var86(bkpt_instructionVar86),
    Var87(bset_l_instructionVar87),
    Var88(btst_l_instructionVar88),
    Var89(callm_instructionVar89),
    Var90(ext_w_instructionVar90),
    Var91(ext_l_instructionVar91),
    Var92(extb_l_instructionVar92),
    Var93(jmp_instructionVar93),
    Var94(jmp_instructionVar94),
    Var95(jmp_instructionVar95),
    Var96(jsr_instructionVar96),
    Var97(jsr_instructionVar97),
    Var98(jsr_instructionVar98),
    Var99(link_w_instructionVar99),
    Var100(link_l_instructionVar100),
    Var101(move_instructionVar101),
    Var102(move_instructionVar102),
    Var103(movem_w_instructionVar103),
    Var104(movem_w_instructionVar104),
    Var105(movem_w_instructionVar105),
    Var106(movem_w_instructionVar106),
    Var107(movem_l_instructionVar107),
    Var108(movem_l_instructionVar108),
    Var109(movem_l_instructionVar109),
    Var110(movem_l_instructionVar110),
    Var111(movem_w_instructionVar111),
    Var112(movem_w_instructionVar112),
    Var113(movem_w_instructionVar113),
    Var114(movem_w_instructionVar114),
    Var115(movem_l_instructionVar115),
    Var116(movem_l_instructionVar116),
    Var117(movem_l_instructionVar117),
    Var118(movem_l_instructionVar118),
    Var119(pea_instructionVar119),
    Var120(rtm_instructionVar120),
    Var121(rtm_instructionVar121),
    Var122(swap_instructionVar122),
    Var123(unlk_instructionVar123),
    Var124(fnop_instructionVar124),
    Var125(fabs_instructionVar125),
    Var126(facos_instructionVar126),
    Var127(fadd_instructionVar127),
    Var128(fasin_instructionVar128),
    Var129(fatan_instructionVar129),
    Var130(fatanh_instructionVar130),
    Var131(fcmp_instructionVar131),
    Var132(fcos_instructionVar132),
    Var133(fcosh_instructionVar133),
    Var134(ftrap_instructionVar134),
    Var135(ftrap_instructionVar135),
    Var136(ftrap_instructionVar136),
    Var137(fdb_instructionVar137),
    Var138(fdiv_instructionVar138),
    Var139(fetox_instructionVar139),
    Var140(fetoxm1_instructionVar140),
    Var141(fgetexp_instructionVar141),
    Var142(fgetman_instructionVar142),
    Var143(fint_instructionVar143),
    Var144(fintrz_instructionVar144),
    Var145(flog10_instructionVar145),
    Var146(flog2_instructionVar146),
    Var147(flogn_instructionVar147),
    Var148(flognp1_instructionVar148),
    Var149(fmod_instructionVar149),
    Var150(fmove_instructionVar150),
    Var151(fmovecr_x_instructionVar151),
    Var152(fmovem_x_instructionVar152),
    Var153(fmovem_x_instructionVar153),
    Var154(fmovem_x_instructionVar154),
    Var155(fmovem_x_instructionVar155),
    Var156(fmovem_x_instructionVar156),
    Var157(fmovem_x_instructionVar157),
    Var158(fmovem_x_instructionVar158),
    Var159(fmovem_x_instructionVar159),
    Var160(fmovem_x_instructionVar160),
    Var161(fmovem_x_instructionVar161),
    Var162(fmul_instructionVar162),
    Var163(fneg_instructionVar163),
    Var164(frem_instructionVar164),
    Var165(fscale_instructionVar165),
    Var166(fsgldiv_instructionVar166),
    Var167(fsglmul_instructionVar167),
    Var168(fsin_instructionVar168),
    Var169(fsinh_instructionVar169),
    Var170(fsqrt_x_instructionVar170),
    Var171(fsub_x_instructionVar171),
    Var172(ftan_x_instructionVar172),
    Var173(ftanh_x_instructionVar173),
    Var174(ftentox_x_instructionVar174),
    Var175(ftst_x_instructionVar175),
    Var176(ftwotox_x_instructionVar176),
    Var177(fsincos_x_instructionVar177),
    Var178(addq_w_instructionVar178),
    Var179(addq_l_instructionVar179),
    Var180(bchg_l_instructionVar180),
    Var181(bclr_l_instructionVar181),
    Var182(bset_l_instructionVar182),
    Var183(btst_l_instructionVar183),
    Var184(cmpm_b_instructionVar184),
    Var185(cmpm_w_instructionVar185),
    Var186(cmpm_l_instructionVar186),
    Var187(exg_instructionVar187),
    Var188(exg_instructionVar188),
    Var189(exg_instructionVar189),
    Var190(movep_w_instructionVar190),
    Var191(movep_l_instructionVar191),
    Var192(movep_w_instructionVar192),
    Var193(movep_l_instructionVar193),
    Var194(pack_instructionVar194),
    Var195(pack_instructionVar195),
    Var196(subq_w_instructionVar196),
    Var197(subq_l_instructionVar197),
    Var198(trap_instructionVar198),
    Var199(unpk_instructionVar199),
    Var200(unpk_instructionVar200),
    Var201(frestore_instructionVar201),
    Var202(fsave_instructionVar202),
    Var203(abcd_instructionVar203),
    Var204(cas_b_instructionVar204),
    Var205(cas_w_instructionVar205),
    Var206(cas_l_instructionVar206),
    Var207(moves_b_instructionVar207),
    Var208(moves_w_instructionVar208),
    Var209(moves_b_instructionVar209),
    Var210(moves_w_instructionVar210),
    Var211(moves_b_instructionVar211),
    Var212(moves_w_instructionVar212),
    Var213(moves_l_instructionVar213),
    Var214(moves_l_instructionVar214),
    Var215(addi_b_instructionVar215),
    Var216(addi_w_instructionVar216),
    Var217(addi_l_instructionVar217),
    Var218(addx_b_instructionVar218),
    Var219(addx_w_instructionVar219),
    Var220(addx_l_instructionVar220),
    Var221(andi_b_instructionVar221),
    Var222(andi_w_instructionVar222),
    Var223(andi_l_instructionVar223),
    Var224(asl_b_instructionVar224),
    Var225(asl_w_instructionVar225),
    Var226(asl_l_instructionVar226),
    Var227(asl_instructionVar227),
    Var228(asr_b_instructionVar228),
    Var229(asr_w_instructionVar229),
    Var230(asr_l_instructionVar230),
    Var231(asr_instructionVar231),
    Var232(bchg_b_instructionVar232),
    Var233(bclr_b_instructionVar233),
    Var234(bset_b_instructionVar234),
    Var235(btst_b_instructionVar235),
    Var236(clr_b_instructionVar236),
    Var237(clr_w_instructionVar237),
    Var238(clr_l_instructionVar238),
    Var239(cmpi_b_instructionVar239),
    Var240(cmpi_w_instructionVar240),
    Var241(cmpi_l_instructionVar241),
    Var242(div_instructionVar242),
    Var243(eori_b_instructionVar243),
    Var244(eori_w_instructionVar244),
    Var245(eori_l_instructionVar245),
    Var246(lsl_b_instructionVar246),
    Var247(lsl_w_instructionVar247),
    Var248(lsl_l_instructionVar248),
    Var249(lsl_instructionVar249),
    Var250(lsr_b_instructionVar250),
    Var251(lsr_w_instructionVar251),
    Var252(lsr_l_instructionVar252),
    Var253(lsr_instructionVar253),
    Var254(move_instructionVar254),
    Var255(move_instructionVar255),
    Var256(move_instructionVar256),
    Var257(move_instructionVar257),
    Var258(mul_instructionVar258),
    Var259(nbcd_instructionVar259),
    Var260(neg_b_instructionVar260),
    Var261(neg_w_instructionVar261),
    Var262(neg_l_instructionVar262),
    Var263(negx_b_instructionVar263),
    Var264(negx_w_instructionVar264),
    Var265(negx_l_instructionVar265),
    Var266(not_b_instructionVar266),
    Var267(not_w_instructionVar267),
    Var268(not_l_instructionVar268),
    Var269(ori_b_instructionVar269),
    Var270(ori_w_instructionVar270),
    Var271(ori_l_instructionVar271),
    Var272(rol_b_instructionVar272),
    Var273(rol_w_instructionVar273),
    Var274(rol_l_instructionVar274),
    Var275(rol_instructionVar275),
    Var276(ror_b_instructionVar276),
    Var277(ror_w_instructionVar277),
    Var278(ror_l_instructionVar278),
    Var279(ror_instructionVar279),
    Var280(roxl_b_instructionVar280),
    Var281(roxl_w_instructionVar281),
    Var282(roxl_l_instructionVar282),
    Var283(roxl_instructionVar283),
    Var284(roxr_b_instructionVar284),
    Var285(roxr_w_instructionVar285),
    Var286(roxr_l_instructionVar286),
    Var287(roxr_instructionVar287),
    Var288(sbcd_instructionVar288),
    Var289(subi_b_instructionVar289),
    Var290(subi_w_instructionVar290),
    Var291(subi_l_instructionVar291),
    Var292(subx_b_instructionVar292),
    Var293(subx_w_instructionVar293),
    Var294(subx_l_instructionVar294),
    Var295(tas_instructionVar295),
    Var296(tst_b_instructionVar296),
    Var297(tst_w_instructionVar297),
    Var298(tst_l_instructionVar298),
    Var299(fmove_l_instructionVar299),
    Var300(fmove_l_instructionVar300),
    Var301(fmove_l_instructionVar301),
    Var302(fmove_l_instructionVar302),
    Var303(fmove_l_instructionVar303),
    Var304(fmove_l_instructionVar304),
    Var305(fabs__instructionVar305),
    Var306(fabs__instructionVar306),
    Var307(fabs__instructionVar307),
    Var308(facos__instructionVar308),
    Var309(facos__instructionVar309),
    Var310(facos__instructionVar310),
    Var311(fadd__instructionVar311),
    Var312(fadd__instructionVar312),
    Var313(fadd__instructionVar313),
    Var314(fasin__instructionVar314),
    Var315(fasin__instructionVar315),
    Var316(fasin__instructionVar316),
    Var317(fatan__instructionVar317),
    Var318(fatan__instructionVar318),
    Var319(fatan__instructionVar319),
    Var320(fatanh__instructionVar320),
    Var321(fatanh__instructionVar321),
    Var322(fatanh__instructionVar322),
    Var323(fcmp_b_instructionVar323),
    Var324(fcmp_w_instructionVar324),
    Var325(fcmp_l_instructionVar325),
    Var326(fcmp_s_instructionVar326),
    Var327(fcmp__instructionVar327),
    Var328(fcmp__instructionVar328),
    Var329(fcos__instructionVar329),
    Var330(fcos__instructionVar330),
    Var331(fcos__instructionVar331),
    Var332(fcosh__instructionVar332),
    Var333(fcosh__instructionVar333),
    Var334(fcosh__instructionVar334),
    Var335(fdiv__instructionVar335),
    Var336(fdiv__instructionVar336),
    Var337(fdiv__instructionVar337),
    Var338(fetox__instructionVar338),
    Var339(fetox__instructionVar339),
    Var340(fetox__instructionVar340),
    Var341(fetoxm1__instructionVar341),
    Var342(fetoxm1__instructionVar342),
    Var343(fetoxm1__instructionVar343),
    Var344(fgetexp__instructionVar344),
    Var345(fgetexp__instructionVar345),
    Var346(fgetexp__instructionVar346),
    Var347(fgetman__instructionVar347),
    Var348(fgetman__instructionVar348),
    Var349(fgetman__instructionVar349),
    Var350(fint__instructionVar350),
    Var351(fint__instructionVar351),
    Var352(fint__instructionVar352),
    Var353(fintrz__instructionVar353),
    Var354(fintrz__instructionVar354),
    Var355(fintrz__instructionVar355),
    Var356(flog10__instructionVar356),
    Var357(flog10__instructionVar357),
    Var358(flog10__instructionVar358),
    Var359(flog2__instructionVar359),
    Var360(flog2__instructionVar360),
    Var361(flog2__instructionVar361),
    Var362(flogn__instructionVar362),
    Var363(flogn__instructionVar363),
    Var364(flogn__instructionVar364),
    Var365(flognp1__instructionVar365),
    Var366(flognp1__instructionVar366),
    Var367(flognp1__instructionVar367),
    Var368(fmod__instructionVar368),
    Var369(fmod__instructionVar369),
    Var370(fmod__instructionVar370),
    Var371(fmove_b_instructionVar371),
    Var372(fmove_w_instructionVar372),
    Var373(fmove_l_instructionVar373),
    Var374(fmove_s_instructionVar374),
    Var375(fmove__instructionVar375),
    Var376(fmove_d_instructionVar376),
    Var377(fmul__instructionVar377),
    Var378(fmul__instructionVar378),
    Var379(fmul__instructionVar379),
    Var380(fneg__instructionVar380),
    Var381(fneg__instructionVar381),
    Var382(fneg__instructionVar382),
    Var383(frem__instructionVar383),
    Var384(frem__instructionVar384),
    Var385(frem__instructionVar385),
    Var386(fscale__instructionVar386),
    Var387(fscale__instructionVar387),
    Var388(fscale__instructionVar388),
    Var389(fs_instructionVar389),
    Var390(fsgldiv__instructionVar390),
    Var391(fsgldiv__instructionVar391),
    Var392(fsgldiv__instructionVar392),
    Var393(fsglmul__instructionVar393),
    Var394(fsglmul_s_instructionVar394),
    Var395(fsglmul__instructionVar395),
    Var396(fsglmul__instructionVar396),
    Var397(fsin__instructionVar397),
    Var398(fsin__instructionVar398),
    Var399(fsin__instructionVar399),
    Var400(fsinh__instructionVar400),
    Var401(fsinh__instructionVar401),
    Var402(fsinh__instructionVar402),
    Var403(fsqrt__instructionVar403),
    Var404(fsqrt__instructionVar404),
    Var405(fsqrt__instructionVar405),
    Var406(fsub__instructionVar406),
    Var407(fsub__instructionVar407),
    Var408(fsub__instructionVar408),
    Var409(ftan__instructionVar409),
    Var410(ftan__instructionVar410),
    Var411(ftan__instructionVar411),
    Var412(ftanh__instructionVar412),
    Var413(ftanh__instructionVar413),
    Var414(ftanh__instructionVar414),
    Var415(ftentox__instructionVar415),
    Var416(ftentox__instructionVar416),
    Var417(ftentox__instructionVar417),
    Var418(ftst__instructionVar418),
    Var419(ftst__instructionVar419),
    Var420(ftst__instructionVar420),
    Var421(ftwotox__instructionVar421),
    Var422(ftwotox__instructionVar422),
    Var423(ftwotox__instructionVar423),
    Var424(fsincos__instructionVar424),
    Var425(fsincos__instructionVar425),
    Var426(fsincos__instructionVar426),
    Var427(fmove_b_instructionVar427),
    Var428(fmove_w_instructionVar428),
    Var429(fmove_l_instructionVar429),
    Var430(fmove_s_instructionVar430),
    Var431(fmove__instructionVar431),
    Var432(fmove__instructionVar432),
    Var433(fmove_p_instructionVar433),
    Var434(fmove_p_instructionVar434),
    Var435(fmovem_l_instructionVar435),
    Var436(fmovem_l_instructionVar436),
    Var437(add_b_instructionVar437),
    Var438(add_w_instructionVar438),
    Var439(add_l_instructionVar439),
    Var440(add_b_instructionVar440),
    Var441(add_w_instructionVar441),
    Var442(add_l_instructionVar442),
    Var443(adda_w_instructionVar443),
    Var444(adda_l_instructionVar444),
    Var445(addq_b_instructionVar445),
    Var446(addq_w_instructionVar446),
    Var447(addq_l_instructionVar447),
    Var448(and_b_instructionVar448),
    Var449(and_w_instructionVar449),
    Var450(and_l_instructionVar450),
    Var451(and_b_instructionVar451),
    Var452(and_w_instructionVar452),
    Var453(and_l_instructionVar453),
    Var454(b_instructionVar454),
    Var455(b_instructionVar455),
    Var456(bchg_b_instructionVar456),
    Var457(bclr_b_instructionVar457),
    Var458(bra_b_instructionVar458),
    Var459(bset_b_instructionVar459),
    Var460(bsr_b_instructionVar460),
    Var461(btst_b_instructionVar461),
    Var462(chk_w_instructionVar462),
    Var463(chk_l_instructionVar463),
    Var464(cmp_b_instructionVar464),
    Var465(cmp_w_instructionVar465),
    Var466(cmp_l_instructionVar466),
    Var467(cmpa_w_instructionVar467),
    Var468(cmpa_l_instructionVar468),
    Var469(trap_instructionVar469),
    Var470(trap_instructionVar470),
    Var471(trap_instructionVar471),
    Var472(db_instructionVar472),
    Var473(divs_w_instructionVar473),
    Var474(divu_w_instructionVar474),
    Var475(eor_b_instructionVar475),
    Var476(eor_w_instructionVar476),
    Var477(eor_l_instructionVar477),
    Var478(lea_instructionVar478),
    Var479(movea_w_instructionVar479),
    Var480(movea_l_instructionVar480),
    Var481(muls_w_instructionVar481),
    Var482(mulu_w_instructionVar482),
    Var483(or_b_instructionVar483),
    Var484(or_w_instructionVar484),
    Var485(or_l_instructionVar485),
    Var486(or_b_instructionVar486),
    Var487(or_w_instructionVar487),
    Var488(or_l_instructionVar488),
    Var489(sub_b_instructionVar489),
    Var490(sub_w_instructionVar490),
    Var491(sub_l_instructionVar491),
    Var492(sub_b_instructionVar492),
    Var493(sub_w_instructionVar493),
    Var494(sub_l_instructionVar494),
    Var495(suba_w_instructionVar495),
    Var496(suba_l_instructionVar496),
    Var497(subq_b_instructionVar497),
    Var498(subq_w_instructionVar498),
    Var499(subq_l_instructionVar499),
    Var500(fb_instructionVar500),
    Var501(fb_instructionVar501),
    Var502(moveq_instructionVar502),
    Var503(s_instructionVar503),
    Var504(b_instructionVar504),
    Var505(move_b_instructionVar505),
    Var506(move_w_instructionVar506),
    Var507(move_l_instructionVar507),
    Var508(instructionVar508),
}
impl Tableinstruction {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var35(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var36(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var37(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var38(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var39(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var40(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var41(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var42(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var43(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var44(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var45(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var46(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var47(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var48(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var49(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var50(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var51(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var52(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var53(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var54(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var55(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var56(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var57(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var58(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var59(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var60(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var61(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var62(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var63(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var64(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var65(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var66(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var67(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var68(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var69(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var70(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var71(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var72(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var73(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var74(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var75(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var76(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var77(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var78(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var79(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var80(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var81(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var82(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var83(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var84(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var85(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var86(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var87(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var88(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var89(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var90(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var91(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var92(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var93(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var94(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var95(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var96(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var97(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var98(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var99(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var100(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var101(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var102(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var103(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var104(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var105(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var106(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var107(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var108(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var109(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var110(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var111(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var112(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var113(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var114(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var115(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var116(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var117(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var118(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var119(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var120(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var121(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var122(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var123(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var124(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var125(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var126(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var127(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var128(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var129(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var130(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var131(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var132(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var133(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var134(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var135(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var136(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var137(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var138(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var139(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var140(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var141(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var142(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var143(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var144(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var145(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var146(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var147(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var148(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var149(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var150(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var151(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var152(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var153(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var154(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var155(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var156(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var157(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var158(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var159(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var160(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var161(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var162(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var163(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var164(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var165(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var166(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var167(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var168(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var169(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var170(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var171(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var172(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var173(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var174(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var175(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var176(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var177(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var178(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var179(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var180(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var181(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var182(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var183(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var184(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var185(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var186(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var187(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var188(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var189(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var190(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var191(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var192(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var193(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var194(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var195(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var196(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var197(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var198(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var199(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var200(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var201(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var202(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var203(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var204(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var205(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var206(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var207(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var208(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var209(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var210(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var211(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var212(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var213(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var214(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var215(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var216(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var217(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var218(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var219(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var220(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var221(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var222(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var223(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var224(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var225(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var226(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var227(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var228(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var229(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var230(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var231(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var232(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var233(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var234(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var235(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var236(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var237(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var238(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var239(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var240(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var241(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var242(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var243(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var244(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var245(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var246(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var247(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var248(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var249(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var250(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var251(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var252(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var253(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var254(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var255(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var256(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var257(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var258(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var259(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var260(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var261(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var262(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var263(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var264(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var265(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var266(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var267(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var268(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var269(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var270(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var271(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var272(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var273(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var274(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var275(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var276(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var277(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var278(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var279(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var280(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var281(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var282(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var283(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var284(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var285(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var286(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var287(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var288(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var289(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var290(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var291(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var292(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var293(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var294(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var295(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var296(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var297(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var298(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var299(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var300(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var301(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var302(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var303(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var304(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var305(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var306(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var307(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var308(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var309(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var310(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var311(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var312(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var313(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var314(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var315(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var316(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var317(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var318(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var319(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var320(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var321(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var322(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var323(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var324(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var325(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var326(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var327(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var328(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var329(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var330(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var331(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var332(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var333(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var334(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var335(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var336(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var337(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var338(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var339(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var340(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var341(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var342(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var343(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var344(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var345(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var346(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var347(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var348(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var349(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var350(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var351(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var352(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var353(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var354(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var355(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var356(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var357(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var358(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var359(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var360(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var361(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var362(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var363(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var364(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var365(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var366(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var367(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var368(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var369(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var370(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var371(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var372(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var373(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var374(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var375(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var376(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var377(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var378(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var379(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var380(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var381(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var382(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var383(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var384(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var385(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var386(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var387(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var388(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var389(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var390(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var391(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var392(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var393(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var394(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var395(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var396(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var397(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var398(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var399(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var400(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var401(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var402(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var403(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var404(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var405(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var406(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var407(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var408(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var409(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var410(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var411(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var412(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var413(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var414(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var415(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var416(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var417(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var418(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var419(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var420(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var421(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var422(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var423(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var424(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var425(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var426(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var427(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var428(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var429(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var430(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var431(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var432(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var433(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var434(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var435(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var436(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var437(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var438(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var439(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var440(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var441(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var442(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var443(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var444(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var445(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var446(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var447(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var448(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var449(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var450(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var451(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var452(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var453(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var454(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var455(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var456(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var457(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var458(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var459(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var460(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var461(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var462(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var463(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var464(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var465(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var466(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var467(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var468(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var469(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var470(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var471(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var472(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var473(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var474(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var475(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var476(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var477(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var478(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var479(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var480(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var481(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var482(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var483(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var484(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var485(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var486(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var487(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var488(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var489(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var490(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var491(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var492(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var493(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var494(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var495(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var496(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var497(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var498(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var499(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var500(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var501(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var502(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var503(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var504(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var505(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var506(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var507(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var508(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 255) == 252
            && (tokens_param[2] & 14) == 0
            && (tokens_param[3] & 56) == 0
            && (tokens_param[4] & 14) == 0
            && (tokens_param[5] & 56) == 0
        {
            if let Some((inst_len, parsed)) =
                cas2_w_instructionVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 255) == 252
            && (tokens_param[2] & 14) == 0
            && (tokens_param[3] & 56) == 0
            && (tokens_param[4] & 14) == 0
            && (tokens_param[5] & 56) == 0
        {
            if let Some((inst_len, parsed)) =
                cas2_l_instructionVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 36
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pflusha_instructionVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 255) == 48
        {
            if let Some((inst_len, parsed)) =
                pflush_instructionVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 255) == 60
        {
            if let Some((inst_len, parsed)) =
                andi_instructionVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                andi_instructionVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 66
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_l_instructionVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 64
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_l_instructionVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 65
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmovefd_l_instructionVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 74
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_d_instructionVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 72
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_d_instructionVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 73
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmovefd_d_instructionVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 78
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_d_instructionVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 76
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_d_instructionVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 77
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmovefd_d_instructionVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 98
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_w_instructionVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 96
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_w_instructionVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 10
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_l_instructionVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 8
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_l_instructionVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 9
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmovefd_l_instructionVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 14
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_l_instructionVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 12
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmove_l_instructionVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 13
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                pmovefd_l_instructionVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 237
            && (tokens_param[1] & 192) == 192
            && (tokens_param[2] & 15) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                bfffo_instructionVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 96
            && (tokens_param[1] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                bra_w_instructionVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 96
            && (tokens_param[1] & 255) == 255
        {
            if let Some((inst_len, parsed)) =
                bra_l_instructionVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 97
            && (tokens_param[1] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                bsr_w_instructionVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 97
            && (tokens_param[1] & 255) == 255
        {
            if let Some((inst_len, parsed)) =
                bsr_l_instructionVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 34
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                ploadr_instructionVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 32
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                ploadw_instructionVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 56
        {
            if let Some((inst_len, parsed)) =
                pflush_instructionVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 192) == 192
            && (tokens_param[2] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                chk2_b_instructionVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 192) == 192
            && (tokens_param[2] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                chk2_w_instructionVar32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 192) == 192
            && (tokens_param[2] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                chk2_l_instructionVar33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 192) == 192
            && (tokens_param[2] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp2_b_instructionVar34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 192) == 192
            && (tokens_param[2] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp2_w_instructionVar35::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var35(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 192) == 192
            && (tokens_param[2] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp2_l_instructionVar36::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var36(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 255) == 60
        {
            if let Some((inst_len, parsed)) =
                eori_instructionVar37::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var37(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                eori_instructionVar38::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var38(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 74
            && (tokens_param[1] & 255) == 252
        {
            if let Some((inst_len, parsed)) =
                illegal_instructionVar39::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var39(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 250
        {
            if let Some((inst_len, parsed)) =
                jmp_instructionVar40::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var40(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 251
        {
            if let Some((inst_len, parsed)) =
                jmp_instructionVar41::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var41(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 248
        {
            if let Some((inst_len, parsed)) =
                jmp_instructionVar42::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var42(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 249
        {
            if let Some((inst_len, parsed)) =
                jmp_instructionVar43::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var43(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 186
        {
            if let Some((inst_len, parsed)) =
                jsr_instructionVar44::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var44(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 187
        {
            if let Some((inst_len, parsed)) =
                jsr_instructionVar45::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var45(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 184
        {
            if let Some((inst_len, parsed)) =
                jsr_instructionVar46::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var46(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 185
        {
            if let Some((inst_len, parsed)) =
                jsr_instructionVar47::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var47(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 122
        {
            if let Some((inst_len, parsed)) =
                movec_instructionVar48::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var48(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 123
        {
            if let Some((inst_len, parsed)) =
                movec_instructionVar49::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var49(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 255) == 184
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar50::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var50(parsed)));
            }
        }
        if tokens_param.len() >= 8
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 255) == 185
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar51::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var51(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 255) == 248
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar52::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var52(parsed)));
            }
        }
        if tokens_param.len() >= 8
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 255) == 249
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar53::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var53(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 255) == 186
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar54::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var54(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 255) == 187
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar55::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var55(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 255) == 184
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar56::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var56(parsed)));
            }
        }
        if tokens_param.len() >= 8
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 255) == 185
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar57::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var57(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 255) == 250
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar58::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var58(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 255) == 251
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar59::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var59(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 255) == 248
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar60::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var60(parsed)));
            }
        }
        if tokens_param.len() >= 8
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 255) == 249
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar61::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var61(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 113
        {
            if let Some((inst_len, parsed)) =
                nop_instructionVar62::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var62(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 60
        {
            if let Some((inst_len, parsed)) =
                ori_instructionVar63::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var63(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 255) == 124
        {
            if let Some((inst_len, parsed)) =
                ori_instructionVar64::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var64(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 227) == 130
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                ptestr_instructionVar65::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var65(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 227) == 128
            && (tokens_param[3] & 224) == 0
        {
            if let Some((inst_len, parsed)) =
                ptestw_instructionVar66::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var66(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 227) == 131
        {
            if let Some((inst_len, parsed)) =
                ptestr_instructionVar67::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var67(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 227) == 129
        {
            if let Some((inst_len, parsed)) =
                ptestw_instructionVar68::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var68(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 112
        {
            if let Some((inst_len, parsed)) =
                reset_instructionVar69::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var69(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 116
        {
            if let Some((inst_len, parsed)) =
                rtd_instructionVar70::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var70(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 115
        {
            if let Some((inst_len, parsed)) =
                rte_instructionVar71::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var71(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 119
        {
            if let Some((inst_len, parsed)) =
                rtr_instructionVar72::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var72(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 117
        {
            if let Some((inst_len, parsed)) =
                rts_instructionVar73::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var73(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 114
        {
            if let Some((inst_len, parsed)) =
                stop_instructionVar74::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var74(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 255) == 118
        {
            if let Some((inst_len, parsed)) =
                trapv_instructionVar75::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var75(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 248) == 64
        {
            if let Some((inst_len, parsed)) =
                bchg_l_instructionVar76::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var76(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                bclr_l_instructionVar77::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var77(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 234
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                bfchg_instructionVar78::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var78(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 236
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                bfclr_instructionVar79::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var79(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 235
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                bfexts_instructionVar80::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var80(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 233
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                bfextu_instructionVar81::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var81(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 237
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                bfffo_instructionVar82::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var82(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 239
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                bfins_instructionVar83::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var83(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 238
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                bfset_instructionVar84::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var84(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 232
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                bftst_instructionVar85::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var85(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                bkpt_instructionVar86::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var86(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                bset_l_instructionVar87::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var87(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 248) == 0
        {
            if let Some((inst_len, parsed)) =
                btst_l_instructionVar88::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var88(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                callm_instructionVar89::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var89(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                ext_w_instructionVar90::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var90(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                ext_l_instructionVar91::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var91(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 73
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                extb_l_instructionVar92::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var92(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 248) == 208
        {
            if let Some((inst_len, parsed)) =
                jmp_instructionVar93::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var93(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                jmp_instructionVar94::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var94(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                jmp_instructionVar95::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var95(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                jsr_instructionVar96::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var96(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 248) == 168
        {
            if let Some((inst_len, parsed)) =
                jsr_instructionVar97::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var97(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 248) == 176
        {
            if let Some((inst_len, parsed)) =
                jsr_instructionVar98::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var98(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 248) == 80
        {
            if let Some((inst_len, parsed)) =
                link_w_instructionVar99::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var99(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                link_l_instructionVar100::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var100(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 248) == 104
        {
            if let Some((inst_len, parsed)) =
                move_instructionVar101::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var101(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 248) == 96
        {
            if let Some((inst_len, parsed)) =
                move_instructionVar102::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var102(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar103::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var103(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 160
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar104::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var104(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 168
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar105::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var105(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 176
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar106::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var106(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 208
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar107::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var107(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 224
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar108::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var108(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar109::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var109(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar110::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var110(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 248) == 144
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar111::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var111(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 248) == 152
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar112::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var112(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 248) == 168
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar113::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var113(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 248) == 176
        {
            if let Some((inst_len, parsed)) =
                movem_w_instructionVar114::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var114(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 248) == 208
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar115::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var115(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 248) == 216
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar116::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var116(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 248) == 232
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar117::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var117(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 248) == 240
        {
            if let Some((inst_len, parsed)) =
                movem_l_instructionVar118::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var118(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                pea_instructionVar119::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var119(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                rtm_instructionVar120::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var120(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 248) == 200
        {
            if let Some((inst_len, parsed)) =
                rtm_instructionVar121::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var121(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 248) == 64
        {
            if let Some((inst_len, parsed)) =
                swap_instructionVar122::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var122(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 248) == 88
        {
            if let Some((inst_len, parsed)) =
                unlk_instructionVar123::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var123(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 128
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                fnop_instructionVar124::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var124(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 24
        {
            if let Some((inst_len, parsed)) =
                fabs_instructionVar125::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var125(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 28
        {
            if let Some((inst_len, parsed)) =
                facos_instructionVar126::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var126(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 34
        {
            if let Some((inst_len, parsed)) =
                fadd_instructionVar127::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var127(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 12
        {
            if let Some((inst_len, parsed)) =
                fasin_instructionVar128::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var128(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 10
        {
            if let Some((inst_len, parsed)) =
                fatan_instructionVar129::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var129(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 13
        {
            if let Some((inst_len, parsed)) =
                fatanh_instructionVar130::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var130(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 56
        {
            if let Some((inst_len, parsed)) =
                fcmp_instructionVar131::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var131(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 29
        {
            if let Some((inst_len, parsed)) =
                fcos_instructionVar132::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var132(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 25
        {
            if let Some((inst_len, parsed)) =
                fcosh_instructionVar133::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var133(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 122
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                ftrap_instructionVar134::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var134(parsed)));
            }
        }
        if tokens_param.len() >= 8
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 123
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                ftrap_instructionVar135::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var135(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 124
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                ftrap_instructionVar136::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var136(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 248) == 72
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                fdb_instructionVar137::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var137(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 32
        {
            if let Some((inst_len, parsed)) =
                fdiv_instructionVar138::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var138(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 16
        {
            if let Some((inst_len, parsed)) =
                fetox_instructionVar139::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var139(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 8
        {
            if let Some((inst_len, parsed)) =
                fetoxm1_instructionVar140::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var140(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 30
        {
            if let Some((inst_len, parsed)) =
                fgetexp_instructionVar141::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var141(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 31
        {
            if let Some((inst_len, parsed)) =
                fgetman_instructionVar142::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var142(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 1
        {
            if let Some((inst_len, parsed)) =
                fint_instructionVar143::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var143(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 3
        {
            if let Some((inst_len, parsed)) =
                fintrz_instructionVar144::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var144(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 21
        {
            if let Some((inst_len, parsed)) =
                flog10_instructionVar145::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var145(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 22
        {
            if let Some((inst_len, parsed)) =
                flog2_instructionVar146::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var146(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 20
        {
            if let Some((inst_len, parsed)) =
                flogn_instructionVar147::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var147(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 6
        {
            if let Some((inst_len, parsed)) =
                flognp1_instructionVar148::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var148(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 33
        {
            if let Some((inst_len, parsed)) =
                fmod_instructionVar149::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var149(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_instructionVar150::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var150(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 252) == 92
        {
            if let Some((inst_len, parsed)) =
                fmovecr_x_instructionVar151::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var151(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 240
        {
            if let Some((inst_len, parsed)) =
                fmovem_x_instructionVar152::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var152(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 248) == 24
            && (tokens_param[2] & 255) == 240
        {
            if let Some((inst_len, parsed)) =
                fmovem_x_instructionVar153::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var153(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 248) == 32
            && (tokens_param[2] & 255) == 224
        {
            if let Some((inst_len, parsed)) =
                fmovem_x_instructionVar154::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var154(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 208
        {
            if let Some((inst_len, parsed)) =
                fmovem_x_instructionVar155::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var155(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 248) == 24
            && (tokens_param[2] & 255) == 208
        {
            if let Some((inst_len, parsed)) =
                fmovem_x_instructionVar156::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var156(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 248) == 32
            && (tokens_param[2] & 255) == 192
        {
            if let Some((inst_len, parsed)) =
                fmovem_x_instructionVar157::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var157(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 248
        {
            if let Some((inst_len, parsed)) =
                fmovem_x_instructionVar158::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var158(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 248) == 32
            && (tokens_param[2] & 255) == 232
        {
            if let Some((inst_len, parsed)) =
                fmovem_x_instructionVar159::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var159(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 216
        {
            if let Some((inst_len, parsed)) =
                fmovem_x_instructionVar160::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var160(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 248) == 32
            && (tokens_param[2] & 255) == 200
        {
            if let Some((inst_len, parsed)) =
                fmovem_x_instructionVar161::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var161(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 35
        {
            if let Some((inst_len, parsed)) =
                fmul_instructionVar162::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var162(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 26
        {
            if let Some((inst_len, parsed)) =
                fneg_instructionVar163::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var163(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 37
        {
            if let Some((inst_len, parsed)) =
                frem_instructionVar164::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var164(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 38
        {
            if let Some((inst_len, parsed)) =
                fscale_instructionVar165::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var165(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 36
        {
            if let Some((inst_len, parsed)) =
                fsgldiv_instructionVar166::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var166(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 39
        {
            if let Some((inst_len, parsed)) =
                fsglmul_instructionVar167::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var167(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 14
        {
            if let Some((inst_len, parsed)) =
                fsin_instructionVar168::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var168(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 2
        {
            if let Some((inst_len, parsed)) =
                fsinh_instructionVar169::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var169(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 4
        {
            if let Some((inst_len, parsed)) =
                fsqrt_x_instructionVar170::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var170(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 40
        {
            if let Some((inst_len, parsed)) =
                fsub_x_instructionVar171::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var171(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 15
        {
            if let Some((inst_len, parsed)) =
                ftan_x_instructionVar172::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var172(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 9
        {
            if let Some((inst_len, parsed)) =
                ftanh_x_instructionVar173::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var173(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 18
        {
            if let Some((inst_len, parsed)) =
                ftentox_x_instructionVar174::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var174(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 58
        {
            if let Some((inst_len, parsed)) =
                ftst_x_instructionVar175::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var175(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 127) == 17
        {
            if let Some((inst_len, parsed)) =
                ftwotox_x_instructionVar176::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var176(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 255) == 0
            && (tokens_param[2] & 224) == 0
            && (tokens_param[3] & 120) == 48
        {
            if let Some((inst_len, parsed)) =
                fsincos_x_instructionVar177::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var177(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 80
            && (tokens_param[1] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                addq_w_instructionVar178::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var178(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 80
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                addq_l_instructionVar179::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var179(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 248) == 64
        {
            if let Some((inst_len, parsed)) =
                bchg_l_instructionVar180::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var180(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                bclr_l_instructionVar181::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var181(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 248) == 192
        {
            if let Some((inst_len, parsed)) =
                bset_l_instructionVar182::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var182(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 248) == 0
        {
            if let Some((inst_len, parsed)) =
                btst_l_instructionVar183::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var183(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 177
            && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                cmpm_b_instructionVar184::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var184(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 177
            && (tokens_param[1] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                cmpm_w_instructionVar185::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var185(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 177
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                cmpm_l_instructionVar186::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var186(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 193
            && (tokens_param[1] & 248) == 64
        {
            if let Some((inst_len, parsed)) =
                exg_instructionVar187::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var187(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 193
            && (tokens_param[1] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                exg_instructionVar188::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var188(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 193
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                exg_instructionVar189::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var189(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 248) == 8
        {
            if let Some((inst_len, parsed)) =
                movep_w_instructionVar190::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var190(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                movep_l_instructionVar191::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var191(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                movep_w_instructionVar192::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var192(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 248) == 200
        {
            if let Some((inst_len, parsed)) =
                movep_l_instructionVar193::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var193(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 129
            && (tokens_param[1] & 248) == 64
        {
            if let Some((inst_len, parsed)) =
                pack_instructionVar194::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var194(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 129
            && (tokens_param[1] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                pack_instructionVar195::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var195(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 81
            && (tokens_param[1] & 248) == 72
        {
            if let Some((inst_len, parsed)) =
                subq_w_instructionVar196::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var196(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 81
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                subq_l_instructionVar197::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var197(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 78
            && (tokens_param[1] & 240) == 64
        {
            if let Some((inst_len, parsed)) =
                trap_instructionVar198::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var198(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 129
            && (tokens_param[1] & 248) == 128
        {
            if let Some((inst_len, parsed)) =
                unpk_instructionVar199::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var199(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 129
            && (tokens_param[1] & 248) == 136
        {
            if let Some((inst_len, parsed)) =
                unpk_instructionVar200::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var200(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 241
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                frestore_instructionVar201::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var201(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 241
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                fsave_instructionVar202::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var202(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 193
            && (tokens_param[1] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                abcd_instructionVar203::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var203(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 192) == 192
            && (tokens_param[2] & 254) == 0
            && (tokens_param[3] & 56) == 0
        {
            if let Some((inst_len, parsed)) =
                cas_b_instructionVar204::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var204(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 192) == 192
            && (tokens_param[2] & 254) == 0
            && (tokens_param[3] & 56) == 0
        {
            if let Some((inst_len, parsed)) =
                cas_w_instructionVar205::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var205(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 192) == 192
            && (tokens_param[2] & 254) == 0
            && (tokens_param[3] & 56) == 0
        {
            if let Some((inst_len, parsed)) =
                cas_l_instructionVar206::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var206(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 136) == 0
        {
            if let Some((inst_len, parsed)) =
                moves_b_instructionVar207::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var207(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 192) == 64
            && (tokens_param[2] & 136) == 0
        {
            if let Some((inst_len, parsed)) =
                moves_w_instructionVar208::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var208(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 136) == 128
        {
            if let Some((inst_len, parsed)) =
                moves_b_instructionVar209::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var209(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 192) == 64
            && (tokens_param[2] & 136) == 128
        {
            if let Some((inst_len, parsed)) =
                moves_w_instructionVar210::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var210(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                moves_b_instructionVar211::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var211(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 192) == 64
            && (tokens_param[2] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                moves_w_instructionVar212::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var212(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 192) == 128
            && (tokens_param[2] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                moves_l_instructionVar213::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var213(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 14
            && (tokens_param[1] & 192) == 128
            && (tokens_param[2] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                moves_l_instructionVar214::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var214(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                addi_b_instructionVar215::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var215(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                addi_w_instructionVar216::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var216(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 6
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                addi_l_instructionVar217::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var217(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 209
            && (tokens_param[1] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                addx_b_instructionVar218::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var218(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 209
            && (tokens_param[1] & 240) == 64
        {
            if let Some((inst_len, parsed)) =
                addx_w_instructionVar219::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var219(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 209
            && (tokens_param[1] & 240) == 128
        {
            if let Some((inst_len, parsed)) =
                addx_l_instructionVar220::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var220(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                andi_b_instructionVar221::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var221(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                andi_w_instructionVar222::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var222(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 2
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                andi_l_instructionVar223::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var223(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 0
        {
            if let Some((inst_len, parsed)) =
                asl_b_instructionVar224::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var224(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 64
        {
            if let Some((inst_len, parsed)) =
                asl_w_instructionVar225::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var225(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 128
        {
            if let Some((inst_len, parsed)) =
                asl_l_instructionVar226::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var226(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 225
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                asl_instructionVar227::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var227(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 0
        {
            if let Some((inst_len, parsed)) =
                asr_b_instructionVar228::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var228(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 64
        {
            if let Some((inst_len, parsed)) =
                asr_w_instructionVar229::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var229(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 128
        {
            if let Some((inst_len, parsed)) =
                asr_l_instructionVar230::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var230(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 224
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                asr_instructionVar231::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var231(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                bchg_b_instructionVar232::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var232(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                bclr_b_instructionVar233::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var233(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                bset_b_instructionVar234::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var234(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 8
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                btst_b_instructionVar235::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var235(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                clr_b_instructionVar236::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var236(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                clr_w_instructionVar237::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var237(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                clr_l_instructionVar238::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var238(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                cmpi_b_instructionVar239::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var239(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                cmpi_w_instructionVar240::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var240(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 12
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                cmpi_l_instructionVar241::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var241(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                div_instructionVar242::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var242(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                eori_b_instructionVar243::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var243(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                eori_w_instructionVar244::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var244(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 10
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                eori_l_instructionVar245::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var245(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 8
        {
            if let Some((inst_len, parsed)) =
                lsl_b_instructionVar246::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var246(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 72
        {
            if let Some((inst_len, parsed)) =
                lsl_w_instructionVar247::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var247(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 136
        {
            if let Some((inst_len, parsed)) =
                lsl_l_instructionVar248::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var248(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 227
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                lsl_instructionVar249::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var249(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 8
        {
            if let Some((inst_len, parsed)) =
                lsr_b_instructionVar250::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var250(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 72
        {
            if let Some((inst_len, parsed)) =
                lsr_w_instructionVar251::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var251(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 136
        {
            if let Some((inst_len, parsed)) =
                lsr_l_instructionVar252::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var252(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 226
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                lsr_instructionVar253::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var253(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 66
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                move_instructionVar254::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var254(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                move_instructionVar255::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var255(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                move_instructionVar256::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var256(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                move_instructionVar257::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var257(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 76
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                mul_instructionVar258::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var258(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 72
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                nbcd_instructionVar259::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var259(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                neg_b_instructionVar260::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var260(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                neg_w_instructionVar261::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var261(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 68
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                neg_l_instructionVar262::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var262(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                negx_b_instructionVar263::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var263(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                negx_w_instructionVar264::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var264(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 64
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                negx_l_instructionVar265::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var265(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                not_b_instructionVar266::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var266(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                not_w_instructionVar267::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var267(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 70
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                not_l_instructionVar268::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var268(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                ori_b_instructionVar269::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var269(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                ori_w_instructionVar270::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var270(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 0
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                ori_l_instructionVar271::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var271(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 24
        {
            if let Some((inst_len, parsed)) =
                rol_b_instructionVar272::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var272(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 88
        {
            if let Some((inst_len, parsed)) =
                rol_w_instructionVar273::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var273(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 152
        {
            if let Some((inst_len, parsed)) =
                rol_l_instructionVar274::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var274(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 231
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                rol_instructionVar275::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var275(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 24
        {
            if let Some((inst_len, parsed)) =
                ror_b_instructionVar276::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var276(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 88
        {
            if let Some((inst_len, parsed)) =
                ror_w_instructionVar277::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var277(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 152
        {
            if let Some((inst_len, parsed)) =
                ror_l_instructionVar278::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var278(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 230
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                ror_instructionVar279::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var279(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 16
        {
            if let Some((inst_len, parsed)) =
                roxl_b_instructionVar280::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var280(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 80
        {
            if let Some((inst_len, parsed)) =
                roxl_w_instructionVar281::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var281(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 225
            && (tokens_param[1] & 216) == 144
        {
            if let Some((inst_len, parsed)) =
                roxl_l_instructionVar282::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var282(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 229
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                roxl_instructionVar283::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var283(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 16
        {
            if let Some((inst_len, parsed)) =
                roxr_b_instructionVar284::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var284(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 80
        {
            if let Some((inst_len, parsed)) =
                roxr_w_instructionVar285::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var285(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 224
            && (tokens_param[1] & 216) == 144
        {
            if let Some((inst_len, parsed)) =
                roxr_l_instructionVar286::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var286(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 228
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                roxr_instructionVar287::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var287(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 129
            && (tokens_param[1] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                sbcd_instructionVar288::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var288(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                subi_b_instructionVar289::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var289(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                subi_w_instructionVar290::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var290(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 4
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                subi_l_instructionVar291::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var291(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 145
            && (tokens_param[1] & 240) == 0
        {
            if let Some((inst_len, parsed)) =
                subx_b_instructionVar292::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var292(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 145
            && (tokens_param[1] & 240) == 64
        {
            if let Some((inst_len, parsed)) =
                subx_w_instructionVar293::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var293(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 145
            && (tokens_param[1] & 240) == 128
        {
            if let Some((inst_len, parsed)) =
                subx_l_instructionVar294::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var294(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 74
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                tas_instructionVar295::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var295(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 74
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                tst_b_instructionVar296::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var296(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 74
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                tst_w_instructionVar297::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var297(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 74
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                tst_l_instructionVar298::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var298(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 144
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_l_instructionVar299::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var299(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 176
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_l_instructionVar300::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var300(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 136
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_l_instructionVar301::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var301(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 168
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_l_instructionVar302::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var302(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 132
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_l_instructionVar303::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var303(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 255) == 164
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_l_instructionVar304::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var304(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 24
        {
            if let Some((inst_len, parsed)) =
                fabs__instructionVar305::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var305(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 24
        {
            if let Some((inst_len, parsed)) =
                fabs__instructionVar306::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var306(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 24
        {
            if let Some((inst_len, parsed)) =
                fabs__instructionVar307::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var307(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 28
        {
            if let Some((inst_len, parsed)) =
                facos__instructionVar308::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var308(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 28
        {
            if let Some((inst_len, parsed)) =
                facos__instructionVar309::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var309(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 28
        {
            if let Some((inst_len, parsed)) =
                facos__instructionVar310::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var310(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 34
        {
            if let Some((inst_len, parsed)) =
                fadd__instructionVar311::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var311(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 34
        {
            if let Some((inst_len, parsed)) =
                fadd__instructionVar312::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var312(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 34
        {
            if let Some((inst_len, parsed)) =
                fadd__instructionVar313::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var313(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 12
        {
            if let Some((inst_len, parsed)) =
                fasin__instructionVar314::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var314(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 12
        {
            if let Some((inst_len, parsed)) =
                fasin__instructionVar315::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var315(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 12
        {
            if let Some((inst_len, parsed)) =
                fasin__instructionVar316::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var316(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 10
        {
            if let Some((inst_len, parsed)) =
                fatan__instructionVar317::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var317(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 10
        {
            if let Some((inst_len, parsed)) =
                fatan__instructionVar318::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var318(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 10
        {
            if let Some((inst_len, parsed)) =
                fatan__instructionVar319::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var319(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 13
        {
            if let Some((inst_len, parsed)) =
                fatanh__instructionVar320::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var320(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 13
        {
            if let Some((inst_len, parsed)) =
                fatanh__instructionVar321::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var321(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 13
        {
            if let Some((inst_len, parsed)) =
                fatanh__instructionVar322::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var322(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 88
            && (tokens_param[3] & 127) == 56
        {
            if let Some((inst_len, parsed)) =
                fcmp_b_instructionVar323::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var323(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 80
            && (tokens_param[3] & 127) == 56
        {
            if let Some((inst_len, parsed)) =
                fcmp_w_instructionVar324::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var324(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 64
            && (tokens_param[3] & 127) == 56
        {
            if let Some((inst_len, parsed)) =
                fcmp_l_instructionVar325::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var325(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 68
            && (tokens_param[3] & 127) == 56
        {
            if let Some((inst_len, parsed)) =
                fcmp_s_instructionVar326::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var326(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 56
        {
            if let Some((inst_len, parsed)) =
                fcmp__instructionVar327::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var327(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 56
        {
            if let Some((inst_len, parsed)) =
                fcmp__instructionVar328::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var328(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 29
        {
            if let Some((inst_len, parsed)) =
                fcos__instructionVar329::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var329(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 29
        {
            if let Some((inst_len, parsed)) =
                fcos__instructionVar330::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var330(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 29
        {
            if let Some((inst_len, parsed)) =
                fcos__instructionVar331::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var331(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 25
        {
            if let Some((inst_len, parsed)) =
                fcosh__instructionVar332::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var332(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 25
        {
            if let Some((inst_len, parsed)) =
                fcosh__instructionVar333::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var333(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 25
        {
            if let Some((inst_len, parsed)) =
                fcosh__instructionVar334::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var334(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 32
        {
            if let Some((inst_len, parsed)) =
                fdiv__instructionVar335::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var335(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 32
        {
            if let Some((inst_len, parsed)) =
                fdiv__instructionVar336::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var336(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 32
        {
            if let Some((inst_len, parsed)) =
                fdiv__instructionVar337::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var337(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 16
        {
            if let Some((inst_len, parsed)) =
                fetox__instructionVar338::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var338(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 16
        {
            if let Some((inst_len, parsed)) =
                fetox__instructionVar339::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var339(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 16
        {
            if let Some((inst_len, parsed)) =
                fetox__instructionVar340::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var340(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 8
        {
            if let Some((inst_len, parsed)) =
                fetoxm1__instructionVar341::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var341(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 8
        {
            if let Some((inst_len, parsed)) =
                fetoxm1__instructionVar342::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var342(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 8
        {
            if let Some((inst_len, parsed)) =
                fetoxm1__instructionVar343::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var343(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 30
        {
            if let Some((inst_len, parsed)) =
                fgetexp__instructionVar344::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var344(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 30
        {
            if let Some((inst_len, parsed)) =
                fgetexp__instructionVar345::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var345(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 30
        {
            if let Some((inst_len, parsed)) =
                fgetexp__instructionVar346::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var346(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 31
        {
            if let Some((inst_len, parsed)) =
                fgetman__instructionVar347::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var347(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 31
        {
            if let Some((inst_len, parsed)) =
                fgetman__instructionVar348::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var348(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 31
        {
            if let Some((inst_len, parsed)) =
                fgetman__instructionVar349::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var349(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 1
        {
            if let Some((inst_len, parsed)) =
                fint__instructionVar350::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var350(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 1
        {
            if let Some((inst_len, parsed)) =
                fint__instructionVar351::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var351(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 1
        {
            if let Some((inst_len, parsed)) =
                fint__instructionVar352::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var352(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 3
        {
            if let Some((inst_len, parsed)) =
                fintrz__instructionVar353::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var353(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 3
        {
            if let Some((inst_len, parsed)) =
                fintrz__instructionVar354::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var354(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 3
        {
            if let Some((inst_len, parsed)) =
                fintrz__instructionVar355::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var355(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 21
        {
            if let Some((inst_len, parsed)) =
                flog10__instructionVar356::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var356(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 21
        {
            if let Some((inst_len, parsed)) =
                flog10__instructionVar357::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var357(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 21
        {
            if let Some((inst_len, parsed)) =
                flog10__instructionVar358::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var358(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 22
        {
            if let Some((inst_len, parsed)) =
                flog2__instructionVar359::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var359(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 22
        {
            if let Some((inst_len, parsed)) =
                flog2__instructionVar360::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var360(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 22
        {
            if let Some((inst_len, parsed)) =
                flog2__instructionVar361::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var361(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 20
        {
            if let Some((inst_len, parsed)) =
                flogn__instructionVar362::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var362(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 20
        {
            if let Some((inst_len, parsed)) =
                flogn__instructionVar363::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var363(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 20
        {
            if let Some((inst_len, parsed)) =
                flogn__instructionVar364::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var364(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 6
        {
            if let Some((inst_len, parsed)) =
                flognp1__instructionVar365::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var365(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 6
        {
            if let Some((inst_len, parsed)) =
                flognp1__instructionVar366::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var366(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 6
        {
            if let Some((inst_len, parsed)) =
                flognp1__instructionVar367::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var367(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 33
        {
            if let Some((inst_len, parsed)) =
                fmod__instructionVar368::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var368(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 33
        {
            if let Some((inst_len, parsed)) =
                fmod__instructionVar369::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var369(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 33
        {
            if let Some((inst_len, parsed)) =
                fmod__instructionVar370::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var370(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 88
            && (tokens_param[3] & 127) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_b_instructionVar371::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var371(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 80
            && (tokens_param[3] & 127) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_w_instructionVar372::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var372(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 64
            && (tokens_param[3] & 127) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_l_instructionVar373::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var373(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 68
            && (tokens_param[3] & 127) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_s_instructionVar374::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var374(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove__instructionVar375::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var375(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 0
        {
            if let Some((inst_len, parsed)) =
                fmove_d_instructionVar376::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var376(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 35
        {
            if let Some((inst_len, parsed)) =
                fmul__instructionVar377::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var377(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 35
        {
            if let Some((inst_len, parsed)) =
                fmul__instructionVar378::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var378(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 35
        {
            if let Some((inst_len, parsed)) =
                fmul__instructionVar379::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var379(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 26
        {
            if let Some((inst_len, parsed)) =
                fneg__instructionVar380::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var380(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 26
        {
            if let Some((inst_len, parsed)) =
                fneg__instructionVar381::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var381(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 26
        {
            if let Some((inst_len, parsed)) =
                fneg__instructionVar382::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var382(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 37
        {
            if let Some((inst_len, parsed)) =
                frem__instructionVar383::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var383(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 37
        {
            if let Some((inst_len, parsed)) =
                frem__instructionVar384::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var384(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 37
        {
            if let Some((inst_len, parsed)) =
                frem__instructionVar385::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var385(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 38
        {
            if let Some((inst_len, parsed)) =
                fscale__instructionVar386::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var386(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 38
        {
            if let Some((inst_len, parsed)) =
                fscale__instructionVar387::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var387(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 38
        {
            if let Some((inst_len, parsed)) =
                fscale__instructionVar388::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var388(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 64
            && (tokens_param[2] & 255) == 0
            && (tokens_param[3] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                fs_instructionVar389::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var389(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 36
        {
            if let Some((inst_len, parsed)) =
                fsgldiv__instructionVar390::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var390(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 36
        {
            if let Some((inst_len, parsed)) =
                fsgldiv__instructionVar391::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var391(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 36
        {
            if let Some((inst_len, parsed)) =
                fsgldiv__instructionVar392::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var392(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 228) == 64
            && (tokens_param[3] & 127) == 39
        {
            if let Some((inst_len, parsed)) =
                fsglmul__instructionVar393::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var393(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 68
            && (tokens_param[3] & 127) == 39
        {
            if let Some((inst_len, parsed)) =
                fsglmul_s_instructionVar394::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var394(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 39
        {
            if let Some((inst_len, parsed)) =
                fsglmul__instructionVar395::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var395(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 39
        {
            if let Some((inst_len, parsed)) =
                fsglmul__instructionVar396::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var396(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 14
        {
            if let Some((inst_len, parsed)) =
                fsin__instructionVar397::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var397(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 14
        {
            if let Some((inst_len, parsed)) =
                fsin__instructionVar398::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var398(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 14
        {
            if let Some((inst_len, parsed)) =
                fsin__instructionVar399::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var399(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 2
        {
            if let Some((inst_len, parsed)) =
                fsinh__instructionVar400::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var400(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 2
        {
            if let Some((inst_len, parsed)) =
                fsinh__instructionVar401::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var401(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 2
        {
            if let Some((inst_len, parsed)) =
                fsinh__instructionVar402::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var402(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 4
        {
            if let Some((inst_len, parsed)) =
                fsqrt__instructionVar403::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var403(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 4
        {
            if let Some((inst_len, parsed)) =
                fsqrt__instructionVar404::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var404(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 4
        {
            if let Some((inst_len, parsed)) =
                fsqrt__instructionVar405::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var405(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 40
        {
            if let Some((inst_len, parsed)) =
                fsub__instructionVar406::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var406(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 40
        {
            if let Some((inst_len, parsed)) =
                fsub__instructionVar407::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var407(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 40
        {
            if let Some((inst_len, parsed)) =
                fsub__instructionVar408::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var408(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 15
        {
            if let Some((inst_len, parsed)) =
                ftan__instructionVar409::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var409(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 15
        {
            if let Some((inst_len, parsed)) =
                ftan__instructionVar410::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var410(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 15
        {
            if let Some((inst_len, parsed)) =
                ftan__instructionVar411::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var411(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 9
        {
            if let Some((inst_len, parsed)) =
                ftanh__instructionVar412::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var412(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 9
        {
            if let Some((inst_len, parsed)) =
                ftanh__instructionVar413::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var413(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 9
        {
            if let Some((inst_len, parsed)) =
                ftanh__instructionVar414::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var414(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 18
        {
            if let Some((inst_len, parsed)) =
                ftentox__instructionVar415::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var415(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 18
        {
            if let Some((inst_len, parsed)) =
                ftentox__instructionVar416::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var416(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 18
        {
            if let Some((inst_len, parsed)) =
                ftentox__instructionVar417::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var417(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 58
        {
            if let Some((inst_len, parsed)) =
                ftst__instructionVar418::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var418(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 58
        {
            if let Some((inst_len, parsed)) =
                ftst__instructionVar419::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var419(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 58
        {
            if let Some((inst_len, parsed)) =
                ftst__instructionVar420::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var420(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 127) == 17
        {
            if let Some((inst_len, parsed)) =
                ftwotox__instructionVar421::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var421(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 127) == 17
        {
            if let Some((inst_len, parsed)) =
                ftwotox__instructionVar422::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var422(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 127) == 17
        {
            if let Some((inst_len, parsed)) =
                ftwotox__instructionVar423::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var423(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 224) == 64
            && (tokens_param[3] & 120) == 48
        {
            if let Some((inst_len, parsed)) =
                fsincos__instructionVar424::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var424(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 248) == 72
            && (tokens_param[3] & 120) == 48
        {
            if let Some((inst_len, parsed)) =
                fsincos__instructionVar425::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var425(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 84
            && (tokens_param[3] & 120) == 48
        {
            if let Some((inst_len, parsed)) =
                fsincos__instructionVar426::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var426(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 120
        {
            if let Some((inst_len, parsed)) =
                fmove_b_instructionVar427::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var427(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 112
        {
            if let Some((inst_len, parsed)) =
                fmove_w_instructionVar428::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var428(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 96
        {
            if let Some((inst_len, parsed)) =
                fmove_l_instructionVar429::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var429(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 100
        {
            if let Some((inst_len, parsed)) =
                fmove_s_instructionVar430::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var430(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 104
        {
            if let Some((inst_len, parsed)) =
                fmove__instructionVar431::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var431(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 116
        {
            if let Some((inst_len, parsed)) =
                fmove__instructionVar432::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var432(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 108
        {
            if let Some((inst_len, parsed)) =
                fmove_p_instructionVar433::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var433(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 252) == 124
        {
            if let Some((inst_len, parsed)) =
                fmove_p_instructionVar434::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var434(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 227) == 160
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                fmovem_l_instructionVar435::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var435(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 0
            && (tokens_param[2] & 227) == 128
            && (tokens_param[3] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                fmovem_l_instructionVar436::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var436(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 208
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                add_b_instructionVar437::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var437(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 208
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                add_w_instructionVar438::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var438(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 208
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                add_l_instructionVar439::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var439(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 209
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                add_b_instructionVar440::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var440(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 209
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                add_w_instructionVar441::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var441(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 209
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                add_l_instructionVar442::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var442(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 208
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                adda_w_instructionVar443::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var443(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 209
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                adda_l_instructionVar444::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var444(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 80
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                addq_b_instructionVar445::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var445(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 80
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                addq_w_instructionVar446::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var446(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 80
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                addq_l_instructionVar447::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var447(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 192
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                and_b_instructionVar448::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var448(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 192
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                and_w_instructionVar449::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var449(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 192
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                and_l_instructionVar450::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var450(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 193
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                and_b_instructionVar451::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var451(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 193
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                and_w_instructionVar452::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var452(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 193
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                and_l_instructionVar453::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var453(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 96
            && (tokens_param[1] & 255) == 0
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar454::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var454(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 96
            && (tokens_param[1] & 255) == 255
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar455::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var455(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                bchg_b_instructionVar456::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var456(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                bclr_b_instructionVar457::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var457(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 96
        {
            if let Some((inst_len, parsed)) =
                bra_b_instructionVar458::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var458(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                bset_b_instructionVar459::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var459(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 255) == 97
        {
            if let Some((inst_len, parsed)) =
                bsr_b_instructionVar460::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var460(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 1
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                btst_b_instructionVar461::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var461(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 65
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                chk_w_instructionVar462::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var462(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 65
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                chk_l_instructionVar463::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var463(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 176
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                cmp_b_instructionVar464::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var464(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 176
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                cmp_w_instructionVar465::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var465(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 176
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                cmp_l_instructionVar466::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var466(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 176
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                cmpa_w_instructionVar467::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var467(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 177
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                cmpa_l_instructionVar468::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var468(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 80
            && (tokens_param[1] & 255) == 252
        {
            if let Some((inst_len, parsed)) =
                trap_instructionVar469::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var469(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 80
            && (tokens_param[1] & 255) == 250
        {
            if let Some((inst_len, parsed)) =
                trap_instructionVar470::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var470(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 80
            && (tokens_param[1] & 255) == 251
        {
            if let Some((inst_len, parsed)) =
                trap_instructionVar471::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var471(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 80
            && (tokens_param[1] & 248) == 200
        {
            if let Some((inst_len, parsed)) =
                db_instructionVar472::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var472(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 129
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                divs_w_instructionVar473::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var473(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 128
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                divu_w_instructionVar474::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var474(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 177
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                eor_b_instructionVar475::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var475(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 177
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                eor_w_instructionVar476::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var476(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 177
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                eor_l_instructionVar477::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var477(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 65
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                lea_instructionVar478::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var478(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 48
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                movea_w_instructionVar479::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var479(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 32
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                movea_l_instructionVar480::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var480(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 193
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                muls_w_instructionVar481::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var481(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 192
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                mulu_w_instructionVar482::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var482(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 128
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                or_b_instructionVar483::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var483(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 128
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                or_w_instructionVar484::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var484(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 128
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                or_l_instructionVar485::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var485(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 129
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                or_b_instructionVar486::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var486(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 129
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                or_w_instructionVar487::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var487(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 129
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                or_l_instructionVar488::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var488(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 144
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                sub_b_instructionVar489::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var489(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 144
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                sub_w_instructionVar490::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var490(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 144
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                sub_l_instructionVar491::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var491(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 145
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                sub_b_instructionVar492::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var492(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 145
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                sub_w_instructionVar493::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var493(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 145
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                sub_l_instructionVar494::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var494(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 144
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                suba_w_instructionVar495::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var495(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 145
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                suba_l_instructionVar496::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var496(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 81
            && (tokens_param[1] & 192) == 0
        {
            if let Some((inst_len, parsed)) =
                subq_b_instructionVar497::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var497(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 81
            && (tokens_param[1] & 192) == 64
        {
            if let Some((inst_len, parsed)) =
                subq_w_instructionVar498::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var498(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 81
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                subq_l_instructionVar499::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var499(parsed)));
            }
        }
        if tokens_param.len() >= 4
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 128
        {
            if let Some((inst_len, parsed)) =
                fb_instructionVar500::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var500(parsed)));
            }
        }
        if tokens_param.len() >= 6
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 240
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                fb_instructionVar501::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var501(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 241) == 112
        {
            if let Some((inst_len, parsed)) =
                moveq_instructionVar502::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var502(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 80
            && (tokens_param[1] & 192) == 192
        {
            if let Some((inst_len, parsed)) =
                s_instructionVar503::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var503(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 96
        {
            if let Some((inst_len, parsed)) =
                b_instructionVar504::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var504(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 16
        {
            if let Some((inst_len, parsed)) =
                move_b_instructionVar505::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var505(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 48
        {
            if let Some((inst_len, parsed)) =
                move_w_instructionVar506::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var506(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 240) == 32
        {
            if let Some((inst_len, parsed)) =
                move_l_instructionVar507::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var507(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 0 {
            if let Some((inst_len, parsed)) =
                instructionVar508::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var508(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:350:1, end:350:9))"]
#[derive(Clone, Debug)]
struct ea_indexVar0 {
    regxan: u8,
    scale: u8,
}
impl ea_indexVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            meaning_5_display(self.regxan),
            <DisplayElement>::Literal("*"),
            meaning_9_display(true, self.scale),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let scale = token_33(tokens_current);
        let regxan = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regxan, scale }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:351:1, end:351:9))"]
#[derive(Clone, Debug)]
struct ea_indexVar1 {
    regxanw: u8,
    scale: u8,
}
impl ea_indexVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            meaning_6_display(self.regxanw),
            <DisplayElement>::Literal("*"),
            meaning_9_display(true, self.scale),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regxanw = token_30(tokens_current);
        let scale = token_33(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regxanw, scale }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:352:1, end:352:9))"]
#[derive(Clone, Debug)]
struct ea_indexVar2 {
    regxdn: u8,
    scale: u8,
}
impl ea_indexVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            meaning_0_display(self.regxdn),
            <DisplayElement>::Literal("*"),
            meaning_9_display(true, self.scale),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regxdn = token_30(tokens_current);
        let scale = token_33(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regxdn, scale }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:353:1, end:353:9))"]
#[derive(Clone, Debug)]
struct ea_indexVar3 {
    regxdnw: u8,
    scale: u8,
}
impl ea_indexVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            meaning_2_display(self.regxdnw),
            <DisplayElement>::Literal("*"),
            meaning_9_display(true, self.scale),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regxdnw = token_30(tokens_current);
        let scale = token_33(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regxdnw, scale }))
    }
}
#[derive(Clone, Debug)]
enum Tableea_index {
    Var0(ea_indexVar0),
    Var1(ea_indexVar1),
    Var2(ea_indexVar2),
    Var3(ea_indexVar3),
}
impl Tableea_index {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 136) == 136 {
            if let Some((inst_len, parsed)) =
                ea_indexVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 136) == 128 {
            if let Some((inst_len, parsed)) =
                ea_indexVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 136) == 8 {
            if let Some((inst_len, parsed)) =
                ea_indexVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 136) == 0 {
            if let Some((inst_len, parsed)) =
                ea_indexVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:356:1, end:356:5))"]
#[derive(Clone, Debug)]
struct bregVar0 {}
impl bregVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_5_display(context.read_regfan())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:357:1, end:357:5))"]
#[derive(Clone, Debug)]
struct bregVar1 {}
impl bregVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_5_display(context.read_regsan())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablebreg {
    Var0(bregVar0),
    Var1(bregVar1),
}
impl Tablebreg {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 1 == 0 {
            if let Some((inst_len, parsed)) =
                bregVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1 == 1 {
            if let Some((inst_len, parsed)) =
                bregVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:361:1, end:361:8))"]
#[derive(Clone, Debug)]
struct fl_bregVar0 {}
impl fl_bregVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ZPC")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:362:1, end:362:8))"]
#[derive(Clone, Debug)]
struct fl_bregVar1 {
    breg: Tablebreg,
}
impl fl_bregVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.breg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let breg = if let Some((len, table)) =
            Tablebreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { breg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:363:1, end:363:8))"]
#[derive(Clone, Debug)]
struct fl_bregVar2 {}
impl fl_bregVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::PC)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:360:1, end:360:8))"]
#[derive(Clone, Debug)]
struct fl_bregVar3 {}
impl fl_bregVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("-")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefl_breg {
    Var0(fl_bregVar0),
    Var1(fl_bregVar1),
    Var2(fl_bregVar2),
    Var3(fl_bregVar3),
}
impl Tablefl_breg {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 2 == 2 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                fl_bregVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 2 == 0 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                fl_bregVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 2 == 2 && (tokens_param[1] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                fl_bregVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                fl_bregVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:366:1, end:366:7))"]
#[derive(Clone, Debug)]
struct cntregVar0 {
    reg9dn: u8,
}
impl cntregVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.reg9dn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dn = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:367:1, end:367:7))"]
#[derive(Clone, Debug)]
struct cntregVar1 {
    quick: u8,
}
impl cntregVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            meaning_10_display(true, self.quick),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let quick = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { quick }))
    }
}
#[derive(Clone, Debug)]
enum Tablecntreg {
    Var0(cntregVar0),
    Var1(cntregVar1),
}
impl Tablecntreg {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                cntregVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                cntregVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:372:1, end:372:5))"]
#[derive(Clone, Debug)]
struct extwVar0 {
    d8: u8,
    ea_index: Tableea_index,
}
impl extwVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_rela: i128 = 0;
        calc_rela = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(
                i128::try_from((if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8))
                    .unwrap(),
            )
            .wrapping_add(2i128);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Number(true, calc_rela.is_negative(), calc_rela.abs() as u64),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_rela: i128 = 0;
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        calc_rela = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(i128::try_from(token_27(tokens_current)).unwrap())
            .wrapping_add(2i128);
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_index, d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:376:1, end:376:5))"]
#[derive(Clone, Debug)]
struct extwVar1 {
    fl_breg: Tablefl_breg,
    ea_index: Tableea_index,
}
impl extwVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fl_breg, ea_index }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:377:1, end:377:5))"]
#[derive(Clone, Debug)]
struct extwVar2 {
    bd16: u16,
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ea_index,
                fl_breg,
                bd16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:378:1, end:378:5))"]
#[derive(Clone, Debug)]
struct extwVar3 {
    bd32: u32,
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ea_index,
                fl_breg,
                bd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:380:1, end:380:5))"]
#[derive(Clone, Debug)]
struct extwVar4 {
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ea_index, fl_breg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:381:1, end:381:5))"]
#[derive(Clone, Debug)]
struct extwVar5 {
    bd16: u16,
    fl_breg: Tablefl_breg,
    ea_index: Tableea_index,
}
impl extwVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                ea_index,
                bd16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:382:1, end:382:5))"]
#[derive(Clone, Debug)]
struct extwVar6 {
    bd32: u32,
    fl_breg: Tablefl_breg,
    ea_index: Tableea_index,
}
impl extwVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                ea_index,
                bd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:383:1, end:383:5))"]
#[derive(Clone, Debug)]
struct extwVar7 {
    od16: u16,
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .is_negative(),
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let od16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ea_index,
                fl_breg,
                od16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:384:1, end:384:5))"]
#[derive(Clone, Debug)]
struct extwVar8 {
    bd16: u16,
    od16: u16,
    fl_breg: Tablefl_breg,
    ea_index: Tableea_index,
}
impl extwVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .is_negative(),
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let od16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                ea_index,
                bd16,
                od16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:385:1, end:385:5))"]
#[derive(Clone, Debug)]
struct extwVar9 {
    bd32: u32,
    od16: u16,
    fl_breg: Tablefl_breg,
    ea_index: Tableea_index,
}
impl extwVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .is_negative(),
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let od16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                ea_index,
                bd32,
                od16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:386:1, end:386:5))"]
#[derive(Clone, Debug)]
struct extwVar10 {
    od32: u32,
    fl_breg: Tablefl_breg,
    ea_index: Tableea_index,
}
impl extwVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .is_negative(),
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let od32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                ea_index,
                od32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:387:1, end:387:5))"]
#[derive(Clone, Debug)]
struct extwVar11 {
    bd16: u16,
    od32: u32,
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .is_negative(),
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let od32 = token_53(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ea_index,
                fl_breg,
                bd16,
                od32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:388:1, end:388:5))"]
#[derive(Clone, Debug)]
struct extwVar12 {
    bd32: u32,
    od32: u32,
    fl_breg: Tablefl_breg,
    ea_index: Tableea_index,
}
impl extwVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("],")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(","),
            DisplayElement::Number(
                true,
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .is_negative(),
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let od32 = token_53(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                ea_index,
                bd32,
                od32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:390:1, end:390:5))"]
#[derive(Clone, Debug)]
struct extwVar13 {
    fl_breg: Tablefl_breg,
    ea_index: Tableea_index,
}
impl extwVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fl_breg, ea_index }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:391:1, end:391:5))"]
#[derive(Clone, Debug)]
struct extwVar14 {
    bd16: u16,
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ea_index,
                fl_breg,
                bd16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:392:1, end:392:5))"]
#[derive(Clone, Debug)]
struct extwVar15 {
    bd32: u32,
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ea_index,
                fl_breg,
                bd32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:393:1, end:393:5))"]
#[derive(Clone, Debug)]
struct extwVar16 {
    od16: u16,
    fl_breg: Tablefl_breg,
    ea_index: Tableea_index,
}
impl extwVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .is_negative(),
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let od16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                ea_index,
                od16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:394:1, end:394:5))"]
#[derive(Clone, Debug)]
struct extwVar17 {
    bd16: u16,
    od16: u16,
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .is_negative(),
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let od16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ea_index,
                fl_breg,
                bd16,
                od16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:395:1, end:395:5))"]
#[derive(Clone, Debug)]
struct extwVar18 {
    bd32: u32,
    od16: u16,
    fl_breg: Tablefl_breg,
    ea_index: Tableea_index,
}
impl extwVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .is_negative(),
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let od16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                ea_index,
                bd32,
                od16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:396:1, end:396:5))"]
#[derive(Clone, Debug)]
struct extwVar19 {
    od32: u32,
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .is_negative(),
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let od32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ea_index,
                fl_breg,
                od32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:397:1, end:397:5))"]
#[derive(Clone, Debug)]
struct extwVar20 {
    bd16: u16,
    od32: u32,
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .is_negative(),
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let od32 = token_53(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ea_index,
                fl_breg,
                bd16,
                od32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:398:1, end:398:5))"]
#[derive(Clone, Debug)]
struct extwVar21 {
    bd32: u32,
    od32: u32,
    ea_index: Tableea_index,
    fl_breg: Tablefl_breg,
}
impl extwVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .is_negative(),
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let od32 = token_53(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                ea_index,
                fl_breg,
                bd32,
                od32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:400:1, end:400:5))"]
#[derive(Clone, Debug)]
struct extwVar22 {
    fl_breg: Tablefl_breg,
}
impl extwVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fl_breg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:401:1, end:401:5))"]
#[derive(Clone, Debug)]
struct extwVar23 {
    bd16: u16,
    fl_breg: Tablefl_breg,
}
impl extwVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fl_breg, bd16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:402:1, end:402:5))"]
#[derive(Clone, Debug)]
struct extwVar24 {
    bd32: u32,
    fl_breg: Tablefl_breg,
}
impl extwVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fl_breg, bd32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:404:1, end:404:5))"]
#[derive(Clone, Debug)]
struct extwVar25 {
    fl_breg: Tablefl_breg,
}
impl extwVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fl_breg }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:405:1, end:405:5))"]
#[derive(Clone, Debug)]
struct extwVar26 {
    bd16: u16,
    fl_breg: Tablefl_breg,
}
impl extwVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fl_breg, bd16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:406:1, end:406:5))"]
#[derive(Clone, Debug)]
struct extwVar27 {
    bd32: u32,
    fl_breg: Tablefl_breg,
}
impl extwVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("]")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fl_breg, bd32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:407:1, end:407:5))"]
#[derive(Clone, Debug)]
struct extwVar28 {
    od16: u16,
    fl_breg: Tablefl_breg,
}
impl extwVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .is_negative(),
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let od16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fl_breg, od16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:408:1, end:408:5))"]
#[derive(Clone, Debug)]
struct extwVar29 {
    bd16: u16,
    od16: u16,
    fl_breg: Tablefl_breg,
}
impl extwVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .is_negative(),
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let od16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                bd16,
                od16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:409:1, end:409:5))"]
#[derive(Clone, Debug)]
struct extwVar30 {
    bd32: u32,
    od16: u16,
    fl_breg: Tablefl_breg,
}
impl extwVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .is_negative(),
                (if self.od16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.od16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 2;
        let od16 = token_11(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                bd32,
                od16,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:410:1, end:410:5))"]
#[derive(Clone, Debug)]
struct extwVar31 {
    od32: u32,
    fl_breg: Tablefl_breg,
}
impl extwVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("[")];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .is_negative(),
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let od32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fl_breg, od32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:411:1, end:411:5))"]
#[derive(Clone, Debug)]
struct extwVar32 {
    bd16: u16,
    od32: u32,
    fl_breg: Tablefl_breg,
}
impl extwVar32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .is_negative(),
                (if self.bd16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.bd16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .is_negative(),
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let bd16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let od32 = token_53(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                bd16,
                od32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:412:1, end:412:5))"]
#[derive(Clone, Debug)]
struct extwVar33 {
    bd32: u32,
    od32: u32,
    fl_breg: Tablefl_breg,
}
impl extwVar33 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("["),
            DisplayElement::Number(
                true,
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .is_negative(),
                (if self.bd32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.bd32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.fl_breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("],"),
            DisplayElement::Number(
                true,
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .is_negative(),
                (if self.od32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.od32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fl_breg = if let Some((len, table)) =
            Tablefl_breg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let bd32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 4;
        let od32 = token_53(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                fl_breg,
                bd32,
                od32,
            },
        ))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:371:1, end:371:5))"]
#[derive(Clone, Debug)]
struct extwVar34 {
    d8: u8,
    breg: Tablebreg,
    ea_index: Tableea_index,
}
impl extwVar34 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
            <DisplayElement>::Literal(","),
        ];
        display.extend_from_slice(&extend);
        self.breg
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(",")];
        display.extend_from_slice(&extend);
        self.ea_index
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        let breg = if let Some((len, table)) =
            Tablebreg::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let ea_index = if let Some((len, table)) =
            Tableea_index::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { breg, ea_index, d8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableextw {
    Var0(extwVar0),
    Var1(extwVar1),
    Var2(extwVar2),
    Var3(extwVar3),
    Var4(extwVar4),
    Var5(extwVar5),
    Var6(extwVar6),
    Var7(extwVar7),
    Var8(extwVar8),
    Var9(extwVar9),
    Var10(extwVar10),
    Var11(extwVar11),
    Var12(extwVar12),
    Var13(extwVar13),
    Var14(extwVar14),
    Var15(extwVar15),
    Var16(extwVar16),
    Var17(extwVar17),
    Var18(extwVar18),
    Var19(extwVar19),
    Var20(extwVar20),
    Var21(extwVar21),
    Var22(extwVar22),
    Var23(extwVar23),
    Var24(extwVar24),
    Var25(extwVar25),
    Var26(extwVar26),
    Var27(extwVar27),
    Var28(extwVar28),
    Var29(extwVar29),
    Var30(extwVar30),
    Var31(extwVar31),
    Var32(extwVar32),
    Var33(extwVar33),
    Var34(extwVar34),
}
impl Tableextw {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var32(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var33(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var34(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 2 == 2 && (tokens_param[0] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                extwVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 16 {
            if let Some((inst_len, parsed)) =
                extwVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 32 {
            if let Some((inst_len, parsed)) =
                extwVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 48 {
            if let Some((inst_len, parsed)) =
                extwVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 17 {
            if let Some((inst_len, parsed)) =
                extwVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 33 {
            if let Some((inst_len, parsed)) =
                extwVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 49 {
            if let Some((inst_len, parsed)) =
                extwVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 18 {
            if let Some((inst_len, parsed)) =
                extwVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 34 {
            if let Some((inst_len, parsed)) =
                extwVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 8 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 50 {
            if let Some((inst_len, parsed)) =
                extwVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 19 {
            if let Some((inst_len, parsed)) =
                extwVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 8 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 35 {
            if let Some((inst_len, parsed)) =
                extwVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 10 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 51 {
            if let Some((inst_len, parsed)) =
                extwVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 21 {
            if let Some((inst_len, parsed)) =
                extwVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 37 {
            if let Some((inst_len, parsed)) =
                extwVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 53 {
            if let Some((inst_len, parsed)) =
                extwVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 22 {
            if let Some((inst_len, parsed)) =
                extwVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 38 {
            if let Some((inst_len, parsed)) =
                extwVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 8 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 54 {
            if let Some((inst_len, parsed)) =
                extwVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 23 {
            if let Some((inst_len, parsed)) =
                extwVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 8 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 39 {
            if let Some((inst_len, parsed)) =
                extwVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 10 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 55 {
            if let Some((inst_len, parsed)) =
                extwVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 80 {
            if let Some((inst_len, parsed)) =
                extwVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 96 {
            if let Some((inst_len, parsed)) =
                extwVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 112 {
            if let Some((inst_len, parsed)) =
                extwVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 81 {
            if let Some((inst_len, parsed)) =
                extwVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 97 {
            if let Some((inst_len, parsed)) =
                extwVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 113 {
            if let Some((inst_len, parsed)) =
                extwVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 82 {
            if let Some((inst_len, parsed)) =
                extwVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 98 {
            if let Some((inst_len, parsed)) =
                extwVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 8 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 114 {
            if let Some((inst_len, parsed)) =
                extwVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 83 {
            if let Some((inst_len, parsed)) =
                extwVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        if tokens_param.len() >= 8 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 99 {
            if let Some((inst_len, parsed)) =
                extwVar32::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var32(parsed)));
            }
        }
        if tokens_param.len() >= 10 && (tokens_param[0] & 1) == 1 && (tokens_param[1] & 119) == 115
        {
            if let Some((inst_len, parsed)) =
                extwVar33::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var33(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 1) == 0 {
            if let Some((inst_len, parsed)) =
                extwVar34::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var34(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:424:1, end:424:4))"]
#[derive(Clone, Debug)]
struct ealVar0 {
    d16: u16,
}
impl ealVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:425:1, end:425:4))"]
#[derive(Clone, Debug)]
struct ealVar1 {
    extw: Tableextw,
}
impl ealVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:426:1, end:426:4))"]
#[derive(Clone, Debug)]
struct ealVar2 {
    d16: u16,
}
impl ealVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:427:1, end:427:4))"]
#[derive(Clone, Debug)]
struct ealVar3 {
    d32: u32,
}
impl ealVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:428:1, end:428:4))"]
#[derive(Clone, Debug)]
struct ealVar4 {
    d32: u32,
}
impl ealVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:417:1, end:417:4))"]
#[derive(Clone, Debug)]
struct ealVar5 {
    regdn: u8,
}
impl ealVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.regdn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:418:1, end:418:4))"]
#[derive(Clone, Debug)]
struct ealVar6 {
    regan: u8,
}
impl ealVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_5_display(self.regan)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:419:1, end:419:4))"]
#[derive(Clone, Debug)]
struct ealVar7 {
    regan: u8,
}
impl ealVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:420:1, end:420:4))"]
#[derive(Clone, Debug)]
struct ealVar8 {
    regan: u8,
}
impl ealVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:421:1, end:421:4))"]
#[derive(Clone, Debug)]
struct ealVar9 {
    regan: u8,
}
impl ealVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:422:1, end:422:4))"]
#[derive(Clone, Debug)]
struct ealVar10 {
    d16: u16,
    regan: u8,
}
impl ealVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:423:1, end:423:4))"]
#[derive(Clone, Debug)]
struct ealVar11 {
    regan: u8,
    extw: Tableextw,
}
impl ealVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw, regan }))
    }
}
#[derive(Clone, Debug)]
enum Tableeal {
    Var0(ealVar0),
    Var1(ealVar1),
    Var2(ealVar2),
    Var3(ealVar3),
    Var4(ealVar4),
    Var5(ealVar5),
    Var6(ealVar6),
    Var7(ealVar7),
    Var8(ealVar8),
    Var9(ealVar9),
    Var10(ealVar10),
    Var11(ealVar11),
}
impl Tableeal {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 58 {
            if let Some((inst_len, parsed)) =
                ealVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 59 {
            if let Some((inst_len, parsed)) =
                ealVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 56 {
            if let Some((inst_len, parsed)) =
                ealVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[1] & 63) == 57 {
            if let Some((inst_len, parsed)) =
                ealVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[1] & 63) == 60 {
            if let Some((inst_len, parsed)) =
                ealVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 0 {
            if let Some((inst_len, parsed)) =
                ealVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 8 {
            if let Some((inst_len, parsed)) =
                ealVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 16 {
            if let Some((inst_len, parsed)) =
                ealVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 24 {
            if let Some((inst_len, parsed)) =
                ealVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 32 {
            if let Some((inst_len, parsed)) =
                ealVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 56) == 40 {
            if let Some((inst_len, parsed)) =
                ealVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 56) == 48 {
            if let Some((inst_len, parsed)) =
                ealVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:437:1, end:437:4))"]
#[derive(Clone, Debug)]
struct eawVar0 {
    d16: u16,
}
impl eawVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:438:1, end:438:4))"]
#[derive(Clone, Debug)]
struct eawVar1 {
    extw: Tableextw,
}
impl eawVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:439:1, end:439:4))"]
#[derive(Clone, Debug)]
struct eawVar2 {
    d16: u16,
}
impl eawVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:440:1, end:440:4))"]
#[derive(Clone, Debug)]
struct eawVar3 {
    d32: u32,
}
impl eawVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:441:1, end:441:4))"]
#[derive(Clone, Debug)]
struct eawVar4 {
    d16: u16,
}
impl eawVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:430:1, end:430:4))"]
#[derive(Clone, Debug)]
struct eawVar5 {
    regdnw: u8,
}
impl eawVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_2_display(self.regdnw)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdnw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:431:1, end:431:4))"]
#[derive(Clone, Debug)]
struct eawVar6 {
    reganw: u8,
}
impl eawVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_6_display(self.reganw)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reganw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reganw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:432:1, end:432:4))"]
#[derive(Clone, Debug)]
struct eawVar7 {
    regan: u8,
}
impl eawVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:433:1, end:433:4))"]
#[derive(Clone, Debug)]
struct eawVar8 {
    regan: u8,
}
impl eawVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:434:1, end:434:4))"]
#[derive(Clone, Debug)]
struct eawVar9 {
    regan: u8,
}
impl eawVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:435:1, end:435:4))"]
#[derive(Clone, Debug)]
struct eawVar10 {
    d16: u16,
    regan: u8,
}
impl eawVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:436:1, end:436:4))"]
#[derive(Clone, Debug)]
struct eawVar11 {
    regan: u8,
    extw: Tableextw,
}
impl eawVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw, regan }))
    }
}
#[derive(Clone, Debug)]
enum Tableeaw {
    Var0(eawVar0),
    Var1(eawVar1),
    Var2(eawVar2),
    Var3(eawVar3),
    Var4(eawVar4),
    Var5(eawVar5),
    Var6(eawVar6),
    Var7(eawVar7),
    Var8(eawVar8),
    Var9(eawVar9),
    Var10(eawVar10),
    Var11(eawVar11),
}
impl Tableeaw {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 58 {
            if let Some((inst_len, parsed)) =
                eawVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 59 {
            if let Some((inst_len, parsed)) =
                eawVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 56 {
            if let Some((inst_len, parsed)) =
                eawVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[1] & 63) == 57 {
            if let Some((inst_len, parsed)) =
                eawVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 60 {
            if let Some((inst_len, parsed)) =
                eawVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 0 {
            if let Some((inst_len, parsed)) =
                eawVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 8 {
            if let Some((inst_len, parsed)) =
                eawVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 16 {
            if let Some((inst_len, parsed)) =
                eawVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 24 {
            if let Some((inst_len, parsed)) =
                eawVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 32 {
            if let Some((inst_len, parsed)) =
                eawVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 56) == 40 {
            if let Some((inst_len, parsed)) =
                eawVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 56) == 48 {
            if let Some((inst_len, parsed)) =
                eawVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:446:1, end:446:4))"]
#[derive(Clone, Debug)]
struct eabVar0 {
    regan: u8,
}
impl eabVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:448:1, end:448:4))"]
#[derive(Clone, Debug)]
struct eabVar1 {
    regan: u8,
}
impl eabVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:452:1, end:452:4))"]
#[derive(Clone, Debug)]
struct eabVar2 {
    d16: u16,
}
impl eabVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:453:1, end:453:4))"]
#[derive(Clone, Debug)]
struct eabVar3 {
    extw: Tableextw,
}
impl eabVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:454:1, end:454:4))"]
#[derive(Clone, Debug)]
struct eabVar4 {
    d16: u16,
}
impl eabVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:455:1, end:455:4))"]
#[derive(Clone, Debug)]
struct eabVar5 {
    d32: u32,
}
impl eabVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:456:1, end:456:4))"]
#[derive(Clone, Debug)]
struct eabVar6 {
    d8: u8,
}
impl eabVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:443:1, end:443:4))"]
#[derive(Clone, Debug)]
struct eabVar7 {
    regdnb: u8,
}
impl eabVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.regdnb)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdnb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdnb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:444:1, end:444:4))"]
#[derive(Clone, Debug)]
struct eabVar8 {
    reganb: u8,
}
impl eabVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_7_display(self.reganb)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reganb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reganb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:445:1, end:445:4))"]
#[derive(Clone, Debug)]
struct eabVar9 {
    regan: u8,
}
impl eabVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:447:1, end:447:4))"]
#[derive(Clone, Debug)]
struct eabVar10 {
    regan: u8,
}
impl eabVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:449:1, end:449:4))"]
#[derive(Clone, Debug)]
struct eabVar11 {
    regan: u8,
}
impl eabVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:450:1, end:450:4))"]
#[derive(Clone, Debug)]
struct eabVar12 {
    d16: u16,
    regan: u8,
}
impl eabVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:451:1, end:451:4))"]
#[derive(Clone, Debug)]
struct eabVar13 {
    regan: u8,
    extw: Tableextw,
}
impl eabVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw, regan }))
    }
}
#[derive(Clone, Debug)]
enum Tableeab {
    Var0(eabVar0),
    Var1(eabVar1),
    Var2(eabVar2),
    Var3(eabVar3),
    Var4(eabVar4),
    Var5(eabVar5),
    Var6(eabVar6),
    Var7(eabVar7),
    Var8(eabVar8),
    Var9(eabVar9),
    Var10(eabVar10),
    Var11(eabVar11),
    Var12(eabVar12),
    Var13(eabVar13),
}
impl Tableeab {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 63) == 31 {
            if let Some((inst_len, parsed)) =
                eabVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 63) == 39 {
            if let Some((inst_len, parsed)) =
                eabVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 58 {
            if let Some((inst_len, parsed)) =
                eabVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 59 {
            if let Some((inst_len, parsed)) =
                eabVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 56 {
            if let Some((inst_len, parsed)) =
                eabVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[1] & 63) == 57 {
            if let Some((inst_len, parsed)) =
                eabVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 60 {
            if let Some((inst_len, parsed)) =
                eabVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 0 {
            if let Some((inst_len, parsed)) =
                eabVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 8 {
            if let Some((inst_len, parsed)) =
                eabVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 16 {
            if let Some((inst_len, parsed)) =
                eabVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 24 {
            if let Some((inst_len, parsed)) =
                eabVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 32 {
            if let Some((inst_len, parsed)) =
                eabVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 56) == 40 {
            if let Some((inst_len, parsed)) =
                eabVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 56) == 48 {
            if let Some((inst_len, parsed)) =
                eabVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:469:1, end:469:4))"]
#[derive(Clone, Debug)]
struct e2xVar0 {
    d16: u16,
}
impl e2xVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:470:1, end:470:4))"]
#[derive(Clone, Debug)]
struct e2xVar1 {
    extw: Tableextw,
}
impl e2xVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:471:1, end:471:4))"]
#[derive(Clone, Debug)]
struct e2xVar2 {
    d16: u16,
}
impl e2xVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:472:1, end:472:4))"]
#[derive(Clone, Debug)]
struct e2xVar3 {
    d32: u32,
}
impl e2xVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:464:1, end:464:4))"]
#[derive(Clone, Debug)]
struct e2xVar4 {}
impl e2xVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:465:1, end:465:4))"]
#[derive(Clone, Debug)]
struct e2xVar5 {}
impl e2xVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:466:1, end:466:4))"]
#[derive(Clone, Debug)]
struct e2xVar6 {}
impl e2xVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:467:1, end:467:4))"]
#[derive(Clone, Debug)]
struct e2xVar7 {
    d16: u16,
}
impl e2xVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:468:1, end:468:4))"]
#[derive(Clone, Debug)]
struct e2xVar8 {
    extw: Tableextw,
}
impl e2xVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_eanum(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:473:1, end:473:4))"]
#[derive(Clone, Debug)]
struct e2xVar9 {
    signX: u8,
    mantissaX: u64,
    exponentX: u16,
}
impl e2xVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_exp: i128 = 0;
        calc_exp = i128::try_from(self.exponentX)
            .unwrap()
            .wrapping_sub(16383i128);
        let extend: [DisplayElement; 7usize] = [
            <DisplayElement>::Literal("#( -1E"),
            DisplayElement::Number(true, false, self.signX as u64),
            <DisplayElement>::Literal(" * 2E"),
            <DisplayElement>::Number(true, calc_exp.is_negative(), calc_exp.abs() as u64),
            <DisplayElement>::Literal("*1."),
            DisplayElement::Number(true, false, self.mantissaX as u64),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_exp: i128 = 0;
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        calc_exp = i128::try_from(token_59(tokens_current))
            .unwrap()
            .wrapping_sub(16383i128);
        let signX = token_58(tokens_current);
        let exponentX = token_59(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        let mut block_2_len = 8;
        let mantissaX = token_60(tokens_current);
        let expintbitX = token_54(tokens_current);
        pattern_len += block_2_len;
        tokens_current = &tokens_current[usize::try_from(block_2_len).unwrap()..];
        *context = context_instance;
        Some((
            pattern_len,
            Self {
                signX,
                mantissaX,
                exponentX,
            },
        ))
    }
}
#[derive(Clone, Debug)]
enum Tablee2x {
    Var0(e2xVar0),
    Var1(e2xVar1),
    Var2(e2xVar2),
    Var3(e2xVar3),
    Var4(e2xVar4),
    Var5(e2xVar5),
    Var6(e2xVar6),
    Var7(e2xVar7),
    Var8(e2xVar8),
    Var9(e2xVar9),
}
impl Tablee2x {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 5888 {
            if let Some((inst_len, parsed)) =
                e2xVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 14080 {
            if let Some((inst_len, parsed)) =
                e2xVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 1792 {
            if let Some((inst_len, parsed)) =
                e2xVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 16128 == 9984 {
            if let Some((inst_len, parsed)) =
                e2xVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 512 {
            if let Some((inst_len, parsed)) =
                e2xVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 1536 {
            if let Some((inst_len, parsed)) =
                e2xVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 256 {
            if let Some((inst_len, parsed)) =
                e2xVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 1792 == 1280 {
            if let Some((inst_len, parsed)) =
                e2xVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 1792 == 768 {
            if let Some((inst_len, parsed)) =
                e2xVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 12 && context_param.0 & 252 == 228 {
            if let Some((inst_len, parsed)) =
                e2xVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:485:1, end:485:4))"]
#[derive(Clone, Debug)]
struct e2dVar0 {
    d16: u16,
}
impl e2dVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:486:1, end:486:4))"]
#[derive(Clone, Debug)]
struct e2dVar1 {
    extw: Tableextw,
}
impl e2dVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:487:1, end:487:4))"]
#[derive(Clone, Debug)]
struct e2dVar2 {
    d16: u16,
}
impl e2dVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:488:1, end:488:4))"]
#[derive(Clone, Debug)]
struct e2dVar3 {
    d32: u32,
}
impl e2dVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:489:1, end:489:4))"]
#[derive(Clone, Debug)]
struct e2dVar4 {
    d64: u64,
}
impl e2dVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d64 & 9223372036854775808 != 0 {
                    -1 & !9223372036854775807
                } else {
                    0
                } | self.d64 as i64)
                    .is_negative(),
                (if self.d64 & 9223372036854775808 != 0 {
                    -1 & !9223372036854775807
                } else {
                    0
                } | self.d64 as i64)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 8;
        let d64 = token_57(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d64 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:480:1, end:480:4))"]
#[derive(Clone, Debug)]
struct e2dVar5 {}
impl e2dVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:481:1, end:481:4))"]
#[derive(Clone, Debug)]
struct e2dVar6 {}
impl e2dVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:482:1, end:482:4))"]
#[derive(Clone, Debug)]
struct e2dVar7 {}
impl e2dVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:483:1, end:483:4))"]
#[derive(Clone, Debug)]
struct e2dVar8 {
    d16: u16,
}
impl e2dVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:484:1, end:484:4))"]
#[derive(Clone, Debug)]
struct e2dVar9 {
    extw: Tableextw,
}
impl e2dVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_eanum(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[derive(Clone, Debug)]
enum Tablee2d {
    Var0(e2dVar0),
    Var1(e2dVar1),
    Var2(e2dVar2),
    Var3(e2dVar3),
    Var4(e2dVar4),
    Var5(e2dVar5),
    Var6(e2dVar6),
    Var7(e2dVar7),
    Var8(e2dVar8),
    Var9(e2dVar9),
}
impl Tablee2d {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 5888 {
            if let Some((inst_len, parsed)) =
                e2dVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 14080 {
            if let Some((inst_len, parsed)) =
                e2dVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 1792 {
            if let Some((inst_len, parsed)) =
                e2dVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 16128 == 9984 {
            if let Some((inst_len, parsed)) =
                e2dVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 8 && context_param.0 & 16128 == 3840 {
            if let Some((inst_len, parsed)) =
                e2dVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 512 {
            if let Some((inst_len, parsed)) =
                e2dVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 1536 {
            if let Some((inst_len, parsed)) =
                e2dVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 256 {
            if let Some((inst_len, parsed)) =
                e2dVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 1792 == 1280 {
            if let Some((inst_len, parsed)) =
                e2dVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 1792 == 768 {
            if let Some((inst_len, parsed)) =
                e2dVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:499:1, end:499:4))"]
#[derive(Clone, Debug)]
struct e2lVar0 {
    d16: u16,
}
impl e2lVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:500:1, end:500:4))"]
#[derive(Clone, Debug)]
struct e2lVar1 {
    extw: Tableextw,
}
impl e2lVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:501:1, end:501:4))"]
#[derive(Clone, Debug)]
struct e2lVar2 {
    d16: u16,
}
impl e2lVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:502:1, end:502:4))"]
#[derive(Clone, Debug)]
struct e2lVar3 {
    d32: u32,
}
impl e2lVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:503:1, end:503:4))"]
#[derive(Clone, Debug)]
struct e2lVar4 {
    d32: u32,
}
impl e2lVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:492:1, end:492:4))"]
#[derive(Clone, Debug)]
struct e2lVar5 {}
impl e2lVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(context.read_regsdn())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:493:1, end:493:4))"]
#[derive(Clone, Debug)]
struct e2lVar6 {}
impl e2lVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_5_display(context.read_regsan())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:494:1, end:494:4))"]
#[derive(Clone, Debug)]
struct e2lVar7 {}
impl e2lVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:495:1, end:495:4))"]
#[derive(Clone, Debug)]
struct e2lVar8 {}
impl e2lVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:496:1, end:496:4))"]
#[derive(Clone, Debug)]
struct e2lVar9 {}
impl e2lVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:497:1, end:497:4))"]
#[derive(Clone, Debug)]
struct e2lVar10 {
    d16: u16,
}
impl e2lVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:498:1, end:498:4))"]
#[derive(Clone, Debug)]
struct e2lVar11 {
    extw: Tableextw,
}
impl e2lVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_eanum(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[derive(Clone, Debug)]
enum Tablee2l {
    Var0(e2lVar0),
    Var1(e2lVar1),
    Var2(e2lVar2),
    Var3(e2lVar3),
    Var4(e2lVar4),
    Var5(e2lVar5),
    Var6(e2lVar6),
    Var7(e2lVar7),
    Var8(e2lVar8),
    Var9(e2lVar9),
    Var10(e2lVar10),
    Var11(e2lVar11),
}
impl Tablee2l {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 5888 {
            if let Some((inst_len, parsed)) =
                e2lVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 14080 {
            if let Some((inst_len, parsed)) =
                e2lVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 1792 {
            if let Some((inst_len, parsed)) =
                e2lVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 16128 == 9984 {
            if let Some((inst_len, parsed)) =
                e2lVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 16128 == 3840 {
            if let Some((inst_len, parsed)) =
                e2lVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 0 {
            if let Some((inst_len, parsed)) =
                e2lVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 1024 {
            if let Some((inst_len, parsed)) =
                e2lVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 512 {
            if let Some((inst_len, parsed)) =
                e2lVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 1536 {
            if let Some((inst_len, parsed)) =
                e2lVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 256 {
            if let Some((inst_len, parsed)) =
                e2lVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 1792 == 1280 {
            if let Some((inst_len, parsed)) =
                e2lVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 1792 == 768 {
            if let Some((inst_len, parsed)) =
                e2lVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:512:1, end:512:4))"]
#[derive(Clone, Debug)]
struct e2wVar0 {
    d16: u16,
}
impl e2wVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:513:1, end:513:4))"]
#[derive(Clone, Debug)]
struct e2wVar1 {
    extw: Tableextw,
}
impl e2wVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:514:1, end:514:4))"]
#[derive(Clone, Debug)]
struct e2wVar2 {
    d16: u16,
}
impl e2wVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:515:1, end:515:4))"]
#[derive(Clone, Debug)]
struct e2wVar3 {
    d32: u32,
}
impl e2wVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:516:1, end:516:4))"]
#[derive(Clone, Debug)]
struct e2wVar4 {
    d16: u16,
}
impl e2wVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:505:1, end:505:4))"]
#[derive(Clone, Debug)]
struct e2wVar5 {}
impl e2wVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_2_display(context.read_regsdnw())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:506:1, end:506:4))"]
#[derive(Clone, Debug)]
struct e2wVar6 {}
impl e2wVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_6_display(context.read_regsanw())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:507:1, end:507:4))"]
#[derive(Clone, Debug)]
struct e2wVar7 {}
impl e2wVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:508:1, end:508:4))"]
#[derive(Clone, Debug)]
struct e2wVar8 {}
impl e2wVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:509:1, end:509:4))"]
#[derive(Clone, Debug)]
struct e2wVar9 {}
impl e2wVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:510:1, end:510:4))"]
#[derive(Clone, Debug)]
struct e2wVar10 {
    d16: u16,
}
impl e2wVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:511:1, end:511:4))"]
#[derive(Clone, Debug)]
struct e2wVar11 {
    extw: Tableextw,
}
impl e2wVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_eanum(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[derive(Clone, Debug)]
enum Tablee2w {
    Var0(e2wVar0),
    Var1(e2wVar1),
    Var2(e2wVar2),
    Var3(e2wVar3),
    Var4(e2wVar4),
    Var5(e2wVar5),
    Var6(e2wVar6),
    Var7(e2wVar7),
    Var8(e2wVar8),
    Var9(e2wVar9),
    Var10(e2wVar10),
    Var11(e2wVar11),
}
impl Tablee2w {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 5888 {
            if let Some((inst_len, parsed)) =
                e2wVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 14080 {
            if let Some((inst_len, parsed)) =
                e2wVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 1792 {
            if let Some((inst_len, parsed)) =
                e2wVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 16128 == 9984 {
            if let Some((inst_len, parsed)) =
                e2wVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 3840 {
            if let Some((inst_len, parsed)) =
                e2wVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 0 {
            if let Some((inst_len, parsed)) =
                e2wVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 1024 {
            if let Some((inst_len, parsed)) =
                e2wVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 512 {
            if let Some((inst_len, parsed)) =
                e2wVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 1536 {
            if let Some((inst_len, parsed)) =
                e2wVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 256 {
            if let Some((inst_len, parsed)) =
                e2wVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 1792 == 1280 {
            if let Some((inst_len, parsed)) =
                e2wVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 1792 == 768 {
            if let Some((inst_len, parsed)) =
                e2wVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:523:1, end:523:4))"]
#[derive(Clone, Debug)]
struct e2bVar0 {}
impl e2bVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:525:1, end:525:4))"]
#[derive(Clone, Debug)]
struct e2bVar1 {}
impl e2bVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:529:1, end:529:4))"]
#[derive(Clone, Debug)]
struct e2bVar2 {
    d16: u16,
}
impl e2bVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:530:1, end:530:4))"]
#[derive(Clone, Debug)]
struct e2bVar3 {
    extw: Tableextw,
}
impl e2bVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:531:1, end:531:4))"]
#[derive(Clone, Debug)]
struct e2bVar4 {
    d16: u16,
}
impl e2bVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:532:1, end:532:4))"]
#[derive(Clone, Debug)]
struct e2bVar5 {
    d32: u32,
}
impl e2bVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:533:1, end:533:4))"]
#[derive(Clone, Debug)]
struct e2bVar6 {
    d8: u8,
}
impl e2bVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:520:1, end:520:4))"]
#[derive(Clone, Debug)]
struct e2bVar7 {}
impl e2bVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(context.read_regsdnb())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:521:1, end:521:4))"]
#[derive(Clone, Debug)]
struct e2bVar8 {}
impl e2bVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_7_display(context.read_regsanb())];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:522:1, end:522:4))"]
#[derive(Clone, Debug)]
struct e2bVar9 {}
impl e2bVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:524:1, end:524:4))"]
#[derive(Clone, Debug)]
struct e2bVar10 {}
impl e2bVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")+"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:526:1, end:526:4))"]
#[derive(Clone, Debug)]
struct e2bVar11 {}
impl e2bVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:527:1, end:527:4))"]
#[derive(Clone, Debug)]
struct e2bVar12 {
    d16: u16,
}
impl e2bVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(context.read_regsan()),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:528:1, end:528:4))"]
#[derive(Clone, Debug)]
struct e2bVar13 {
    extw: Tableextw,
}
impl e2bVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 0;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_eanum(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[derive(Clone, Debug)]
enum Tablee2b {
    Var0(e2bVar0),
    Var1(e2bVar1),
    Var2(e2bVar2),
    Var3(e2bVar3),
    Var4(e2bVar4),
    Var5(e2bVar5),
    Var6(e2bVar6),
    Var7(e2bVar7),
    Var8(e2bVar8),
    Var9(e2bVar9),
    Var10(e2bVar10),
    Var11(e2bVar11),
    Var12(e2bVar12),
    Var13(e2bVar13),
}
impl Tablee2b {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 0 && context_param.0 & 16128 == 15872 {
            if let Some((inst_len, parsed)) =
                e2bVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 16128 == 14592 {
            if let Some((inst_len, parsed)) =
                e2bVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 5888 {
            if let Some((inst_len, parsed)) =
                e2bVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 14080 {
            if let Some((inst_len, parsed)) =
                e2bVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 1792 {
            if let Some((inst_len, parsed)) =
                e2bVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && context_param.0 & 16128 == 9984 {
            if let Some((inst_len, parsed)) =
                e2bVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16128 == 3840 {
            if let Some((inst_len, parsed)) =
                e2bVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 0 {
            if let Some((inst_len, parsed)) =
                e2bVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 1024 {
            if let Some((inst_len, parsed)) =
                e2bVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 512 {
            if let Some((inst_len, parsed)) =
                e2bVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 1536 {
            if let Some((inst_len, parsed)) =
                e2bVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 0 && context_param.0 & 1792 == 256 {
            if let Some((inst_len, parsed)) =
                e2bVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 1792 == 1280 {
            if let Some((inst_len, parsed)) =
                e2bVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 1792 == 768 {
            if let Some((inst_len, parsed)) =
                e2bVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:540:1, end:540:6))"]
#[derive(Clone, Debug)]
struct eaptrVar0 {
    d16: u16,
}
impl eaptrVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            <DisplayElement>::Register(Register::PC),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:541:1, end:541:6))"]
#[derive(Clone, Debug)]
struct eaptrVar1 {
    extw: Tableextw,
}
impl eaptrVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(1i128 & 1).unwrap());
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:542:1, end:542:6))"]
#[derive(Clone, Debug)]
struct eaptrVar2 {
    d16: u16,
}
impl eaptrVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").w"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:543:1, end:543:6))"]
#[derive(Clone, Debug)]
struct eaptrVar3 {
    d32: u32,
}
impl eaptrVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(").l"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:537:1, end:537:6))"]
#[derive(Clone, Debug)]
struct eaptrVar4 {
    regan: u8,
}
impl eaptrVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:538:1, end:538:6))"]
#[derive(Clone, Debug)]
struct eaptrVar5 {
    d16: u16,
    regan: u8,
}
impl eaptrVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 5usize] = [
            <DisplayElement>::Literal("("),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
            <DisplayElement>::Literal(","),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16, regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:539:1, end:539:6))"]
#[derive(Clone, Debug)]
struct eaptrVar6 {
    regan: u8,
    extw: Tableextw,
}
impl eaptrVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("(")];
        display.extend_from_slice(&extend);
        self.extw
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal(")")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        context_instance.write_pcmode(u8::try_from(0i128 & 1).unwrap());
        context_instance.write_regtfan(
            u8::try_from(i128::try_from(token_3(tokens_current)).unwrap() & 7).unwrap(),
        );
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        let mut block_1_len = 2;
        let extw = if let Some((len, table)) =
            Tableextw::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_1_len = block_1_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_1_len;
        tokens_current = &tokens_current[usize::try_from(block_1_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { extw, regan }))
    }
}
#[derive(Clone, Debug)]
enum Tableeaptr {
    Var0(eaptrVar0),
    Var1(eaptrVar1),
    Var2(eaptrVar2),
    Var3(eaptrVar3),
    Var4(eaptrVar4),
    Var5(eaptrVar5),
    Var6(eaptrVar6),
}
impl Tableeaptr {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 58 {
            if let Some((inst_len, parsed)) =
                eaptrVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 59 {
            if let Some((inst_len, parsed)) =
                eaptrVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 63) == 56 {
            if let Some((inst_len, parsed)) =
                eaptrVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 6 && (tokens_param[1] & 63) == 57 {
            if let Some((inst_len, parsed)) =
                eaptrVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 56) == 16 {
            if let Some((inst_len, parsed)) =
                eaptrVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 56) == 40 {
            if let Some((inst_len, parsed)) =
                eaptrVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 4 && (tokens_param[1] & 56) == 48 {
            if let Some((inst_len, parsed)) =
                eaptrVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:546:1, end:546:3))"]
#[derive(Clone, Debug)]
struct TyVar0 {
    regan: u8,
}
impl TyVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:547:1, end:547:3))"]
#[derive(Clone, Debug)]
struct TyVar1 {
    regdn: u8,
}
impl TyVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.regdn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdn = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdn }))
    }
}
#[derive(Clone, Debug)]
enum TableTy {
    Var0(TyVar0),
    Var1(TyVar1),
}
impl TableTy {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                TyVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                TyVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:548:1, end:548:3))"]
#[derive(Clone, Debug)]
struct TxVar0 {
    reg9an: u8,
}
impl TxVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(self.reg9an),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9an = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:549:1, end:549:3))"]
#[derive(Clone, Debug)]
struct TxVar1 {
    reg9dn: u8,
}
impl TxVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.reg9dn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dn = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dn }))
    }
}
#[derive(Clone, Debug)]
enum TableTx {
    Var0(TxVar0),
    Var1(TxVar1),
}
impl TableTx {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                TxVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                TxVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:550:1, end:550:4))"]
#[derive(Clone, Debug)]
struct TywVar0 {
    regan: u8,
}
impl TywVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:551:1, end:551:4))"]
#[derive(Clone, Debug)]
struct TywVar1 {
    regdnw: u8,
}
impl TywVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_2_display(self.regdnw)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdnw = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdnw }))
    }
}
#[derive(Clone, Debug)]
enum TableTyw {
    Var0(TywVar0),
    Var1(TywVar1),
}
impl TableTyw {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                TywVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                TywVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:552:1, end:552:4))"]
#[derive(Clone, Debug)]
struct TxwVar0 {
    reg9an: u8,
}
impl TxwVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(self.reg9an),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9an = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:553:1, end:553:4))"]
#[derive(Clone, Debug)]
struct TxwVar1 {
    reg9dnw: u8,
}
impl TxwVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_2_display(self.reg9dnw)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dnw = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dnw }))
    }
}
#[derive(Clone, Debug)]
enum TableTxw {
    Var0(TxwVar0),
    Var1(TxwVar1),
}
impl TableTxw {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                TxwVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                TxwVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:554:1, end:554:4))"]
#[derive(Clone, Debug)]
struct TybVar0 {
    regan: u8,
}
impl TybVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(self.regan),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regan = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regan }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:555:1, end:555:4))"]
#[derive(Clone, Debug)]
struct TybVar1 {
    regdnb: u8,
}
impl TybVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.regdnb)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdnb = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdnb }))
    }
}
#[derive(Clone, Debug)]
enum TableTyb {
    Var0(TybVar0),
    Var1(TybVar1),
}
impl TableTyb {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                TybVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                TybVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:556:1, end:556:4))"]
#[derive(Clone, Debug)]
struct TxbVar0 {
    reg9an: u8,
}
impl TxbVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal("-("),
            meaning_5_display(self.reg9an),
            <DisplayElement>::Literal(")"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9an = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9an }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:557:1, end:557:4))"]
#[derive(Clone, Debug)]
struct TxbVar1 {
    reg9dnb: u8,
}
impl TxbVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_3_display(self.reg9dnb)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let reg9dnb = token_5(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { reg9dnb }))
    }
}
#[derive(Clone, Debug)]
enum TableTxb {
    Var0(TxbVar0),
    Var1(TxbVar1),
}
impl TableTxb {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                TxbVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                TxbVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:560:1, end:560:6))"]
#[derive(Clone, Debug)]
struct f_offVar0 {
    fldoffdat: u8,
}
impl f_offVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.fldoffdat as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fldoffdat = token_61(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fldoffdat }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:561:1, end:561:6))"]
#[derive(Clone, Debug)]
struct f_offVar1 {
    fldoffreg: u8,
}
impl f_offVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_1_display(self.fldoffreg)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fldoffreg = token_2(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fldoffreg }))
    }
}
#[derive(Clone, Debug)]
enum Tablef_off {
    Var0(f_offVar0),
    Var1(f_offVar1),
}
impl Tablef_off {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 8) == 0 {
            if let Some((inst_len, parsed)) =
                f_offVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 8) == 8 {
            if let Some((inst_len, parsed)) =
                f_offVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:562:1, end:562:5))"]
#[derive(Clone, Debug)]
struct f_wdVar0 {
    fldwddat: u8,
}
impl f_wdVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] =
            [DisplayElement::Number(true, false, self.fldwddat as u64)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fldwddat = token_62(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fldwddat }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:563:1, end:563:5))"]
#[derive(Clone, Debug)]
struct f_wdVar1 {
    fldwdreg: u8,
}
impl f_wdVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_1_display(self.fldwdreg)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fldwdreg = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fldwdreg }))
    }
}
#[derive(Clone, Debug)]
enum Tablef_wd {
    Var0(f_wdVar0),
    Var1(f_wdVar1),
}
impl Tablef_wd {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 0 {
            if let Some((inst_len, parsed)) =
                f_wdVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[1] & 32) == 32 {
            if let Some((inst_len, parsed)) =
                f_wdVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:565:1, end:565:5))"]
#[derive(Clone, Debug)]
struct rregVar0 {
    regxdn: u8,
}
impl rregVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.regxdn)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regxdn = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regxdn }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:566:1, end:566:5))"]
#[derive(Clone, Debug)]
struct rregVar1 {
    regxan: u8,
}
impl rregVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_5_display(self.regxan)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regxan = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regxan }))
    }
}
#[derive(Clone, Debug)]
enum Tablerreg {
    Var0(rregVar0),
    Var1(rregVar1),
}
impl Tablerreg {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 128) == 0 {
            if let Some((inst_len, parsed)) =
                rregVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 128) == 128 {
            if let Some((inst_len, parsed)) =
                rregVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:570:1, end:570:3))"]
#[derive(Clone, Debug)]
struct ccVar0 {}
impl ccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:571:1, end:571:3))"]
#[derive(Clone, Debug)]
struct ccVar1 {}
impl ccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("f")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:572:1, end:572:3))"]
#[derive(Clone, Debug)]
struct ccVar2 {}
impl ccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("hi")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:573:1, end:573:3))"]
#[derive(Clone, Debug)]
struct ccVar3 {}
impl ccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ls")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:574:1, end:574:3))"]
#[derive(Clone, Debug)]
struct ccVar4 {}
impl ccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:575:1, end:575:3))"]
#[derive(Clone, Debug)]
struct ccVar5 {}
impl ccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("cs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:576:1, end:576:3))"]
#[derive(Clone, Debug)]
struct ccVar6 {}
impl ccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:577:1, end:577:3))"]
#[derive(Clone, Debug)]
struct ccVar7 {}
impl ccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:578:1, end:578:3))"]
#[derive(Clone, Debug)]
struct ccVar8 {}
impl ccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vc")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:579:1, end:579:3))"]
#[derive(Clone, Debug)]
struct ccVar9 {}
impl ccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("vs")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:580:1, end:580:3))"]
#[derive(Clone, Debug)]
struct ccVar10 {}
impl ccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("pl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:581:1, end:581:3))"]
#[derive(Clone, Debug)]
struct ccVar11 {}
impl ccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("mi")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:582:1, end:582:3))"]
#[derive(Clone, Debug)]
struct ccVar12 {}
impl ccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:583:1, end:583:3))"]
#[derive(Clone, Debug)]
struct ccVar13 {}
impl ccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:584:1, end:584:3))"]
#[derive(Clone, Debug)]
struct ccVar14 {}
impl ccVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:585:1, end:585:3))"]
#[derive(Clone, Debug)]
struct ccVar15 {}
impl ccVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablecc {
    Var0(ccVar0),
    Var1(ccVar1),
    Var2(ccVar2),
    Var3(ccVar3),
    Var4(ccVar4),
    Var5(ccVar5),
    Var6(ccVar6),
    Var7(ccVar7),
    Var8(ccVar8),
    Var9(ccVar9),
    Var10(ccVar10),
    Var11(ccVar11),
    Var12(ccVar12),
    Var13(ccVar13),
    Var14(ccVar14),
    Var15(ccVar15),
}
impl Tablecc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 {
            if let Some((inst_len, parsed)) =
                ccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 1 {
            if let Some((inst_len, parsed)) =
                ccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 2 {
            if let Some((inst_len, parsed)) =
                ccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 3 {
            if let Some((inst_len, parsed)) =
                ccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 4 {
            if let Some((inst_len, parsed)) =
                ccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 5 {
            if let Some((inst_len, parsed)) =
                ccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 6 {
            if let Some((inst_len, parsed)) =
                ccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 7 {
            if let Some((inst_len, parsed)) =
                ccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 {
            if let Some((inst_len, parsed)) =
                ccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 9 {
            if let Some((inst_len, parsed)) =
                ccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 10 {
            if let Some((inst_len, parsed)) =
                ccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 11 {
            if let Some((inst_len, parsed)) =
                ccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 12 {
            if let Some((inst_len, parsed)) =
                ccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 13 {
            if let Some((inst_len, parsed)) =
                ccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 14 {
            if let Some((inst_len, parsed)) =
                ccVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 15 {
            if let Some((inst_len, parsed)) =
                ccVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:587:1, end:587:7))"]
#[derive(Clone, Debug)]
struct const8Var0 {
    d8: u8,
}
impl const8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).is_negative(),
                (if self.d8 & 128 != 0 { -1 & !127 } else { 0 } | self.d8 as i8).abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let d8 = token_27(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8 }))
    }
}
#[derive(Clone, Debug)]
enum Tableconst8 {
    Var0(const8Var0),
}
impl Tableconst8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                const8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:588:1, end:588:8))"]
#[derive(Clone, Debug)]
struct const16Var0 {
    d16: u16,
}
impl const16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .is_negative(),
                (if self.d16 & 32768 != 0 {
                    -1 & !32767
                } else {
                    0
                } | self.d16 as i16)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableconst16 {
    Var0(const16Var0),
}
impl Tableconst16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                const16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:589:1, end:589:8))"]
#[derive(Clone, Debug)]
struct const32Var0 {
    d32: u32,
}
impl const32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(
                true,
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .is_negative(),
                (if self.d32 & 2147483648 != 0 {
                    -1 & !2147483647
                } else {
                    0
                } | self.d32 as i32)
                    .abs() as u64,
            ),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[derive(Clone, Debug)]
enum Tableconst32 {
    Var0(const32Var0),
}
impl Tableconst32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                const32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:591:1, end:591:7))"]
#[derive(Clone, Debug)]
struct ctlregVar0 {}
impl ctlregVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::SFC)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:592:1, end:592:7))"]
#[derive(Clone, Debug)]
struct ctlregVar1 {}
impl ctlregVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DFC)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:593:1, end:593:7))"]
#[derive(Clone, Debug)]
struct ctlregVar2 {}
impl ctlregVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::USP)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:594:1, end:594:7))"]
#[derive(Clone, Debug)]
struct ctlregVar3 {}
impl ctlregVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::VBR)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:595:1, end:595:7))"]
#[derive(Clone, Debug)]
struct ctlregVar4 {}
impl ctlregVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::CACR)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:596:1, end:596:7))"]
#[derive(Clone, Debug)]
struct ctlregVar5 {}
impl ctlregVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::CAAR)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:597:1, end:597:7))"]
#[derive(Clone, Debug)]
struct ctlregVar6 {}
impl ctlregVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::MSP)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:598:1, end:598:7))"]
#[derive(Clone, Debug)]
struct ctlregVar7 {}
impl ctlregVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::ISP)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:599:1, end:599:7))"]
#[derive(Clone, Debug)]
struct ctlregVar8 {}
impl ctlregVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::TC)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:600:1, end:600:7))"]
#[derive(Clone, Debug)]
struct ctlregVar9 {}
impl ctlregVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::ITT0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:601:1, end:601:7))"]
#[derive(Clone, Debug)]
struct ctlregVar10 {}
impl ctlregVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::ITT1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:602:1, end:602:7))"]
#[derive(Clone, Debug)]
struct ctlregVar11 {}
impl ctlregVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DTT0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:603:1, end:603:7))"]
#[derive(Clone, Debug)]
struct ctlregVar12 {}
impl ctlregVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DTT1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:604:1, end:604:7))"]
#[derive(Clone, Debug)]
struct ctlregVar13 {}
impl ctlregVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::SRP)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:605:1, end:605:7))"]
#[derive(Clone, Debug)]
struct ctlregVar14 {}
impl ctlregVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::MMUSR)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:606:1, end:606:7))"]
#[derive(Clone, Debug)]
struct ctlregVar15 {}
impl ctlregVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::URP)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:607:1, end:607:7))"]
#[derive(Clone, Debug)]
struct ctlregVar16 {}
impl ctlregVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::SRP)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:608:1, end:608:7))"]
#[derive(Clone, Debug)]
struct ctlregVar17 {}
impl ctlregVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::PCR)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:609:1, end:609:7))"]
#[derive(Clone, Debug)]
struct ctlregVar18 {}
impl ctlregVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::RAMBAR0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:610:1, end:610:7))"]
#[derive(Clone, Debug)]
struct ctlregVar19 {}
impl ctlregVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::RAMBAR1)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:612:1, end:612:7))"]
#[derive(Clone, Debug)]
struct ctlregVar20 {}
impl ctlregVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::CAC)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:613:1, end:613:7))"]
#[derive(Clone, Debug)]
struct ctlregVar21 {}
impl ctlregVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::MBB)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:614:1, end:614:7))"]
#[derive(Clone, Debug)]
struct ctlregVar22 {
    ctl: u16,
}
impl ctlregVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("UNK_CTL_"),
            DisplayElement::Number(true, false, self.ctl as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let ctl = token_36(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { ctl }))
    }
}
#[derive(Clone, Debug)]
enum Tablectlreg {
    Var0(ctlregVar0),
    Var1(ctlregVar1),
    Var2(ctlregVar2),
    Var3(ctlregVar3),
    Var4(ctlregVar4),
    Var5(ctlregVar5),
    Var6(ctlregVar6),
    Var7(ctlregVar7),
    Var8(ctlregVar8),
    Var9(ctlregVar9),
    Var10(ctlregVar10),
    Var11(ctlregVar11),
    Var12(ctlregVar12),
    Var13(ctlregVar13),
    Var14(ctlregVar14),
    Var15(ctlregVar15),
    Var16(ctlregVar16),
    Var17(ctlregVar17),
    Var18(ctlregVar18),
    Var19(ctlregVar19),
    Var20(ctlregVar20),
    Var21(ctlregVar21),
    Var22(ctlregVar22),
}
impl Tablectlreg {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 && (tokens_param[1] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                ctlregVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 && (tokens_param[1] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                ctlregVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 && (tokens_param[1] & 255) == 0 {
            if let Some((inst_len, parsed)) =
                ctlregVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 && (tokens_param[1] & 255) == 1 {
            if let Some((inst_len, parsed)) =
                ctlregVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 && (tokens_param[1] & 255) == 2 {
            if let Some((inst_len, parsed)) =
                ctlregVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 && (tokens_param[1] & 255) == 2 {
            if let Some((inst_len, parsed)) =
                ctlregVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 && (tokens_param[1] & 255) == 3 {
            if let Some((inst_len, parsed)) =
                ctlregVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 && (tokens_param[1] & 255) == 4 {
            if let Some((inst_len, parsed)) =
                ctlregVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 && (tokens_param[1] & 255) == 3 {
            if let Some((inst_len, parsed)) =
                ctlregVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 && (tokens_param[1] & 255) == 4 {
            if let Some((inst_len, parsed)) =
                ctlregVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 && (tokens_param[1] & 255) == 5 {
            if let Some((inst_len, parsed)) =
                ctlregVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 && (tokens_param[1] & 255) == 6 {
            if let Some((inst_len, parsed)) =
                ctlregVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 && (tokens_param[1] & 255) == 7 {
            if let Some((inst_len, parsed)) =
                ctlregVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 0 && (tokens_param[1] & 255) == 8 {
            if let Some((inst_len, parsed)) =
                ctlregVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 && (tokens_param[1] & 255) == 5 {
            if let Some((inst_len, parsed)) =
                ctlregVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 && (tokens_param[1] & 255) == 6 {
            if let Some((inst_len, parsed)) =
                ctlregVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 && (tokens_param[1] & 255) == 7 {
            if let Some((inst_len, parsed)) =
                ctlregVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 8 && (tokens_param[1] & 255) == 8 {
            if let Some((inst_len, parsed)) =
                ctlregVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 12 && (tokens_param[1] & 255) == 4 {
            if let Some((inst_len, parsed)) =
                ctlregVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 12 && (tokens_param[1] & 255) == 5 {
            if let Some((inst_len, parsed)) =
                ctlregVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 15 && (tokens_param[1] & 255) == 254
        {
            if let Some((inst_len, parsed)) =
                ctlregVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 2 && (tokens_param[0] & 15) == 15 && (tokens_param[1] & 255) == 255
        {
            if let Some((inst_len, parsed)) =
                ctlregVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                ctlregVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:618:1, end:618:6))"]
#[derive(Clone, Debug)]
struct addr8Var0 {
    d8base: u8,
}
impl addr8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(
                i128::try_from(
                    (if self.d8base & 128 != 0 { -1 & !127 } else { 0 } | self.d8base as i8),
                )
                .unwrap(),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(i128::try_from(token_27(tokens_current)).unwrap());
        let d8base = token_27(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d8base }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddr8 {
    Var0(addr8Var0),
}
impl Tableaddr8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                addr8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:619:1, end:619:7))"]
#[derive(Clone, Debug)]
struct addr16Var0 {
    d16: u16,
}
impl addr16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(
                i128::try_from(
                    (if self.d16 & 32768 != 0 {
                        -1 & !32767
                    } else {
                        0
                    } | self.d16 as i16),
                )
                .unwrap(),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(i128::try_from(token_11(tokens_current)).unwrap());
        let d16 = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddr16 {
    Var0(addr16Var0),
}
impl Tableaddr16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 {
            if let Some((inst_len, parsed)) =
                addr16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:620:1, end:620:7))"]
#[derive(Clone, Debug)]
struct addr32Var0 {
    d32: u32,
}
impl addr32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(
                i128::try_from(
                    (if self.d32 & 2147483648 != 0 {
                        -1 & !2147483647
                    } else {
                        0
                    } | self.d32 as i32),
                )
                .unwrap(),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 4;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(i128::try_from(token_53(tokens_current)).unwrap());
        let d32 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddr32 {
    Var0(addr32Var0),
}
impl Tableaddr32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 {
            if let Some((inst_len, parsed)) =
                addr32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1249:1, end:1249:7))"]
#[derive(Clone, Debug)]
struct remyesVar0 {}
impl remyesVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("sl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1251:1, end:1251:7))"]
#[derive(Clone, Debug)]
struct remyesVar1 {}
impl remyesVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ul")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableremyes {
    Var0(remyesVar0),
    Var1(remyesVar1),
}
impl Tableremyes {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                remyesVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                remyesVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1258:1, end:1258:7))"]
#[derive(Clone, Debug)]
struct subdivVar0 {
    regdr: u8,
    regdq: u8,
}
impl subdivVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            meaning_0_display(self.regdr),
            <DisplayElement>::Literal(":"),
            meaning_0_display(self.regdq),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdr = token_3(tokens_current);
        let regdq = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdr, regdq }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1261:1, end:1261:7))"]
#[derive(Clone, Debug)]
struct subdivVar1 {
    regdr: u8,
    regdq: u8,
}
impl subdivVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            meaning_0_display(self.regdr),
            <DisplayElement>::Literal(":"),
            meaning_0_display(self.regdq),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdr = token_3(tokens_current);
        let regdq = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdr, regdq }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1266:1, end:1266:7))"]
#[derive(Clone, Debug)]
struct subdivVar2 {
    regdr: u8,
    regdq: u8,
}
impl subdivVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            meaning_0_display(self.regdr),
            <DisplayElement>::Literal(":"),
            meaning_0_display(self.regdq),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdq = token_30(tokens_current);
        let regdr = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdr, regdq }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1269:1, end:1269:7))"]
#[derive(Clone, Debug)]
struct subdivVar3 {
    regdr: u8,
    regdq: u8,
}
impl subdivVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            meaning_0_display(self.regdr),
            <DisplayElement>::Literal(":"),
            meaning_0_display(self.regdq),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdr = token_3(tokens_current);
        let regdq = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdr, regdq }))
    }
}
#[derive(Clone, Debug)]
enum Tablesubdiv {
    Var0(subdivVar0),
    Var1(subdivVar1),
    Var2(subdivVar2),
    Var3(subdivVar3),
}
impl Tablesubdiv {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 12) == 0
        {
            if let Some((inst_len, parsed)) =
                subdivVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 12) == 4
        {
            if let Some((inst_len, parsed)) =
                subdivVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 12) == 8
        {
            if let Some((inst_len, parsed)) =
                subdivVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 12) == 12
        {
            if let Some((inst_len, parsed)) =
                subdivVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1305:1, end:1305:9))"]
#[derive(Clone, Debug)]
struct addrpc16Var0 {
    d16: u16,
}
impl addrpc16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let mut calc_reloc: i128 = 0;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(
                i128::try_from(
                    (if self.d16 & 32768 != 0 {
                        -1 & !32767
                    } else {
                        0
                    } | self.d16 as i16),
                )
                .unwrap(),
            );
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Number(
            true,
            calc_reloc.is_negative(),
            calc_reloc.abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut calc_reloc: i128 = 0;
        let mut block_0_len = 2;
        calc_reloc = i128::try_from(inst_start)
            .unwrap()
            .wrapping_add(2i128)
            .wrapping_add(i128::try_from(token_11(tokens_current)).unwrap());
        let d16 = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrpc16 {
    Var0(addrpc16Var0),
}
impl Tableaddrpc16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                addrpc16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1306:1, end:1306:8))"]
#[derive(Clone, Debug)]
struct addrd16Var0 {
    d16: u16,
}
impl addrd16Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Number(
            true,
            (if self.d16 & 32768 != 0 {
                -1 & !32767
            } else {
                0
            } | self.d16 as i16)
                .is_negative(),
            (if self.d16 & 32768 != 0 {
                -1 & !32767
            } else {
                0
            } | self.d16 as i16)
                .abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let d16 = token_11(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d16 }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrd16 {
    Var0(addrd16Var0),
}
impl Tableaddrd16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                addrd16Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1307:1, end:1307:8))"]
#[derive(Clone, Debug)]
struct addrd32Var0 {
    d32: u32,
}
impl addrd32Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [DisplayElement::Number(
            true,
            (if self.d32 & 2147483648 != 0 {
                -1 & !2147483647
            } else {
                0
            } | self.d32 as i32)
                .is_negative(),
            (if self.d32 & 2147483648 != 0 {
                -1 & !2147483647
            } else {
                0
            } | self.d32 as i32)
                .abs() as u64,
        )];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 4;
        let d32 = token_53(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { d32 }))
    }
}
#[derive(Clone, Debug)]
enum Tableaddrd32 {
    Var0(addrd32Var0),
}
impl Tableaddrd32 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 4 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                addrd32Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1418:1, end:1418:7))"]
#[derive(Clone, Debug)]
struct r2mfwfVar0 {}
impl r2mfwfVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::D0w)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1419:1, end:1419:7))"]
#[derive(Clone, Debug)]
struct r2mfwfVar1 {}
impl r2mfwfVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfwf {
    Var0(r2mfwfVar0),
    Var1(r2mfwfVar1),
}
impl Tabler2mfwf {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                r2mfwfVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfwfVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1420:1, end:1420:7))"]
#[derive(Clone, Debug)]
struct r2mfweVar0 {
    r2mfwf: Tabler2mfwf,
}
impl r2mfweVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwf
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D1w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwf = if let Some((len, table)) =
            Tabler2mfwf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwf }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1421:1, end:1421:7))"]
#[derive(Clone, Debug)]
struct r2mfweVar1 {
    r2mfwf: Tabler2mfwf,
}
impl r2mfweVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwf
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwf = if let Some((len, table)) =
            Tabler2mfwf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwf }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfwe {
    Var0(r2mfweVar0),
    Var1(r2mfweVar1),
}
impl Tabler2mfwe {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                r2mfweVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfweVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1422:1, end:1422:7))"]
#[derive(Clone, Debug)]
struct r2mfwdVar0 {
    r2mfwe: Tabler2mfwe,
}
impl r2mfwdVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwe
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D2w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwe = if let Some((len, table)) =
            Tabler2mfwe::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwe }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1423:1, end:1423:7))"]
#[derive(Clone, Debug)]
struct r2mfwdVar1 {
    r2mfwe: Tabler2mfwe,
}
impl r2mfwdVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwe
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwe = if let Some((len, table)) =
            Tabler2mfwe::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwe }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfwd {
    Var0(r2mfwdVar0),
    Var1(r2mfwdVar1),
}
impl Tabler2mfwd {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                r2mfwdVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfwdVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1424:1, end:1424:7))"]
#[derive(Clone, Debug)]
struct r2mfwcVar0 {
    r2mfwd: Tabler2mfwd,
}
impl r2mfwcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D3w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwd = if let Some((len, table)) =
            Tabler2mfwd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1425:1, end:1425:7))"]
#[derive(Clone, Debug)]
struct r2mfwcVar1 {
    r2mfwd: Tabler2mfwd,
}
impl r2mfwcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwd
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwd = if let Some((len, table)) =
            Tabler2mfwd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwd }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfwc {
    Var0(r2mfwcVar0),
    Var1(r2mfwcVar1),
}
impl Tabler2mfwc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                r2mfwcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfwcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1426:1, end:1426:7))"]
#[derive(Clone, Debug)]
struct r2mfwbVar0 {
    r2mfwc: Tabler2mfwc,
}
impl r2mfwbVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D4w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwc = if let Some((len, table)) =
            Tabler2mfwc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1427:1, end:1427:7))"]
#[derive(Clone, Debug)]
struct r2mfwbVar1 {
    r2mfwc: Tabler2mfwc,
}
impl r2mfwbVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwc = if let Some((len, table)) =
            Tabler2mfwc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwc }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfwb {
    Var0(r2mfwbVar0),
    Var1(r2mfwbVar1),
}
impl Tabler2mfwb {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                r2mfwbVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfwbVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1428:1, end:1428:7))"]
#[derive(Clone, Debug)]
struct r2mfwaVar0 {
    r2mfwb: Tabler2mfwb,
}
impl r2mfwaVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D5w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwb = if let Some((len, table)) =
            Tabler2mfwb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1429:1, end:1429:7))"]
#[derive(Clone, Debug)]
struct r2mfwaVar1 {
    r2mfwb: Tabler2mfwb,
}
impl r2mfwaVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwb = if let Some((len, table)) =
            Tabler2mfwb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwb }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfwa {
    Var0(r2mfwaVar0),
    Var1(r2mfwaVar1),
}
impl Tabler2mfwa {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                r2mfwaVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfwaVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1430:1, end:1430:7))"]
#[derive(Clone, Debug)]
struct r2mfw9Var0 {
    r2mfwa: Tabler2mfwa,
}
impl r2mfw9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwa
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D6w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwa = if let Some((len, table)) =
            Tabler2mfwa::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwa }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1431:1, end:1431:7))"]
#[derive(Clone, Debug)]
struct r2mfw9Var1 {
    r2mfwa: Tabler2mfwa,
}
impl r2mfw9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfwa
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfwa = if let Some((len, table)) =
            Tabler2mfwa::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfwa }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfw9 {
    Var0(r2mfw9Var0),
    Var1(r2mfw9Var1),
}
impl Tabler2mfw9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                r2mfw9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfw9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1432:1, end:1432:7))"]
#[derive(Clone, Debug)]
struct r2mfw8Var0 {
    r2mfw9: Tabler2mfw9,
}
impl r2mfw8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D7w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw9 = if let Some((len, table)) =
            Tabler2mfw9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1433:1, end:1433:7))"]
#[derive(Clone, Debug)]
struct r2mfw8Var1 {
    r2mfw9: Tabler2mfw9,
}
impl r2mfw8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw9 = if let Some((len, table)) =
            Tabler2mfw9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw9 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfw8 {
    Var0(r2mfw8Var0),
    Var1(r2mfw8Var1),
}
impl Tabler2mfw8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                r2mfw8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfw8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1434:1, end:1434:7))"]
#[derive(Clone, Debug)]
struct r2mfw7Var0 {
    r2mfw8: Tabler2mfw8,
}
impl r2mfw7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A0w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw8 = if let Some((len, table)) =
            Tabler2mfw8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1435:1, end:1435:7))"]
#[derive(Clone, Debug)]
struct r2mfw7Var1 {
    r2mfw8: Tabler2mfw8,
}
impl r2mfw7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw8 = if let Some((len, table)) =
            Tabler2mfw8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw8 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfw7 {
    Var0(r2mfw7Var0),
    Var1(r2mfw7Var1),
}
impl Tabler2mfw7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                r2mfw7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfw7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1436:1, end:1436:7))"]
#[derive(Clone, Debug)]
struct r2mfw6Var0 {
    r2mfw7: Tabler2mfw7,
}
impl r2mfw6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A1w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw7 = if let Some((len, table)) =
            Tabler2mfw7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1437:1, end:1437:7))"]
#[derive(Clone, Debug)]
struct r2mfw6Var1 {
    r2mfw7: Tabler2mfw7,
}
impl r2mfw6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw7 = if let Some((len, table)) =
            Tabler2mfw7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw7 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfw6 {
    Var0(r2mfw6Var0),
    Var1(r2mfw6Var1),
}
impl Tabler2mfw6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                r2mfw6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfw6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1438:1, end:1438:7))"]
#[derive(Clone, Debug)]
struct r2mfw5Var0 {
    r2mfw6: Tabler2mfw6,
}
impl r2mfw5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A2w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw6 = if let Some((len, table)) =
            Tabler2mfw6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1439:1, end:1439:7))"]
#[derive(Clone, Debug)]
struct r2mfw5Var1 {
    r2mfw6: Tabler2mfw6,
}
impl r2mfw5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw6 = if let Some((len, table)) =
            Tabler2mfw6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw6 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfw5 {
    Var0(r2mfw5Var0),
    Var1(r2mfw5Var1),
}
impl Tabler2mfw5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                r2mfw5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfw5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1440:1, end:1440:7))"]
#[derive(Clone, Debug)]
struct r2mfw4Var0 {
    r2mfw5: Tabler2mfw5,
}
impl r2mfw4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A3w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw5 = if let Some((len, table)) =
            Tabler2mfw5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1441:1, end:1441:7))"]
#[derive(Clone, Debug)]
struct r2mfw4Var1 {
    r2mfw5: Tabler2mfw5,
}
impl r2mfw4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw5 = if let Some((len, table)) =
            Tabler2mfw5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw5 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfw4 {
    Var0(r2mfw4Var0),
    Var1(r2mfw4Var1),
}
impl Tabler2mfw4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                r2mfw4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfw4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1442:1, end:1442:7))"]
#[derive(Clone, Debug)]
struct r2mfw3Var0 {
    r2mfw4: Tabler2mfw4,
}
impl r2mfw3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A4w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw4 = if let Some((len, table)) =
            Tabler2mfw4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1443:1, end:1443:7))"]
#[derive(Clone, Debug)]
struct r2mfw3Var1 {
    r2mfw4: Tabler2mfw4,
}
impl r2mfw3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw4 = if let Some((len, table)) =
            Tabler2mfw4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw4 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfw3 {
    Var0(r2mfw3Var0),
    Var1(r2mfw3Var1),
}
impl Tabler2mfw3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                r2mfw3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfw3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1444:1, end:1444:7))"]
#[derive(Clone, Debug)]
struct r2mfw2Var0 {
    r2mfw3: Tabler2mfw3,
}
impl r2mfw2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A5w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw3 = if let Some((len, table)) =
            Tabler2mfw3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1445:1, end:1445:7))"]
#[derive(Clone, Debug)]
struct r2mfw2Var1 {
    r2mfw3: Tabler2mfw3,
}
impl r2mfw2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw3 = if let Some((len, table)) =
            Tabler2mfw3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw3 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfw2 {
    Var0(r2mfw2Var0),
    Var1(r2mfw2Var1),
}
impl Tabler2mfw2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                r2mfw2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfw2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1446:1, end:1446:7))"]
#[derive(Clone, Debug)]
struct r2mfw1Var0 {
    r2mfw2: Tabler2mfw2,
}
impl r2mfw1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A6w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw2 = if let Some((len, table)) =
            Tabler2mfw2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1447:1, end:1447:7))"]
#[derive(Clone, Debug)]
struct r2mfw1Var1 {
    r2mfw2: Tabler2mfw2,
}
impl r2mfw1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfw2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw2 = if let Some((len, table)) =
            Tabler2mfw2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw2 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfw1 {
    Var0(r2mfw1Var0),
    Var1(r2mfw1Var1),
}
impl Tabler2mfw1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                r2mfw1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfw1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1448:1, end:1448:7))"]
#[derive(Clone, Debug)]
struct r2mfw0Var0 {
    r2mfw1: Tabler2mfw1,
}
impl r2mfw0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.r2mfw1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A7w),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw1 = if let Some((len, table)) =
            Tabler2mfw1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1449:1, end:1449:7))"]
#[derive(Clone, Debug)]
struct r2mfw0Var1 {
    r2mfw1: Tabler2mfw1,
}
impl r2mfw0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.r2mfw1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfw1 = if let Some((len, table)) =
            Tabler2mfw1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfw1 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfw0 {
    Var0(r2mfw0Var0),
    Var1(r2mfw0Var1),
}
impl Tabler2mfw0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                r2mfw0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfw0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1453:1, end:1453:7))"]
#[derive(Clone, Debug)]
struct r2mflfVar0 {}
impl r2mflfVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::D0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1454:1, end:1454:7))"]
#[derive(Clone, Debug)]
struct r2mflfVar1 {}
impl r2mflfVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mflf {
    Var0(r2mflfVar0),
    Var1(r2mflfVar1),
}
impl Tabler2mflf {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                r2mflfVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mflfVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1455:1, end:1455:7))"]
#[derive(Clone, Debug)]
struct r2mfleVar0 {
    r2mflf: Tabler2mflf,
}
impl r2mfleVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mflf
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mflf = if let Some((len, table)) =
            Tabler2mflf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mflf }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1456:1, end:1456:7))"]
#[derive(Clone, Debug)]
struct r2mfleVar1 {
    r2mflf: Tabler2mflf,
}
impl r2mfleVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mflf
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mflf = if let Some((len, table)) =
            Tabler2mflf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mflf }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfle {
    Var0(r2mfleVar0),
    Var1(r2mfleVar1),
}
impl Tabler2mfle {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                r2mfleVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfleVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1457:1, end:1457:7))"]
#[derive(Clone, Debug)]
struct r2mfldVar0 {
    r2mfle: Tabler2mfle,
}
impl r2mfldVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfle
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfle = if let Some((len, table)) =
            Tabler2mfle::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfle }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1458:1, end:1458:7))"]
#[derive(Clone, Debug)]
struct r2mfldVar1 {
    r2mfle: Tabler2mfle,
}
impl r2mfldVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfle
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfle = if let Some((len, table)) =
            Tabler2mfle::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfle }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfld {
    Var0(r2mfldVar0),
    Var1(r2mfldVar1),
}
impl Tabler2mfld {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                r2mfldVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfldVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1459:1, end:1459:7))"]
#[derive(Clone, Debug)]
struct r2mflcVar0 {
    r2mfld: Tabler2mfld,
}
impl r2mflcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfld
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfld = if let Some((len, table)) =
            Tabler2mfld::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfld }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1460:1, end:1460:7))"]
#[derive(Clone, Debug)]
struct r2mflcVar1 {
    r2mfld: Tabler2mfld,
}
impl r2mflcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfld
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfld = if let Some((len, table)) =
            Tabler2mfld::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfld }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mflc {
    Var0(r2mflcVar0),
    Var1(r2mflcVar1),
}
impl Tabler2mflc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                r2mflcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mflcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1461:1, end:1461:7))"]
#[derive(Clone, Debug)]
struct r2mflbVar0 {
    r2mflc: Tabler2mflc,
}
impl r2mflbVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mflc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mflc = if let Some((len, table)) =
            Tabler2mflc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mflc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1462:1, end:1462:7))"]
#[derive(Clone, Debug)]
struct r2mflbVar1 {
    r2mflc: Tabler2mflc,
}
impl r2mflbVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mflc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mflc = if let Some((len, table)) =
            Tabler2mflc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mflc }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mflb {
    Var0(r2mflbVar0),
    Var1(r2mflbVar1),
}
impl Tabler2mflb {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                r2mflbVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mflbVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1463:1, end:1463:7))"]
#[derive(Clone, Debug)]
struct r2mflaVar0 {
    r2mflb: Tabler2mflb,
}
impl r2mflaVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mflb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mflb = if let Some((len, table)) =
            Tabler2mflb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mflb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1464:1, end:1464:7))"]
#[derive(Clone, Debug)]
struct r2mflaVar1 {
    r2mflb: Tabler2mflb,
}
impl r2mflaVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mflb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mflb = if let Some((len, table)) =
            Tabler2mflb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mflb }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfla {
    Var0(r2mflaVar0),
    Var1(r2mflaVar1),
}
impl Tabler2mfla {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                r2mflaVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mflaVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1465:1, end:1465:7))"]
#[derive(Clone, Debug)]
struct r2mfl9Var0 {
    r2mfla: Tabler2mfla,
}
impl r2mfl9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfla
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfla = if let Some((len, table)) =
            Tabler2mfla::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfla }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1466:1, end:1466:7))"]
#[derive(Clone, Debug)]
struct r2mfl9Var1 {
    r2mfla: Tabler2mfla,
}
impl r2mfl9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfla
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfla = if let Some((len, table)) =
            Tabler2mfla::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfla }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfl9 {
    Var0(r2mfl9Var0),
    Var1(r2mfl9Var1),
}
impl Tabler2mfl9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                r2mfl9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfl9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1467:1, end:1467:7))"]
#[derive(Clone, Debug)]
struct r2mfl8Var0 {
    r2mfl9: Tabler2mfl9,
}
impl r2mfl8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl9 = if let Some((len, table)) =
            Tabler2mfl9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1468:1, end:1468:7))"]
#[derive(Clone, Debug)]
struct r2mfl8Var1 {
    r2mfl9: Tabler2mfl9,
}
impl r2mfl8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl9 = if let Some((len, table)) =
            Tabler2mfl9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl9 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfl8 {
    Var0(r2mfl8Var0),
    Var1(r2mfl8Var1),
}
impl Tabler2mfl8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                r2mfl8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfl8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1469:1, end:1469:7))"]
#[derive(Clone, Debug)]
struct r2mfl7Var0 {
    r2mfl8: Tabler2mfl8,
}
impl r2mfl7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl8 = if let Some((len, table)) =
            Tabler2mfl8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1470:1, end:1470:7))"]
#[derive(Clone, Debug)]
struct r2mfl7Var1 {
    r2mfl8: Tabler2mfl8,
}
impl r2mfl7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl8 = if let Some((len, table)) =
            Tabler2mfl8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl8 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfl7 {
    Var0(r2mfl7Var0),
    Var1(r2mfl7Var1),
}
impl Tabler2mfl7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                r2mfl7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfl7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1471:1, end:1471:7))"]
#[derive(Clone, Debug)]
struct r2mfl6Var0 {
    r2mfl7: Tabler2mfl7,
}
impl r2mfl6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl7 = if let Some((len, table)) =
            Tabler2mfl7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1472:1, end:1472:7))"]
#[derive(Clone, Debug)]
struct r2mfl6Var1 {
    r2mfl7: Tabler2mfl7,
}
impl r2mfl6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl7 = if let Some((len, table)) =
            Tabler2mfl7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl7 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfl6 {
    Var0(r2mfl6Var0),
    Var1(r2mfl6Var1),
}
impl Tabler2mfl6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                r2mfl6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfl6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1473:1, end:1473:7))"]
#[derive(Clone, Debug)]
struct r2mfl5Var0 {
    r2mfl6: Tabler2mfl6,
}
impl r2mfl5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl6 = if let Some((len, table)) =
            Tabler2mfl6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1474:1, end:1474:7))"]
#[derive(Clone, Debug)]
struct r2mfl5Var1 {
    r2mfl6: Tabler2mfl6,
}
impl r2mfl5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl6 = if let Some((len, table)) =
            Tabler2mfl6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl6 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfl5 {
    Var0(r2mfl5Var0),
    Var1(r2mfl5Var1),
}
impl Tabler2mfl5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                r2mfl5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfl5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1475:1, end:1475:7))"]
#[derive(Clone, Debug)]
struct r2mfl4Var0 {
    r2mfl5: Tabler2mfl5,
}
impl r2mfl4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl5 = if let Some((len, table)) =
            Tabler2mfl5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1476:1, end:1476:7))"]
#[derive(Clone, Debug)]
struct r2mfl4Var1 {
    r2mfl5: Tabler2mfl5,
}
impl r2mfl4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl5 = if let Some((len, table)) =
            Tabler2mfl5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl5 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfl4 {
    Var0(r2mfl4Var0),
    Var1(r2mfl4Var1),
}
impl Tabler2mfl4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                r2mfl4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfl4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1477:1, end:1477:7))"]
#[derive(Clone, Debug)]
struct r2mfl3Var0 {
    r2mfl4: Tabler2mfl4,
}
impl r2mfl3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl4 = if let Some((len, table)) =
            Tabler2mfl4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1478:1, end:1478:7))"]
#[derive(Clone, Debug)]
struct r2mfl3Var1 {
    r2mfl4: Tabler2mfl4,
}
impl r2mfl3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl4 = if let Some((len, table)) =
            Tabler2mfl4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl4 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfl3 {
    Var0(r2mfl3Var0),
    Var1(r2mfl3Var1),
}
impl Tabler2mfl3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                r2mfl3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfl3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1479:1, end:1479:7))"]
#[derive(Clone, Debug)]
struct r2mfl2Var0 {
    r2mfl3: Tabler2mfl3,
}
impl r2mfl2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl3 = if let Some((len, table)) =
            Tabler2mfl3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1480:1, end:1480:7))"]
#[derive(Clone, Debug)]
struct r2mfl2Var1 {
    r2mfl3: Tabler2mfl3,
}
impl r2mfl2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl3 = if let Some((len, table)) =
            Tabler2mfl3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl3 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfl2 {
    Var0(r2mfl2Var0),
    Var1(r2mfl2Var1),
}
impl Tabler2mfl2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                r2mfl2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfl2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1481:1, end:1481:7))"]
#[derive(Clone, Debug)]
struct r2mfl1Var0 {
    r2mfl2: Tabler2mfl2,
}
impl r2mfl1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl2 = if let Some((len, table)) =
            Tabler2mfl2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1482:1, end:1482:7))"]
#[derive(Clone, Debug)]
struct r2mfl1Var1 {
    r2mfl2: Tabler2mfl2,
}
impl r2mfl1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mfl2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl2 = if let Some((len, table)) =
            Tabler2mfl2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl2 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfl1 {
    Var0(r2mfl1Var0),
    Var1(r2mfl1Var1),
}
impl Tabler2mfl1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                r2mfl1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfl1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1483:1, end:1483:7))"]
#[derive(Clone, Debug)]
struct r2mfl0Var0 {
    r2mfl1: Tabler2mfl1,
}
impl r2mfl0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.r2mfl1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::SP),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl1 = if let Some((len, table)) =
            Tabler2mfl1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1484:1, end:1484:7))"]
#[derive(Clone, Debug)]
struct r2mfl0Var1 {
    r2mfl1: Tabler2mfl1,
}
impl r2mfl0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.r2mfl1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mfl1 = if let Some((len, table)) =
            Tabler2mfl1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mfl1 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mfl0 {
    Var0(r2mfl0Var0),
    Var1(r2mfl0Var1),
}
impl Tabler2mfl0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                r2mfl0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mfl0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1488:1, end:1488:7))"]
#[derive(Clone, Debug)]
struct r2mbwfVar0 {}
impl r2mbwfVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::A7w)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1489:1, end:1489:7))"]
#[derive(Clone, Debug)]
struct r2mbwfVar1 {}
impl r2mbwfVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbwf {
    Var0(r2mbwfVar0),
    Var1(r2mbwfVar1),
}
impl Tabler2mbwf {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                r2mbwfVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbwfVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1490:1, end:1490:7))"]
#[derive(Clone, Debug)]
struct r2mbweVar0 {
    r2mbwf: Tabler2mbwf,
}
impl r2mbweVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwf
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A6w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwf = if let Some((len, table)) =
            Tabler2mbwf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwf }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1491:1, end:1491:7))"]
#[derive(Clone, Debug)]
struct r2mbweVar1 {
    r2mbwf: Tabler2mbwf,
}
impl r2mbweVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwf
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwf = if let Some((len, table)) =
            Tabler2mbwf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwf }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbwe {
    Var0(r2mbweVar0),
    Var1(r2mbweVar1),
}
impl Tabler2mbwe {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                r2mbweVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbweVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1492:1, end:1492:7))"]
#[derive(Clone, Debug)]
struct r2mbwdVar0 {
    r2mbwe: Tabler2mbwe,
}
impl r2mbwdVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwe
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A5w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwe = if let Some((len, table)) =
            Tabler2mbwe::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwe }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1493:1, end:1493:7))"]
#[derive(Clone, Debug)]
struct r2mbwdVar1 {
    r2mbwe: Tabler2mbwe,
}
impl r2mbwdVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwe
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwe = if let Some((len, table)) =
            Tabler2mbwe::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwe }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbwd {
    Var0(r2mbwdVar0),
    Var1(r2mbwdVar1),
}
impl Tabler2mbwd {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                r2mbwdVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbwdVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1494:1, end:1494:7))"]
#[derive(Clone, Debug)]
struct r2mbwcVar0 {
    r2mbwd: Tabler2mbwd,
}
impl r2mbwcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A4w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwd = if let Some((len, table)) =
            Tabler2mbwd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1495:1, end:1495:7))"]
#[derive(Clone, Debug)]
struct r2mbwcVar1 {
    r2mbwd: Tabler2mbwd,
}
impl r2mbwcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwd
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwd = if let Some((len, table)) =
            Tabler2mbwd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwd }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbwc {
    Var0(r2mbwcVar0),
    Var1(r2mbwcVar1),
}
impl Tabler2mbwc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                r2mbwcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbwcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1496:1, end:1496:7))"]
#[derive(Clone, Debug)]
struct r2mbwbVar0 {
    r2mbwc: Tabler2mbwc,
}
impl r2mbwbVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A3w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwc = if let Some((len, table)) =
            Tabler2mbwc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1497:1, end:1497:7))"]
#[derive(Clone, Debug)]
struct r2mbwbVar1 {
    r2mbwc: Tabler2mbwc,
}
impl r2mbwbVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwc = if let Some((len, table)) =
            Tabler2mbwc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwc }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbwb {
    Var0(r2mbwbVar0),
    Var1(r2mbwbVar1),
}
impl Tabler2mbwb {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                r2mbwbVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbwbVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1498:1, end:1498:7))"]
#[derive(Clone, Debug)]
struct r2mbwaVar0 {
    r2mbwb: Tabler2mbwb,
}
impl r2mbwaVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A2w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwb = if let Some((len, table)) =
            Tabler2mbwb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1499:1, end:1499:7))"]
#[derive(Clone, Debug)]
struct r2mbwaVar1 {
    r2mbwb: Tabler2mbwb,
}
impl r2mbwaVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwb = if let Some((len, table)) =
            Tabler2mbwb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwb }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbwa {
    Var0(r2mbwaVar0),
    Var1(r2mbwaVar1),
}
impl Tabler2mbwa {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                r2mbwaVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbwaVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1500:1, end:1500:7))"]
#[derive(Clone, Debug)]
struct r2mbw9Var0 {
    r2mbwa: Tabler2mbwa,
}
impl r2mbw9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwa
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A1w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwa = if let Some((len, table)) =
            Tabler2mbwa::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwa }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1501:1, end:1501:7))"]
#[derive(Clone, Debug)]
struct r2mbw9Var1 {
    r2mbwa: Tabler2mbwa,
}
impl r2mbw9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbwa
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbwa = if let Some((len, table)) =
            Tabler2mbwa::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbwa }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbw9 {
    Var0(r2mbw9Var0),
    Var1(r2mbw9Var1),
}
impl Tabler2mbw9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                r2mbw9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbw9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1502:1, end:1502:7))"]
#[derive(Clone, Debug)]
struct r2mbw8Var0 {
    r2mbw9: Tabler2mbw9,
}
impl r2mbw8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A0w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw9 = if let Some((len, table)) =
            Tabler2mbw9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1503:1, end:1503:7))"]
#[derive(Clone, Debug)]
struct r2mbw8Var1 {
    r2mbw9: Tabler2mbw9,
}
impl r2mbw8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw9 = if let Some((len, table)) =
            Tabler2mbw9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw9 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbw8 {
    Var0(r2mbw8Var0),
    Var1(r2mbw8Var1),
}
impl Tabler2mbw8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                r2mbw8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbw8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1504:1, end:1504:7))"]
#[derive(Clone, Debug)]
struct r2mbw7Var0 {
    r2mbw8: Tabler2mbw8,
}
impl r2mbw7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D7w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw8 = if let Some((len, table)) =
            Tabler2mbw8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1505:1, end:1505:7))"]
#[derive(Clone, Debug)]
struct r2mbw7Var1 {
    r2mbw8: Tabler2mbw8,
}
impl r2mbw7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw8 = if let Some((len, table)) =
            Tabler2mbw8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw8 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbw7 {
    Var0(r2mbw7Var0),
    Var1(r2mbw7Var1),
}
impl Tabler2mbw7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                r2mbw7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbw7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1506:1, end:1506:7))"]
#[derive(Clone, Debug)]
struct r2mbw6Var0 {
    r2mbw7: Tabler2mbw7,
}
impl r2mbw6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D6w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw7 = if let Some((len, table)) =
            Tabler2mbw7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1507:1, end:1507:7))"]
#[derive(Clone, Debug)]
struct r2mbw6Var1 {
    r2mbw7: Tabler2mbw7,
}
impl r2mbw6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw7 = if let Some((len, table)) =
            Tabler2mbw7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw7 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbw6 {
    Var0(r2mbw6Var0),
    Var1(r2mbw6Var1),
}
impl Tabler2mbw6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                r2mbw6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbw6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1508:1, end:1508:7))"]
#[derive(Clone, Debug)]
struct r2mbw5Var0 {
    r2mbw6: Tabler2mbw6,
}
impl r2mbw5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D5w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw6 = if let Some((len, table)) =
            Tabler2mbw6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1509:1, end:1509:7))"]
#[derive(Clone, Debug)]
struct r2mbw5Var1 {
    r2mbw6: Tabler2mbw6,
}
impl r2mbw5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw6 = if let Some((len, table)) =
            Tabler2mbw6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw6 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbw5 {
    Var0(r2mbw5Var0),
    Var1(r2mbw5Var1),
}
impl Tabler2mbw5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                r2mbw5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbw5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1510:1, end:1510:7))"]
#[derive(Clone, Debug)]
struct r2mbw4Var0 {
    r2mbw5: Tabler2mbw5,
}
impl r2mbw4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D4w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw5 = if let Some((len, table)) =
            Tabler2mbw5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1511:1, end:1511:7))"]
#[derive(Clone, Debug)]
struct r2mbw4Var1 {
    r2mbw5: Tabler2mbw5,
}
impl r2mbw4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw5 = if let Some((len, table)) =
            Tabler2mbw5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw5 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbw4 {
    Var0(r2mbw4Var0),
    Var1(r2mbw4Var1),
}
impl Tabler2mbw4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                r2mbw4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbw4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1512:1, end:1512:7))"]
#[derive(Clone, Debug)]
struct r2mbw3Var0 {
    r2mbw4: Tabler2mbw4,
}
impl r2mbw3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D3w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw4 = if let Some((len, table)) =
            Tabler2mbw4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1513:1, end:1513:7))"]
#[derive(Clone, Debug)]
struct r2mbw3Var1 {
    r2mbw4: Tabler2mbw4,
}
impl r2mbw3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw4 = if let Some((len, table)) =
            Tabler2mbw4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw4 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbw3 {
    Var0(r2mbw3Var0),
    Var1(r2mbw3Var1),
}
impl Tabler2mbw3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                r2mbw3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbw3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1514:1, end:1514:7))"]
#[derive(Clone, Debug)]
struct r2mbw2Var0 {
    r2mbw3: Tabler2mbw3,
}
impl r2mbw2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D2w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw3 = if let Some((len, table)) =
            Tabler2mbw3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1515:1, end:1515:7))"]
#[derive(Clone, Debug)]
struct r2mbw2Var1 {
    r2mbw3: Tabler2mbw3,
}
impl r2mbw2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw3 = if let Some((len, table)) =
            Tabler2mbw3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw3 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbw2 {
    Var0(r2mbw2Var0),
    Var1(r2mbw2Var1),
}
impl Tabler2mbw2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                r2mbw2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbw2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1516:1, end:1516:7))"]
#[derive(Clone, Debug)]
struct r2mbw1Var0 {
    r2mbw2: Tabler2mbw2,
}
impl r2mbw1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D1w),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw2 = if let Some((len, table)) =
            Tabler2mbw2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1517:1, end:1517:7))"]
#[derive(Clone, Debug)]
struct r2mbw1Var1 {
    r2mbw2: Tabler2mbw2,
}
impl r2mbw1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbw2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw2 = if let Some((len, table)) =
            Tabler2mbw2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw2 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbw1 {
    Var0(r2mbw1Var0),
    Var1(r2mbw1Var1),
}
impl Tabler2mbw1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                r2mbw1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbw1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1518:1, end:1518:7))"]
#[derive(Clone, Debug)]
struct r2mbw0Var0 {
    r2mbw1: Tabler2mbw1,
}
impl r2mbw0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.r2mbw1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D0w),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw1 = if let Some((len, table)) =
            Tabler2mbw1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1519:1, end:1519:7))"]
#[derive(Clone, Debug)]
struct r2mbw0Var1 {
    r2mbw1: Tabler2mbw1,
}
impl r2mbw0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.r2mbw1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbw1 = if let Some((len, table)) =
            Tabler2mbw1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbw1 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbw0 {
    Var0(r2mbw0Var0),
    Var1(r2mbw0Var1),
}
impl Tabler2mbw0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                r2mbw0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbw0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1523:1, end:1523:7))"]
#[derive(Clone, Debug)]
struct r2mblfVar0 {}
impl r2mblfVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::SP)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1524:1, end:1524:7))"]
#[derive(Clone, Debug)]
struct r2mblfVar1 {}
impl r2mblfVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mblf {
    Var0(r2mblfVar0),
    Var1(r2mblfVar1),
}
impl Tabler2mblf {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                r2mblfVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mblfVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1525:1, end:1525:7))"]
#[derive(Clone, Debug)]
struct r2mbleVar0 {
    r2mblf: Tabler2mblf,
}
impl r2mbleVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mblf
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mblf = if let Some((len, table)) =
            Tabler2mblf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mblf }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1526:1, end:1526:7))"]
#[derive(Clone, Debug)]
struct r2mbleVar1 {
    r2mblf: Tabler2mblf,
}
impl r2mbleVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mblf
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mblf = if let Some((len, table)) =
            Tabler2mblf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mblf }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mble {
    Var0(r2mbleVar0),
    Var1(r2mbleVar1),
}
impl Tabler2mble {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                r2mbleVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbleVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1527:1, end:1527:7))"]
#[derive(Clone, Debug)]
struct r2mbldVar0 {
    r2mble: Tabler2mble,
}
impl r2mbldVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mble
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mble = if let Some((len, table)) =
            Tabler2mble::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mble }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1528:1, end:1528:7))"]
#[derive(Clone, Debug)]
struct r2mbldVar1 {
    r2mble: Tabler2mble,
}
impl r2mbldVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mble
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mble = if let Some((len, table)) =
            Tabler2mble::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mble }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbld {
    Var0(r2mbldVar0),
    Var1(r2mbldVar1),
}
impl Tabler2mbld {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                r2mbldVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbldVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1529:1, end:1529:7))"]
#[derive(Clone, Debug)]
struct r2mblcVar0 {
    r2mbld: Tabler2mbld,
}
impl r2mblcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbld
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbld = if let Some((len, table)) =
            Tabler2mbld::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbld }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1530:1, end:1530:7))"]
#[derive(Clone, Debug)]
struct r2mblcVar1 {
    r2mbld: Tabler2mbld,
}
impl r2mblcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbld
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbld = if let Some((len, table)) =
            Tabler2mbld::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbld }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mblc {
    Var0(r2mblcVar0),
    Var1(r2mblcVar1),
}
impl Tabler2mblc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                r2mblcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mblcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1531:1, end:1531:7))"]
#[derive(Clone, Debug)]
struct r2mblbVar0 {
    r2mblc: Tabler2mblc,
}
impl r2mblbVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mblc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mblc = if let Some((len, table)) =
            Tabler2mblc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mblc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1532:1, end:1532:7))"]
#[derive(Clone, Debug)]
struct r2mblbVar1 {
    r2mblc: Tabler2mblc,
}
impl r2mblbVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mblc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mblc = if let Some((len, table)) =
            Tabler2mblc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mblc }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mblb {
    Var0(r2mblbVar0),
    Var1(r2mblbVar1),
}
impl Tabler2mblb {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                r2mblbVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mblbVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1533:1, end:1533:7))"]
#[derive(Clone, Debug)]
struct r2mblaVar0 {
    r2mblb: Tabler2mblb,
}
impl r2mblaVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mblb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mblb = if let Some((len, table)) =
            Tabler2mblb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mblb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1534:1, end:1534:7))"]
#[derive(Clone, Debug)]
struct r2mblaVar1 {
    r2mblb: Tabler2mblb,
}
impl r2mblaVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mblb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mblb = if let Some((len, table)) =
            Tabler2mblb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mblb }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbla {
    Var0(r2mblaVar0),
    Var1(r2mblaVar1),
}
impl Tabler2mbla {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                r2mblaVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mblaVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1535:1, end:1535:7))"]
#[derive(Clone, Debug)]
struct r2mbl9Var0 {
    r2mbla: Tabler2mbla,
}
impl r2mbl9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbla
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbla = if let Some((len, table)) =
            Tabler2mbla::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbla }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1536:1, end:1536:7))"]
#[derive(Clone, Debug)]
struct r2mbl9Var1 {
    r2mbla: Tabler2mbla,
}
impl r2mbl9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbla
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbla = if let Some((len, table)) =
            Tabler2mbla::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbla }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbl9 {
    Var0(r2mbl9Var0),
    Var1(r2mbl9Var1),
}
impl Tabler2mbl9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                r2mbl9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbl9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1537:1, end:1537:7))"]
#[derive(Clone, Debug)]
struct r2mbl8Var0 {
    r2mbl9: Tabler2mbl9,
}
impl r2mbl8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl9 = if let Some((len, table)) =
            Tabler2mbl9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1538:1, end:1538:7))"]
#[derive(Clone, Debug)]
struct r2mbl8Var1 {
    r2mbl9: Tabler2mbl9,
}
impl r2mbl8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl9 = if let Some((len, table)) =
            Tabler2mbl9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl9 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbl8 {
    Var0(r2mbl8Var0),
    Var1(r2mbl8Var1),
}
impl Tabler2mbl8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                r2mbl8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbl8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1539:1, end:1539:7))"]
#[derive(Clone, Debug)]
struct r2mbl7Var0 {
    r2mbl8: Tabler2mbl8,
}
impl r2mbl7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl8 = if let Some((len, table)) =
            Tabler2mbl8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1540:1, end:1540:7))"]
#[derive(Clone, Debug)]
struct r2mbl7Var1 {
    r2mbl8: Tabler2mbl8,
}
impl r2mbl7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl8 = if let Some((len, table)) =
            Tabler2mbl8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl8 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbl7 {
    Var0(r2mbl7Var0),
    Var1(r2mbl7Var1),
}
impl Tabler2mbl7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                r2mbl7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbl7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1541:1, end:1541:7))"]
#[derive(Clone, Debug)]
struct r2mbl6Var0 {
    r2mbl7: Tabler2mbl7,
}
impl r2mbl6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl7 = if let Some((len, table)) =
            Tabler2mbl7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1542:1, end:1542:7))"]
#[derive(Clone, Debug)]
struct r2mbl6Var1 {
    r2mbl7: Tabler2mbl7,
}
impl r2mbl6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl7 = if let Some((len, table)) =
            Tabler2mbl7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl7 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbl6 {
    Var0(r2mbl6Var0),
    Var1(r2mbl6Var1),
}
impl Tabler2mbl6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                r2mbl6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbl6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1543:1, end:1543:7))"]
#[derive(Clone, Debug)]
struct r2mbl5Var0 {
    r2mbl6: Tabler2mbl6,
}
impl r2mbl5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl6 = if let Some((len, table)) =
            Tabler2mbl6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1544:1, end:1544:7))"]
#[derive(Clone, Debug)]
struct r2mbl5Var1 {
    r2mbl6: Tabler2mbl6,
}
impl r2mbl5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl6 = if let Some((len, table)) =
            Tabler2mbl6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl6 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbl5 {
    Var0(r2mbl5Var0),
    Var1(r2mbl5Var1),
}
impl Tabler2mbl5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                r2mbl5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbl5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1545:1, end:1545:7))"]
#[derive(Clone, Debug)]
struct r2mbl4Var0 {
    r2mbl5: Tabler2mbl5,
}
impl r2mbl4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl5 = if let Some((len, table)) =
            Tabler2mbl5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1546:1, end:1546:7))"]
#[derive(Clone, Debug)]
struct r2mbl4Var1 {
    r2mbl5: Tabler2mbl5,
}
impl r2mbl4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl5 = if let Some((len, table)) =
            Tabler2mbl5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl5 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbl4 {
    Var0(r2mbl4Var0),
    Var1(r2mbl4Var1),
}
impl Tabler2mbl4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                r2mbl4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbl4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1547:1, end:1547:7))"]
#[derive(Clone, Debug)]
struct r2mbl3Var0 {
    r2mbl4: Tabler2mbl4,
}
impl r2mbl3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl4 = if let Some((len, table)) =
            Tabler2mbl4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1548:1, end:1548:7))"]
#[derive(Clone, Debug)]
struct r2mbl3Var1 {
    r2mbl4: Tabler2mbl4,
}
impl r2mbl3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl4 = if let Some((len, table)) =
            Tabler2mbl4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl4 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbl3 {
    Var0(r2mbl3Var0),
    Var1(r2mbl3Var1),
}
impl Tabler2mbl3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                r2mbl3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbl3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1549:1, end:1549:7))"]
#[derive(Clone, Debug)]
struct r2mbl2Var0 {
    r2mbl3: Tabler2mbl3,
}
impl r2mbl2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl3 = if let Some((len, table)) =
            Tabler2mbl3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1550:1, end:1550:7))"]
#[derive(Clone, Debug)]
struct r2mbl2Var1 {
    r2mbl3: Tabler2mbl3,
}
impl r2mbl2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl3 = if let Some((len, table)) =
            Tabler2mbl3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl3 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbl2 {
    Var0(r2mbl2Var0),
    Var1(r2mbl2Var1),
}
impl Tabler2mbl2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                r2mbl2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbl2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1551:1, end:1551:7))"]
#[derive(Clone, Debug)]
struct r2mbl1Var0 {
    r2mbl2: Tabler2mbl2,
}
impl r2mbl1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl2 = if let Some((len, table)) =
            Tabler2mbl2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1552:1, end:1552:7))"]
#[derive(Clone, Debug)]
struct r2mbl1Var1 {
    r2mbl2: Tabler2mbl2,
}
impl r2mbl1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.r2mbl2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl2 = if let Some((len, table)) =
            Tabler2mbl2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl2 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbl1 {
    Var0(r2mbl1Var0),
    Var1(r2mbl1Var1),
}
impl Tabler2mbl1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                r2mbl1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbl1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1553:1, end:1553:7))"]
#[derive(Clone, Debug)]
struct r2mbl0Var0 {
    r2mbl1: Tabler2mbl1,
}
impl r2mbl0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.r2mbl1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D0),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl1 = if let Some((len, table)) =
            Tabler2mbl1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1554:1, end:1554:7))"]
#[derive(Clone, Debug)]
struct r2mbl0Var1 {
    r2mbl1: Tabler2mbl1,
}
impl r2mbl0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.r2mbl1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let r2mbl1 = if let Some((len, table)) =
            Tabler2mbl1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { r2mbl1 }))
    }
}
#[derive(Clone, Debug)]
enum Tabler2mbl0 {
    Var0(r2mbl0Var0),
    Var1(r2mbl0Var1),
}
impl Tabler2mbl0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                r2mbl0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                r2mbl0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1558:1, end:1558:7))"]
#[derive(Clone, Debug)]
struct m2rfwfVar0 {}
impl m2rfwfVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::D0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1559:1, end:1559:7))"]
#[derive(Clone, Debug)]
struct m2rfwfVar1 {}
impl m2rfwfVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfwf {
    Var0(m2rfwfVar0),
    Var1(m2rfwfVar1),
}
impl Tablem2rfwf {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                m2rfwfVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfwfVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1560:1, end:1560:7))"]
#[derive(Clone, Debug)]
struct m2rfweVar0 {
    m2rfwf: Tablem2rfwf,
}
impl m2rfweVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwf
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwf = if let Some((len, table)) =
            Tablem2rfwf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwf }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1561:1, end:1561:7))"]
#[derive(Clone, Debug)]
struct m2rfweVar1 {
    m2rfwf: Tablem2rfwf,
}
impl m2rfweVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwf
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwf = if let Some((len, table)) =
            Tablem2rfwf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwf }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfwe {
    Var0(m2rfweVar0),
    Var1(m2rfweVar1),
}
impl Tablem2rfwe {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                m2rfweVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfweVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1562:1, end:1562:7))"]
#[derive(Clone, Debug)]
struct m2rfwdVar0 {
    m2rfwe: Tablem2rfwe,
}
impl m2rfwdVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwe
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwe = if let Some((len, table)) =
            Tablem2rfwe::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwe }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1563:1, end:1563:7))"]
#[derive(Clone, Debug)]
struct m2rfwdVar1 {
    m2rfwe: Tablem2rfwe,
}
impl m2rfwdVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwe
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwe = if let Some((len, table)) =
            Tablem2rfwe::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwe }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfwd {
    Var0(m2rfwdVar0),
    Var1(m2rfwdVar1),
}
impl Tablem2rfwd {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                m2rfwdVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfwdVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1564:1, end:1564:7))"]
#[derive(Clone, Debug)]
struct m2rfwcVar0 {
    m2rfwd: Tablem2rfwd,
}
impl m2rfwcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwd
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwd = if let Some((len, table)) =
            Tablem2rfwd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwd }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1565:1, end:1565:7))"]
#[derive(Clone, Debug)]
struct m2rfwcVar1 {
    m2rfwd: Tablem2rfwd,
}
impl m2rfwcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwd
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwd = if let Some((len, table)) =
            Tablem2rfwd::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwd }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfwc {
    Var0(m2rfwcVar0),
    Var1(m2rfwcVar1),
}
impl Tablem2rfwc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                m2rfwcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfwcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1566:1, end:1566:7))"]
#[derive(Clone, Debug)]
struct m2rfwbVar0 {
    m2rfwc: Tablem2rfwc,
}
impl m2rfwbVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwc = if let Some((len, table)) =
            Tablem2rfwc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1567:1, end:1567:7))"]
#[derive(Clone, Debug)]
struct m2rfwbVar1 {
    m2rfwc: Tablem2rfwc,
}
impl m2rfwbVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwc = if let Some((len, table)) =
            Tablem2rfwc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwc }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfwb {
    Var0(m2rfwbVar0),
    Var1(m2rfwbVar1),
}
impl Tablem2rfwb {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                m2rfwbVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfwbVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1568:1, end:1568:7))"]
#[derive(Clone, Debug)]
struct m2rfwaVar0 {
    m2rfwb: Tablem2rfwb,
}
impl m2rfwaVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwb = if let Some((len, table)) =
            Tablem2rfwb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1569:1, end:1569:7))"]
#[derive(Clone, Debug)]
struct m2rfwaVar1 {
    m2rfwb: Tablem2rfwb,
}
impl m2rfwaVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwb = if let Some((len, table)) =
            Tablem2rfwb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwb }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfwa {
    Var0(m2rfwaVar0),
    Var1(m2rfwaVar1),
}
impl Tablem2rfwa {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                m2rfwaVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfwaVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1570:1, end:1570:7))"]
#[derive(Clone, Debug)]
struct m2rfw9Var0 {
    m2rfwa: Tablem2rfwa,
}
impl m2rfw9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwa
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwa = if let Some((len, table)) =
            Tablem2rfwa::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwa }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1571:1, end:1571:7))"]
#[derive(Clone, Debug)]
struct m2rfw9Var1 {
    m2rfwa: Tablem2rfwa,
}
impl m2rfw9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfwa
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfwa = if let Some((len, table)) =
            Tablem2rfwa::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfwa }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfw9 {
    Var0(m2rfw9Var0),
    Var1(m2rfw9Var1),
}
impl Tablem2rfw9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                m2rfw9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfw9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1572:1, end:1572:7))"]
#[derive(Clone, Debug)]
struct m2rfw8Var0 {
    m2rfw9: Tablem2rfw9,
}
impl m2rfw8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw9 = if let Some((len, table)) =
            Tablem2rfw9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1573:1, end:1573:7))"]
#[derive(Clone, Debug)]
struct m2rfw8Var1 {
    m2rfw9: Tablem2rfw9,
}
impl m2rfw8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw9 = if let Some((len, table)) =
            Tablem2rfw9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfw8 {
    Var0(m2rfw8Var0),
    Var1(m2rfw8Var1),
}
impl Tablem2rfw8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                m2rfw8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfw8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1574:1, end:1574:7))"]
#[derive(Clone, Debug)]
struct m2rfw7Var0 {
    m2rfw8: Tablem2rfw8,
}
impl m2rfw7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw8 = if let Some((len, table)) =
            Tablem2rfw8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1575:1, end:1575:7))"]
#[derive(Clone, Debug)]
struct m2rfw7Var1 {
    m2rfw8: Tablem2rfw8,
}
impl m2rfw7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw8 = if let Some((len, table)) =
            Tablem2rfw8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfw7 {
    Var0(m2rfw7Var0),
    Var1(m2rfw7Var1),
}
impl Tablem2rfw7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                m2rfw7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfw7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1576:1, end:1576:7))"]
#[derive(Clone, Debug)]
struct m2rfw6Var0 {
    m2rfw7: Tablem2rfw7,
}
impl m2rfw6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw7 = if let Some((len, table)) =
            Tablem2rfw7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1577:1, end:1577:7))"]
#[derive(Clone, Debug)]
struct m2rfw6Var1 {
    m2rfw7: Tablem2rfw7,
}
impl m2rfw6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw7 = if let Some((len, table)) =
            Tablem2rfw7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfw6 {
    Var0(m2rfw6Var0),
    Var1(m2rfw6Var1),
}
impl Tablem2rfw6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                m2rfw6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfw6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1578:1, end:1578:7))"]
#[derive(Clone, Debug)]
struct m2rfw5Var0 {
    m2rfw6: Tablem2rfw6,
}
impl m2rfw5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw6 = if let Some((len, table)) =
            Tablem2rfw6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1579:1, end:1579:7))"]
#[derive(Clone, Debug)]
struct m2rfw5Var1 {
    m2rfw6: Tablem2rfw6,
}
impl m2rfw5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw6 = if let Some((len, table)) =
            Tablem2rfw6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfw5 {
    Var0(m2rfw5Var0),
    Var1(m2rfw5Var1),
}
impl Tablem2rfw5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                m2rfw5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfw5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1580:1, end:1580:7))"]
#[derive(Clone, Debug)]
struct m2rfw4Var0 {
    m2rfw5: Tablem2rfw5,
}
impl m2rfw4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw5 = if let Some((len, table)) =
            Tablem2rfw5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1581:1, end:1581:7))"]
#[derive(Clone, Debug)]
struct m2rfw4Var1 {
    m2rfw5: Tablem2rfw5,
}
impl m2rfw4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw5 = if let Some((len, table)) =
            Tablem2rfw5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfw4 {
    Var0(m2rfw4Var0),
    Var1(m2rfw4Var1),
}
impl Tablem2rfw4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                m2rfw4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfw4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1582:1, end:1582:7))"]
#[derive(Clone, Debug)]
struct m2rfw3Var0 {
    m2rfw4: Tablem2rfw4,
}
impl m2rfw3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw4 = if let Some((len, table)) =
            Tablem2rfw4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1583:1, end:1583:7))"]
#[derive(Clone, Debug)]
struct m2rfw3Var1 {
    m2rfw4: Tablem2rfw4,
}
impl m2rfw3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw4 = if let Some((len, table)) =
            Tablem2rfw4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfw3 {
    Var0(m2rfw3Var0),
    Var1(m2rfw3Var1),
}
impl Tablem2rfw3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                m2rfw3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfw3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1584:1, end:1584:7))"]
#[derive(Clone, Debug)]
struct m2rfw2Var0 {
    m2rfw3: Tablem2rfw3,
}
impl m2rfw2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw3 = if let Some((len, table)) =
            Tablem2rfw3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1585:1, end:1585:7))"]
#[derive(Clone, Debug)]
struct m2rfw2Var1 {
    m2rfw3: Tablem2rfw3,
}
impl m2rfw2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw3 = if let Some((len, table)) =
            Tablem2rfw3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfw2 {
    Var0(m2rfw2Var0),
    Var1(m2rfw2Var1),
}
impl Tablem2rfw2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                m2rfw2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfw2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1586:1, end:1586:7))"]
#[derive(Clone, Debug)]
struct m2rfw1Var0 {
    m2rfw2: Tablem2rfw2,
}
impl m2rfw1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw2 = if let Some((len, table)) =
            Tablem2rfw2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1587:1, end:1587:7))"]
#[derive(Clone, Debug)]
struct m2rfw1Var1 {
    m2rfw2: Tablem2rfw2,
}
impl m2rfw1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfw2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw2 = if let Some((len, table)) =
            Tablem2rfw2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfw1 {
    Var0(m2rfw1Var0),
    Var1(m2rfw1Var1),
}
impl Tablem2rfw1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                m2rfw1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfw1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1588:1, end:1588:7))"]
#[derive(Clone, Debug)]
struct m2rfw0Var0 {
    m2rfw1: Tablem2rfw1,
}
impl m2rfw0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2rfw1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::SP),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw1 = if let Some((len, table)) =
            Tablem2rfw1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1589:1, end:1589:7))"]
#[derive(Clone, Debug)]
struct m2rfw0Var1 {
    m2rfw1: Tablem2rfw1,
}
impl m2rfw0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2rfw1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfw1 = if let Some((len, table)) =
            Tablem2rfw1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfw1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfw0 {
    Var0(m2rfw0Var0),
    Var1(m2rfw0Var1),
}
impl Tablem2rfw0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                m2rfw0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfw0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1594:1, end:1594:7))"]
#[derive(Clone, Debug)]
struct m2rflfVar0 {}
impl m2rflfVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::D0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1595:1, end:1595:7))"]
#[derive(Clone, Debug)]
struct m2rflfVar1 {}
impl m2rflfVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rflf {
    Var0(m2rflfVar0),
    Var1(m2rflfVar1),
}
impl Tablem2rflf {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                m2rflfVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rflfVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1596:1, end:1596:7))"]
#[derive(Clone, Debug)]
struct m2rfleVar0 {
    m2rflf: Tablem2rflf,
}
impl m2rfleVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rflf
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rflf = if let Some((len, table)) =
            Tablem2rflf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rflf }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1597:1, end:1597:7))"]
#[derive(Clone, Debug)]
struct m2rfleVar1 {
    m2rflf: Tablem2rflf,
}
impl m2rfleVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rflf
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rflf = if let Some((len, table)) =
            Tablem2rflf::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rflf }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfle {
    Var0(m2rfleVar0),
    Var1(m2rfleVar1),
}
impl Tablem2rfle {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                m2rfleVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfleVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1598:1, end:1598:7))"]
#[derive(Clone, Debug)]
struct m2rfldVar0 {
    m2rfle: Tablem2rfle,
}
impl m2rfldVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfle
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfle = if let Some((len, table)) =
            Tablem2rfle::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfle }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1599:1, end:1599:7))"]
#[derive(Clone, Debug)]
struct m2rfldVar1 {
    m2rfle: Tablem2rfle,
}
impl m2rfldVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfle
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfle = if let Some((len, table)) =
            Tablem2rfle::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfle }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfld {
    Var0(m2rfldVar0),
    Var1(m2rfldVar1),
}
impl Tablem2rfld {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                m2rfldVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfldVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1600:1, end:1600:7))"]
#[derive(Clone, Debug)]
struct m2rflcVar0 {
    m2rfld: Tablem2rfld,
}
impl m2rflcVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfld
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfld = if let Some((len, table)) =
            Tablem2rfld::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfld }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1601:1, end:1601:7))"]
#[derive(Clone, Debug)]
struct m2rflcVar1 {
    m2rfld: Tablem2rfld,
}
impl m2rflcVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfld
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfld = if let Some((len, table)) =
            Tablem2rfld::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfld }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rflc {
    Var0(m2rflcVar0),
    Var1(m2rflcVar1),
}
impl Tablem2rflc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                m2rflcVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rflcVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1602:1, end:1602:7))"]
#[derive(Clone, Debug)]
struct m2rflbVar0 {
    m2rflc: Tablem2rflc,
}
impl m2rflbVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rflc
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rflc = if let Some((len, table)) =
            Tablem2rflc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rflc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1603:1, end:1603:7))"]
#[derive(Clone, Debug)]
struct m2rflbVar1 {
    m2rflc: Tablem2rflc,
}
impl m2rflbVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rflc
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rflc = if let Some((len, table)) =
            Tablem2rflc::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rflc }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rflb {
    Var0(m2rflbVar0),
    Var1(m2rflbVar1),
}
impl Tablem2rflb {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                m2rflbVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rflbVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1604:1, end:1604:7))"]
#[derive(Clone, Debug)]
struct m2rflaVar0 {
    m2rflb: Tablem2rflb,
}
impl m2rflaVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rflb
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rflb = if let Some((len, table)) =
            Tablem2rflb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rflb }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1605:1, end:1605:7))"]
#[derive(Clone, Debug)]
struct m2rflaVar1 {
    m2rflb: Tablem2rflb,
}
impl m2rflaVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rflb
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rflb = if let Some((len, table)) =
            Tablem2rflb::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rflb }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfla {
    Var0(m2rflaVar0),
    Var1(m2rflaVar1),
}
impl Tablem2rfla {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                m2rflaVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rflaVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1606:1, end:1606:7))"]
#[derive(Clone, Debug)]
struct m2rfl9Var0 {
    m2rfla: Tablem2rfla,
}
impl m2rfl9Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfla
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfla = if let Some((len, table)) =
            Tablem2rfla::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfla }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1607:1, end:1607:7))"]
#[derive(Clone, Debug)]
struct m2rfl9Var1 {
    m2rfla: Tablem2rfla,
}
impl m2rfl9Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfla
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfla = if let Some((len, table)) =
            Tablem2rfla::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfla }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfl9 {
    Var0(m2rfl9Var0),
    Var1(m2rfl9Var1),
}
impl Tablem2rfl9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                m2rfl9Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfl9Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1608:1, end:1608:7))"]
#[derive(Clone, Debug)]
struct m2rfl8Var0 {
    m2rfl9: Tablem2rfl9,
}
impl m2rfl8Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl9
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::D7),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl9 = if let Some((len, table)) =
            Tablem2rfl9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl9 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1609:1, end:1609:7))"]
#[derive(Clone, Debug)]
struct m2rfl8Var1 {
    m2rfl9: Tablem2rfl9,
}
impl m2rfl8Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl9
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl9 = if let Some((len, table)) =
            Tablem2rfl9::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl9 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfl8 {
    Var0(m2rfl8Var0),
    Var1(m2rfl8Var1),
}
impl Tablem2rfl8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                m2rfl8Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfl8Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1610:1, end:1610:7))"]
#[derive(Clone, Debug)]
struct m2rfl7Var0 {
    m2rfl8: Tablem2rfl8,
}
impl m2rfl7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl8
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A0),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl8 = if let Some((len, table)) =
            Tablem2rfl8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl8 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1611:1, end:1611:7))"]
#[derive(Clone, Debug)]
struct m2rfl7Var1 {
    m2rfl8: Tablem2rfl8,
}
impl m2rfl7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl8
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl8 = if let Some((len, table)) =
            Tablem2rfl8::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl8 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfl7 {
    Var0(m2rfl7Var0),
    Var1(m2rfl7Var1),
}
impl Tablem2rfl7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                m2rfl7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfl7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1612:1, end:1612:7))"]
#[derive(Clone, Debug)]
struct m2rfl6Var0 {
    m2rfl7: Tablem2rfl7,
}
impl m2rfl6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl7 = if let Some((len, table)) =
            Tablem2rfl7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1613:1, end:1613:7))"]
#[derive(Clone, Debug)]
struct m2rfl6Var1 {
    m2rfl7: Tablem2rfl7,
}
impl m2rfl6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl7 = if let Some((len, table)) =
            Tablem2rfl7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfl6 {
    Var0(m2rfl6Var0),
    Var1(m2rfl6Var1),
}
impl Tablem2rfl6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                m2rfl6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfl6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1614:1, end:1614:7))"]
#[derive(Clone, Debug)]
struct m2rfl5Var0 {
    m2rfl6: Tablem2rfl6,
}
impl m2rfl5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl6 = if let Some((len, table)) =
            Tablem2rfl6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1615:1, end:1615:7))"]
#[derive(Clone, Debug)]
struct m2rfl5Var1 {
    m2rfl6: Tablem2rfl6,
}
impl m2rfl5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl6 = if let Some((len, table)) =
            Tablem2rfl6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfl5 {
    Var0(m2rfl5Var0),
    Var1(m2rfl5Var1),
}
impl Tablem2rfl5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                m2rfl5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfl5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1616:1, end:1616:7))"]
#[derive(Clone, Debug)]
struct m2rfl4Var0 {
    m2rfl5: Tablem2rfl5,
}
impl m2rfl4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl5 = if let Some((len, table)) =
            Tablem2rfl5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1617:1, end:1617:7))"]
#[derive(Clone, Debug)]
struct m2rfl4Var1 {
    m2rfl5: Tablem2rfl5,
}
impl m2rfl4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl5 = if let Some((len, table)) =
            Tablem2rfl5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfl4 {
    Var0(m2rfl4Var0),
    Var1(m2rfl4Var1),
}
impl Tablem2rfl4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                m2rfl4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfl4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1618:1, end:1618:7))"]
#[derive(Clone, Debug)]
struct m2rfl3Var0 {
    m2rfl4: Tablem2rfl4,
}
impl m2rfl3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl4 = if let Some((len, table)) =
            Tablem2rfl4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1619:1, end:1619:7))"]
#[derive(Clone, Debug)]
struct m2rfl3Var1 {
    m2rfl4: Tablem2rfl4,
}
impl m2rfl3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl4 = if let Some((len, table)) =
            Tablem2rfl4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfl3 {
    Var0(m2rfl3Var0),
    Var1(m2rfl3Var1),
}
impl Tablem2rfl3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                m2rfl3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfl3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1620:1, end:1620:7))"]
#[derive(Clone, Debug)]
struct m2rfl2Var0 {
    m2rfl3: Tablem2rfl3,
}
impl m2rfl2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl3 = if let Some((len, table)) =
            Tablem2rfl3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1621:1, end:1621:7))"]
#[derive(Clone, Debug)]
struct m2rfl2Var1 {
    m2rfl3: Tablem2rfl3,
}
impl m2rfl2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl3 = if let Some((len, table)) =
            Tablem2rfl3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfl2 {
    Var0(m2rfl2Var0),
    Var1(m2rfl2Var1),
}
impl Tablem2rfl2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                m2rfl2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfl2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1622:1, end:1622:7))"]
#[derive(Clone, Debug)]
struct m2rfl1Var0 {
    m2rfl2: Tablem2rfl2,
}
impl m2rfl1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::A6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl2 = if let Some((len, table)) =
            Tablem2rfl2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1623:1, end:1623:7))"]
#[derive(Clone, Debug)]
struct m2rfl1Var1 {
    m2rfl2: Tablem2rfl2,
}
impl m2rfl1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2rfl2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl2 = if let Some((len, table)) =
            Tablem2rfl2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfl1 {
    Var0(m2rfl1Var0),
    Var1(m2rfl1Var1),
}
impl Tablem2rfl1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                m2rfl1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfl1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1624:1, end:1624:7))"]
#[derive(Clone, Debug)]
struct m2rfl0Var0 {
    m2rfl1: Tablem2rfl1,
}
impl m2rfl0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2rfl1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 3usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::SP),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl1 = if let Some((len, table)) =
            Tablem2rfl1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1625:1, end:1625:7))"]
#[derive(Clone, Debug)]
struct m2rfl0Var1 {
    m2rfl1: Tablem2rfl1,
}
impl m2rfl0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2rfl1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("}")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2rfl1 = if let Some((len, table)) =
            Tablem2rfl1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2rfl1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2rfl0 {
    Var0(m2rfl0Var0),
    Var1(m2rfl0Var1),
}
impl Tablem2rfl0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                m2rfl0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                m2rfl0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1682:1, end:1682:8))"]
#[derive(Clone, Debug)]
struct mulsizeVar0 {}
impl mulsizeVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("s.l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1683:1, end:1683:8))"]
#[derive(Clone, Debug)]
struct mulsizeVar1 {}
impl mulsizeVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("u.l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablemulsize {
    Var0(mulsizeVar0),
    Var1(mulsizeVar1),
}
impl Tablemulsize {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                mulsizeVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                mulsizeVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1685:1, end:1685:7))"]
#[derive(Clone, Debug)]
struct submulVar0 {
    regdq: u8,
}
impl submulVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.regdq)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdq = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdq }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1686:1, end:1686:7))"]
#[derive(Clone, Debug)]
struct submulVar1 {
    regdr: u8,
    regdq: u8,
}
impl submulVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            meaning_0_display(self.regdr),
            <DisplayElement>::Literal("-"),
            meaning_0_display(self.regdq),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdq = token_30(tokens_current);
        let regdr = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdr, regdq }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1688:1, end:1688:7))"]
#[derive(Clone, Debug)]
struct submulVar2 {
    regdq: u8,
}
impl submulVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.regdq)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdq = token_30(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdq }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1689:1, end:1689:7))"]
#[derive(Clone, Debug)]
struct submulVar3 {
    regdr: u8,
    regdq: u8,
}
impl submulVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 3usize] = [
            meaning_0_display(self.regdr),
            <DisplayElement>::Literal("-"),
            meaning_0_display(self.regdq),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdq = token_30(tokens_current);
        let regdr = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdr, regdq }))
    }
}
#[derive(Clone, Debug)]
enum Tablesubmul {
    Var0(submulVar0),
    Var1(submulVar1),
    Var2(submulVar2),
    Var3(submulVar3),
}
impl Tablesubmul {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 12) == 8
        {
            if let Some((inst_len, parsed)) =
                submulVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 12) == 12
        {
            if let Some((inst_len, parsed)) =
                submulVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 12) == 0
        {
            if let Some((inst_len, parsed)) =
                submulVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 12) == 4
        {
            if let Some((inst_len, parsed)) =
                submulVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1782:1, end:1782:3))"]
#[derive(Clone, Debug)]
struct FCVar0 {}
impl FCVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::SFC)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1783:1, end:1783:3))"]
#[derive(Clone, Debug)]
struct FCVar1 {}
impl FCVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::DFC)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1784:1, end:1784:3))"]
#[derive(Clone, Debug)]
struct FCVar2 {
    regdc: u8,
}
impl FCVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [meaning_0_display(self.regdc)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let regdc = token_3(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { regdc }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1785:1, end:1785:3))"]
#[derive(Clone, Debug)]
struct FCVar3 {
    fc03: u8,
}
impl FCVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.fc03 as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fc03 = token_9(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fc03 }))
    }
}
#[derive(Clone, Debug)]
enum TableFC {
    Var0(FCVar0),
    Var1(FCVar1),
    Var2(FCVar2),
    Var3(FCVar3),
}
impl TableFC {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 31) == 0
        {
            if let Some((inst_len, parsed)) =
                FCVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 31) == 1
        {
            if let Some((inst_len, parsed)) =
                FCVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 24) == 8
        {
            if let Some((inst_len, parsed)) =
                FCVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 24) == 16
        {
            if let Some((inst_len, parsed)) =
                FCVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1787:1, end:1787:7))"]
#[derive(Clone, Debug)]
struct FCmaskVar0 {
    fcmask: u8,
}
impl FCmaskVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.fcmask as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fcmask = token_34(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fcmask }))
    }
}
#[derive(Clone, Debug)]
enum TableFCmask {
    Var0(FCmaskVar0),
}
impl TableFCmask {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                FCmaskVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:1841:1, end:1841:11))"]
#[derive(Clone, Debug)]
struct ptestLevelVar0 {
    mregn: u8,
}
impl ptestLevelVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("#"),
            DisplayElement::Number(true, false, self.mregn as u64),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let mregn = token_31(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { mregn }))
    }
}
#[derive(Clone, Debug)]
enum TableptestLevel {
    Var0(ptestLevelVar0),
}
impl TableptestLevel {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                ptestLevelVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2040:1, end:2040:4))"]
#[derive(Clone, Debug)]
struct fccVar0 {}
impl fccVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("eq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2041:1, end:2041:4))"]
#[derive(Clone, Debug)]
struct fccVar1 {}
impl fccVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2042:1, end:2042:4))"]
#[derive(Clone, Debug)]
struct fccVar2 {}
impl fccVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2043:1, end:2043:4))"]
#[derive(Clone, Debug)]
struct fccVar3 {}
impl fccVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ngt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2044:1, end:2044:4))"]
#[derive(Clone, Debug)]
struct fccVar4 {}
impl fccVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2045:1, end:2045:4))"]
#[derive(Clone, Debug)]
struct fccVar5 {}
impl fccVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("nge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2046:1, end:2046:4))"]
#[derive(Clone, Debug)]
struct fccVar6 {}
impl fccVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("lt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2047:1, end:2047:4))"]
#[derive(Clone, Debug)]
struct fccVar7 {}
impl fccVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("nlt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2048:1, end:2048:4))"]
#[derive(Clone, Debug)]
struct fccVar8 {}
impl fccVar8 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("le")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2049:1, end:2049:4))"]
#[derive(Clone, Debug)]
struct fccVar9 {}
impl fccVar9 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("nle")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2050:1, end:2050:4))"]
#[derive(Clone, Debug)]
struct fccVar10 {}
impl fccVar10 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2051:1, end:2051:4))"]
#[derive(Clone, Debug)]
struct fccVar11 {}
impl fccVar11 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ngl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2052:1, end:2052:4))"]
#[derive(Clone, Debug)]
struct fccVar12 {}
impl fccVar12 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("gle")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2053:1, end:2053:4))"]
#[derive(Clone, Debug)]
struct fccVar13 {}
impl fccVar13 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ngle")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2055:1, end:2055:4))"]
#[derive(Clone, Debug)]
struct fccVar14 {}
impl fccVar14 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ogt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2056:1, end:2056:4))"]
#[derive(Clone, Debug)]
struct fccVar15 {}
impl fccVar15 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ule")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2057:1, end:2057:4))"]
#[derive(Clone, Debug)]
struct fccVar16 {}
impl fccVar16 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("oge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2058:1, end:2058:4))"]
#[derive(Clone, Debug)]
struct fccVar17 {}
impl fccVar17 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ult")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2059:1, end:2059:4))"]
#[derive(Clone, Debug)]
struct fccVar18 {}
impl fccVar18 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("olt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2060:1, end:2060:4))"]
#[derive(Clone, Debug)]
struct fccVar19 {}
impl fccVar19 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("uge")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2061:1, end:2061:4))"]
#[derive(Clone, Debug)]
struct fccVar20 {}
impl fccVar20 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ole")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2062:1, end:2062:4))"]
#[derive(Clone, Debug)]
struct fccVar21 {}
impl fccVar21 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ugt")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2063:1, end:2063:4))"]
#[derive(Clone, Debug)]
struct fccVar22 {}
impl fccVar22 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ogl")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2064:1, end:2064:4))"]
#[derive(Clone, Debug)]
struct fccVar23 {}
impl fccVar23 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("ueq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2065:1, end:2065:4))"]
#[derive(Clone, Debug)]
struct fccVar24 {}
impl fccVar24 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("or")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2066:1, end:2066:4))"]
#[derive(Clone, Debug)]
struct fccVar25 {}
impl fccVar25 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("un")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2068:1, end:2068:4))"]
#[derive(Clone, Debug)]
struct fccVar26 {}
impl fccVar26 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("f")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2069:1, end:2069:4))"]
#[derive(Clone, Debug)]
struct fccVar27 {}
impl fccVar27 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("t")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2070:1, end:2070:4))"]
#[derive(Clone, Debug)]
struct fccVar28 {}
impl fccVar28 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("sf")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2071:1, end:2071:4))"]
#[derive(Clone, Debug)]
struct fccVar29 {}
impl fccVar29 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("st")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2072:1, end:2072:4))"]
#[derive(Clone, Debug)]
struct fccVar30 {}
impl fccVar30 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("seq")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2073:1, end:2073:4))"]
#[derive(Clone, Debug)]
struct fccVar31 {}
impl fccVar31 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("sne")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefcc {
    Var0(fccVar0),
    Var1(fccVar1),
    Var2(fccVar2),
    Var3(fccVar3),
    Var4(fccVar4),
    Var5(fccVar5),
    Var6(fccVar6),
    Var7(fccVar7),
    Var8(fccVar8),
    Var9(fccVar9),
    Var10(fccVar10),
    Var11(fccVar11),
    Var12(fccVar12),
    Var13(fccVar13),
    Var14(fccVar14),
    Var15(fccVar15),
    Var16(fccVar16),
    Var17(fccVar17),
    Var18(fccVar18),
    Var19(fccVar19),
    Var20(fccVar20),
    Var21(fccVar21),
    Var22(fccVar22),
    Var23(fccVar23),
    Var24(fccVar24),
    Var25(fccVar25),
    Var26(fccVar26),
    Var27(fccVar27),
    Var28(fccVar28),
    Var29(fccVar29),
    Var30(fccVar30),
    Var31(fccVar31),
}
impl Tablefcc {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var8(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var9(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var10(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var11(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var12(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var13(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var14(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var15(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var16(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var17(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var18(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var19(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var20(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var21(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var22(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var23(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var24(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var25(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var26(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var27(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var28(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var29(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var30(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var31(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 1
        {
            if let Some((inst_len, parsed)) =
                fccVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 14
        {
            if let Some((inst_len, parsed)) =
                fccVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 18
        {
            if let Some((inst_len, parsed)) =
                fccVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 29
        {
            if let Some((inst_len, parsed)) =
                fccVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 19
        {
            if let Some((inst_len, parsed)) =
                fccVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 28
        {
            if let Some((inst_len, parsed)) =
                fccVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 20
        {
            if let Some((inst_len, parsed)) =
                fccVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 27
        {
            if let Some((inst_len, parsed)) =
                fccVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 21
        {
            if let Some((inst_len, parsed)) =
                fccVar8::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var8(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 26
        {
            if let Some((inst_len, parsed)) =
                fccVar9::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var9(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 22
        {
            if let Some((inst_len, parsed)) =
                fccVar10::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var10(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 25
        {
            if let Some((inst_len, parsed)) =
                fccVar11::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var11(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 23
        {
            if let Some((inst_len, parsed)) =
                fccVar12::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var12(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 24
        {
            if let Some((inst_len, parsed)) =
                fccVar13::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var13(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 2
        {
            if let Some((inst_len, parsed)) =
                fccVar14::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var14(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 13
        {
            if let Some((inst_len, parsed)) =
                fccVar15::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var15(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 3
        {
            if let Some((inst_len, parsed)) =
                fccVar16::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var16(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 12
        {
            if let Some((inst_len, parsed)) =
                fccVar17::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var17(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 4
        {
            if let Some((inst_len, parsed)) =
                fccVar18::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var18(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 11
        {
            if let Some((inst_len, parsed)) =
                fccVar19::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var19(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 5
        {
            if let Some((inst_len, parsed)) =
                fccVar20::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var20(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 10
        {
            if let Some((inst_len, parsed)) =
                fccVar21::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var21(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 6
        {
            if let Some((inst_len, parsed)) =
                fccVar22::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var22(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 9
        {
            if let Some((inst_len, parsed)) =
                fccVar23::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var23(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 7
        {
            if let Some((inst_len, parsed)) =
                fccVar24::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var24(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 8
        {
            if let Some((inst_len, parsed)) =
                fccVar25::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var25(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 0
        {
            if let Some((inst_len, parsed)) =
                fccVar26::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var26(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 15
        {
            if let Some((inst_len, parsed)) =
                fccVar27::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var27(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 16
        {
            if let Some((inst_len, parsed)) =
                fccVar28::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var28(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 31
        {
            if let Some((inst_len, parsed)) =
                fccVar29::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var29(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 17
        {
            if let Some((inst_len, parsed)) =
                fccVar30::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var30(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 63) == 30
        {
            if let Some((inst_len, parsed)) =
                fccVar31::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var31(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2087:1, end:2087:6))"]
#[derive(Clone, Debug)]
struct fprecVar0 {}
impl fprecVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("l")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2088:1, end:2088:6))"]
#[derive(Clone, Debug)]
struct fprecVar1 {}
impl fprecVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("s")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2089:1, end:2089:6))"]
#[derive(Clone, Debug)]
struct fprecVar2 {}
impl fprecVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("x")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2090:1, end:2090:6))"]
#[derive(Clone, Debug)]
struct fprecVar3 {}
impl fprecVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("p")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2091:1, end:2091:6))"]
#[derive(Clone, Debug)]
struct fprecVar4 {}
impl fprecVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("w")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2092:1, end:2092:6))"]
#[derive(Clone, Debug)]
struct fprecVar5 {}
impl fprecVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("d")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2093:1, end:2093:6))"]
#[derive(Clone, Debug)]
struct fprecVar6 {}
impl fprecVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("b")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2094:1, end:2094:6))"]
#[derive(Clone, Debug)]
struct fprecVar7 {}
impl fprecVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Literal("p")];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefprec {
    Var0(fprecVar0),
    Var1(fprecVar1),
    Var2(fprecVar2),
    Var3(fprecVar3),
    Var4(fprecVar4),
    Var5(fprecVar5),
    Var6(fprecVar6),
    Var7(fprecVar7),
}
impl Tablefprec {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 28) == 0
        {
            if let Some((inst_len, parsed)) =
                fprecVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 28) == 4
        {
            if let Some((inst_len, parsed)) =
                fprecVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 28) == 8
        {
            if let Some((inst_len, parsed)) =
                fprecVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 28) == 12
        {
            if let Some((inst_len, parsed)) =
                fprecVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 28) == 16
        {
            if let Some((inst_len, parsed)) =
                fprecVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 28) == 20
        {
            if let Some((inst_len, parsed)) =
                fprecVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 28) == 24
        {
            if let Some((inst_len, parsed)) =
                fprecVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 28) == 28
        {
            if let Some((inst_len, parsed)) =
                fprecVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2365:1, end:2365:9))"]
#[derive(Clone, Debug)]
struct romconstVar0 {}
impl romconstVar0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2366:1, end:2366:9))"]
#[derive(Clone, Debug)]
struct romconstVar1 {}
impl romconstVar1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2367:1, end:2367:9))"]
#[derive(Clone, Debug)]
struct romconstVar2 {}
impl romconstVar2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2368:1, end:2368:9))"]
#[derive(Clone, Debug)]
struct romconstVar3 {}
impl romconstVar3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2369:1, end:2369:9))"]
#[derive(Clone, Debug)]
struct romconstVar4 {}
impl romconstVar4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2370:1, end:2370:9))"]
#[derive(Clone, Debug)]
struct romconstVar5 {}
impl romconstVar5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2371:1, end:2371:9))"]
#[derive(Clone, Debug)]
struct romconstVar6 {}
impl romconstVar6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2372:1, end:2372:9))"]
#[derive(Clone, Debug)]
struct romconstVar7 {}
impl romconstVar7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fromoffset = token_48(tokens_current);
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tableromconst {
    Var0(romconstVar0),
    Var1(romconstVar1),
    Var2(romconstVar2),
    Var3(romconstVar3),
    Var4(romconstVar4),
    Var5(romconstVar5),
    Var6(romconstVar6),
    Var7(romconstVar7),
}
impl Tableromconst {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var2(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var3(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var4(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var5(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var6(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var7(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 127) == 0
        {
            if let Some((inst_len, parsed)) =
                romconstVar0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 127) == 15
        {
            if let Some((inst_len, parsed)) =
                romconstVar1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 127) == 50
        {
            if let Some((inst_len, parsed)) =
                romconstVar2::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var2(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 127) == 51
        {
            if let Some((inst_len, parsed)) =
                romconstVar3::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var3(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 127) == 52
        {
            if let Some((inst_len, parsed)) =
                romconstVar4::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var4(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 127) == 53
        {
            if let Some((inst_len, parsed)) =
                romconstVar5::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var5(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 127) == 54
        {
            if let Some((inst_len, parsed)) =
                romconstVar6::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var6(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 {
            if let Some((inst_len, parsed)) =
                romconstVar7::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var7(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2377:1, end:2377:7))"]
#[derive(Clone, Debug)]
struct m2fpF7Var0 {}
impl m2fpF7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::FP0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2378:1, end:2378:7))"]
#[derive(Clone, Debug)]
struct m2fpF7Var1 {}
impl m2fpF7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpF7 {
    Var0(m2fpF7Var0),
    Var1(m2fpF7Var1),
}
impl Tablem2fpF7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                m2fpF7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpF7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2379:1, end:2379:7))"]
#[derive(Clone, Debug)]
struct m2fpF6Var0 {
    m2fpF7: Tablem2fpF7,
}
impl m2fpF6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF7 = if let Some((len, table)) =
            Tablem2fpF7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2380:1, end:2380:7))"]
#[derive(Clone, Debug)]
struct m2fpF6Var1 {
    m2fpF7: Tablem2fpF7,
}
impl m2fpF6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF7 = if let Some((len, table)) =
            Tablem2fpF7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpF6 {
    Var0(m2fpF6Var0),
    Var1(m2fpF6Var1),
}
impl Tablem2fpF6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                m2fpF6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpF6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2381:1, end:2381:7))"]
#[derive(Clone, Debug)]
struct m2fpF5Var0 {
    m2fpF6: Tablem2fpF6,
}
impl m2fpF5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF6 = if let Some((len, table)) =
            Tablem2fpF6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2382:1, end:2382:7))"]
#[derive(Clone, Debug)]
struct m2fpF5Var1 {
    m2fpF6: Tablem2fpF6,
}
impl m2fpF5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF6 = if let Some((len, table)) =
            Tablem2fpF6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpF5 {
    Var0(m2fpF5Var0),
    Var1(m2fpF5Var1),
}
impl Tablem2fpF5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                m2fpF5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpF5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2383:1, end:2383:7))"]
#[derive(Clone, Debug)]
struct m2fpF4Var0 {
    m2fpF5: Tablem2fpF5,
}
impl m2fpF4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF5 = if let Some((len, table)) =
            Tablem2fpF5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2384:1, end:2384:7))"]
#[derive(Clone, Debug)]
struct m2fpF4Var1 {
    m2fpF5: Tablem2fpF5,
}
impl m2fpF4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF5 = if let Some((len, table)) =
            Tablem2fpF5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpF4 {
    Var0(m2fpF4Var0),
    Var1(m2fpF4Var1),
}
impl Tablem2fpF4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                m2fpF4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpF4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2385:1, end:2385:7))"]
#[derive(Clone, Debug)]
struct m2fpF3Var0 {
    m2fpF4: Tablem2fpF4,
}
impl m2fpF3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF4 = if let Some((len, table)) =
            Tablem2fpF4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2386:1, end:2386:7))"]
#[derive(Clone, Debug)]
struct m2fpF3Var1 {
    m2fpF4: Tablem2fpF4,
}
impl m2fpF3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF4 = if let Some((len, table)) =
            Tablem2fpF4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpF3 {
    Var0(m2fpF3Var0),
    Var1(m2fpF3Var1),
}
impl Tablem2fpF3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                m2fpF3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpF3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2387:1, end:2387:7))"]
#[derive(Clone, Debug)]
struct m2fpF2Var0 {
    m2fpF3: Tablem2fpF3,
}
impl m2fpF2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF3 = if let Some((len, table)) =
            Tablem2fpF3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2388:1, end:2388:7))"]
#[derive(Clone, Debug)]
struct m2fpF2Var1 {
    m2fpF3: Tablem2fpF3,
}
impl m2fpF2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF3 = if let Some((len, table)) =
            Tablem2fpF3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpF2 {
    Var0(m2fpF2Var0),
    Var1(m2fpF2Var1),
}
impl Tablem2fpF2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                m2fpF2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpF2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2389:1, end:2389:7))"]
#[derive(Clone, Debug)]
struct m2fpF1Var0 {
    m2fpF2: Tablem2fpF2,
}
impl m2fpF1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF2 = if let Some((len, table)) =
            Tablem2fpF2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2390:1, end:2390:7))"]
#[derive(Clone, Debug)]
struct m2fpF1Var1 {
    m2fpF2: Tablem2fpF2,
}
impl m2fpF1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpF2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF2 = if let Some((len, table)) =
            Tablem2fpF2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpF1 {
    Var0(m2fpF1Var0),
    Var1(m2fpF1Var1),
}
impl Tablem2fpF1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                m2fpF1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpF1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2391:1, end:2391:7))"]
#[derive(Clone, Debug)]
struct m2fpF0Var0 {
    m2fpF1: Tablem2fpF1,
}
impl m2fpF0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2fpF1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP7),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF1 = if let Some((len, table)) =
            Tablem2fpF1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2392:1, end:2392:7))"]
#[derive(Clone, Debug)]
struct m2fpF0Var1 {
    m2fpF1: Tablem2fpF1,
}
impl m2fpF0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2fpF1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpF1 = if let Some((len, table)) =
            Tablem2fpF1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpF1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpF0 {
    Var0(m2fpF0Var0),
    Var1(m2fpF0Var1),
}
impl Tablem2fpF0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                m2fpF0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpF0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2395:1, end:2395:7))"]
#[derive(Clone, Debug)]
struct m2fpR7Var0 {}
impl m2fpR7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::FP7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2396:1, end:2396:7))"]
#[derive(Clone, Debug)]
struct m2fpR7Var1 {}
impl m2fpR7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpR7 {
    Var0(m2fpR7Var0),
    Var1(m2fpR7Var1),
}
impl Tablem2fpR7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                m2fpR7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpR7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2397:1, end:2397:7))"]
#[derive(Clone, Debug)]
struct m2fpR6Var0 {
    m2fpR7: Tablem2fpR7,
}
impl m2fpR6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR7 = if let Some((len, table)) =
            Tablem2fpR7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2398:1, end:2398:7))"]
#[derive(Clone, Debug)]
struct m2fpR6Var1 {
    m2fpR7: Tablem2fpR7,
}
impl m2fpR6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR7 = if let Some((len, table)) =
            Tablem2fpR7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpR6 {
    Var0(m2fpR6Var0),
    Var1(m2fpR6Var1),
}
impl Tablem2fpR6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                m2fpR6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpR6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2399:1, end:2399:7))"]
#[derive(Clone, Debug)]
struct m2fpR5Var0 {
    m2fpR6: Tablem2fpR6,
}
impl m2fpR5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR6 = if let Some((len, table)) =
            Tablem2fpR6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2400:1, end:2400:7))"]
#[derive(Clone, Debug)]
struct m2fpR5Var1 {
    m2fpR6: Tablem2fpR6,
}
impl m2fpR5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR6 = if let Some((len, table)) =
            Tablem2fpR6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpR5 {
    Var0(m2fpR5Var0),
    Var1(m2fpR5Var1),
}
impl Tablem2fpR5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                m2fpR5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpR5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2401:1, end:2401:7))"]
#[derive(Clone, Debug)]
struct m2fpR4Var0 {
    m2fpR5: Tablem2fpR5,
}
impl m2fpR4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR5 = if let Some((len, table)) =
            Tablem2fpR5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2402:1, end:2402:7))"]
#[derive(Clone, Debug)]
struct m2fpR4Var1 {
    m2fpR5: Tablem2fpR5,
}
impl m2fpR4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR5 = if let Some((len, table)) =
            Tablem2fpR5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpR4 {
    Var0(m2fpR4Var0),
    Var1(m2fpR4Var1),
}
impl Tablem2fpR4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                m2fpR4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpR4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2403:1, end:2403:7))"]
#[derive(Clone, Debug)]
struct m2fpR3Var0 {
    m2fpR4: Tablem2fpR4,
}
impl m2fpR3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR4 = if let Some((len, table)) =
            Tablem2fpR4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2404:1, end:2404:7))"]
#[derive(Clone, Debug)]
struct m2fpR3Var1 {
    m2fpR4: Tablem2fpR4,
}
impl m2fpR3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR4 = if let Some((len, table)) =
            Tablem2fpR4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpR3 {
    Var0(m2fpR3Var0),
    Var1(m2fpR3Var1),
}
impl Tablem2fpR3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                m2fpR3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpR3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2405:1, end:2405:7))"]
#[derive(Clone, Debug)]
struct m2fpR2Var0 {
    m2fpR3: Tablem2fpR3,
}
impl m2fpR2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR3 = if let Some((len, table)) =
            Tablem2fpR3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2406:1, end:2406:7))"]
#[derive(Clone, Debug)]
struct m2fpR2Var1 {
    m2fpR3: Tablem2fpR3,
}
impl m2fpR2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR3 = if let Some((len, table)) =
            Tablem2fpR3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpR2 {
    Var0(m2fpR2Var0),
    Var1(m2fpR2Var1),
}
impl Tablem2fpR2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                m2fpR2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpR2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2407:1, end:2407:7))"]
#[derive(Clone, Debug)]
struct m2fpR1Var0 {
    m2fpR2: Tablem2fpR2,
}
impl m2fpR1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR2 = if let Some((len, table)) =
            Tablem2fpR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2408:1, end:2408:7))"]
#[derive(Clone, Debug)]
struct m2fpR1Var1 {
    m2fpR2: Tablem2fpR2,
}
impl m2fpR1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpR2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR2 = if let Some((len, table)) =
            Tablem2fpR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpR1 {
    Var0(m2fpR1Var0),
    Var1(m2fpR1Var1),
}
impl Tablem2fpR1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                m2fpR1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpR1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2409:1, end:2409:7))"]
#[derive(Clone, Debug)]
struct m2fpR0Var0 {
    m2fpR1: Tablem2fpR1,
}
impl m2fpR0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2fpR1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP0),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR1 = if let Some((len, table)) =
            Tablem2fpR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2410:1, end:2410:7))"]
#[derive(Clone, Debug)]
struct m2fpR0Var1 {
    m2fpR1: Tablem2fpR1,
}
impl m2fpR0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2fpR1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpR1 = if let Some((len, table)) =
            Tablem2fpR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpR1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpR0 {
    Var0(m2fpR0Var0),
    Var1(m2fpR0Var1),
}
impl Tablem2fpR0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                m2fpR0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpR0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2414:1, end:2414:7))"]
#[derive(Clone, Debug)]
struct fp2mF7Var0 {}
impl fp2mF7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::FP0)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2415:1, end:2415:7))"]
#[derive(Clone, Debug)]
struct fp2mF7Var1 {}
impl fp2mF7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mF7 {
    Var0(fp2mF7Var0),
    Var1(fp2mF7Var1),
}
impl Tablefp2mF7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                fp2mF7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mF7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2416:1, end:2416:7))"]
#[derive(Clone, Debug)]
struct fp2mF6Var0 {
    fp2mF7: Tablefp2mF7,
}
impl fp2mF6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF7 = if let Some((len, table)) =
            Tablefp2mF7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2417:1, end:2417:7))"]
#[derive(Clone, Debug)]
struct fp2mF6Var1 {
    fp2mF7: Tablefp2mF7,
}
impl fp2mF6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF7 = if let Some((len, table)) =
            Tablefp2mF7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mF6 {
    Var0(fp2mF6Var0),
    Var1(fp2mF6Var1),
}
impl Tablefp2mF6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                fp2mF6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mF6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2418:1, end:2418:7))"]
#[derive(Clone, Debug)]
struct fp2mF5Var0 {
    fp2mF6: Tablefp2mF6,
}
impl fp2mF5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF6 = if let Some((len, table)) =
            Tablefp2mF6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2419:1, end:2419:7))"]
#[derive(Clone, Debug)]
struct fp2mF5Var1 {
    fp2mF6: Tablefp2mF6,
}
impl fp2mF5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF6 = if let Some((len, table)) =
            Tablefp2mF6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mF5 {
    Var0(fp2mF5Var0),
    Var1(fp2mF5Var1),
}
impl Tablefp2mF5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                fp2mF5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mF5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2420:1, end:2420:7))"]
#[derive(Clone, Debug)]
struct fp2mF4Var0 {
    fp2mF5: Tablefp2mF5,
}
impl fp2mF4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF5 = if let Some((len, table)) =
            Tablefp2mF5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2421:1, end:2421:7))"]
#[derive(Clone, Debug)]
struct fp2mF4Var1 {
    fp2mF5: Tablefp2mF5,
}
impl fp2mF4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF5 = if let Some((len, table)) =
            Tablefp2mF5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mF4 {
    Var0(fp2mF4Var0),
    Var1(fp2mF4Var1),
}
impl Tablefp2mF4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                fp2mF4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mF4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2422:1, end:2422:7))"]
#[derive(Clone, Debug)]
struct fp2mF3Var0 {
    fp2mF4: Tablefp2mF4,
}
impl fp2mF3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF4 = if let Some((len, table)) =
            Tablefp2mF4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2423:1, end:2423:7))"]
#[derive(Clone, Debug)]
struct fp2mF3Var1 {
    fp2mF4: Tablefp2mF4,
}
impl fp2mF3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF4 = if let Some((len, table)) =
            Tablefp2mF4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mF3 {
    Var0(fp2mF3Var0),
    Var1(fp2mF3Var1),
}
impl Tablefp2mF3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                fp2mF3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mF3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2424:1, end:2424:7))"]
#[derive(Clone, Debug)]
struct fp2mF2Var0 {
    fp2mF3: Tablefp2mF3,
}
impl fp2mF2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF3 = if let Some((len, table)) =
            Tablefp2mF3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2425:1, end:2425:7))"]
#[derive(Clone, Debug)]
struct fp2mF2Var1 {
    fp2mF3: Tablefp2mF3,
}
impl fp2mF2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF3 = if let Some((len, table)) =
            Tablefp2mF3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mF2 {
    Var0(fp2mF2Var0),
    Var1(fp2mF2Var1),
}
impl Tablefp2mF2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                fp2mF2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mF2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2426:1, end:2426:7))"]
#[derive(Clone, Debug)]
struct fp2mF1Var0 {
    fp2mF2: Tablefp2mF2,
}
impl fp2mF1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF2 = if let Some((len, table)) =
            Tablefp2mF2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2427:1, end:2427:7))"]
#[derive(Clone, Debug)]
struct fp2mF1Var1 {
    fp2mF2: Tablefp2mF2,
}
impl fp2mF1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mF2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF2 = if let Some((len, table)) =
            Tablefp2mF2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mF1 {
    Var0(fp2mF1Var0),
    Var1(fp2mF1Var1),
}
impl Tablefp2mF1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                fp2mF1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mF1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2428:1, end:2428:7))"]
#[derive(Clone, Debug)]
struct fp2mF0Var0 {
    fp2mF1: Tablefp2mF1,
}
impl fp2mF0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.fp2mF1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP7),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF1 = if let Some((len, table)) =
            Tablefp2mF1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2429:1, end:2429:7))"]
#[derive(Clone, Debug)]
struct fp2mF0Var1 {
    fp2mF1: Tablefp2mF1,
}
impl fp2mF0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.fp2mF1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mF1 = if let Some((len, table)) =
            Tablefp2mF1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mF1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mF0 {
    Var0(fp2mF0Var0),
    Var1(fp2mF0Var1),
}
impl Tablefp2mF0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                fp2mF0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mF0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2432:1, end:2432:7))"]
#[derive(Clone, Debug)]
struct fp2mR7Var0 {}
impl fp2mR7Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::FP7)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2433:1, end:2433:7))"]
#[derive(Clone, Debug)]
struct fp2mR7Var1 {}
impl fp2mR7Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mR7 {
    Var0(fp2mR7Var0),
    Var1(fp2mR7Var1),
}
impl Tablefp2mR7 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 128
        {
            if let Some((inst_len, parsed)) =
                fp2mR7Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 128) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mR7Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2434:1, end:2434:7))"]
#[derive(Clone, Debug)]
struct fp2mR6Var0 {
    fp2mR7: Tablefp2mR7,
}
impl fp2mR6Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR7
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP6),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR7 = if let Some((len, table)) =
            Tablefp2mR7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR7 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2435:1, end:2435:7))"]
#[derive(Clone, Debug)]
struct fp2mR6Var1 {
    fp2mR7: Tablefp2mR7,
}
impl fp2mR6Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR7
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR7 = if let Some((len, table)) =
            Tablefp2mR7::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR7 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mR6 {
    Var0(fp2mR6Var0),
    Var1(fp2mR6Var1),
}
impl Tablefp2mR6 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 64
        {
            if let Some((inst_len, parsed)) =
                fp2mR6Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 64) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mR6Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2436:1, end:2436:7))"]
#[derive(Clone, Debug)]
struct fp2mR5Var0 {
    fp2mR6: Tablefp2mR6,
}
impl fp2mR5Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR6
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP5),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR6 = if let Some((len, table)) =
            Tablefp2mR6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR6 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2437:1, end:2437:7))"]
#[derive(Clone, Debug)]
struct fp2mR5Var1 {
    fp2mR6: Tablefp2mR6,
}
impl fp2mR5Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR6
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR6 = if let Some((len, table)) =
            Tablefp2mR6::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR6 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mR5 {
    Var0(fp2mR5Var0),
    Var1(fp2mR5Var1),
}
impl Tablefp2mR5 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 32
        {
            if let Some((inst_len, parsed)) =
                fp2mR5Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 32) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mR5Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2438:1, end:2438:7))"]
#[derive(Clone, Debug)]
struct fp2mR4Var0 {
    fp2mR5: Tablefp2mR5,
}
impl fp2mR4Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR5
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP4),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR5 = if let Some((len, table)) =
            Tablefp2mR5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR5 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2439:1, end:2439:7))"]
#[derive(Clone, Debug)]
struct fp2mR4Var1 {
    fp2mR5: Tablefp2mR5,
}
impl fp2mR4Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR5
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR5 = if let Some((len, table)) =
            Tablefp2mR5::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR5 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mR4 {
    Var0(fp2mR4Var0),
    Var1(fp2mR4Var1),
}
impl Tablefp2mR4 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                fp2mR4Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[1] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mR4Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2440:1, end:2440:7))"]
#[derive(Clone, Debug)]
struct fp2mR3Var0 {
    fp2mR4: Tablefp2mR4,
}
impl fp2mR3Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR4
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP3),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR4 = if let Some((len, table)) =
            Tablefp2mR4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR4 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2441:1, end:2441:7))"]
#[derive(Clone, Debug)]
struct fp2mR3Var1 {
    fp2mR4: Tablefp2mR4,
}
impl fp2mR3Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR4
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR4 = if let Some((len, table)) =
            Tablefp2mR4::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR4 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mR3 {
    Var0(fp2mR3Var0),
    Var1(fp2mR3Var1),
}
impl Tablefp2mR3 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                fp2mR3Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mR3Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2442:1, end:2442:7))"]
#[derive(Clone, Debug)]
struct fp2mR2Var0 {
    fp2mR3: Tablefp2mR3,
}
impl fp2mR2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR3
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP2),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR3 = if let Some((len, table)) =
            Tablefp2mR3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR3 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2443:1, end:2443:7))"]
#[derive(Clone, Debug)]
struct fp2mR2Var1 {
    fp2mR3: Tablefp2mR3,
}
impl fp2mR2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR3
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR3 = if let Some((len, table)) =
            Tablefp2mR3::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR3 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mR2 {
    Var0(fp2mR2Var0),
    Var1(fp2mR2Var1),
}
impl Tablefp2mR2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                fp2mR2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mR2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2444:1, end:2444:7))"]
#[derive(Clone, Debug)]
struct fp2mR1Var0 {
    fp2mR2: Tablefp2mR2,
}
impl fp2mR1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP1),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR2 = if let Some((len, table)) =
            Tablefp2mR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2445:1, end:2445:7))"]
#[derive(Clone, Debug)]
struct fp2mR1Var1 {
    fp2mR2: Tablefp2mR2,
}
impl fp2mR1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mR2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR2 = if let Some((len, table)) =
            Tablefp2mR2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mR1 {
    Var0(fp2mR1Var0),
    Var1(fp2mR1Var1),
}
impl Tablefp2mR1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 2
        {
            if let Some((inst_len, parsed)) =
                fp2mR1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 2) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mR1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2446:1, end:2446:7))"]
#[derive(Clone, Debug)]
struct fp2mR0Var0 {
    fp2mR1: Tablefp2mR1,
}
impl fp2mR0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.fp2mR1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FP0),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR1 = if let Some((len, table)) =
            Tablefp2mR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2447:1, end:2447:7))"]
#[derive(Clone, Debug)]
struct fp2mR0Var1 {
    fp2mR1: Tablefp2mR1,
}
impl fp2mR0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.fp2mR1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mR1 = if let Some((len, table)) =
            Tablefp2mR1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mR1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mR0 {
    Var0(fp2mR0Var0),
    Var1(fp2mR0Var1),
}
impl Tablefp2mR0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 1
        {
            if let Some((inst_len, parsed)) =
                fp2mR0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[1] & 1) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mR0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2495:1, end:2495:7))"]
#[derive(Clone, Debug)]
struct m2fpC2Var0 {}
impl m2fpC2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::FPCR)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2496:1, end:2496:7))"]
#[derive(Clone, Debug)]
struct m2fpC2Var1 {}
impl m2fpC2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpC2 {
    Var0(m2fpC2Var0),
    Var1(m2fpC2Var1),
}
impl Tablem2fpC2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                m2fpC2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpC2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2497:1, end:2497:7))"]
#[derive(Clone, Debug)]
struct m2fpC1Var0 {
    m2fpC2: Tablem2fpC2,
}
impl m2fpC1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpC2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FPSR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpC2 = if let Some((len, table)) =
            Tablem2fpC2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpC2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2498:1, end:2498:7))"]
#[derive(Clone, Debug)]
struct m2fpC1Var1 {
    m2fpC2: Tablem2fpC2,
}
impl m2fpC1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.m2fpC2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpC2 = if let Some((len, table)) =
            Tablem2fpC2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpC2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpC1 {
    Var0(m2fpC1Var0),
    Var1(m2fpC1Var1),
}
impl Tablem2fpC1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                m2fpC1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpC1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2499:1, end:2499:7))"]
#[derive(Clone, Debug)]
struct m2fpC0Var0 {
    m2fpC1: Tablem2fpC1,
}
impl m2fpC0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2fpC1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FPCR),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpC1 = if let Some((len, table)) =
            Tablem2fpC1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpC1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2500:1, end:2500:7))"]
#[derive(Clone, Debug)]
struct m2fpC0Var1 {
    m2fpC1: Tablem2fpC1,
}
impl m2fpC0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.m2fpC1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let m2fpC1 = if let Some((len, table)) =
            Tablem2fpC1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { m2fpC1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablem2fpC0 {
    Var0(m2fpC0Var0),
    Var1(m2fpC0Var1),
}
impl Tablem2fpC0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                m2fpC0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                m2fpC0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2503:1, end:2503:7))"]
#[derive(Clone, Debug)]
struct fp2mC2Var0 {}
impl fp2mC2Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 1usize] = [<DisplayElement>::Register(Register::FPCR)];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2504:1, end:2504:7))"]
#[derive(Clone, Debug)]
struct fp2mC2Var1 {}
impl fp2mC2Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self {}))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mC2 {
    Var0(fp2mC2Var0),
    Var1(fp2mC2Var1),
}
impl Tablefp2mC2 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 16
        {
            if let Some((inst_len, parsed)) =
                fp2mC2Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2
            && context_param.0 & 16384 == 16384
            && (tokens_param[0] & 16) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mC2Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2505:1, end:2505:7))"]
#[derive(Clone, Debug)]
struct fp2mC1Var0 {
    fp2mC2: Tablefp2mC2,
}
impl fp2mC1Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mC2
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FPSR),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mC2 = if let Some((len, table)) =
            Tablefp2mC2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mC2 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2506:1, end:2506:7))"]
#[derive(Clone, Debug)]
struct fp2mC1Var1 {
    fp2mC2: Tablefp2mC2,
}
impl fp2mC1Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        self.fp2mC2
            .display_extend(display, context, inst_start, inst_next, global_set);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mC2 = if let Some((len, table)) =
            Tablefp2mC2::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mC2 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mC1 {
    Var0(fp2mC1Var0),
    Var1(fp2mC1Var1),
}
impl Tablefp2mC1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 8
        {
            if let Some((inst_len, parsed)) =
                fp2mC1Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 8) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mC1Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2507:1, end:2507:7))"]
#[derive(Clone, Debug)]
struct fp2mC0Var0 {
    fp2mC1: Tablefp2mC1,
}
impl fp2mC0Var0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.fp2mC1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 4usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Register(Register::FPIAR),
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mC1 = if let Some((len, table)) =
            Tablefp2mC1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mC1 }))
    }
}
#[doc = "Constructor at Location(FileSpan(/home/rbran/src/ghidra/Ghidra/Processors/68000/data/languages/68000.sinc, start:2508:1, end:2508:7))"]
#[derive(Clone, Debug)]
struct fp2mC0Var1 {
    fp2mC1: Tablefp2mC1,
}
impl fp2mC0Var1 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set: &mut GlobalSet,
    ) {
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal("{"),
            <DisplayElement>::Literal(" "),
        ];
        display.extend_from_slice(&extend);
        self.fp2mC1
            .display_extend(display, context, inst_start, inst_next, global_set);
        let extend: [DisplayElement; 2usize] = [
            <DisplayElement>::Literal(" "),
            <DisplayElement>::Literal("}"),
        ];
        display.extend_from_slice(&extend);
    }
    fn parse(
        mut tokens_current: &[u8],
        context: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut pattern_len = 0;
        let mut context_instance = context.clone();
        let mut block_0_len = 2;
        let fp2mC1 = if let Some((len, table)) =
            Tablefp2mC1::parse(tokens_current, &mut context_instance, inst_start)
        {
            block_0_len = block_0_len.max(len as AddrType);
            table
        } else {
            return None;
        };
        pattern_len += block_0_len;
        tokens_current = &tokens_current[usize::try_from(block_0_len).unwrap()..];
        *context = context_instance;
        Some((pattern_len, Self { fp2mC1 }))
    }
}
#[derive(Clone, Debug)]
enum Tablefp2mC0 {
    Var0(fp2mC0Var0),
    Var1(fp2mC0Var1),
}
impl Tablefp2mC0 {
    fn display_extend(
        &self,
        display: &mut Vec<DisplayElement>,
        context: &ContextMemory,
        inst_start: AddrType,
        inst_next: AddrType,
        global_set_param: &mut GlobalSet,
    ) {
        match self {
            Self::Var0(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
            Self::Var1(x) => {
                x.display_extend(display, context, inst_start, inst_next, global_set_param)
            }
        }
    }
    fn parse(
        tokens_param: &[u8],
        context_param: &mut ContextMemory,
        inst_start: AddrType,
    ) -> Option<(AddrType, Self)> {
        let mut context_current = context_param.clone();
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 4
        {
            if let Some((inst_len, parsed)) =
                fp2mC0Var0::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var0(parsed)));
            }
        }
        if tokens_param.len() >= 2 && context_param.0 & 16384 == 16384 && (tokens_param[0] & 4) == 0
        {
            if let Some((inst_len, parsed)) =
                fp2mC0Var1::parse(tokens_param, &mut context_current, inst_start)
            {
                *context_param = context_current;
                return Some((inst_len, Self::Var1(parsed)));
            }
        }
        None
    }
}
pub fn parse_instruction(
    tokens: &[u8],
    context: &mut ContextMemory,
    inst_start: AddrType,
    global_set: &mut GlobalSet,
) -> Option<(u32, Vec<DisplayElement>)> {
    let (inst_len, instruction) = Tableinstruction::parse(tokens, context, inst_start)?;
    let inst_next = inst_start + inst_len;
    let mut display = vec![];
    instruction.display_extend(&mut display, context, inst_start, inst_next, global_set);
    Some((inst_next, display))
}
